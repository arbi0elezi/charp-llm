{"text": "public static bool NeedsToBeRun(PrintHostConfig printer) { PrintLevelingData levelingData = printer.Settings.Helpers.PrintLevelingData; var required = printer.Settings.GetValue<bool>(SettingsKey.print_leveling_required_to_print); if (required && levelingData == null) { // need but don't have data return true; } if (printer.Settings.GetValue<bool>(SettingsKey.has_hardware_leveling)) { // If printer has hardware leveling, software leveling is disabled return false; } var enabled = printer.Settings.GetValue<bool>(SettingsKey.print_leveling_enabled); // check if leveling is turned on if (required && !enabled) { // need but not turned on return true; } if (!required && !enabled) { return false; } // check that there are no duplicate points var positionCounts = from x in levelingData.SampledPositions group x by x into g let count = g.Count() orderby count descending select new { Value = g.Key, Count = count }; foreach (var x in positionCounts) { if (x.Count > 1) { return true; } } // check that the solution last measured is the currently selected solution if (printer.Settings.GetValue<LevelingSystem>(SettingsKey.print_leveling_solution) != levelingData.LevelingSystem) { return true; } // check that the bed temperature at probe time was close enough to the current print bed temp double requiredLevelingTemp = printer.Settings.GetValue<bool>(SettingsKey.has_heated_bed) ? printer.Settings.GetValue<double>(SettingsKey.bed_temperature) : 0; // check that the number of points sampled is correct for the solution switch (levelingData.LevelingSystem) { case LevelingSystem.Probe3Points: if (levelingData.SampledPositions.Count != 3) // different criteria for what is not initialized { return true; } break; case LevelingSystem.Probe7PointRadial: if (levelingData.SampledPositions.Count != 7) // different criteria for what is not initialized { return true; } break; case LevelingSystem.Probe13PointRadial: if (levelingData.SampledPositions.Count != 13) // different criteria for what is not initialized { return true; } break; case LevelingSystem.Probe100PointRadial: if (levelingData.SampledPositions.Count != 100) // different criteria for what is not initialized { return true; } break; case LevelingSystem.Probe3x3Mesh: if (levelingData.SampledPositions.Count != 9) // different criteria for what is not initialized { return true; } break; case LevelingSystem.Probe5x5Mesh: if (levelingData.SampledPositions.Count != 25) // different criteria for what is not initialized { return true; } break; case LevelingSystem.Probe10x10Mesh: if (levelingData.SampledPositions.Count != 100) // different criteria for what is not initialized { return true; } break; case LevelingSystem.ProbeCustom: if (levelingData.SampledPositions.Count != LevelWizardCustom.ParseLevelingSamplePoints(printer).Count) { return true; } break; default: throw new NotImplementedException(); } return false; }", "label": "ComplexMethod"}
{"text": "private static float ComboDamage(Obj_AI_Base enemy) { var damage = 0d; if (_igniteSlot != SpellSlot.Unknown && Player.Spellbook.CanUseSpell(_igniteSlot) == SpellState.Ready) damage += ObjectManager.Player.GetSummonerSpellDamage(enemy, Damage.SummonerSpell.Ignite); if (Items.HasItem(3077) && Items.CanUseItem(3077)) damage += Player.GetItemDamage(enemy, Damage.DamageItems.Tiamat); if (Items.HasItem(3074) && Items.CanUseItem(3074)) damage += Player.GetItemDamage(enemy, Damage.DamageItems.Hydra); if (Items.HasItem(3153) && Items.CanUseItem(3153)) damage += Player.GetItemDamage(enemy, Damage.DamageItems.Botrk); if (Items.HasItem(3144) && Items.CanUseItem(3144)) damage += Player.GetItemDamage(enemy, Damage.DamageItems.Bilgewater); if (Q.IsReady()) damage += Player.GetSpellDamage(enemy, SpellSlot.Q)*2*1.2; if (E.IsReady()) damage += Player.GetSpellDamage(enemy, SpellSlot.E); if (R.IsReady()) damage += Player.GetSpellDamage(enemy, SpellSlot.R); damage += Player.GetAutoAttackDamage(enemy, true)*1.1; damage += Player.GetAutoAttackDamage(enemy, true); return (float) damage; }", "label": "ComplexMethod"}
{"text": "static void Main(string[] args) { try { // Create a message actionClient to receive events on ActionClient = new AriClient(new StasisEndpoint(\"127.0.0.1\", 8088, \"dev\", \"test\"), AppName); ActionClient.OnStasisStartEvent += c_OnStasisStartEvent; ActionClient.OnStasisEndEvent += c_OnStasisEndEvent; ActionClient.Connect(); // Create simple bridge SimpleBridge = ActionClient.Bridges.Create(\"mixing\", Guid.NewGuid().ToString(), AppName); // subscribe to bridge events ActionClient.Applications.Subscribe(AppName, \"bridge:\" + SimpleBridge.Id); // start MOH on bridge ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\"); var done = false; while (!done) { var lastKey = Console.ReadKey(); switch(lastKey.KeyChar.ToString()) { case \"*\": done = true; break; case \"1\": ActionClient.Bridges.StopMoh(SimpleBridge.Id); break; case \"2\": ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\"); break; case \"3\": // Mute all channels on bridge var bridgeMute = ActionClient.Bridges.Get(SimpleBridge.Id); foreach (var chan in bridgeMute.Channels) ActionClient.Channels.Mute(chan, \"in\"); break; case \"4\": // Unmute all channels on bridge var bridgeUnmute = ActionClient.Bridges.Get(SimpleBridge.Id); foreach (var chan in bridgeUnmute.Channels) ActionClient.Channels.Unmute(chan, \"in\"); break; } } ActionClient.Bridges.Destroy(SimpleBridge.Id); ActionClient.Disconnect(); } catch (Exception ex) { Console.WriteLine(ex.ToString()); Console.ReadKey(); } }", "label": "ComplexMethod"}
{"text": "private void BuildPreprocessorStateChangeMap() { InternalSyntax.DirectiveStack currentState = InternalSyntax.DirectiveStack.Empty; var positions = ArrayBuilder<int>.GetInstance(); var states = ArrayBuilder<InternalSyntax.DirectiveStack>.GetInstance(); foreach (DirectiveTriviaSyntax directive in this.GetRoot().GetDirectives(d => { switch (d.Kind()) { case SyntaxKind.IfDirectiveTrivia: case SyntaxKind.ElifDirectiveTrivia: case SyntaxKind.ElseDirectiveTrivia: case SyntaxKind.EndIfDirectiveTrivia: case SyntaxKind.DefineDirectiveTrivia: case SyntaxKind.UndefDirectiveTrivia: return true; default: return false; } })) { currentState = directive.ApplyDirectives(currentState); switch (directive.Kind()) { case SyntaxKind.IfDirectiveTrivia: // #if directive doesn't affect the set of defined/undefined symbols break; case SyntaxKind.ElifDirectiveTrivia: states.Add(currentState); positions.Add(((ElifDirectiveTriviaSyntax)directive).ElifKeyword.SpanStart); break; case SyntaxKind.ElseDirectiveTrivia: states.Add(currentState); positions.Add(((ElseDirectiveTriviaSyntax)directive).ElseKeyword.SpanStart); break; case SyntaxKind.EndIfDirectiveTrivia: states.Add(currentState); positions.Add(((EndIfDirectiveTriviaSyntax)directive).EndIfKeyword.SpanStart); break; case SyntaxKind.DefineDirectiveTrivia: states.Add(currentState); positions.Add(((DefineDirectiveTriviaSyntax)directive).Name.SpanStart); break; case SyntaxKind.UndefDirectiveTrivia: states.Add(currentState); positions.Add(((UndefDirectiveTriviaSyntax)directive).Name.SpanStart); break; default: throw ExceptionUtilities.Unreachable; } } #if DEBUG int currentPos = -1; foreach (int pos in positions) { Debug.Assert(currentPos < pos); currentPos = pos; } #endif ImmutableInterlocked.InterlockedInitialize(ref _preprocessorStates, states.ToImmutableAndFree()); ImmutableInterlocked.InterlockedInitialize(ref _preprocessorStateChangePositions, positions.ToImmutableAndFree()); }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Formats the literal with a type prefix and quotes (if the type requires it). /// </summary> /// <param name=\"value\">The value to format.</param> /// <returns>The formatted literal, with type marker if needed.</returns> private string FormatLiteralWithTypePrefix(object value) { Debug.Assert(value != null, \"value != null. Null values need to be handled differently in some cases.\"); var enumValue = value as ODataEnumValue; if (enumValue != null) { if (string.IsNullOrEmpty(enumValue.TypeName)) { // TODO: [Sizhong Du] Replace with error string #647. throw new ODataException(\"Type name should not be null or empty when serializing an Enum value for URI key.\"); } return enumValue.TypeName + \"'\" + this.FormatAndEscapeLiteral(enumValue.Value) + \"'\"; } string result = this.FormatAndEscapeLiteral(value); if (value is byte[]) { return ExpressionConstants.LiteralPrefixBinary + \"'\" + result + \"'\"; } if (value is Geography) { return ExpressionConstants.LiteralPrefixGeography + \"'\" + result + \"'\"; } if (value is Geometry) { return ExpressionConstants.LiteralPrefixGeometry + \"'\" + result + \"'\"; } if (value is TimeSpan) { return ExpressionConstants.LiteralPrefixDuration + \"'\" + result + \"'\"; } if (value is string) { return \"'\" + result + \"'\"; } // for int32,int64,float,double, decimal, Infinity/NaN, just output them without prefix or suffix such as L/M/D/F. return result; }", "label": "ComplexMethod"}
{"text": "private static MethodSupport GetMathMethodSupport(SqlMethodCall mc) { if(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(Math)) { switch(mc.Method.Name) { case \"Abs\": case \"Acos\": case \"Asin\": case \"Atan\": case \"Ceiling\": case \"Cos\": case \"Cosh\": case \"Exp\": case \"Floor\": case \"Log10\": if(mc.Arguments.Count == 1) { return MethodSupport.Method; } return MethodSupport.MethodGroup; case \"Log\": if(mc.Arguments.Count == 1 || mc.Arguments.Count == 2) { return MethodSupport.Method; }; return MethodSupport.MethodGroup; case \"Max\": case \"Min\": case \"Pow\": case \"Atan2\": case \"BigMul\": if(mc.Arguments.Count == 2) { return MethodSupport.Method; } return MethodSupport.MethodGroup; case \"Round\": if(mc.Arguments[mc.Arguments.Count - 1].ClrType == typeof(MidpointRounding) && (mc.Arguments.Count == 2 || mc.Arguments.Count == 3)) { return MethodSupport.Method; } return MethodSupport.MethodGroup; case \"Sign\": case \"Sin\": case \"Sinh\": case \"Sqrt\": case \"Tan\": case \"Tanh\": case \"Truncate\": if(mc.Arguments.Count == 1) { return MethodSupport.Method; } return MethodSupport.MethodGroup; } } return MethodSupport.None; }", "label": "ComplexMethod"}
{"text": "private static int LZ4_compressHCCtx_64(LZ4HC_Data_Structure ctx) { var src = ctx.src; var src_p = ctx.src_base; var src_end = ctx.src_end; var dst_0 = ctx.dst_base; var src_anchor = src_p; var src_mflimit = src_end - MFLIMIT; var dst = ctx.dst; var dst_len = ctx.dst_len; var dst_p = ctx.dst_base; var xxx_ref = 0; var start2 = 0; var ref2 = 0; var start3 = 0; var ref3 = 0; src_p++; // Main Loop while (src_p < src_mflimit) { var ml = LZ4HC_InsertAndFindBestMatch_64(ctx, src_p, ref xxx_ref); if (ml == 0) { src_p++; continue; } // saved, in case we would skip too much var start0 = src_p; var ref0 = xxx_ref; var ml0 = ml; _Search2: var ml2 = src_p + ml < src_mflimit ? LZ4HC_InsertAndGetWiderMatch_64(ctx, src_p + ml - 2, src_p + 1, ml, ref ref2, ref start2) : ml; if (ml2 == ml) // No better match { if (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0; continue; } if (start0 < src_p) { if (start2 < src_p + ml0) // empirical { src_p = start0; xxx_ref = ref0; ml = ml0; } } // Here, start0==ip if ((start2 - src_p) < 3) // First Match too small : removed { ml = ml2; src_p = start2; xxx_ref = ref2; goto _Search2; } _Search3: // Currently we have : // ml2 > ml1, and // ip1+3 <= ip2 (usually < ip1+ml1) if ((start2 - src_p) < OPTIMAL_ML) { var new_ml = ml; if (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML; if (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH; var correction = new_ml - (start2 - src_p); if (correction > 0) { start2 += correction; ref2 += correction; ml2 -= correction; } } // Now, we have start2 = ip+new_ml, with new_ml=min(ml, OPTIMAL_ML=18) var ml3 = start2 + ml2 < src_mflimit ? LZ4HC_InsertAndGetWiderMatch_64(ctx, start2 + ml2 - 3, start2, ml2, ref ref3, ref start3) : ml2; if (ml3 == ml2) // No better match : 2 sequences to encode { // ip & ref are known; Now for ml if (start2 < src_p + ml) ml = (start2 - src_p); // Now, encode 2 sequences if (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0; src_p = start2; if (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml2, ref2) != 0) return 0; continue; } if (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it { if (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1 { if (start2 < src_p + ml) { var correction = (src_p + ml - start2); start2 += correction; ref2 += correction; ml2 -= correction; if (ml2 < MINMATCH) { start2 = start3; ref2 = ref3; ml2 = ml3; } } if (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0; src_p = start3; xxx_ref = ref3; ml = ml3; start0 = start2; ref0 = ref2; ml0 = ml2; goto _Search2; } start2 = start3; ref2 = ref3; ml2 = ml3; goto _Search3; } // OK, now we have 3 ascending matches; let's write at least the first one // ip & ref are known; Now for ml if (start2 < src_p + ml) { if ((start2 - src_p) < ML_MASK) { if (ml > OPTIMAL_ML) ml = OPTIMAL_ML; if (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH; var correction = ml - (start2 - src_p); if (correction > 0) { start2 += correction; ref2 += correction; ml2 -= correction; } } else { ml = (start2 - src_p); } } if (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0; src_p = start2; xxx_ref = ref2; ml = ml2; start2 = start3; ref2 = ref3; ml2 = ml3; goto _Search3; } // Encode Last Literals { var lastRun = (src_end - src_anchor); if ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit if (lastRun >= RUN_MASK) { dst[dst_p++] = (RUN_MASK << ML_BITS); lastRun -= RUN_MASK; for (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255; dst[dst_p++] = (byte)lastRun; } else { dst[dst_p++] = (byte)(lastRun << ML_BITS); } BlockCopy(src, src_anchor, dst, dst_p, src_end - src_anchor); dst_p += src_end - src_anchor; } // End return (dst_p - dst_0); }", "label": "FeatureEnvy"}
{"text": "private static STOutput ImplSTRandomPrime(IDigest d, int length, byte[] primeSeed) { int dLen = d.GetDigestSize(); if (length < 33) { int primeGenCounter = 0; byte[] c0 = new byte[dLen]; byte[] c1 = new byte[dLen]; for (;;) { Hash(d, primeSeed, c0, 0); Inc(primeSeed, 1); Hash(d, primeSeed, c1, 0); Inc(primeSeed, 1); uint c = Extract32(c0) ^ Extract32(c1); c &= (uint.MaxValue >> (32 - length)); c |= (1U << (length - 1)) | 1U; ++primeGenCounter; if (IsPrime32(c)) { return new STOutput(BigInteger.ValueOf((long)c), primeSeed, primeGenCounter); } if (primeGenCounter > (4 * length)) { throw new InvalidOperationException(\"Too many iterations in Shawe-Taylor Random_Prime Routine\"); } } } STOutput rec = ImplSTRandomPrime(d, (length + 3)/2, primeSeed); { BigInteger c0 = rec.Prime; primeSeed = rec.PrimeSeed; int primeGenCounter = rec.PrimeGenCounter; int outlen = 8 * dLen; int iterations = (length - 1)/outlen; int oldCounter = primeGenCounter; BigInteger x = HashGen(d, primeSeed, iterations + 1); x = x.Mod(One.ShiftLeft(length - 1)).SetBit(length - 1); BigInteger c0x2 = c0.ShiftLeft(1); BigInteger tx2 = x.Subtract(One).Divide(c0x2).Add(One).ShiftLeft(1); int dt = 0; BigInteger c = tx2.Multiply(c0).Add(One); /* * TODO Since the candidate primes are generated by constant steps ('c0x2'), * sieving could be used here in place of the 'HasAnySmallFactors' approach. */ for (;;) { if (c.BitLength > length) { tx2 = One.ShiftLeft(length - 1).Subtract(One).Divide(c0x2).Add(One).ShiftLeft(1); c = tx2.Multiply(c0).Add(One); } ++primeGenCounter; /* * This is an optimization of the original algorithm, using trial division to screen out * many non-primes quickly. * * NOTE: 'primeSeed' is still incremented as if we performed the full check! */ if (!ImplHasAnySmallFactors(c)) { BigInteger a = HashGen(d, primeSeed, iterations + 1); a = a.Mod(c.Subtract(Three)).Add(Two); tx2 = tx2.Add(BigInteger.ValueOf(dt)); dt = 0; BigInteger z = a.ModPow(tx2, c); if (c.Gcd(z.Subtract(One)).Equals(One) && z.ModPow(c0, c).Equals(One)) { return new STOutput(c, primeSeed, primeGenCounter); } } else { Inc(primeSeed, iterations + 1); } if (primeGenCounter >= ((4 * length) + oldCounter)) { throw new InvalidOperationException(\"Too many iterations in Shawe-Taylor Random_Prime Routine\"); } dt += 2; c = c.Add(c0x2); } } }", "label": "ComplexMethod"}
{"text": "public int GetMaxHitPoints() { var result = 0; //this is inaccurate if ( Body == null ) { return 0; } result = Body.Hitpoints; if ( Propulsion == null ) { return result; } result += (Body.Hitpoints * Propulsion.HitPoints / 100.0D).ToInt(); if ( Turret1 == null ) { return result; } result += Body.Hitpoints + Turret1.HitPoints; if ( TurretCount < 2 || Turret2 == null ) { return result; } if ( Turret2.TurretType != TurretType.Weapon ) { return result; } result += Body.Hitpoints + Turret2.HitPoints; if ( TurretCount < 3 || Turret3 == null ) { return result; } if ( Turret3.TurretType != TurretType.Weapon ) { return result; } result += Body.Hitpoints + Turret3.HitPoints; return result; }", "label": "ComplexMethod"}
{"text": "private void ComputeLocation(Coordinate p, Geometry geom) { if (geom is Point) UpdateLocationInfo(LocateOnPoint(p, (Point) geom)); if (geom is LineString) UpdateLocationInfo(LocateOnLineString(p, (LineString) geom)); else if(geom is Polygon) UpdateLocationInfo(LocateInPolygon(p, (Polygon) geom)); else if(geom is MultiLineString) { var ml = (MultiLineString) geom; foreach (LineString l in ml.Geometries) UpdateLocationInfo(LocateOnLineString(p, l)); } else if(geom is MultiPolygon) { var mpoly = (MultiPolygon) geom; foreach (Polygon poly in mpoly.Geometries) UpdateLocationInfo(LocateInPolygon(p, poly)); } else if (geom is GeometryCollection) { var geomi = new GeometryCollectionEnumerator((GeometryCollection) geom); while(geomi.MoveNext()) { var g2 = (Geometry) geomi.Current; if (g2 != geom) ComputeLocation(p, g2); } } }", "label": "ComplexMethod"}
{"text": "public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 0: if (field.Type == TType.Set) { { Success = new THashSet<string>(); TSet _set222 = iprot.ReadSetBegin(); for( int _i223 = 0; _i223 < _set222.Count; ++_i223) { string _elem224 = null; _elem224 = iprot.ReadString(); Success.Add(_elem224); } iprot.ReadSetEnd(); } } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 1: if (field.Type == TType.Struct) { E = new TalkException(); E.Read(iprot); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); }", "label": "ComplexMethod"}
{"text": "/// <summary>Renames the page. Redirection from old title to new title is /// automatically created.</summary> /// <param name=\"newTitle\">New title of this page.</param> /// <param name=\"reason\">Reason for renaming.</param> public void RenameTo(string newTitle, string reason) { RenameTo(newTitle, reason, false, false); }/// <summary>Renames the page. Redirection from old title to new title is /// automatically created.</summary> /// <param name=\"newTitle\">New title of this page.</param> /// <param name=\"reason\">Reason for renaming.</param> /// <param name=\"renameTalkPage\">If true, corresponding talk page will /// also be renamed.</param> /// <param name=\"renameSubPages\">If true, subpages (like User:Me/Subpage) /// will also be renamed.</param> public void RenameTo(string newTitle, string reason, bool renameTalkPage, bool renameSubPages) { if (string.IsNullOrEmpty(newTitle)) throw new ArgumentNullException(\"newTitle\"); if (string.IsNullOrEmpty(title)) throw new WikiBotException(Bot.Msg(\"No title is specified for page to rename.\")); if (Bot.askConfirm) { Console.Write(\"\\n\\n\" + Bot.Msg(\"The page \\\"{0}\\\" is going to be renamed to \\\"{1}\\\".\\n\"), title, newTitle); if(!Bot.UserConfirms()) return; } if (site.useApi) { string token = \"\"; if (site.tokens != null && site.tokens.ContainsKey(\"csrftoken\")) token = site.tokens[\"csrftoken\"]; else { var tokens = GetSecurityTokens(\"move\"); if (tokens.ContainsKey(\"missing\")) throw new WikiBotException( string.Format(Bot.Msg(\"Page \\\"{0}\\\" doesn't exist.\"), title)); if (!tokens.ContainsKey(\"movetoken\") || tokens[\"movetoken\"] == \"\") throw new WikiBotException(string.Format( Bot.Msg(\"Unable to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle)); token = tokens[\"movetoken\"]; } string postData = string.Format(\"from={0}&to={1}&reason={2}{3}{4}&token={5}\", Bot.UrlEncode(title), Bot.UrlEncode(newTitle), Bot.UrlEncode(reason), renameTalkPage ? \"&movetalk=1\" : \"\", renameSubPages ? \"&movesubpages=1\" : \"\", Bot.UrlEncode(token)); string respStr = site.PostDataAndGetResult(site.apiPath + \"?action=move\" + \"&format=xml\", postData); if (respStr.Contains(\"<error\")) throw new WikiBotException(string.Format( Bot.Msg(\"Failed to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle)); } else { string respStr = site.GetWebPage(site.indexPath + \"?title=Special:Movepage/\" + Bot.UrlEncode(title)); Match m = site.regexes[\"editToken\"].Match(respStr); string securityToken = string.IsNullOrEmpty(m.Groups[1].Value) ? m.Groups[2].Value : m.Groups[1].Value; if (string.IsNullOrEmpty(securityToken)) { Console.Error.WriteLine( Bot.Msg(\"Unable to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle); return; } if (site.watchList == null) { site.watchList = new PageList(site); site.watchList.FillFromWatchList(); } watched = site.watchList.Contains(this); string postData = string.Format(\"wpNewTitle={0}&wpOldTitle={1}&wpEditToken={2}\" + \"&wpReason={3}{4}{5}{6}\", Bot.UrlEncode(newTitle), Bot.UrlEncode(title), Bot.UrlEncode(securityToken), Bot.UrlEncode(reason), renameTalkPage ? \"&wpMovetalk=1\" : \"\", renameSubPages ? \"&wpMovesubpages=1\" : \"\", watched ? \"&wpWatch=1\" : \"\"); respStr = site.PostDataAndGetResult(site.indexPath + \"?title=Special:Movepage&action=submit\", postData); if (site.messages == null) site.LoadMediawikiMessages(true); Regex successMsg = new Regex( \"<h1[^>]*>(<span[^>]*>)?\\\\s*\" + site.messages[\"pagemovedsub\"] + \"\\\\s*<\"); if (!successMsg.IsMatch(respStr)) throw new WikiBotException(string.Format( Bot.Msg(\"Failed to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle)); } title = newTitle; Console.WriteLine( Bot.Msg(\"Page \\\"{0}\\\" has been successfully renamed to \\\"{1}\\\".\"), title, newTitle); }", "label": "ComplexMethod"}
{"text": "private static void UpdateModel(CPpmd7 p) { CPpmd_Void_Ref successor, fSuccessor = SUCCESSOR(p.FoundState); CPpmd7_Context* c; uint s0, ns; if (p.FoundState->Freq < MAX_FREQ / 4 && p.MinContext->Suffix.Value != 0) { c = SUFFIX(p, p.MinContext); if (c->NumStats == 1) { CPpmd_State* s = ONE_STATE(c); if (s->Freq < 32) s->Freq++; } else { CPpmd_State* s = STATS(p, c); if (s->Symbol != p.FoundState->Symbol) { do { s++; } while (s->Symbol != p.FoundState->Symbol); if (s[0].Freq >= s[-1].Freq) { SwapStates(&s[0], &s[-1]); s--; } } if (s->Freq < MAX_FREQ - 9) { s->Freq += 2; c->SummFreq += 2; } } } if (p.OrderFall == 0) { p.MinContext = p.MaxContext = CreateSuccessors(p, true); if (p.MinContext == null) { RestartModel(p); return; } SetSuccessor(p.FoundState, REF(p, p.MinContext)); return; } *p.Text++ = p.FoundState->Symbol; successor = REF(p, p.Text); if (p.Text >= p.UnitsStart) { RestartModel(p); return; } if (fSuccessor.Value != 0) { if (fSuccessor.Value <= successor.Value) { CPpmd7_Context* cs = CreateSuccessors(p, false); if (cs == null) { RestartModel(p); return; } fSuccessor = REF(p, cs); } if (--p.OrderFall == 0) { successor = fSuccessor; p.Text -= (p.MaxContext != p.MinContext) ? 1 : 0; } } else { SetSuccessor(p.FoundState, successor); fSuccessor = REF(p, p.MinContext); } s0 = p.MinContext->SummFreq - (ns = p.MinContext->NumStats) - (p.FoundState->Freq - 1u); for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p, c)) { uint ns1; uint cf, sf; if ((ns1 = c->NumStats) != 1) { if ((ns1 & 1) == 0) { /* Expand for one UNIT */ uint oldNU = ns1 >> 1; uint i = U2I(p, oldNU); if (i != U2I(p, oldNU + 1)) { void* ptr = AllocUnits(p, i + 1); void* oldPtr; if (ptr == null) { RestartModel(p); return; } oldPtr = STATS(p, c); MyMem12Cpy(ptr, oldPtr, oldNU); InsertNode(p, oldPtr, i); c->Stats = STATS_REF(p, ptr); } } c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u))); } else { CPpmd_State* s = (CPpmd_State*)AllocUnits(p, 0); if (s == null) { RestartModel(p); return; } *s = *ONE_STATE(c); c->Stats = REF(p, s); if (s->Freq < MAX_FREQ / 4 - 1) s->Freq <<= 1; else s->Freq = MAX_FREQ - 4; c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u)); } cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u); sf = (uint)s0 + c->SummFreq; if (cf < 6 * sf) { cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u); c->SummFreq += 3; } else { cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u); c->SummFreq = (ushort)(c->SummFreq + cf); } { CPpmd_State* s = STATS(p, c) + ns1; SetSuccessor(s, successor); s->Symbol = p.FoundState->Symbol; s->Freq = (byte)cf; c->NumStats = (ushort)(ns1 + 1); } } p.MaxContext = p.MinContext = CTX(p, fSuccessor); }", "label": "FeatureEnvy"}
{"text": "public DynValue Coroutine_Resume(DynValue[] args) { EnterProcessor(); try { int entrypoint = 0; if (m_State != CoroutineState.NotStarted && m_State != CoroutineState.Suspended && m_State != CoroutineState.ForceSuspended) throw ScriptRuntimeException.CannotResumeNotSuspended(m_State); if (m_State == CoroutineState.NotStarted) { entrypoint = PushClrToScriptStackFrame(CallStackItemFlags.ResumeEntryPoint, null, args); } else if (m_State == CoroutineState.Suspended) { m_ValueStack.Push(DynValue.NewTuple(args)); entrypoint = m_SavedInstructionPtr; } else if (m_State == CoroutineState.ForceSuspended) { if (args != null && args.Length > 0) throw new ArgumentException(\"When resuming a force-suspended coroutine, args must be empty.\"); entrypoint = m_SavedInstructionPtr; } m_State = CoroutineState.Running; DynValue retVal = Processing_Loop(entrypoint); if (retVal.Type == DataType.YieldRequest) { if (retVal.YieldRequest.Forced) { m_State = CoroutineState.ForceSuspended; return retVal; } else { m_State = CoroutineState.Suspended; return DynValue.NewTuple(retVal.YieldRequest.ReturnValues); } } else { m_State = CoroutineState.Dead; return retVal; } } catch (Exception) { // Unhandled exception - move to dead m_State = CoroutineState.Dead; throw; } finally { LeaveProcessor(); } }", "label": "ComplexMethod"}
{"text": "private List<IEntity> ImportEntityGroup(IEnumerable<JNode> entityNodes, EntityType entityType, Dictionary<EntityKey, EntityKey> tempKeyMap, MergeStrategy mergeStrategy) { var importedEntities = new List<IEntity>(); foreach (var entityNode in entityNodes) { var ek = ExtractEntityKey(entityType, entityNode); var entityAspectNode = entityNode.GetJNode(\"entityAspect\"); // var entityState = (EntityState)Enum.Parse(typeof(EntityState), entityAspectNode.Get<String>(\"entityState\")); var entityState = entityAspectNode.GetEnum<EntityState>(\"entityState\"); IEntity targetEntity = null; bool hasCollision = false; // allow merge of added records with non temp keys if (entityState.IsAdded() && tempKeyMap.ContainsKey(ek)) { hasCollision = tempKeyMap[ek] != ek; } else { targetEntity = GetEntityByKey(ek); } if (targetEntity != null) { var targetAspect = targetEntity.EntityAspect; if (mergeStrategy == MergeStrategy.Disallowed) continue; if (mergeStrategy == MergeStrategy.PreserveChanges && targetAspect.EntityState != EntityState.Unchanged) continue; PopulateImportedEntity(targetEntity, entityNode); UpdateTempFks(targetEntity, entityAspectNode, tempKeyMap); if (targetAspect.EntityState != entityState) { targetAspect.EntityState = entityState; } OnEntityChanged(targetEntity, EntityAction.MergeOnImport); } else { targetEntity = (IEntity)Activator.CreateInstance(entityType.ClrType); targetEntity.EntityAspect.EntityType = entityType; PopulateImportedEntity(targetEntity, entityNode); if (hasCollision) { var origEk = targetEntity.EntityAspect.EntityKey; var newEk = tempKeyMap[origEk]; targetEntity.EntityAspect.SetDpValue(entityType.KeyProperties[0], newEk.Values[0]); } UpdateTempFks(targetEntity, entityAspectNode, tempKeyMap); AttachImportedEntity(targetEntity, entityType, entityState); } importedEntities.Add(targetEntity); }; return importedEntities; }", "label": "ComplexMethod"}
{"text": "private void AppendSymbolsWithName( List<MergedNamespaceOrTypeDeclaration> spine, MergedNamespaceOrTypeDeclaration current, Func<string, bool> predicate, SymbolFilter filter, HashSet<ISymbol> set, CancellationToken cancellationToken) { var includeNamespace = (filter & SymbolFilter.Namespace) == SymbolFilter.Namespace; var includeType = (filter & SymbolFilter.Type) == SymbolFilter.Type; var includeMember = (filter & SymbolFilter.Member) == SymbolFilter.Member; if (current.Kind == DeclarationKind.Namespace) { if (includeNamespace && predicate(current.Name)) { var container = GetSpineSymbol(spine); set.Add(GetSymbol(container, current)); } } else { if (includeType && predicate(current.Name)) { var container = GetSpineSymbol(spine); set.Add(GetSymbol(container, current)); } if (includeMember) { AppendMemberSymbolsWithName(spine, current, predicate, set, cancellationToken); } } spine.Add(current); foreach (var child in current.Children.OfType<MergedNamespaceOrTypeDeclaration>()) { if (includeMember || includeType) { AppendSymbolsWithName(spine, child, predicate, filter, set, cancellationToken); continue; } if (child.Kind == DeclarationKind.Namespace) { AppendSymbolsWithName(spine, child, predicate, filter, set, cancellationToken); } } // pop last one spine.RemoveAt(spine.Count - 1); }", "label": "ComplexMethod"}
{"text": "protected virtual void CompileOptions(ToolbarGump toolbar, GumpButton clicked, Point loc, MenuGumpOptions opts) { if (toolbar == null) { return; } PlayerMobile user = toolbar.User; if (CanEdit || user.AccessLevel >= Toolbars.Access) { if (!toolbar.GlobalEdit) { opts.AppendEntry( new ListGumpEntry( \"Load Default\", b => SuperGump.Send( new ConfirmDialogGump(user, toolbar) { Title = \"Load Default\", Html = \"Loading the default entry will overwrite your custom entry.\\n\\nDo you want to continue?\", AcceptHandler = db => { ToolbarEntry def = Toolbars.DefaultEntries.GetContent(loc.X, loc.Y); toolbar.State.SetContent(loc.X, loc.Y, def != null ? def.Clone() : null); toolbar.Refresh(true); } }), toolbar.HighlightHue)); } opts.AppendEntry( new ListGumpEntry( \"Reset\", b => { Reset(toolbar); toolbar.Refresh(true); }, toolbar.HighlightHue)); } if (CanDelete || user.AccessLevel >= Toolbars.Access) { opts.AppendEntry( new ListGumpEntry( \"Delete\", b => { toolbar.State.SetContent(loc.X, loc.Y, null); toolbar.Refresh(true); }, toolbar.HighlightHue)); } if (CanEdit || user.AccessLevel >= Toolbars.Access) { opts.AppendEntry( new ListGumpEntry( \"Set Value\", b => SuperGump.Send( new InputDialogGump(user, toolbar) { Title = \"Set Value\", Html = \"Set the value of this entry.\", InputText = Value, Callback = (cb, text) => { Value = text; toolbar.Refresh(true); } }), toolbar.HighlightHue)); opts.AppendEntry( new ListGumpEntry( \"Set Label\", b => SuperGump.Send( new InputDialogGump(user, toolbar) { Title = \"Set Label\", Html = \"Set the label of this entry.\", InputText = Label, Callback = (cb, text) => { Label = text; toolbar.Refresh(true); } }), toolbar.HighlightHue)); opts.AppendEntry( new ListGumpEntry( \"Set Label Color\", b => { int rrr = 255, ggg = 255, bbb = 255; if (LabelColor != null) { rrr = LabelColor.Value.R; ggg = LabelColor.Value.G; bbb = LabelColor.Value.B; } SuperGump.Send( new InputDialogGump(user, toolbar) { Title = \"Set Label Color\", Html = \"Set the label color for this entry.\\nFormat 1: NamedColor (EG; Red)\\nFormat 2: RRR,GGG,BBB\", InputText = String.Format(\"{0:D3},{1:D3},{2:D3}\", rrr, ggg, bbb), Callback = (cb, text) => { if (!String.IsNullOrWhiteSpace(text)) { if (text.IndexOf(',') != -1) { var args = text.Split(','); if (args.Length >= 3) { Int32.TryParse(args[0], out rrr); Int32.TryParse(args[1], out ggg); Int32.TryParse(args[2], out bbb); rrr = Math.Min(255, Math.Max(0, rrr)); ggg = Math.Min(255, Math.Max(0, ggg)); bbb = Math.Min(255, Math.Max(0, bbb)); LabelColor = Color.FromArgb(rrr, ggg, bbb); } } else { try { LabelColor = Color.FromName(text); } catch { } } } toolbar.Refresh(true); } }); }, toolbar.HighlightHue)); if (Highlight) { opts.Replace( \"Highlight\", new ListGumpEntry( \"Unhighlight\", b => { Highlight = false; toolbar.Refresh(true); }, toolbar.ErrorHue)); } else { opts.Replace( \"Unhighlight\", new ListGumpEntry( \"Highlight\", b => { Highlight = true; toolbar.Refresh(true); }, toolbar.HighlightHue)); } } if (user.AccessLevel < Toolbars.Access) { return; } opts.AppendEntry( new ListGumpEntry( \"Open Props\", b => SuperGump.Send( new NoticeDialogGump(user, toolbar) { Title = \"Props Note\", Html = \"Editing the properties of an entry this way requires a hard refresh.\\nExit and re-open the Toolbar when you make any changes.\", AcceptHandler = cb => { toolbar.Refresh(true); PropertiesGump pg = new PropertiesGump(user, this) { X = b.X, Y = b.Y }; user.SendGump(pg); } }), toolbar.HighlightHue)); if (toolbar.GlobalEdit && toolbar.CanGlobalEdit()) { opts.AppendEntry( new ListGumpEntry( \"Global Apply\", b => SuperGump.Send( new ConfirmDialogGump(user, toolbar) { Title = \"Global Apply\", Html = \"Applying this entry globally will overwrite any custom entries at the entry location on all existing toolbars.\\n\\nDo you want to continue?\", AcceptHandler = db => { ToolbarEntry def = Toolbars.DefaultEntries.GetContent(loc.X, loc.Y); foreach (ToolbarState tbs in Toolbars.Profiles.Values) { try { tbs.SetContent(loc.X, loc.Y, def != null ? def.Clone() : null); SuperGump tb = tbs.GetToolbarGump(); if (tb != null && tb.IsOpen) { tb.Refresh(true); } } catch { } } } }), toolbar.HighlightHue)); } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Add pdf blobs for Display Appliance /// </summary> /// <exception cref=\"DocuSign.eSign.Client.ApiException\">Thrown when fails to make API call</exception> /// <param name=\"accountId\">The external account number (int) or account ID Guid.</param>/// <param name=\"envelopeId\">The envelopeId Guid of the envelope being accessed.</param> /// <returns>ApiResponse of DisplayAppliancePdf</returns> public ApiResponse< DisplayAppliancePdf > CreatePdfBlobWithHttpInfo (string accountId, string envelopeId) { // verify the required parameter 'accountId' is set if (accountId == null) throw new ApiException(400, \"Missing required parameter 'accountId' when calling EnvelopesApi->CreatePdfBlob\"); // verify the required parameter 'envelopeId' is set if (envelopeId == null) throw new ApiException(400, \"Missing required parameter 'envelopeId' when calling EnvelopesApi->CreatePdfBlob\"); var localVarPath = \"/v2.1/accounts/{accountId}/envelopes/{envelopeId}/display_appliance_info/pdf_blobs\"; var localVarPathParams = new Dictionary<String, String>(); var localVarQueryParams = new Dictionary<String, String>(); var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader); var localVarFormParams = new Dictionary<String, String>(); var localVarFileParams = new Dictionary<String, FileParameter>(); Object localVarPostBody = null; // to determine the Content-Type header String[] localVarHttpContentTypes = new String[] { }; String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes); // to determine the Accept header String[] localVarHttpHeaderAccepts = new String[] { \"application/json\" }; String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts); if (localVarHttpHeaderAccept != null) localVarHeaderParams.Add(\"Accept\", localVarHttpHeaderAccept); // set \"format\" to json by default // e.g. /pet/{petId}.{format} becomes /pet/{petId}.json localVarPathParams.Add(\"format\", \"json\"); if (accountId != null) localVarPathParams.Add(\"accountId\", Configuration.ApiClient.ParameterToString(accountId)); // path parameter if (envelopeId != null) localVarPathParams.Add(\"envelopeId\", Configuration.ApiClient.ParameterToString(envelopeId)); // path parameter // make the HTTP request IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath, Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarPathParams, localVarHttpContentType); int localVarStatusCode = (int) localVarResponse.StatusCode; if (ExceptionFactory != null) { Exception exception = ExceptionFactory(\"CreatePdfBlob\", localVarResponse); if (exception != null) throw exception; } // DocuSign: Handle for PDF return types if (localVarResponse.ContentType != null && !localVarResponse.ContentType.ToLower().Contains(\"json\")) { return new ApiResponse<DisplayAppliancePdf>(localVarStatusCode, localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()), (DisplayAppliancePdf) Configuration.ApiClient.Deserialize(localVarResponse.RawBytes, typeof(DisplayAppliancePdf))); } else { return new ApiResponse<DisplayAppliancePdf>(localVarStatusCode, localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()), (DisplayAppliancePdf) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DisplayAppliancePdf))); } }", "label": "ComplexConditional"}
{"text": "#endregion #region Method: Decompress(string, string) public override void Decompress(string infile, string outfile) { // make sure the output directory exists string outDirectory = Path.GetDirectoryName(outfile); if (!Directory.Exists(outDirectory)) Directory.CreateDirectory(outDirectory); // open the two given files, and delegate to the format-specific code. using (FileStream inStream = new FileStream(infile, FileMode.Open), outStream = new FileStream(outfile, FileMode.Create)) { long fLength = inStream.Length; // arm9.bin needs special attention if (Path.GetFileName(infile) == \"arm9.bin\") fLength -= 0xC; this.Decompress(inStream, fLength, outStream); } }#endregion #region Decompression method public override long Decompress(System.IO.Stream instream, long inLength, System.IO.Stream outstream) { #region Format description // Overlay LZ compression is basically just LZ-0x10 compression. // however the order if reading is reversed: the compression starts at the end of the file. // Assuming we start reading at the end towards the beginning, the format is: /* * u32 extraSize; // decompressed data size = file length (including header) + this value * u8 headerSize; * u24 compressedLength; // can be less than file size (w/o header). If so, the rest of the file is uncompressed. * // may also be the file size * u8[headerSize-8] padding; // 0xFF-s * * 0x10-like-compressed data follows (without the usual 4-byte header). * The only difference is that 2 should be added to the DISP value in compressed blocks * to get the proper value. * the u32 and u24 are read most significant byte first. * if extraSize is 0, there is no headerSize, decompressedLength or padding. * the data starts immediately, and is uncompressed. * * arm9.bin has 3 extra u32 values at the 'start' (ie: end of the file), * which may be ignored. (and are ignored here) These 12 bytes also should not * be included in the computation of the output size. */ #endregion #region First read the last 4 bytes of the stream (the 'extraSize') // first go to the end of the stream, since we're reading from back to front // read the last 4 bytes, the 'extraSize' instream.Position += inLength - 4; byte[] buffer = new byte[4]; try { instream.Read(buffer, 0, 4); } catch (System.IO.EndOfStreamException) { // since we're immediately checking the end of the stream, // this is the only location where we have to check for an EOS to occur. throw new StreamTooShortException(); } uint extraSize = IOUtils.ToNDSu32(buffer, 0); #endregion // if the extra size is 0, there is no compressed part, and the header ends there. if (extraSize == 0) { #region just copy the input to the output // first go back to the start of the file. the current location is after the 'extraSize', // and thus at the end of the file. instream.Position -= inLength; // no buffering -> slow buffer = new byte[inLength - 4]; instream.Read(buffer, 0, (int)(inLength - 4)); outstream.Write(buffer, 0, (int)(inLength - 4)); // make sure the input is positioned at the end of the file instream.Position += 4; return inLength - 4; #endregion } else { // get the size of the compression header first. instream.Position -= 5; int headerSize = instream.ReadByte(); // then the compressed data size. instream.Position -= 4; instream.Read(buffer, 0, 3); int compressedSize = buffer[0] | (buffer[1] << 8) | (buffer[2] << 16); // the compressed size sometimes is the file size. if (compressedSize + headerSize >= inLength) compressedSize = (int)(inLength - headerSize); #region copy the non-compressed data // copy the non-compressed data first. buffer = new byte[inLength - headerSize - compressedSize]; instream.Position -= (inLength - 5); instream.Read(buffer, 0, buffer.Length); outstream.Write(buffer, 0, buffer.Length); #endregion // buffer the compressed data, such that we don't need to keep // moving the input stream position back and forth buffer = new byte[compressedSize]; instream.Read(buffer, 0, compressedSize); // we're filling the output from end to start, so we can't directly write the data. // buffer it instead (also use this data as buffer instead of a ring-buffer for // decompression) byte[] outbuffer = new byte[compressedSize + headerSize + extraSize]; int currentOutSize = 0; int decompressedLength = outbuffer.Length; int readBytes = 0; byte flags = 0, mask = 1; while (currentOutSize < decompressedLength) { // (throws when requested new flags byte is not available) #region Update the mask. If all flag bits have been read, get a new set. // the current mask is the mask used in the previous run. So if it masks the // last flag bit, get a new flags byte. if (mask == 1) { if (readBytes >= compressedSize) throw new NotEnoughDataException(currentOutSize, decompressedLength); flags = buffer[buffer.Length - 1 - readBytes]; readBytes++; mask = 0x80; } else { mask >>= 1; } #endregion // bit = 1 <=> compressed. if ((flags & mask) > 0) { // (throws when < 2 bytes are available) #region Get length and displacement('disp') values from next 2 bytes // there are < 2 bytes available when the end is at most 1 byte away if (readBytes + 1 >= inLength) { throw new NotEnoughDataException(currentOutSize, decompressedLength); } int byte1 = buffer[compressedSize - 1 - readBytes]; readBytes++; int byte2 = buffer[compressedSize - 1 - readBytes]; readBytes++; // the number of bytes to copy int length = byte1 >> 4; length += 3; // from where the bytes should be copied (relatively) int disp = ((byte1 & 0x0F) << 8) | byte2; disp += 3; if (disp > currentOutSize) { if (currentOutSize < 2) throw new InvalidDataException(String.Format(Main.Get_Traduction(\"S0D\"), disp.ToString(\"X\"), currentOutSize.ToString(\"X\"))); // HACK. this seems to produce valid files, but isn't the most elegant solution. // although this _could_ be the actual way to use a disp of 2 in this format, // as otherwise the minimum would be 3 (and 0 is undefined, and 1 is less useful). disp = 2; } #endregion int bufIdx = currentOutSize - disp; for (int i = 0; i < length; i++) { byte next = outbuffer[outbuffer.Length - 1 - bufIdx]; bufIdx++; outbuffer[outbuffer.Length - 1 - currentOutSize] = next; currentOutSize++; } } else { if (readBytes >= inLength) throw new NotEnoughDataException(currentOutSize, decompressedLength); byte next = buffer[buffer.Length - 1 - readBytes]; readBytes++; outbuffer[outbuffer.Length - 1 - currentOutSize] = next; currentOutSize++; } } // write the decompressed data outstream.Write(outbuffer, 0, outbuffer.Length); // make sure the input is positioned at the end of the file; the stream is currently // at the compression header. instream.Position += headerSize; return decompressedLength + (inLength - headerSize - compressedSize); } }", "label": "ComplexMethod"}
{"text": "public static Op GetPushOp(long value) { return GetPushOp(Utils.BigIntegerToBytes(ooo.BigInteger.ValueOf(value))); }public static Op GetPushOp(byte[] data) { Op op = new Op(); op.PushData = data; if (data.Length == 0) op.Code = OpcodeType.OP_0; else if (data.Length == 1 && (byte)1 <= data[0] && data[0] <= (byte)16) op.Code = (OpcodeType)(data[0] + (byte)OpcodeType.OP_1 - 1); else if (data.Length == 1 && (byte)0x81 == data[0]) op.Code = OpcodeType.OP_1NEGATE; else if (0x01 <= data.Length && data.Length <= 0x4b) op.Code = (OpcodeType)(byte)data.Length; else if (data.Length <= 0xFF) op.Code = OpcodeType.OP_PUSHDATA1; #if !NETSTANDARD1X else if (data.LongLength <= 0xFFFF) op.Code = OpcodeType.OP_PUSHDATA2; else if (data.LongLength <= 0xFFFFFFFF) op.Code = OpcodeType.OP_PUSHDATA4; #else else if(data.Length <= 0xFFFF) op.Code = OpcodeType.OP_PUSHDATA2; #endif else throw new NotSupportedException(\"Data length should not be bigger than 0xFFFFFFFF\"); return op; }", "label": "ComplexMethod"}
{"text": "/// <summary> /// this implements the evaluation functionality, cannot be used directly /// </summary> /// <param name=\"tree\">the parsetree itself</param> /// <param name=\"paramlist\">optional input parameters</param> /// <returns>a partial result of the evaluation</returns> internal object Eval(ParseTree tree, params object[] paramlist) { object Value = null; switch (Token.Type) { case TokenType.Start: Value = EvalStart(tree, paramlist); break; case TokenType.instruction_block: Value = Evalinstruction_block(tree, paramlist); break; case TokenType.instruction: Value = Evalinstruction(tree, paramlist); break; case TokenType.lazyglobal_directive: Value = Evallazyglobal_directive(tree, paramlist); break; case TokenType.directive: Value = Evaldirective(tree, paramlist); break; case TokenType.empty_stmt: Value = Evalempty_stmt(tree, paramlist); break; case TokenType.set_stmt: Value = Evalset_stmt(tree, paramlist); break; case TokenType.if_stmt: Value = Evalif_stmt(tree, paramlist); break; case TokenType.until_stmt: Value = Evaluntil_stmt(tree, paramlist); break; case TokenType.fromloop_stmt: Value = Evalfromloop_stmt(tree, paramlist); break; case TokenType.unlock_stmt: Value = Evalunlock_stmt(tree, paramlist); break; case TokenType.print_stmt: Value = Evalprint_stmt(tree, paramlist); break; case TokenType.on_stmt: Value = Evalon_stmt(tree, paramlist); break; case TokenType.toggle_stmt: Value = Evaltoggle_stmt(tree, paramlist); break; case TokenType.wait_stmt: Value = Evalwait_stmt(tree, paramlist); break; case TokenType.when_stmt: Value = Evalwhen_stmt(tree, paramlist); break; case TokenType.onoff_stmt: Value = Evalonoff_stmt(tree, paramlist); break; case TokenType.onoff_trailer: Value = Evalonoff_trailer(tree, paramlist); break; case TokenType.stage_stmt: Value = Evalstage_stmt(tree, paramlist); break; case TokenType.clear_stmt: Value = Evalclear_stmt(tree, paramlist); break; case TokenType.add_stmt: Value = Evaladd_stmt(tree, paramlist); break; case TokenType.remove_stmt: Value = Evalremove_stmt(tree, paramlist); break; case TokenType.log_stmt: Value = Evallog_stmt(tree, paramlist); break; case TokenType.break_stmt: Value = Evalbreak_stmt(tree, paramlist); break; case TokenType.preserve_stmt: Value = Evalpreserve_stmt(tree, paramlist); break; case TokenType.declare_identifier_clause: Value = Evaldeclare_identifier_clause(tree, paramlist); break; case TokenType.declare_parameter_clause: Value = Evaldeclare_parameter_clause(tree, paramlist); break; case TokenType.declare_function_clause: Value = Evaldeclare_function_clause(tree, paramlist); break; case TokenType.declare_lock_clause: Value = Evaldeclare_lock_clause(tree, paramlist); break; case TokenType.declare_stmt: Value = Evaldeclare_stmt(tree, paramlist); break; case TokenType.return_stmt: Value = Evalreturn_stmt(tree, paramlist); break; case TokenType.switch_stmt: Value = Evalswitch_stmt(tree, paramlist); break; case TokenType.copy_stmt: Value = Evalcopy_stmt(tree, paramlist); break; case TokenType.rename_stmt: Value = Evalrename_stmt(tree, paramlist); break; case TokenType.delete_stmt: Value = Evaldelete_stmt(tree, paramlist); break; case TokenType.edit_stmt: Value = Evaledit_stmt(tree, paramlist); break; case TokenType.run_stmt: Value = Evalrun_stmt(tree, paramlist); break; case TokenType.runpath_stmt: Value = Evalrunpath_stmt(tree, paramlist); break; case TokenType.runoncepath_stmt: Value = Evalrunoncepath_stmt(tree, paramlist); break; case TokenType.compile_stmt: Value = Evalcompile_stmt(tree, paramlist); break; case TokenType.list_stmt: Value = Evallist_stmt(tree, paramlist); break; case TokenType.reboot_stmt: Value = Evalreboot_stmt(tree, paramlist); break; case TokenType.shutdown_stmt: Value = Evalshutdown_stmt(tree, paramlist); break; case TokenType.for_stmt: Value = Evalfor_stmt(tree, paramlist); break; case TokenType.unset_stmt: Value = Evalunset_stmt(tree, paramlist); break; case TokenType.arglist: Value = Evalarglist(tree, paramlist); break; case TokenType.expr: Value = Evalexpr(tree, paramlist); break; case TokenType.ternary_expr: Value = Evalternary_expr(tree, paramlist); break; case TokenType.or_expr: Value = Evalor_expr(tree, paramlist); break; case TokenType.and_expr: Value = Evaland_expr(tree, paramlist); break; case TokenType.compare_expr: Value = Evalcompare_expr(tree, paramlist); break; case TokenType.arith_expr: Value = Evalarith_expr(tree, paramlist); break; case TokenType.multdiv_expr: Value = Evalmultdiv_expr(tree, paramlist); break; case TokenType.unary_expr: Value = Evalunary_expr(tree, paramlist); break; case TokenType.factor: Value = Evalfactor(tree, paramlist); break; case TokenType.suffix: Value = Evalsuffix(tree, paramlist); break; case TokenType.suffix_trailer: Value = Evalsuffix_trailer(tree, paramlist); break; case TokenType.suffixterm: Value = Evalsuffixterm(tree, paramlist); break; case TokenType.suffixterm_trailer: Value = Evalsuffixterm_trailer(tree, paramlist); break; case TokenType.function_trailer: Value = Evalfunction_trailer(tree, paramlist); break; case TokenType.array_trailer: Value = Evalarray_trailer(tree, paramlist); break; case TokenType.atom: Value = Evalatom(tree, paramlist); break; case TokenType.sci_number: Value = Evalsci_number(tree, paramlist); break; case TokenType.number: Value = Evalnumber(tree, paramlist); break; case TokenType.varidentifier: Value = Evalvaridentifier(tree, paramlist); break; case TokenType.identifier_led_stmt: Value = Evalidentifier_led_stmt(tree, paramlist); break; case TokenType.identifier_led_expr: Value = Evalidentifier_led_expr(tree, paramlist); break; default: Value = Token.Text; break; } return Value; }", "label": "FeatureEnvy"}
{"text": "public static ushort ConvertCPE(ushort b) { switch (b) { case 50: return 44; case 51: return 39; case 52: return 12; case 53: return 0; case 54: return 10; case 55: return 33; case 56: return 25; case 57: return 3; case 58: return 29; case 59: return 28; case 60: return 20; case 61: return 42; case 62: return 49; case 63: return 36; case 64: return 5; case 65: return 1; default: return b; } }", "label": "ComplexMethod"}
{"text": "/// <inheritdoc/> public override Size MeasureOverride(Size availableSize) { var scrollable = (ILogicalScrollable)Owner; var visualRoot = Owner.GetVisualRoot(); var maxAvailableSize = (visualRoot as WindowBase)?.PlatformImpl?.MaxClientSize ?? (visualRoot as TopLevel)?.ClientSize; // If infinity is passed as the available size and we're virtualized then we need to // fill the available space, but to do that we *don't* want to materialize all our // items! Take a look at the root of the tree for a MaxClientSize and use that as // the available size. if (VirtualizingPanel.ScrollDirection == Orientation.Vertical) { if (availableSize.Height == double.PositiveInfinity) { if (maxAvailableSize.HasValue) { availableSize = availableSize.WithHeight(maxAvailableSize.Value.Height); } } if (scrollable.CanHorizontallyScroll) { availableSize = availableSize.WithWidth(double.PositiveInfinity); } } else { if (availableSize.Width == double.PositiveInfinity) { if (maxAvailableSize.HasValue) { availableSize = availableSize.WithWidth(maxAvailableSize.Value.Width); } } if (scrollable.CanVerticallyScroll) { availableSize = availableSize.WithHeight(double.PositiveInfinity); } } Owner.Panel.Measure(availableSize); return Owner.Panel.DesiredSize; }", "label": "ComplexMethod"}
{"text": "public override void WriteXml(XmlWriter writer) { writer.WriteElementString(\"Name\", Namespace, Name.ToString()); writer.WriteElementString(\"Title\", Namespace, Title); if (!string.IsNullOrEmpty(Abstract)) writer.WriteElementString(\"Abstract\", Namespace, Abstract); if (_keywordListField != null && _keywordListField.Keyword.Count > 0) { writer.WriteStartElement(\"KeywordList\", Namespace); KeywordList.WriteXml(writer); writer.WriteEndElement(); } writer.WriteStartElement(\"OnlineResource\", Namespace); OnlineResource.WriteXml(writer); writer.WriteEndElement(); if (_contactInformationField != null) { writer.WriteStartElement(\"ContactInformation\", Namespace); _contactInformationField.WriteXml(writer); writer.WriteEndElement(); } if (!string.IsNullOrEmpty(Fees)) writer.WriteElementString(\"Fees\", Namespace, Fees); if (!string.IsNullOrEmpty(AccessConstraints)) writer.WriteElementString(\"AccessConstraints\", Namespace, AccessConstraints); if (LayerLimit.HasValue) writer.WriteElementString(\"LayerLimit\", Namespace, LayerLimit.Value.ToString()); if (MaxWidth.HasValue) writer.WriteElementString(\"MaxWidth\", Namespace, MaxWidth.Value.ToString()); if (MaxHeight.HasValue) writer.WriteElementString(\"MaxHeight\", Namespace, MaxHeight.Value.ToString()); }", "label": "ComplexMethod"}
{"text": "public override bool Equals(object obj) { if (this == obj) { return true; } var cacheKey = obj as CacheKey; if (cacheKey == null) { return false; } if (!Equals(type, cacheKey.type)) { return false; } if (!Equals(target, cacheKey.target)) { return false; } if (interfaces.Length != cacheKey.interfaces.Length) { return false; } for (var i = 0; i < interfaces.Length; i++) { if (!Equals(interfaces[i], cacheKey.interfaces[i])) { return false; } } if (!Equals(options, cacheKey.options)) { return false; } return true; }", "label": "ComplexMethod"}
{"text": "internal static P<uint> GetMatchesSpec1(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue, P<uint> distances, uint maxLen) { P<uint> ptr0 = son + (_cyclicBufferPos << 1) + 1; P<uint> ptr1 = son + (_cyclicBufferPos << 1); uint len0 = 0; uint len1 = 0; for (;;) { uint delta = pos - curMatch; if (cutValue-- == 0 || delta >= _cyclicBufferSize) { ptr0[0] = ptr1[0] = CMatchFinder.kEmptyHashValue; return distances; } P<uint> pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1); P<byte> pb = cur - delta; uint len = (len0 < len1 ? len0 : len1); if (pb[len] == cur[len]) { if (++len != lenLimit && pb[len] == cur[len]) while (++len != lenLimit) if (pb[len] != cur[len]) break; if (maxLen < len) { distances[0] = maxLen = len; distances++; distances[0] = delta - 1; distances++; if (len == lenLimit) { ptr1[0] = pair[0]; ptr0[0] = pair[1]; return distances; } } } if (pb[len] < cur[len]) { ptr1[0] = curMatch; ptr1 = pair + 1; curMatch = ptr1[0]; len1 = len; } else { ptr0[0] = curMatch; ptr0 = pair; curMatch = ptr0[0]; len0 = len; } } }", "label": "ComplexMethod"}
{"text": "private void BreakAllInvalidJoints() { GameEvents.onVesselWasModified.Remove(OnVesselWasModified); foreach (ConfigurableJoint j in joints) GameObject.Destroy(j); joints.Clear(); var vessels = new List<Vessel>(); foreach (Part n in neighbours) { if (n.vessel == null || vessels.Contains(n.vessel)) continue; vessels.Add(n.vessel); foreach (Part p in n.vessel.Parts) { if (p.Modules.Contains<LaunchClamp>()) continue; ConfigurableJoint[] possibleConnections = p.GetComponents<ConfigurableJoint>(); if (possibleConnections == null) continue; foreach (ConfigurableJoint j in possibleConnections) { if (j.connectedBody == null) { GameObject.Destroy(j); continue; } Part cp = j.connectedBody.GetComponent<Part>(); if (cp != null && cp.vessel != p.vessel) GameObject.Destroy(j); } } } neighbours.Clear(); }", "label": "ComplexMethod"}
{"text": "private static void Provider_Executing(object sender, ExecutingEventArgs args) { if (!(args.CommandName == \"CommitTransaction\" || args.CommandName == \"FlushTransaction\")) return; var provider = sender as PageDataProvider; var dirtyItems = provider.GetDirtyItems(); if (dirtyItems.Count == 0) return; var createdPageTemplates = provider.GetExecutionStateData(CreatedPageTemplatesCategoryIds) as HashSet<string>; if (createdPageTemplates == null) createdPageTemplates = new HashSet<string>(); foreach (var item in dirtyItems) { SecurityConstants.TransactionActionType itemStatus = provider.GetDirtyItemStatus(item); var pageTemplate = item as PageTemplate; if (pageTemplate != null) { if (itemStatus == SecurityConstants.TransactionActionType.New && pageTemplate.Framework == PageTemplateFramework.Mvc) { // the template name is formulated as Bootstrap.default var nameParts = pageTemplate.Name.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries); if (nameParts.Length > 1) { var package = nameParts[0]; // always create the template, desipite if the package is not there // in case the client first performs a sync and then deploys the files by mistake createdPageTemplates.Add(package); } } } } if (createdPageTemplates.Any()) { provider.SetExecutionStateData(CreatedPageTemplatesCategoryIds, createdPageTemplates); } }", "label": "ComplexMethod"}
{"text": "private static float ComboDamage(Obj_AI_Base enemy) { var damage = 0d; if (_igniteSlot != SpellSlot.Unknown && _player.Spellbook.CanUseSpell(_igniteSlot) == SpellState.Ready) damage += ObjectManager.Player.GetSummonerSpellDamage(enemy, Damage.SummonerSpell.Ignite); if (Items.HasItem(3077) && Items.CanUseItem(3077)) damage += _player.GetItemDamage(enemy, Damage.DamageItems.Tiamat); if (Items.HasItem(3074) && Items.CanUseItem(3074)) damage += _player.GetItemDamage(enemy, Damage.DamageItems.Hydra); if (Items.HasItem(3153) && Items.CanUseItem(3153)) damage += _player.GetItemDamage(enemy, Damage.DamageItems.Botrk); if (Items.HasItem(3144) && Items.CanUseItem(3144)) damage += _player.GetItemDamage(enemy, Damage.DamageItems.Bilgewater); if (_q.IsReady()) damage += _player.GetSpellDamage(enemy, SpellSlot.Q)*1.2; if (_q.IsReady()) damage += _player.GetSpellDamage(enemy, SpellSlot.W)*3; if (_e.IsReady()) damage += _player.GetSpellDamage(enemy, SpellSlot.E); if (_r.IsReady()) damage += _player.GetSpellDamage(enemy, SpellSlot.R); damage += _player.GetAutoAttackDamage(enemy, true)*2; return (float) damage; }", "label": "ComplexMethod"}
{"text": "public void ExportHQTFFD(string path, ETLExportEnum exportType = ETLExportEnum.ETLExportSimple, bool append = false, bool omitSource = false, bool omitLegacy = false, long size = 32) { // The public entry point for exporting HQTFFD from the JMSML library // into CSV format. These include combinations of headquarter, task force, and feint/dummy amplifiers // Accepts a path for the output (sans file name extension). The output may also // be appended to an existing file. IHQTFFDExport hqTFFDExporter = null; string line = \"\"; _configHelper.PointSize = (int)size; switch (exportType) { case ETLExportEnum.ETLExportDomain: hqTFFDExporter = new DomainHQTFFDExport(_configHelper); break; case ETLExportEnum.ETLExportImage: hqTFFDExporter = new ImageHQTFFDExport(_configHelper, omitSource, omitLegacy); break; } if (hqTFFDExporter != null) { using (var w = new StreamWriter(path + \".csv\", append)) { if (!append) { line = string.Format(\"{0}\", hqTFFDExporter.Headers); w.WriteLine(line); w.Flush(); } foreach (LibraryHQTFDummy hqTFFD in _library.HQTFDummies) { if (hqTFFD.Graphics != null && exportType == ETLExportEnum.ETLExportImage) { foreach (LibraryHQTFDummyGraphic graphic in hqTFFD.Graphics) { line = hqTFFDExporter.Line(hqTFFD, graphic); if (line != \"\") { w.WriteLine(line); w.Flush(); } } } else if (exportType == ETLExportEnum.ETLExportDomain) { if (!hqTFFD.IsExtension) { line = hqTFFDExporter.Line(hqTFFD, null); if (line != \"\") { w.WriteLine(line); w.Flush(); } } } } } } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// <p> /// If buffer is non null stream assumed to be partial, otherwise the length will be used /// to output a fixed length packet. /// </p> /// <p> /// The stream created can be closed off by either calling Close() /// on the stream or Close() on the generator. Closing the returned /// stream does not close off the Stream parameter <c>outStr</c>. /// </p> /// </summary> private Stream Open( Stream outStr, long length, byte[] buffer) { if (cOut != null) throw new InvalidOperationException(\"generator already in open state\"); if (methods.Count == 0) throw new InvalidOperationException(\"No encryption methods specified\"); if (outStr == null) throw new ArgumentNullException(\"outStr\"); pOut = new BcpgOutputStream(outStr); KeyParameter key; if (methods.Count == 1) { if (methods[0] is PbeMethod) { PbeMethod m = (PbeMethod)methods[0]; key = m.GetKey(); } else { key = PgpUtilities.MakeRandomKey(defAlgorithm, rand); byte[] sessionInfo = CreateSessionInfo(defAlgorithm, key); PubMethod m = (PubMethod)methods[0]; try { m.AddSessionInfo(sessionInfo, rand); } catch (Exception e) { throw new PgpException(\"exception encrypting session key\", e); } } pOut.WritePacket((ContainedPacket)methods[0]); } else // multiple methods { key = PgpUtilities.MakeRandomKey(defAlgorithm, rand); byte[] sessionInfo = CreateSessionInfo(defAlgorithm, key); for (int i = 0; i != methods.Count; i++) { EncMethod m = (EncMethod)methods[i]; try { m.AddSessionInfo(sessionInfo, rand); } catch (Exception e) { throw new PgpException(\"exception encrypting session key\", e); } pOut.WritePacket(m); } } string cName = PgpUtilities.GetSymmetricCipherName(defAlgorithm); if (cName == null) { throw new PgpException(\"null cipher specified\"); } try { if (withIntegrityPacket) { cName += \"/CFB/NoPadding\"; } else { cName += \"/OpenPGPCFB/NoPadding\"; } c = CipherUtilities.GetCipher(cName); // TODO Confirm the IV should be all zero bytes (not inLineIv - see below) byte[] iv = new byte[c.GetBlockSize()]; c.Init(true, new ParametersWithRandom(new ParametersWithIV(key, iv), rand)); if (buffer == null) { // // we have to Add block size + 2 for the Generated IV and + 1 + 22 if integrity protected // if (withIntegrityPacket) { pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricEncryptedIntegrityProtected, length + c.GetBlockSize() + 2 + 1 + 22); pOut.WriteByte(1); // version number } else { pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricKeyEncrypted, length + c.GetBlockSize() + 2, oldFormat); } } else { if (withIntegrityPacket) { pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricEncryptedIntegrityProtected, buffer); pOut.WriteByte(1); // version number } else { pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricKeyEncrypted, buffer); } } int blockSize = c.GetBlockSize(); byte[] inLineIv = new byte[blockSize + 2]; rand.NextBytes(inLineIv, 0, blockSize); Array.Copy(inLineIv, inLineIv.Length - 4, inLineIv, inLineIv.Length - 2, 2); Stream myOut = cOut = new CipherStream(pOut, null, c); if (withIntegrityPacket) { string digestName = PgpUtilities.GetDigestName(HashAlgorithmTag.Sha1); IDigest digest = DigestUtilities.GetDigest(digestName); myOut = digestOut = new DigestStream(myOut, null, digest); } myOut.Write(inLineIv, 0, inLineIv.Length); return new WrappedGeneratorStream(this, myOut); } catch (Exception e) { throw new PgpException(\"Exception creating cipher\", e); } }/// <summary> /// <p> /// Return an output stream which will encrypt the data as it is written to it. /// </p> /// <p> /// The stream created can be closed off by either calling Close() /// on the stream or Close() on the generator. Closing the returned /// stream does not close off the Stream parameter <c>outStr</c>. /// </p> /// </summary> public Stream Open( Stream outStr, long length) { return Open(outStr, length, null); }/// <summary> /// <p> /// Return an output stream which will encrypt the data as it is written to it. /// The stream will be written out in chunks according to the size of the passed in buffer. /// </p> /// <p> /// The stream created can be closed off by either calling Close() /// on the stream or Close() on the generator. Closing the returned /// stream does not close off the Stream parameter <c>outStr</c>. /// </p> /// <p> /// <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2 /// bytes worth of the buffer will be used. /// </p> /// </summary> public Stream Open( Stream outStr, byte[] buffer) { return Open(outStr, 0, buffer); }", "label": "ComplexConditional"}
{"text": "// REVIEW: We can use a stack if the perf is bad for Except and MergeWith public static XElement Except(this XElement source, XElement target) { if (target == null) { return source; } var attributesToRemove = from e in source.Attributes() where AttributeEquals(e, target.Attribute(e.Name)) select e; // Remove the attributes foreach (var a in attributesToRemove.ToList()) { a.Remove(); } foreach (var sourceChildNode in source.Nodes().ToList()) { var sourceChildComment = sourceChildNode as XComment; if (sourceChildComment != null) { var hasMatchingComment = HasComment(target, sourceChildComment); if (hasMatchingComment) { sourceChildComment.Remove(); } continue; } var sourceChild = sourceChildNode as XElement; if (sourceChild != null) { var targetChild = FindElement(target, sourceChild); if (targetChild != null && !HasConflict(sourceChild, targetChild)) { Except(sourceChild, targetChild); var hasContent = sourceChild.HasAttributes || sourceChild.HasElements; if (!hasContent) { // Remove the element if there is no content sourceChild.Remove(); targetChild.Remove(); } } } } return source; }", "label": "ComplexMethod"}
{"text": "public override bool DoActionCombat() { Mobile combatant = m_Mobile.Combatant; if (combatant == null || combatant.Deleted || combatant.Map != m_Mobile.Map || !combatant.Alive || combatant.IsDeadBondedPet) { m_Mobile.DebugSay(\"My combatant is gone, so my guard is up\"); Action = ActionType.Guard; return true; } if (Utility.RandomDouble() < teleportChance) { TryToTeleport(); } if (!m_Mobile.InRange(combatant, m_Mobile.RangePerception)) { // They are somewhat far away, can we find something else? if (AcquireFocusMob(m_Mobile.RangePerception, m_Mobile.FightMode, false, false, true)) { m_Mobile.Combatant = m_Mobile.FocusMob; m_Mobile.FocusMob = null; } else if (!m_Mobile.InRange(combatant, m_Mobile.RangePerception * 3)) { m_Mobile.Combatant = null; } combatant = m_Mobile.Combatant; if (combatant == null) { m_Mobile.DebugSay(\"My combatant has fled, so I am on guard\"); Action = ActionType.Guard; return true; } } /*if ( !m_Mobile.InLOS( combatant ) ) { if ( AcquireFocusMob( m_Mobile.RangePerception, m_Mobile.FightMode, false, false, true ) ) { m_Mobile.Combatant = combatant = m_Mobile.FocusMob; m_Mobile.FocusMob = null; } }*/ if (MoveTo(combatant, true, m_Mobile.RangeFight)) { m_Mobile.Direction = m_Mobile.GetDirectionTo(combatant); } else if (AcquireFocusMob(m_Mobile.RangePerception, m_Mobile.FightMode, false, false, true)) { if (m_Mobile.Debug) { m_Mobile.DebugSay(\"My move is blocked, so I am going to attack {0}\", m_Mobile.FocusMob.Name); } m_Mobile.Combatant = m_Mobile.FocusMob; Action = ActionType.Combat; return true; } else if (m_Mobile.GetDistanceToSqrt(combatant) > m_Mobile.RangePerception + 1) { if (m_Mobile.Debug) { m_Mobile.DebugSay(\"I cannot find {0}, so my guard is up\", combatant.Name); } Action = ActionType.Guard; return true; } else { if (m_Mobile.Debug) { m_Mobile.DebugSay(\"I should be closer to {0}\", combatant.Name); } } if (!m_Mobile.Controlled && !m_Mobile.Summoned) { if (m_Mobile.Hits < m_Mobile.HitsMax * 20 / 100) { // We are low on health, should we flee? bool flee = false; if (m_Mobile.Hits < combatant.Hits) { // We are more hurt than them int diff = combatant.Hits - m_Mobile.Hits; flee = (Utility.Random(0, 100) < (10 + diff)); // (10 + diff)% chance to flee } else { flee = Utility.Random(0, 100) < 10; // 10% chance to flee } if (flee) { if (m_Mobile.Debug) { m_Mobile.DebugSay(\"I am going to flee from {0}\", combatant.Name); } Action = ActionType.Flee; if (Utility.RandomDouble() < teleportChance + 0.1) { TryToTeleport(); } } } } return true; }", "label": "FeatureEnvy"}
{"text": "protected override void OnTick() { if (m_NextSkillTime != m_From.NextSkillTime || m_NextSpellTime != m_From.NextSpellTime || m_NextActionTime != m_From.NextActionTime) { Terminate(); return; } if (m_LastMoveTime != m_From.LastMoveTime) { m_From.SendLocalizedMessage(503023); // You cannot move around while digging up treasure. You will need to start digging anew. Terminate(); return; } int z = (m_Chest != null) ? m_Chest.Z + m_Chest.ItemData.Height : int.MinValue; int height = 16; if (z > m_Location.Z) { height -= (z - m_Location.Z); } else { z = m_Location.Z; } if (!m_Map.CanFit(m_Location.X, m_Location.Y, z, height, true, true, false)) { m_From.SendLocalizedMessage(503024); // You stop digging because something is directly on top of the treasure chest. Terminate(); return; } m_Count++; m_From.RevealingAction(); m_From.Direction = m_From.GetDirectionTo(m_Location); if (m_Count > 1 && m_Dirt1 == null) { m_Dirt1 = new TreasureChestDirt(); m_Dirt1.MoveToWorld(m_Location, m_Map); m_Dirt2 = new TreasureChestDirt(); m_Dirt2.MoveToWorld(new Point3D(m_Location.X, m_Location.Y - 1, m_Location.Z), m_Map); } if (m_Count == 5) { m_Dirt1.Turn1(); } else if (m_Count == 10) { m_Dirt1.Turn2(); m_Dirt2.Turn2(); } else if (m_Count > 10) { if (m_Chest == null) { m_Chest = new TreasureMapChest(m_From, m_TreasureMap.Level, true); m_Chest.MoveToWorld(new Point3D(m_Location.X, m_Location.Y, m_Location.Z - 15), m_Map); } else { m_Chest.Z++; } Effects.PlaySound(m_Chest, m_Map, 0x33B); } if (m_Chest != null && m_Chest.Location.Z >= m_Location.Z) { Stop(); m_From.EndAction(typeof(TreasureMap)); m_Chest.Temporary = false; m_TreasureMap.Completed = true; m_TreasureMap.CompletedBy = m_From; int spawns; switch (m_TreasureMap.Level) { case 0: spawns = 3; break; case 1: spawns = 0; break; default: spawns = 4; break; } for (int i = 0; i < spawns; ++i) { BaseCreature bc = Spawn(m_TreasureMap.Level, m_Chest.Location, m_Chest.Map, null, true); if (bc != null) { m_Chest.Guardians.Add(bc); } } } else { if (m_From.Body.IsHuman && !m_From.Mounted) { m_From.Animate(11, 5, 1, true, false, 0); } new SoundTimer(m_From, 0x125 + (m_Count % 2)).Start(); } }", "label": "ComplexMethod"}
{"text": "public override void Use(Player p, string message) { message = message.ToLower (); if (message == \"\") { Help(p); return; } Player pl = Player.Find(message); if (pl != null && !pl.hidden) { Player.SendMessage(p, pl.color + pl.name + Server.DefaultColor + \" is online, using /whois instead.\"); Command.all.Find(\"whois\").Use(p, message); return; } if (message.IndexOf(\"'\") != -1) { Player.SendMessage(p, \"Cannot parse request.\"); return; } string FoundRank = Group.findPlayer(message.ToLower()); if (!Load(message)) { Player.SendMessage(p, Group.Find(FoundRank).color + message + Server.DefaultColor + \" has the rank of \" + Group.Find(FoundRank).color + FoundRank); return; } if (title == \"\" || title == null || String.IsNullOrEmpty(title)) Player.SendMessage(p, color + message + Server.DefaultColor + \" has :\"); else Player.SendMessage(p, color + \"[\" + titlecolor + title + color + \"] \" + message + Server.DefaultColor + \" has :\"); Player.SendMessage(p, \"> > the rank of \" + Group.Find(FoundRank).color + FoundRank); try { if (!Group.Find(\"Nobody\").commands.Contains(\"pay\") && !Group.Find(\"Nobody\").commands.Contains(\"give\") && !Group.Find(\"Nobody\").commands.Contains(\"take\")) Player.SendMessage(p, \"> > &a\" + money + Server.DefaultColor + \" \" + Server.moneys); } catch { } Player.SendMessage(p, \"> > &cdied &a\" + overalldeaths + Server.DefaultColor + \" times\"); Player.SendMessage(p, \"> > &bmodified &a\" + overallblocks + \" &eblocks.\"); Player.SendMessage(p, \"> > was last seen on &a\" + lastlogin); Player.SendMessage(p, \"> > first logged into the server on &a\" + firstlogin); Player.SendMessage(p, \"> > logged in &a\" + totallogins + Server.DefaultColor + \" times, &c\" + totalkicks + Server.DefaultColor + \" of which ended in a kick.\"); Player.SendMessage(p, \"> > \" + Awards.awardAmount(message) + \" awards\"); if (Ban.Isbanned(message)) { string[] data = Ban.Getbandata(message); Player.SendMessage(p, \"> > was banned by \" + data[0] + \" for \" + data[1] + \" on \" + data[2]); } if (Server.Devs.Contains(message.ToLower())) { Player.SendMessage(p, Server.DefaultColor + \"> > Player is a &9Developer\"); if (Server.forgeProtection == ForgeProtection.Mod || Server.forgeProtection == ForgeProtection.Dev) Player.SendMessage(p, Server.DefaultColor + \"> > Player is &CPROTECTED\" + Server.DefaultColor + \" under MCForge Staff protection\"); } else if (Server.Mods.Contains(message.ToLower())) { Player.SendMessage(p, Server.DefaultColor + \"> > Player is a &9MCForge Moderator\"); if (Server.forgeProtection == ForgeProtection.Mod) Player.SendMessage(p, Server.DefaultColor + \"> > Player is &CPROTECTED\" + Server.DefaultColor + \" under MCForge Staff protection\"); } else if (Server.GCmods.Contains(message.ToLower())) Player.SendMessage(p, Server.DefaultColor + \"> > Player is a &9Global Chat Moderator\"); if (!(p != null && (int)p.group.Permission <= CommandOtherPerms.GetPerm(this))) { if (Server.useWhitelist) { if (Server.whiteList.Contains(message.ToLower())) { Player.SendMessage(p, \"> > Player is &fWhitelisted\"); } } } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Returns an URL to entry thumbnail image, or placeholder if no image if specified. /// </summary> /// <param name=\"urlHelper\">URL helper. Cannot be null.</param> /// <param name=\"imageInfo\">Image information. Cannot be null.</param> /// <param name=\"size\">Requested image size.</param> /// <returns>URL to the image thumbnail (may be placeholder).</returns> public static string ImageThumb(this UrlHelper urlHelper, EntryThumbForApiContract imageInfo, ImageSize size) { return imageInfo?.GetSmallestThumb(size).EmptyToNull() ?? GetUnknownImageUrl(urlHelper); }/// <summary> /// Returns an URL to entry thumbnail image. /// Currently only used for album and artist main images. /// /// Gets the URL to the static images folder on disk if possible, /// otherwise gets the image from the DB. /// </summary> /// <param name=\"urlHelper\">URL helper. Cannot be null.</param> /// <param name=\"imageInfo\">Image information. Cannot be null.</param> /// <param name=\"size\">Requested image size.</param> /// <param name=\"fullUrl\"> /// Whether the URL should always include the hostname and application path root. /// If this is false (default), the URL maybe either full (such as http://vocadb.net/Album/CoverPicture/123) /// or relative (such as /Album/CoverPicture/123). /// Usually this should be set to true if the image is to be referred from another domain. /// </param> /// <returns>URL to the image thumbnail.</returns> public static string ImageThumb(this UrlHelper urlHelper, IEntryImageInformation imageInfo, ImageSize size, bool fullUrl = false) { if (imageInfo == null) return null; var shouldExist = ShouldExist(imageInfo); string dynamicUrl = null; // Use MVC dynamic actions (instead of static file) when requesting original or an image that doesn't exist on disk. if (imageInfo.EntryType == EntryType.Album) { if (size == ImageSize.Original) dynamicUrl = urlHelper.Action(\"CoverPicture\", \"Album\", new { id = imageInfo.Id, v = imageInfo.Version }); else if (shouldExist && !imagePersister.HasImage(imageInfo, size)) dynamicUrl = urlHelper.Action(\"CoverPictureThumb\", \"Album\", new { id = imageInfo.Id, v = imageInfo.Version }); } else if (imageInfo.EntryType == EntryType.Artist) { if (size == ImageSize.Original) dynamicUrl = urlHelper.Action(\"Picture\", \"Artist\", new { id = imageInfo.Id, v = imageInfo.Version }); else if (shouldExist && !imagePersister.HasImage(imageInfo, size)) dynamicUrl = urlHelper.Action(\"PictureThumb\", \"Artist\", new { id = imageInfo.Id, v = imageInfo.Version }); } if (dynamicUrl != null) { return fullUrl ? VocaUriBuilder.Absolute(dynamicUrl) : dynamicUrl; } if (!shouldExist) { var unknown = GetUnknownImageUrl(urlHelper); return fullUrl ? VocaUriBuilder.Absolute(unknown) : unknown; } // For all other cases use the static file return imagePersister.GetUrlAbsolute(imageInfo, size); }", "label": "ComplexMethod"}
{"text": "public Unit GetNextTarget() { Unit Me = GetUnit(); Unit Target = null; if (!Me.IsPlayer()) { AggroInfo Info = GetMaxAggroHate(true); if (Info == null) Info = GetMaxAggroHate(false); if(Info != null) Target = _Owner.Region.GetObject(Info.Oid) as Unit; } else { Target = GetTarget(GameData.TargetTypes.TARGETTYPES_TARGET_ENEMY); } if (Target == null) return null; if (!Target.IsInWorld()) return null; if (Target.IsDead) { if (AI.State == AiState.FIGHTING) OnTargetDie(Target); return null; } return Target; }", "label": "ComplexMethod"}
{"text": "public static VkGroup FromJson(JToken json) { if (json == null) throw new ArgumentException(\"Json can not be null.\"); var result = new VkGroup(); result.Id = Math.Abs(json[\"id\"].Value<long>()); result.Name = WebUtility.HtmlDecode(json[\"name\"].Value<string>()).Trim(); if (json[\"photo_50\"] != null) result.Photo = (string)json[\"photo_50\"]; if (json[\"photo_100\"] != null) result.PhotoMedium = json[\"photo_100\"].Value<string>(); if (json[\"photo_200_orig\"] != null) result.PhotoBig = json[\"photo_200_orig\"].Value<string>(); if (json[\"photo_200\"] != null) result.PhotoBigSquare = json[\"photo_200\"].Value<string>(); if (json[\"photo_400_orig\"] != null) result.PhotoLarge = json[\"photo_400_orig\"].Value<string>(); if (json[\"photo_max\"] != null) result.PhotoMaxSquare = json[\"photo_max\"].Value<string>(); if (json[\"photo_max_orig\"] != null) result.PhotoMax = json[\"photo_max_orig\"].Value<string>(); if (json[\"is_admin\"] != null) result.IsAdmin = json[\"is_admin\"].Value<int>() == 1; if (json[\"is_member\"] != null) result.IsAdmin = json[\"is_member\"].Value<int>() == 1; if (json[\"is_closed\"] != null) result.IsClosed = json[\"is_closed\"].Value<int>() == 1; if (json[\"type\"] != null) result.Type = json[\"type\"].Value<string>(); return result; }", "label": "ComplexMethod"}
{"text": "public override void Close(PdfWriter writer) { CheckOutputIntentsInStamperMode(writer); if ((rgbUsed || cmykUsed || grayUsed) && pdfaOutputIntentColorSpace == null) { throw new PdfAConformanceException(null, MessageLocalization.GetComposedMessage(\"if.device.rgb.cmyk.gray.used.in.file.that.file.shall.contain.pdfa.outputintent\")); } if (\"RGB \".Equals(pdfaOutputIntentColorSpace)) { if (cmykUsed) throw new PdfAConformanceException(null, MessageLocalization.GetComposedMessage( \"devicecmyk.may.be.used.only.if.the.file.has.a.cmyk.pdfa.outputIntent\")); } else if (\"CMYK\".Equals(pdfaOutputIntentColorSpace)) { if (rgbUsed) throw new PdfAConformanceException(null, MessageLocalization.GetComposedMessage( \"devicergb.may.be.used.only.if.the.file.has.a.rgb.pdfa.outputIntent\")); } else { if (cmykUsed) throw new PdfAConformanceException(null, MessageLocalization.GetComposedMessage( \"devicecmyk.may.be.used.only.if.the.file.has.a.cmyk.pdfa.outputIntent\")); if (rgbUsed) throw new PdfAConformanceException(null, MessageLocalization.GetComposedMessage( \"devicergb.may.be.used.only.if.the.file.has.a.rgb.pdfa.outputIntent\")); } }", "label": "ComplexMethod"}
{"text": "private bool ParsePostValue() { while (true) { char currentChar = _chars[_charPos]; switch (currentChar) { case '\\0': if (_charsUsed == _charPos) { if (ReadData(false) == 0) { _currentState = State.Finished; return false; } } else { _charPos++; } break; case '}': _charPos++; SetToken(JsonToken.EndObject); return true; case ']': _charPos++; SetToken(JsonToken.EndArray); return true; case ')': _charPos++; SetToken(JsonToken.EndConstructor); return true; case '/': ParseComment(); return true; case ',': _charPos++; // finished parsing SetStateBasedOnCurrent(); return false; case ' ': case StringUtils.Tab: // eat _charPos++; break; case StringUtils.CarriageReturn: ProcessCarriageReturn(false); break; case StringUtils.LineFeed: ProcessLineFeed(); break; default: if (char.IsWhiteSpace(currentChar)) { // eat _charPos++; } else { throw JsonReaderException.Create(this, \"After parsing a value an unexpected character was encountered: {0}.\".FormatWith(CultureInfo.InvariantCulture, currentChar)); } break; } } }", "label": "ComplexMethod"}
{"text": "public virtual enHelperActivityType Process(ref Socket soUDP, ref IPEndPoint remoteIpEndPoint, string sessionID, Encoding enc) { ProcessCommand(ref soUDP, ref remoteIpEndPoint, sessionID, enc); // handle 555 BANNED and 598 - UNKNOWN COMMAND switch (ResponseCode) { case 598: return enHelperActivityType.UnknownCommand_598; case 555: return enHelperActivityType.Banned_555; } if (errorOccurred) return enHelperActivityType.NoSuchFile; string sMsgType = socketResponse.Substring(0, 3); switch (sMsgType) { case \"210\": return enHelperActivityType.FileMarkedAsDeleted; case \"310\": return enHelperActivityType.FileMarkedAsDeleted; case \"311\": return enHelperActivityType.FileMarkedAsDeleted; case \"320\": return enHelperActivityType.NoSuchFile; case \"411\": return enHelperActivityType.NoSuchFile; case \"502\": return enHelperActivityType.LoginFailed; case \"501\": return enHelperActivityType.LoginRequired; } return enHelperActivityType.FileDoesNotExist; }", "label": "ComplexMethod"}
{"text": "public HouseListGump(int number, ArrayList list, BaseHouse house, bool accountOf) : base(20, 30) { if (house.Deleted) return; m_House = house; AddPage(0); AddBackground(0, 0, 420, 430, 5054); AddBackground(10, 10, 400, 410, 3000); AddButton(20, 388, 4005, 4007, 0, GumpButtonType.Reply, 0); AddHtmlLocalized(55, 388, 300, 20, 1011104, false, false); // Return to previous menu AddHtmlLocalized(20, 20, 350, 20, number, false, false); if (list != null) { for (int i = 0; i < list.Count; ++i) { if ((i % 16) == 0) { if (i != 0) { // Next button AddButton(370, 20, 4005, 4007, 0, GumpButtonType.Page, (i / 16) + 1); } AddPage((i / 16) + 1); if (i != 0) { // Previous button AddButton(340, 20, 4014, 4016, 0, GumpButtonType.Page, i / 16); } } Mobile m = (Mobile)list[i]; string name; if (m == null || (name = m.Name) == null || (name = name.Trim()).Length <= 0) continue; AddLabel(55, 55 + ((i % 16) * 20), 0, accountOf && m.Player && m.Account != null ? String.Format(\"Account of {0}\", name) : name); } } }", "label": "ComplexMethod"}
{"text": "public void ValidateAndFillDetails() { if (IsNullOrEmpty(Title)) Title = $\"{FounderName}'s game\"; if (IsNullOrEmpty(EngineVersion) || (Mode != AutohostMode.None)) EngineVersion = server.Engine; server.Downloader.GetResource(DownloadType.ENGINE, server.Engine); switch (Mode) { case AutohostMode.Game1v1: MaxPlayers = 2; break; case AutohostMode.Planetwars: if (MaxPlayers < 2) MaxPlayers = 16; break; case AutohostMode.GameChickens: if (MaxPlayers < 2) MaxPlayers = 10; break; case AutohostMode.GameFFA: if (MaxPlayers < 3) MaxPlayers = 16; break; case AutohostMode.Teams: if (MaxPlayers < 4) MaxPlayers = 16; break; case AutohostMode.None: if (MaxPlayers == 0) MaxPlayers = 16; break; } if (MaxPlayers > DynamicConfig.Instance.MaximumBattlePlayers && !IsAutohost) MaxPlayers = DynamicConfig.Instance.MaximumBattlePlayers; HostedMod = MapPicker.FindResources(ResourceType.Mod, ModName ?? server.Game ?? GlobalConst.DefaultZkTag).FirstOrDefault(); HostedMap = MapName != null ? MapPicker.FindResources(ResourceType.Map, MapName).FirstOrDefault() : MapPicker.GetRecommendedMap(GetContext()); ModName = HostedMod?.InternalName ?? ModName ?? server.Game ?? GlobalConst.DefaultZkTag; MapName = HostedMap?.InternalName ?? MapName ?? \"Small_Divide-Remake-v04\"; if (HostedMod != null) try { HostedModInfo = MetaDataCache.ServerGetMod(HostedMod.InternalName); } catch (Exception ex) { Trace.TraceWarning(\"Error loading mod metadata for {0} : {1}\", HostedMod.InternalName, ex); } }", "label": "ComplexConditional"}
{"text": "public virtual byte[] Unwrap( byte[] inBytes, int inOff, int inLen) { if (forWrapping) { throw new InvalidOperationException(\"not set for unwrapping\"); } int blockSize = engine.GetBlockSize(); if (inLen < 2 * blockSize) { throw new InvalidCipherTextException(\"input too short\"); } byte[] cekBlock = new byte[inLen]; byte[] iv = new byte[blockSize]; Array.Copy(inBytes, inOff, cekBlock, 0, inLen); Array.Copy(inBytes, inOff, iv, 0, iv.Length); engine.Init(false, new ParametersWithIV(param.Parameters, iv)); for (int i = blockSize; i < cekBlock.Length; i += blockSize) { engine.ProcessBlock(cekBlock, i, cekBlock, i); } Array.Copy(cekBlock, cekBlock.Length - iv.Length, iv, 0, iv.Length); engine.Init(false, new ParametersWithIV(param.Parameters, iv)); engine.ProcessBlock(cekBlock, 0, cekBlock, 0); engine.Init(false, param); for (int i = 0; i < cekBlock.Length; i += blockSize) { engine.ProcessBlock(cekBlock, i, cekBlock, i); } if ((cekBlock[0] & 0xff) > cekBlock.Length - 4) { throw new InvalidCipherTextException(\"wrapped key corrupted\"); } byte[] key = new byte[cekBlock[0] & 0xff]; Array.Copy(cekBlock, 4, key, 0, cekBlock[0]); // Note: Using constant time comparison int nonEqual = 0; for (int i = 0; i != 3; i++) { byte check = (byte)~cekBlock[1 + i]; nonEqual |= (check ^ key[i]); } if (nonEqual != 0) throw new InvalidCipherTextException(\"wrapped key fails checksum\"); return key; }", "label": "ComplexMethod"}
{"text": "private bool TryReadErrorDetail(out ODataErrorDetail detail) { Debug.Assert( this.currentBufferedNode.NodeType == JsonNodeType.StartObject, \"this.currentBufferedNode.NodeType == JsonNodeType.StartObject\"); Debug.Assert(this.parsingInStreamError, \"this.parsingInStreamError\"); this.AssertBuffering(); if (this.currentBufferedNode.NodeType != JsonNodeType.StartObject) { detail = null; return false; } // { ReadInternal(); detail = new ODataErrorDetail(); // we expect one of the supported properties for the value (or end-object) var propertiesFoundBitmask = ODataJsonLightReaderUtils.ErrorPropertyBitMask.None; while (this.currentBufferedNode.NodeType == JsonNodeType.Property) { var propertyName = (string)this.currentBufferedNode.Value; switch (propertyName) { case JsonConstants.ODataErrorCodeName: if (!ODataJsonLightReaderUtils.ErrorPropertyNotFound( ref propertiesFoundBitmask, ODataJsonLightReaderUtils.ErrorPropertyBitMask.Code)) { return false; } string code; if (this.TryReadErrorStringPropertyValue(out code)) { detail.ErrorCode = code; } else { return false; } break; case JsonConstants.ODataErrorTargetName: if (!ODataJsonLightReaderUtils.ErrorPropertyNotFound( ref propertiesFoundBitmask, ODataJsonLightReaderUtils.ErrorPropertyBitMask.Target)) { return false; } string target; if (this.TryReadErrorStringPropertyValue(out target)) { detail.Target = target; } else { return false; } break; case JsonConstants.ODataErrorMessageName: if (!ODataJsonLightReaderUtils.ErrorPropertyNotFound( ref propertiesFoundBitmask, ODataJsonLightReaderUtils.ErrorPropertyBitMask.MessageValue)) { return false; } string message; if (this.TryReadErrorStringPropertyValue(out message)) { detail.Message = message; } else { return false; } break; default: // if we find a non-supported property in an inner error, we skip it this.SkipValueInternal(); break; } this.ReadInternal(); } Debug.Assert( this.currentBufferedNode.NodeType == JsonNodeType.EndObject, \"this.currentBufferedNode.NodeType == JsonNodeType.EndObject\"); return true; }", "label": "ComplexConditional"}
{"text": "public static string GetImagePath(ImageEntityType type, int id) { string path; switch (type) { // 1 case ImageEntityType.AniDB_Cover: SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(id); if (anime == null) return null; path = anime.PosterPath; if (File.Exists(path)) { return path; } else { path = string.Empty; } break; // 4 case ImageEntityType.TvDB_Banner: TvDB_ImageWideBanner wideBanner = RepoFactory.TvDB_ImageWideBanner.GetByID(id); if (wideBanner == null) return null; path = wideBanner.GetFullImagePath(); if (File.Exists(path)) { return path; } else { path = string.Empty; } break; // 5 case ImageEntityType.TvDB_Cover: TvDB_ImagePoster poster = RepoFactory.TvDB_ImagePoster.GetByID(id); if (poster == null) return null; path = poster.GetFullImagePath(); if (File.Exists(path)) { return path; } else { path = string.Empty; } break; // 6 case ImageEntityType.TvDB_Episode: TvDB_Episode ep = RepoFactory.TvDB_Episode.GetByID(id); if (ep == null) return null; path = ep.GetFullImagePath(); if (File.Exists(path)) { return path; } else { path = string.Empty; } break; // 7 case ImageEntityType.TvDB_FanArt: TvDB_ImageFanart fanart = RepoFactory.TvDB_ImageFanart.GetByID(id); if (fanart == null) return null; path = fanart.GetFullImagePath(); if (File.Exists(path)) return path; path = string.Empty; break; // 8 case ImageEntityType.MovieDB_FanArt: MovieDB_Fanart mFanart = RepoFactory.MovieDB_Fanart.GetByID(id); if (mFanart == null) return null; mFanart = RepoFactory.MovieDB_Fanart.GetByOnlineID(mFanart.URL); if (mFanart == null) return null; path = mFanart.GetFullImagePath(); if (File.Exists(path)) { return path; } else { path = string.Empty; } break; // 9 case ImageEntityType.MovieDB_Poster: MovieDB_Poster mPoster = RepoFactory.MovieDB_Poster.GetByID(id); if (mPoster == null) return null; mPoster = RepoFactory.MovieDB_Poster.GetByOnlineID(mPoster.URL); if (mPoster == null) return null; path = mPoster.GetFullImagePath(); if (File.Exists(path)) { return path; } else { path = string.Empty; } break; case ImageEntityType.Character: AnimeCharacter character = RepoFactory.AnimeCharacter.GetByID(id); if (character == null) return null; path = ImageUtils.GetBaseAniDBCharacterImagesPath() + Path.DirectorySeparatorChar + character.ImagePath; if (File.Exists(path)) { return path; } else { path = string.Empty; } break; case ImageEntityType.Staff: var staff = RepoFactory.AnimeStaff.GetByID(id); if (staff == null) return null; path = ImageUtils.GetBaseAniDBCreatorImagesPath() + Path.DirectorySeparatorChar + staff.ImagePath; if (File.Exists(path)) { return path; } else { path = string.Empty; } break; default: path = string.Empty; break; } return path; }", "label": "ComplexMethod"}
{"text": "private void UpdateStatusChanged(object sender, EventArgs e) { switch (UpdateControlData.Instance.UpdateStatus) { case UpdateControlData.UpdateStatusStates.MayBeAvailable: updateStatusText.Text = \"New updates may be available\".Localize(); checkUpdateButton.Visible = true; break; case UpdateControlData.UpdateStatusStates.CheckingForUpdate: updateStatusText.Text = \"Checking for updates...\".Localize(); //checkUpdateLink.Visible = false; break; case UpdateControlData.UpdateStatusStates.UnableToConnectToServer: updateStatusText.Text = \"Oops! Unable to connect to server\".Localize(); downloadButton.Visible = false; installButton.Visible = false; checkUpdateButton.Visible = true; break; case UpdateControlData.UpdateStatusStates.UpdateAvailable: if (UpdateControlData.Instance.UpdateRequired) { updateStatusText.Text = requiredUpdateAvailable; } else { updateStatusText.Text = recommendedUpdateAvailable; } downloadButton.Visible = true; installButton.Visible = false; checkUpdateButton.Visible = false; break; case UpdateControlData.UpdateStatusStates.UpdateDownloading: updateStatusText.Text = string.Format( \"{0} {1}%\", \"Downloading updates...\".Localize(), UpdateControlData.Instance.DownloadPercent); break; case UpdateControlData.UpdateStatusStates.ReadyToInstall: updateStatusText.Text = \"New updates are ready to install\".Localize(); downloadButton.Visible = false; installButton.Visible = true; checkUpdateButton.Visible = false; break; case UpdateControlData.UpdateStatusStates.UpToDate: updateStatusText.Text = \"Your application is up-to-date\".Localize(); downloadButton.Visible = false; installButton.Visible = false; checkUpdateButton.Visible = true; break; default: throw new NotImplementedException(); } }", "label": "FeatureEnvy"}
{"text": "private void SetClickAction() { switch (CursorPosition()) { case CursPos.BottomLine: CurrentAction = ClickAction.BottomSizing; break; case CursPos.TopLine: CurrentAction = ClickAction.TopSizing; break; case CursPos.LeftLine: CurrentAction = ClickAction.LeftSizing; break; case CursPos.TopLeft: CurrentAction = ClickAction.TopLeftSizing; break; case CursPos.BottomLeft: CurrentAction = ClickAction.BottomLeftSizing; break; case CursPos.RightLine: CurrentAction = ClickAction.RightSizing; break; case CursPos.TopRight: CurrentAction = ClickAction.TopRightSizing; break; case CursPos.BottomRight: CurrentAction = ClickAction.BottomRightSizing; break; case CursPos.WithinSelectionArea: CurrentAction = ClickAction.Dragging; break; case CursPos.OutsideSelectionArea: CurrentAction = ClickAction.Outside; break; } }", "label": "ComplexMethod"}
{"text": "private static void CreateRow(JsonReader reader, DataTable dt) { DataRow dr = dt.NewRow(); CheckedRead(reader); while (reader.TokenType == JsonToken.PropertyName) { string columnName = (string)reader.Value; CheckedRead(reader); DataColumn column = dt.Columns[columnName]; if (column == null) { Type columnType = GetColumnDataType(reader); column = new DataColumn(columnName, columnType); dt.Columns.Add(column); } if (column.DataType == typeof(DataTable)) { if (reader.TokenType == JsonToken.StartArray) CheckedRead(reader); DataTable nestedDt = new DataTable(); while (reader.TokenType != JsonToken.EndArray) { CreateRow(reader, nestedDt); CheckedRead(reader); } dr[columnName] = nestedDt; } else if (column.DataType.IsArray && column.DataType != typeof(byte[])) { if (reader.TokenType == JsonToken.StartArray) CheckedRead(reader); List<object> o = new List<object>(); while (reader.TokenType != JsonToken.EndArray) { o.Add(reader.Value); CheckedRead(reader); } Array destinationArray = Array.CreateInstance(column.DataType.GetElementType(), o.Count); Array.Copy(o.ToArray(), destinationArray, o.Count); dr[columnName] = destinationArray; } else { dr[columnName] = reader.Value ?? DBNull.Value; } CheckedRead(reader); } dr.EndEdit(); dt.Rows.Add(dr); }", "label": "ComplexMethod"}
{"text": "public static void IncreaseStat(Mobile from, Stat stat, bool atrophy) { atrophy = atrophy || (from.RawStatTotal >= from.StatCap); switch ( stat ) { case Stat.Str: { if (atrophy) { if (CanLower(from, Stat.Dex) && (from.RawDex < from.RawInt || !CanLower(from, Stat.Int))) --from.RawDex; else if (CanLower(from, Stat.Int)) --from.RawInt; } if (CanRaise(from, Stat.Str)) ++from.RawStr; break; } case Stat.Dex: { if (atrophy) { if (CanLower(from, Stat.Str) && (from.RawStr < from.RawInt || !CanLower(from, Stat.Int))) --from.RawStr; else if (CanLower(from, Stat.Int)) --from.RawInt; } if (CanRaise(from, Stat.Dex)) ++from.RawDex; break; } case Stat.Int: { if (atrophy) { if (CanLower(from, Stat.Str) && (from.RawStr < from.RawDex || !CanLower(from, Stat.Dex))) --from.RawStr; else if (CanLower(from, Stat.Dex)) --from.RawDex; } if (CanRaise(from, Stat.Int)) ++from.RawInt; break; } } }", "label": "ComplexMethod"}
{"text": "internal static bool TryFindCommonPrefix(IEnumerable<string> collection, bool ignoreCase, char separatorChar, out string commonPrefix) { Debug.Assert(collection != null); commonPrefix = null; var array = collection.ToArray(); if (array.Length == 0) { return false; } // If the list contains a path null -> no common commonPrefix foreach (var str in array) { if (str == null || str.Length == 0) { return false; } } var firstStr = array[0]; // // Case where all paths are identical // or where only one path // bool allStringsAreIdentical = true; foreach (var str in array) { if (string.Compare(firstStr, str, ignoreCase) != 0) { allStringsAreIdentical = false; break; } } if (allStringsAreIdentical) { commonPrefix = firstStr; return true; } // // Build listOfSplittedPaths // var listOfSplittedStrings = new List<string[]>(); int maxDeep = int.MaxValue; foreach (var str in array) { string[] strSplitted = str.Split(new[] { separatorChar }); if (strSplitted.Length < maxDeep) { maxDeep = strSplitted.Length; } listOfSplittedStrings.Add(strSplitted); } Debug.Assert(maxDeep >= 1); // // Compute prefixSb! // var prefixSb = new StringBuilder(); for (int i = 0; i < maxDeep; i++) { string current = listOfSplittedStrings[0][i]; foreach (string[] strSplitted in listOfSplittedStrings) { if (string.Compare(strSplitted[i], current, ignoreCase) != 0) { // i==0 means that we have no common commonPrefix!! if (i == 0) { return false; } goto DONE_OK; } } if (i > 0) { prefixSb.Append(separatorChar); } prefixSb.Append(current); } DONE_OK: Debug.Assert(prefixSb.Length > 0); commonPrefix = prefixSb.ToString(); return true; }", "label": "ComplexMethod"}
{"text": "public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 1: if (field.Type == TType.Bool) { HasNext = iprot.ReadBool(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 4: if (field.Type == TType.I64) { BannerSequence = iprot.ReadI64(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 5: if (field.Type == TType.I32) { BannerTargetType = (ProductBannerLinkType)iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 6: if (field.Type == TType.String) { BannerTargetPath = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 7: if (field.Type == TType.List) { { ProductList_ = new List<Product>(); TList _list34 = iprot.ReadListBegin(); for( int _i35 = 0; _i35 < _list34.Count; ++_i35) { Product _elem36 = new Product(); _elem36 = new Product(); _elem36.Read(iprot); ProductList_.Add(_elem36); } iprot.ReadListEnd(); } } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 8: if (field.Type == TType.String) { BannerLang = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); }", "label": "ComplexMethod"}
{"text": "private void ParseSubscriptionResults(byte[][] multiBytes) { int componentsPerMsg = IsPSubscription ? 4 : 3; for (var i = 0; i < multiBytes.Length; i += componentsPerMsg) { var messageType = multiBytes[i]; var channel = multiBytes[i + 1].FromUtf8Bytes(); if (SubscribeWord.AreEqual(messageType) || PSubscribeWord.AreEqual(messageType)) { IsPSubscription = PSubscribeWord.AreEqual(messageType); this.SubscriptionCount = int.Parse(multiBytes[i + MsgIndex].FromUtf8Bytes()); activeChannels.Add(channel); if (this.OnSubscribe != null) { this.OnSubscribe(channel); } } else if (UnSubscribeWord.AreEqual(messageType) || PUnSubscribeWord.AreEqual(messageType)) { this.SubscriptionCount = int.Parse(multiBytes[i + 2].FromUtf8Bytes()); activeChannels.Remove(channel); if (this.OnUnSubscribe != null) { this.OnUnSubscribe(channel); } } else if (MessageWord.AreEqual(messageType)) { var message = multiBytes[i + MsgIndex].FromUtf8Bytes(); if (this.OnMessage != null) { this.OnMessage(channel, message); } } else if (PMessageWord.AreEqual(messageType)) { var message = multiBytes[i + MsgIndex + 1].FromUtf8Bytes(); channel = multiBytes[i + 2].FromUtf8Bytes(); if (this.OnMessage != null) { this.OnMessage(channel, message); } } else { throw new RedisException( \"Invalid state. Expected [[p]subscribe|[p]unsubscribe|message] got: \" + messageType.FromUtf8Bytes()); } } }", "label": "ComplexMethod"}
{"text": "public async Task<bool> TryToSuspectOrKill(SiloAddress silo) { var table = await membershipTableProvider.ReadAll(); if (log.IsEnabled(LogLevel.Debug)) log.Debug(\"-TryToSuspectOrKill: Read Membership table {0}\", table.ToString()); if (this.IsStopping) { this.log.LogInformation( (int)ErrorCode.MembershipFoundMyselfDead3, \"Ignoring call to TrySuspectOrKill for silo {Silo} since the local silo is dead\", silo); return true; } var (localSiloEntry, _) = this.GetOrCreateLocalSiloEntry(table, this.CurrentStatus); if (localSiloEntry.Status == SiloStatus.Dead) { var msg = string.Format(\"I should be Dead according to membership table (in TryToSuspectOrKill): entry = {0}.\", localSiloEntry.ToFullString(full: true)); log.Warn(ErrorCode.MembershipFoundMyselfDead3, msg); KillMyselfLocally(msg); return true; } if (!table.Contains(silo)) { // this should not happen ... var str = string.Format(\"-Could not find silo entry for silo {0} in the table.\", silo); log.Error(ErrorCode.MembershipFailedToReadSilo, str); throw new KeyNotFoundException(str); } var tuple = table.Get(silo); var entry = tuple.Item1.Copy(); string eTag = tuple.Item2; if (log.IsEnabled(LogLevel.Debug)) log.Debug(\"-TryToSuspectOrKill {siloAddress}: The current status of {siloAddress} in the table is {status}, its entry is {entry}\", entry.SiloAddress, // First entry.SiloAddress, // Second entry.Status, entry.ToFullString()); // check if the table already knows that this silo is dead if (entry.Status == SiloStatus.Dead) { this.ProcessTableUpdate(table, \"TrySuspectOrKill\"); return true; } var allVotes = entry.SuspectTimes ?? new List<Tuple<SiloAddress, DateTime>>(); // get all valid (non-expired) votes var freshVotes = entry.GetFreshVotes(DateTime.UtcNow, this.clusterMembershipOptions.DeathVoteExpirationTimeout); if (log.IsEnabled(LogLevel.Trace)) log.Trace(\"-Current number of fresh Voters for {0} is {1}\", silo, freshVotes.Count.ToString()); if (freshVotes.Count >= this.clusterMembershipOptions.NumVotesForDeathDeclaration) { // this should not happen ... var str = string.Format(\"-Silo {0} is suspected by {1} which is more or equal than {2}, but is not marked as dead. This is a bug!!!\", entry.SiloAddress, freshVotes.Count.ToString(), this.clusterMembershipOptions.NumVotesForDeathDeclaration.ToString()); log.Error(ErrorCode.Runtime_Error_100053, str); KillMyselfLocally(\"Found a bug! Will stop.\"); return false; } // handle the corner case when the number of active silos is very small (then my only vote is enough) int activeSilos = table.GetSiloStatuses(status => status == SiloStatus.Active, true, this.localSiloDetails.SiloAddress).Count; // find if I have already voted int myVoteIndex = freshVotes.FindIndex(voter => myAddress.Equals(voter.Item1)); // Try to kill: // if there is NumVotesForDeathDeclaration votes (including me) to kill - kill. // otherwise, if there is a majority of nodes (including me) voting to kill – kill. bool declareDead = false; int myAdditionalVote = myVoteIndex == -1 ? 1 : 0; if (freshVotes.Count + myAdditionalVote >= this.clusterMembershipOptions.NumVotesForDeathDeclaration) declareDead = true; if (freshVotes.Count + myAdditionalVote >= (activeSilos + 1) / 2) declareDead = true; if (declareDead) { // kick this silo off log.Info(ErrorCode.MembershipMarkingAsDead, \"-Going to mark silo {0} as DEAD in the table #1. I am the last voter: #freshVotes={1}, myVoteIndex = {2}, NumVotesForDeathDeclaration={3} , #activeSilos={4}, suspect list={5}\", entry.SiloAddress, freshVotes.Count, myVoteIndex, this.clusterMembershipOptions.NumVotesForDeathDeclaration, activeSilos, PrintSuspectList(allVotes)); return await DeclareDead(entry, eTag, table.Version); } // we still do not have enough votes - need to vote // find voting place: // update my vote, if I voted previously // OR if the list is not full - just add a new vote // OR overwrite the oldest entry. int indexToWrite = allVotes.FindIndex(voter => myAddress.Equals(voter.Item1)); if (indexToWrite == -1) { // My vote is not recorded. Find the most outdated vote if the list is full, and overwrite it if (allVotes.Count >= this.clusterMembershipOptions.NumVotesForDeathDeclaration) // if the list is full { // The list is full. DateTime minVoteTime = allVotes.Min(voter => voter.Item2); // pick the most outdated vote indexToWrite = allVotes.FindIndex(voter => voter.Item2.Equals(minVoteTime)); } } var prevList = allVotes.ToList(); // take a copy var now = DateTime.UtcNow; if (indexToWrite == -1) { // if did not find specific place to write (the list is not full), just add a new element to the list entry.AddSuspector(myAddress, now); } else { var newEntry = new Tuple<SiloAddress, DateTime>(myAddress, now); entry.SuspectTimes[indexToWrite] = newEntry; } log.Info(ErrorCode.MembershipVotingForKill, \"-Putting my vote to mark silo {0} as DEAD #2. Previous suspect list is {1}, trying to update to {2}, eTag={3}, freshVotes is {4}\", entry.SiloAddress, PrintSuspectList(prevList), PrintSuspectList(entry.SuspectTimes), eTag, PrintSuspectList(freshVotes)); // If we fail to update here we will retry later. return await membershipTableProvider.UpdateRow(entry, eTag, table.Version.Next()); string PrintSuspectList(IEnumerable<Tuple<SiloAddress, DateTime>> list) { return Utils.EnumerableToString(list, t => string.Format(\"<{0}, {1}>\", t.Item1, LogFormatter.PrintDate(t.Item2))); } }", "label": "FeatureEnvy"}
{"text": "private object ReadStringValue(ReadType readType) { EnsureBuffer(); switch (_currentState) { case State.PostValue: if (ParsePostValue(true)) { return null; } goto case State.Start; case State.Start: case State.Property: case State.Array: case State.ArrayStart: case State.Constructor: case State.ConstructorStart: while (true) { char currentChar = _chars[_charPos]; switch (currentChar) { case '\\0': if (ReadNullChar()) { SetToken(JsonToken.None, null, false); return null; } break; case '\"': case '\\'': ParseString(currentChar, readType); return FinishReadQuotedStringValue(readType); case '-': if (EnsureChars(1, true) && _chars[_charPos + 1] == 'I') { return ParseNumberNegativeInfinity(readType); } else { ParseNumber(readType); return Value; } case '.': case '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': if (readType != ReadType.ReadAsString) { _charPos++; throw CreateUnexpectedCharacterException(currentChar); } ParseNumber(ReadType.ReadAsString); return Value; case 't': case 'f': if (readType != ReadType.ReadAsString) { _charPos++; throw CreateUnexpectedCharacterException(currentChar); } string expected = currentChar == 't' ? JsonConvert.True : JsonConvert.False; if (!MatchValueWithTrailingSeparator(expected)) { throw CreateUnexpectedCharacterException(_chars[_charPos]); } SetToken(JsonToken.String, expected); return expected; case 'I': return ParseNumberPositiveInfinity(readType); case 'N': return ParseNumberNaN(readType); case 'n': HandleNull(); return null; case '/': ParseComment(false); break; case ',': ProcessValueComma(); break; case ']': _charPos++; if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue) { SetToken(JsonToken.EndArray); return null; } throw CreateUnexpectedCharacterException(currentChar); case StringUtils.CarriageReturn: ProcessCarriageReturn(false); break; case StringUtils.LineFeed: ProcessLineFeed(); break; case ' ': case StringUtils.Tab: // eat _charPos++; break; default: _charPos++; if (!char.IsWhiteSpace(currentChar)) { throw CreateUnexpectedCharacterException(currentChar); } // eat break; } } case State.Finished: ReadFinished(); return null; default: throw JsonReaderException.Create(this, \"Unexpected state: {0}.\".FormatWith(CultureInfo.InvariantCulture, CurrentState)); } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// See <see cref=\"IByteProvider.WriteByte\" /> for more information. /// </summary> public void WriteByte(long index, byte value) { try { // Find the block affected. long blockOffset; DataBlock block = GetDataBlock(index, out blockOffset); // If the byte is already in a memory block, modify it. MemoryDataBlock memoryBlock = block as MemoryDataBlock; if (memoryBlock != null) { memoryBlock.Data[index - blockOffset] = value; return; } FileDataBlock fileBlock = (FileDataBlock)block; // If the byte changing is the first byte in the block and the previous block is a memory block, extend that. if (blockOffset == index && block.PreviousBlock != null) { MemoryDataBlock previousMemoryBlock = block.PreviousBlock as MemoryDataBlock; if (previousMemoryBlock != null) { previousMemoryBlock.AddByteToEnd(value); fileBlock.RemoveBytesFromStart(1); if (fileBlock.Length == 0) { _dataMap.Remove(fileBlock); } return; } } // If the byte changing is the last byte in the block and the next block is a memory block, extend that. if (blockOffset + fileBlock.Length - 1 == index && block.NextBlock != null) { MemoryDataBlock nextMemoryBlock = block.NextBlock as MemoryDataBlock; if (nextMemoryBlock != null) { nextMemoryBlock.AddByteToStart(value); fileBlock.RemoveBytesFromEnd(1); if (fileBlock.Length == 0) { _dataMap.Remove(fileBlock); } return; } } // Split the block into a prefix and a suffix and place a memory block in-between. FileDataBlock prefixBlock = null; if (index > blockOffset) { prefixBlock = new FileDataBlock(fileBlock.FileOffset, index - blockOffset); } FileDataBlock suffixBlock = null; if (index < blockOffset + fileBlock.Length - 1) { suffixBlock = new FileDataBlock( fileBlock.FileOffset + index - blockOffset + 1, fileBlock.Length - (index - blockOffset + 1)); } block = _dataMap.Replace(block, new MemoryDataBlock(value)); if (prefixBlock != null) { _dataMap.AddBefore(block, prefixBlock); } if (suffixBlock != null) { _dataMap.AddAfter(block, suffixBlock); } } finally { OnChanged(EventArgs.Empty); } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Renders the template. /// </summary> /// <param name=\"template\">The template.</param> /// <param name=\"additionalMergeObjects\">Any additional merge objects as a comma-delimited-list of EntityTypeId|MergeKey|EntityId</param> /// <returns></returns> [System.Web.Http.Route( \"api/Lava/RenderTemplate\" )] [HttpPost] [Authenticate, Secured] public string RenderTemplate( [NakedBody] string template, [FromUri] string additionalMergeObjects = null ) { Rock.Lava.CommonMergeFieldsOptions lavaOptions = new Lava.CommonMergeFieldsOptions(); lavaOptions.GetPageContext = false; lavaOptions.GetPageParameters = false; lavaOptions.GetCurrentPerson = true; lavaOptions.GetCampuses = true; lavaOptions.GetLegacyGlobalMergeFields = false; var currentPerson = GetPerson(); Dictionary<string, object> mergeFields = Rock.Lava.LavaHelper.GetCommonMergeFields( null, currentPerson, lavaOptions ); if ( additionalMergeObjects != null ) { var additionalMergeObjectList = additionalMergeObjects.Split( ',' ).Select( a => a.Split( '|' ) ).Where( a => a.Length == 3 ).Select( a => new { EntityTypeId = a[0].AsInteger(), MergeKey = a[1], EntityId = a[2].AsInteger() } ).ToList(); foreach ( var additionalMergeObject in additionalMergeObjectList ) { var entityTypeType = EntityTypeCache.Get( additionalMergeObject.EntityTypeId )?.GetEntityType(); if ( entityTypeType != null ) { var dbContext = Rock.Reflection.GetDbContextForEntityType( entityTypeType ); var serviceInstance = Rock.Reflection.GetServiceForEntityType( entityTypeType, dbContext ); if ( serviceInstance != null ) { System.Reflection.MethodInfo getMethod = serviceInstance.GetType().GetMethod( \"Get\", new Type[] { typeof( int ) } ); var mergeObjectEntity = getMethod.Invoke( serviceInstance, new object[] { additionalMergeObject.EntityId } ) as Rock.Data.IEntity; if ( mergeObjectEntity != null ) { bool canView = true; if ( mergeObjectEntity is Rock.Security.ISecured ) { canView = ( mergeObjectEntity as Rock.Security.ISecured ).IsAuthorized( Rock.Security.Authorization.VIEW, currentPerson ); } if ( canView ) { mergeFields.Add( additionalMergeObject.MergeKey, mergeObjectEntity ); } } } } } } return template.ResolveMergeFields( mergeFields, currentPerson ); }", "label": "ComplexMethod"}
{"text": "#endregion #region GetProcAddress /// <summary> /// Retrieves the address of an exported function or variable from loaded module. /// </summary> /// <param name=\"procName\">The function or variable name.</param> /// <returns> /// If the function succeeds, the return value is the address of the exported function or variable. /// If the function fails, the return value is IntPtr.Zero. /// </returns> private IntPtr GetProcAddress(string procName) { if (_loadedModuleHandle == IntPtr.Zero) return IntPtr.Zero; if (!_loadedFromMemory) { return WinBase.GetProcAddress(_loadedModuleHandle, procName); } MEMORY_MODULE* memory_module = (MEMORY_MODULE*)_loadedModuleHandle; byte* codeBase = memory_module->codeBase; int idx = -1; uint i; uint* nameRef; ushort* ordinal; WinNT.IMAGE_DATA_DIRECTORY* directory = this.GET_HEADER_DIRECTORY(memory_module, WinNT.IMAGE_DIRECTORY_ENTRY_EXPORT); if (directory->Size == 0) // no export table found return IntPtr.Zero; WinNT.IMAGE_EXPORT_DIRECTORY* exports = (WinNT.IMAGE_EXPORT_DIRECTORY*)(codeBase + directory->VirtualAddress); if (exports->NumberOfNames == 0 || exports->NumberOfFunctions == 0) // DLL doesn't export anything return IntPtr.Zero; // search function name in list of exported names nameRef = (uint*)(codeBase + exports->AddressOfNames); ordinal = (ushort*)(codeBase + exports->AddressOfNameOrdinals); for (i = 0; i < exports->NumberOfNames; i++, nameRef++, ordinal++) { IntPtr procNameHandle = (IntPtr)((byte*)((ulong)codeBase + *nameRef)); string testProcName = Marshal.PtrToStringAnsi(procNameHandle); if (testProcName == procName) { idx = *ordinal; break; } } if (idx == -1) // exported symbol not found return IntPtr.Zero; if ((uint)idx > exports->NumberOfFunctions) // name <-> ordinal number don't match return IntPtr.Zero; // AddressOfFunctions contains the RVAs to the \"real\" functions //return (IntPtr)((uint)codeBase + *(uint*)((uint)codeBase + exports->AddressOfFunctions + (idx * 4))); return (IntPtr)(codeBase + *(uint*)(codeBase + exports->AddressOfFunctions + (idx * 4))); }", "label": "ComplexMethod"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class findAndAddContactsByEmail_args : TBase { private int _reqSeq; private THashSet<string> _emails; public int ReqSeq { get { return _reqSeq; } set { __isset.reqSeq = true; this._reqSeq = value; } } public THashSet<string> Emails { get { return _emails; } set { __isset.emails = true; this._emails = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool reqSeq; public bool emails; } public findAndAddContactsByEmail_args() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 1: if (field.Type == TType.I32) { ReqSeq = iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 2: if (field.Type == TType.Set) { { Emails = new THashSet<string>(); TSet _set176 = iprot.ReadSetBegin(); for( int _i177 = 0; _i177 < _set176.Count; ++_i177) { string _elem178 = null; _elem178 = iprot.ReadString(); Emails.Add(_elem178); } iprot.ReadSetEnd(); } } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"findAndAddContactsByEmail_args\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (__isset.reqSeq) { field.Name = \"reqSeq\"; field.Type = TType.I32; field.ID = 1; oprot.WriteFieldBegin(field); oprot.WriteI32(ReqSeq); oprot.WriteFieldEnd(); } if (Emails != null && __isset.emails) { field.Name = \"emails\"; field.Type = TType.Set; field.ID = 2; oprot.WriteFieldBegin(field); { oprot.WriteSetBegin(new TSet(TType.String, Emails.Count)); foreach (string _iter179 in Emails) { oprot.WriteString(_iter179); } oprot.WriteSetEnd(); } oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"findAndAddContactsByEmail_args(\"); sb.Append(\"ReqSeq: \"); sb.Append(ReqSeq); sb.Append(\",Emails: \"); sb.Append(Emails); sb.Append(\")\"); return sb.ToString(); } }", "label": "ComplexConditional"}
{"text": "public class HandSiegeAttack : XmlAttachment { private const double DamageScaleFactor = 0.5; // multiplier of weapon min/max damage used to calculate siege damage. private const double BaseWeaponDelay = 9.0; // base delay in seconds between attacks. Actual delay will be reduced by weapon speed. private Item m_AttackTarget = null; // target of the attack private Point3D m_currentloc; //private int m_currentdirection; private Map m_currentmap; private Point3D m_targetloc; private Map m_targetmap; private int m_MaxDistance = 2; // max distance away from the target allowed private InternalTimer m_Timer; [CommandProperty(AccessLevel.GameMaster)] public Item AttackTarget { get { return m_AttackTarget; } set { m_AttackTarget = value; if (m_AttackTarget != null) { // immediate attack unless already attacking DoTimer(TimeSpan.Zero, true); } } } [CommandProperty(AccessLevel.GameMaster)] public int MaxDistance { get { return m_MaxDistance; } set { m_MaxDistance = value; } } [CommandProperty(AccessLevel.GameMaster)] public Point3D CurrentLoc { get { return m_currentloc; } set { m_currentloc = value; } } [CommandProperty(AccessLevel.GameMaster)] public Map CurrentMap { get { return m_currentmap; } set { m_currentmap = value; } } [CommandProperty(AccessLevel.GameMaster)] public Point3D TargetLoc { get { return m_targetloc; } set { m_targetloc = value; } } [CommandProperty(AccessLevel.GameMaster)] public Map TargetMap { get { return m_targetmap; } set { m_targetmap = value; } } // These are the various ways in which the message attachment can be constructed. // These can be called via the [addatt interface, via scripts, via the spawner ATTACH keyword. // Other overloads could be defined to handle other types of arguments // a serial constructor is REQUIRED public HandSiegeAttack(ASerial serial) : base(serial) { } [Attachable] public HandSiegeAttack() { } public static void SelectTarget(Mobile from, Item weapon) { if (from == null || weapon == null) return; // does this weapon have a HandSiegeAttack attachment on it already? HandSiegeAttack a = (HandSiegeAttack)XmlAttach.FindAttachment(weapon, typeof(HandSiegeAttack)); if (a == null || a.Deleted) { a = new HandSiegeAttack(); XmlAttach.AttachTo(weapon, a); } from.Target = new HandSiegeTarget(weapon, a); } private class HandSiegeTarget : Target { private Item m_weapon; private HandSiegeAttack m_attachment; public HandSiegeTarget(Item weapon, HandSiegeAttack attachment) : base(30, true, TargetFlags.None) { m_weapon = weapon; m_attachment = attachment; } protected override void OnTarget(Mobile from, object targeted) { if (from == null || m_weapon == null || from.Map == null || m_attachment == null) return; if (targeted is StaticTarget) { int staticid = ((StaticTarget)targeted).ItemID; int staticx = ((StaticTarget)targeted).Location.X; int staticy = ((StaticTarget)targeted).Location.Y; Item multiitem = null; Point3D tileloc = Point3D.Zero; // find the possible multi owner of the static tile foreach (Item item in from.Map.GetItemsInRange(((StaticTarget)targeted).Location, 50)) { if (item is BaseMulti) { // search the component list for a match MultiComponentList mcl = ((BaseMulti)item).Components; bool found = false; if (mcl != null && mcl.List != null) { for (int i = 0; i < mcl.List.Length; i++) { MultiTileEntry t = mcl.List[i]; int x = t.m_OffsetX + item.X; int y = t.m_OffsetY + item.Y; int z = t.m_OffsetZ + item.Z; int itemID = t.m_ItemID & 0x3FFF; if (itemID == staticid && x == staticx && y == staticy) { found = true; tileloc = new Point3D(x, y, z); break; } } } if (found) { multiitem = item; break; } } } if (multiitem != null) { //Console.WriteLine(\"attacking {0} at {1}:{2}\", multiitem, tileloc, ((StaticTarget)targeted).Location); // may have to reconsider the use tileloc vs target loc //m_cannon.AttackTarget(from, multiitem, ((StaticTarget)targeted).Location); //m_weapon.AttackTarget(from, multiitem, multiitem.Map.GetPoint(targeted, true), m_checklos); m_attachment.BeginAttackTarget(from, multiitem, multiitem.Map.GetPoint(targeted, true)); } } else if (targeted is AddonComponent) { // if the addon doesnt have an xmlsiege attachment, then attack the addon XmlSiege a = (XmlSiege)XmlAttach.FindAttachment(targeted, typeof(XmlSiege)); if (a == null || a.Deleted) { m_attachment.BeginAttackTarget(from, ((AddonComponent)targeted).Addon, ((Item)targeted).Location); } else { m_attachment.BeginAttackTarget(from, (Item)targeted, ((Item)targeted).Location); } } else if (targeted is Item) { m_attachment.BeginAttackTarget(from, (Item)targeted, ((Item)targeted).Location); } } } public void BeginAttackTarget(Mobile from, Item target, Point3D targetloc) { if (from == null || target == null) return; // check the target line of sight Point3D adjustedloc = new Point3D(targetloc.X, targetloc.Y, targetloc.Z + target.ItemData.Height); Point3D fromloc = new Point3D(from.Location.X, from.Location.Y, from.Location.Z + 14); if (!from.Map.LineOfSight(fromloc, adjustedloc)) { from.SendMessage(\"Cannot see target.\"); return; } int distance = (int)XmlSiege.GetDistance(from.Location, targetloc); if (distance <= MaxDistance) { CurrentLoc = from.Location; CurrentMap = from.Map; TargetLoc = target.Location; TargetMap = target.Map; AttackTarget = target; } else { from.SendLocalizedMessage(500446); // That is too far away. } } public override void Serialize(GenericWriter writer) { base.Serialize(writer); writer.Write((int)0); // version 0 } public override void Deserialize(GenericReader reader) { base.Deserialize(reader); int version = reader.ReadInt(); // version 0 } public override void OnAttach() { base.OnAttach(); if (!(AttachedTo is Item)) { Delete(); } } public override void OnDelete() { base.OnDelete(); if (m_Timer != null) m_Timer.Stop(); } public void DoTimer(TimeSpan delay, bool wait) { // is there a timer already running? Then let it finish if (m_Timer != null && m_Timer.Running && wait) return; if (m_Timer != null) m_Timer.Stop(); m_Timer = new InternalTimer(this, delay); m_Timer.Start(); } // added the duration timer that begins on spawning private class InternalTimer : Timer { private HandSiegeAttack m_attachment; public InternalTimer(HandSiegeAttack attachment, TimeSpan delay) : base(delay) { Priority = TimerPriority.TwoFiftyMS; m_attachment = attachment; } protected override void OnTick() { if (m_attachment == null) return; Item weapon = m_attachment.AttachedTo as Item; Item target = m_attachment.AttackTarget; if (weapon == null || weapon.Deleted || target == null || target.Deleted) { Stop(); return; } // the weapon must be equipped Mobile attacker = weapon.Parent as Mobile; if (attacker == null || attacker.Deleted) { Stop(); return; } // the attacker cannot be fighting if (attacker.Combatant != null) { attacker.SendMessage(\"Cannot siege while fighting.\"); Stop(); return; } // get the location of the attacker Point3D attackerloc = attacker.Location; Map attackermap = attacker.Map; Point3D targetloc = target.Location; Map targetmap = target.Map; if (targetmap == null || targetmap == Map.Internal || attackermap == null || attackermap == Map.Internal || targetmap != attackermap) { // if the attacker or target has an invalid map, then stop Stop(); return; } // compare it against previous locations. If they have moved then break off the attack if (attackerloc != m_attachment.CurrentLoc || attackermap != m_attachment.CurrentMap) { Stop(); return; } // attack the target // Animate( int action, int frameCount, int repeatCount, bool forward, bool repeat, int delay ) int action = 26; // 1-H bash animation, 29=2-H mounted // get the layer switch (weapon.Layer) { case Layer.OneHanded: if (attacker.Mount == null) { // unmounted animation action = 9; } else action = 26; break; case Layer.TwoHanded: if (attacker.Mount == null) { // unmounted animation action = 12; } else action = 29; break; } // attack animation attacker.Animate(action, 7, 1, true, false, 0); int basedamage = 1; double basedelay = BaseWeaponDelay; if (weapon is BaseWeapon) { BaseWeapon b = (BaseWeapon)weapon; // calculate the siege damage based on the weapon min/max damage and the overall damage scale factor basedamage = (int)(Utility.RandomMinMax(b.MinDamage, b.MaxDamage)*DamageScaleFactor); // reduce the actual delay by the weapon speed basedelay -= b.Speed/10; } if (basedelay < 1) basedelay = 1; if (basedamage < 1) basedamage = 1; // apply siege damage, all physical XmlSiege.Attack(attacker, target, basedamage, 0); // prepare for the next attack m_attachment.DoTimer(TimeSpan.FromSeconds(basedelay), false); } } }", "label": "FeatureEnvy"}
{"text": "public class UserResolverSelector : IIdentityResolverSelector { private readonly IContentManager _contentManager; public UserResolverSelector(IContentManager contentManager) { _contentManager = contentManager; } public IdentityResolverSelectorResult GetResolver(ContentIdentity contentIdentity) { if (contentIdentity.Has(\"User.UserName\")) { return new IdentityResolverSelectorResult { Priority = 0, Resolve = ResolveIdentity }; } return null; } private IEnumerable<ContentItem> ResolveIdentity(ContentIdentity identity) { var identifier = identity.Get(\"User.UserName\"); if (identifier == null) { return null; } var comparer = new ContentIdentity.ContentIdentityEqualityComparer(); return _contentManager .Query<UserPart, UserPartRecord>() .Where(p => p.UserName == identifier) .List<ContentItem>() .Where(c => comparer.Equals(identity, _contentManager.GetItemMetadata(c).Identity)); } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// /// </summary> public class WorkflowPicker : CompositeControl, IRockControl { #region IRockControl implementation (Custom implementation) /// <summary> /// Gets or sets the label text. /// </summary> /// <value> /// The label text. /// </value> [ Bindable( true ), Category( \"Appearance\" ), DefaultValue( \"\" ), Description( \"The text for the label.\" ) ] public string Label { get { return ViewState[\"Label\"] as string ?? string.Empty; } set { ViewState[\"Label\"] = value; } } /// <summary> /// Gets or sets the form group class. /// </summary> /// <value> /// The form group class. /// </value> [ Bindable( true ), Category( \"Appearance\" ), Description( \"The CSS class to add to the form-group div.\" ) ] public string FormGroupCssClass { get { return ViewState[\"FormGroupCssClass\"] as string ?? string.Empty; } set { ViewState[\"FormGroupCssClass\"] = value; } } /// <summary> /// Gets or sets the help text. /// </summary> /// <value> /// The help text. /// </value> [ Bindable( true ), Category( \"Appearance\" ), DefaultValue( \"\" ), Description( \"The help block.\" ) ] public string Help { get { return HelpBlock != null ? HelpBlock.Text : string.Empty; } set { if ( HelpBlock != null ) { HelpBlock.Text = value; } } } /// <summary> /// Gets or sets the warning text. /// </summary> /// <value> /// The warning text. /// </value> [ Bindable( true ), Category( \"Appearance\" ), DefaultValue( \"\" ), Description( \"The warning block.\" ) ] public string Warning { get { return WarningBlock != null ? WarningBlock.Text : string.Empty; } set { if ( WarningBlock != null ) { WarningBlock.Text = value; } } } /// <summary> /// Gets or sets a value indicating whether this <see cref=\"RockTextBox\"/> is required. /// </summary> /// <value> /// <c>true</c> if required; otherwise, <c>false</c>. /// </value> [ Bindable( true ), Category( \"Behavior\" ), DefaultValue( \"false\" ), Description( \"Is the value required?\" ) ] public bool Required { get { EnsureChildControls(); return _ddlWorkflow.Required; } set { EnsureChildControls(); _ddlWorkflow.Required = value; } } /// <summary> /// Gets or sets the required error message. If blank, the LabelName name will be used /// </summary> /// <value> /// The required error message. /// </value> public string RequiredErrorMessage { get { return RequiredFieldValidator != null ? RequiredFieldValidator.ErrorMessage : string.Empty; } set { if ( RequiredFieldValidator != null ) { RequiredFieldValidator.ErrorMessage = value; } } } /// <summary> /// Gets or sets an optional validation group to use. /// </summary> /// <value> /// The validation group. /// </value> public string ValidationGroup { get { return ViewState[\"ValidationGroup\"] as string; } set { ViewState[\"ValidationGroup\"] = value; } } /// <summary> /// Gets a value indicating whether this instance is valid. /// </summary> /// <value> /// <c>true</c> if this instance is valid; otherwise, <c>false</c>. /// </value> public virtual bool IsValid { get { return !Required || RequiredFieldValidator == null || RequiredFieldValidator.IsValid; } } /// <summary> /// Gets or sets the help block. /// </summary> /// <value> /// The help block. /// </value> public HelpBlock HelpBlock { get; set; } /// <summary> /// Gets or sets the warning block. /// </summary> /// <value> /// The warning block. /// </value> public WarningBlock WarningBlock { get; set; } /// <summary> /// Gets or sets the required field validator. /// </summary> /// <value> /// The required field validator. /// </value> public RequiredFieldValidator RequiredFieldValidator { get; set; } #endregion #region Controls private RockDropDownList _ddlWorkflowType; private RockDropDownList _ddlWorkflow; #endregion #region Properties /// <summary> /// Gets or sets the workflow type id. /// </summary> /// <value> /// The workflow type id. /// </value> public int? WorkflowTypeId { get { return ViewState[\"WorkflowTypeId\"] as int?; } set { ViewState[\"WorkflowTypeId\"] = value; if ( value.HasValue ) { LoadWorkflows( value.Value ); } } } /// <summary> /// Gets or sets the workflow id. /// </summary> /// <value> /// The workflow id. /// </value> public int? WorkflowId { get { EnsureChildControls(); int workflowId = int.MinValue; if ( int.TryParse( _ddlWorkflow.SelectedValue, out workflowId ) && workflowId > 0 ) { return workflowId; } return null; } set { EnsureChildControls(); int workflowId = value.HasValue ? value.Value : 0; if ( _ddlWorkflow.SelectedValue != workflowId.ToString() ) { if ( !WorkflowTypeId.HasValue ) { var workflow = new Rock.Model.WorkflowService( new RockContext() ).Get( workflowId ); if ( workflow != null && _ddlWorkflowType.SelectedValue != workflow.WorkflowTypeId.ToString() ) { _ddlWorkflowType.SelectedValue = workflow.WorkflowTypeId.ToString(); LoadWorkflows( workflow.WorkflowTypeId ); } } _ddlWorkflow.SetValue( workflowId.ToString() ); } } } #endregion /// <summary> /// Initializes a new instance of the <see cref=\"WorkflowPicker\"/> class. /// </summary> public WorkflowPicker() : base() { HelpBlock = new HelpBlock(); WarningBlock = new WarningBlock(); } /// <summary> /// Called by the ASP.NET page framework to notify server controls that use composition-based implementation to create any child controls they contain in preparation for posting back or rendering. /// </summary> protected override void CreateChildControls() { base.CreateChildControls(); Controls.Clear(); RockControlHelper.CreateChildControls( this, Controls ); _ddlWorkflowType = new RockDropDownList(); _ddlWorkflowType.ID = this.ID + \"_ddlWorkflowType\"; _ddlWorkflowType.AutoPostBack = true; _ddlWorkflowType.SelectedIndexChanged += _ddlWorkflowType_SelectedIndexChanged; Controls.Add( _ddlWorkflowType ); _ddlWorkflow = new RockDropDownList(); _ddlWorkflow.ID = this.ID + \"_ddlWorkflow\"; _ddlWorkflow.Label = \"Workflow\"; Controls.Add( _ddlWorkflow ); LoadWorkflowTypes(); } /// <summary> /// Handles the SelectedIndexChanged event of the _ddlWorkflowType control. /// </summary> /// <param name=\"sender\">The source of the event.</param> /// <param name=\"e\">The <see cref=\"EventArgs\"/> instance containing the event data.</param> protected void _ddlWorkflowType_SelectedIndexChanged( object sender, EventArgs e ) { int workflowTypeId = _ddlWorkflowType.SelectedValue.AsInteger(); LoadWorkflows( workflowTypeId ); } /// <summary> /// Outputs server control content to a provided <see cref=\"T:System.Web.UI.HtmlTextWriter\" /> object and stores tracing information about the control if tracing is enabled. /// </summary> /// <param name=\"writer\">The <see cref=\"T:System.Web.UI.HtmlTextWriter\" /> object that receives the control content.</param> public override void RenderControl( HtmlTextWriter writer ) { if ( this.Visible ) { RockControlHelper.RenderControl( this, writer ); } } /// <summary> /// Renders the base control. /// </summary> /// <param name=\"writer\">The writer.</param> public void RenderBaseControl( HtmlTextWriter writer ) { if ( !WorkflowTypeId.HasValue ) { _ddlWorkflowType.RenderControl( writer ); } _ddlWorkflow.RenderControl( writer ); } /// <summary> /// Loads the workflow types. /// </summary> private void LoadWorkflowTypes() { _ddlWorkflowType.Items.Clear(); if ( !Required ) { _ddlWorkflowType.Items.Add( new ListItem( string.Empty, Rock.Constants.None.IdValue ) ); } using ( var rockContext = new RockContext() ) { var workflowTypeService = new Rock.Model.WorkflowTypeService( rockContext ); var workflowTypes = workflowTypeService.Queryable().AsNoTracking() .Where( t => t.Category != null && t.IsActive.HasValue && t.IsActive.Value) .OrderBy( t => t.Category.Name) .ThenBy( t => t.Name ) .Select(a => new { a.Id, CategoryName = a.Category.Name, a.Name} ) .AsNoTracking() .ToList(); foreach ( var t in workflowTypes ) { _ddlWorkflowType.Items.Add( new ListItem( string.Format( \"{0}: {1}\", t.CategoryName, t.Name), t.Id.ToString().ToUpper() ) ); } } } /// <summary> /// Loads the workflows. /// </summary> /// <param name=\"workflowTypeId\">The workflow type unique identifier.</param> private void LoadWorkflows( int? workflowTypeId ) { int? currentWorkflowId = this.WorkflowId; _ddlWorkflow.SelectedValue = null; _ddlWorkflow.Items.Clear(); if ( workflowTypeId.HasValue ) { if ( !Required ) { _ddlWorkflow.Items.Add( new ListItem( string.Empty, Rock.Constants.None.IdValue ) ); } var workflowService = new Rock.Model.WorkflowService( new RockContext() ); var workflows = workflowService.Queryable() .Where( w => w.WorkflowTypeId == workflowTypeId.Value && w.ActivatedDateTime.HasValue && !w.CompletedDateTime.HasValue ) .OrderBy( w => w.Name ) .Select(a => new { a.Id, a.Name } ) .ToList(); foreach ( var w in workflows ) { var workflowItem = new ListItem( w.Name, w.Id.ToString().ToUpper() ); workflowItem.Selected = w.Id == currentWorkflowId; _ddlWorkflow.Items.Add( workflowItem ); } } } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// The GitVersion runner. /// </summary> public sealed class GitVersionRunner : Tool<GitVersionSettings> { private readonly ICakeLog _log; /// <summary> /// Initializes a new instance of the <see cref=\"GitVersionRunner\"/> class. /// </summary> /// <param name=\"fileSystem\">The file system.</param> /// <param name=\"environment\">The environment.</param> /// <param name=\"processRunner\">The process runner.</param> /// <param name=\"tools\">The tool locator.</param> /// <param name=\"log\">The log.</param> public GitVersionRunner( IFileSystem fileSystem, ICakeEnvironment environment, IProcessRunner processRunner, IToolLocator tools, ICakeLog log) : base(fileSystem, environment, processRunner, tools) { _log = log; } /// <summary> /// Runs GitVersion and processes the results. /// </summary> /// <param name=\"settings\">The settings.</param> /// <returns>A task with the GitVersion results.</returns> public GitVersion Run(GitVersionSettings settings) { if (settings == null) { throw new ArgumentNullException(nameof(settings)); } if (settings.OutputType != GitVersionOutput.BuildServer) { var jsonString = string.Empty; Run(settings, GetArguments(settings), new ProcessSettings { RedirectStandardOutput = true }, process => jsonString = string.Join(\"\\n\", process.GetStandardOutput())); var jsonSerializer = new DataContractJsonSerializer(typeof(GitVersionInternal)); using (var jsonStream = new MemoryStream(Encoding.UTF8.GetBytes(jsonString))) { return (jsonSerializer.ReadObject(jsonStream) as GitVersionInternal)?.GitVersion; } } Run(settings, GetArguments(settings)); return new GitVersion(); } private ProcessArgumentBuilder GetArguments(GitVersionSettings settings) { var builder = new ProcessArgumentBuilder(); if (settings.OutputType.HasValue) { switch (settings.OutputType.Value) { case GitVersionOutput.Json: builder.Append(\"-output\"); builder.Append(\"json\"); break; case GitVersionOutput.BuildServer: builder.Append(\"-output\"); builder.Append(\"buildserver\"); break; } } if (!string.IsNullOrWhiteSpace(settings.ShowVariable)) { builder.Append(\"-showvariable\"); builder.Append(settings.ShowVariable); } if (!string.IsNullOrWhiteSpace(settings.UserName)) { builder.Append(\"-u\"); builder.AppendQuoted(settings.UserName); builder.Append(\"-p\"); builder.AppendQuotedSecret(settings.Password); } if (settings.UpdateAssemblyInfo) { builder.Append(\"-updateassemblyinfo\"); if (settings.UpdateAssemblyInfoFilePath != null) { builder.AppendQuoted(settings.UpdateAssemblyInfoFilePath.FullPath); } } if (settings.RepositoryPath != null) { builder.Append(\"-targetpath\"); builder.AppendQuoted(settings.RepositoryPath.FullPath); } else if (!string.IsNullOrWhiteSpace(settings.Url)) { builder.Append(\"-url\"); builder.AppendQuoted(settings.Url); if (!string.IsNullOrWhiteSpace(settings.Branch)) { builder.Append(\"-b\"); builder.Append(settings.Branch); } else { _log.Warning(\"If you leave the branch name for GitVersion unset, it will fallback to the default branch for the repository.\"); } if (!string.IsNullOrWhiteSpace(settings.Commit)) { builder.Append(\"-c\"); builder.AppendQuoted(settings.Commit); } if (settings.DynamicRepositoryPath != null) { builder.Append(\"-dynamicRepoLocation\"); builder.AppendQuoted(settings.DynamicRepositoryPath.FullPath); } } if (settings.LogFilePath != null) { builder.Append(\"-l\"); builder.AppendQuoted(settings.LogFilePath.FullPath); } if (settings.NoFetch) { builder.Append(\"-nofetch\"); } if (settings.Verbosity.HasValue) { switch (settings.Verbosity.Value) { case GitVersionVerbosity.None: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.None)); break; case GitVersionVerbosity.Debug: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.Debug)); break; case GitVersionVerbosity.Info: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.Info)); break; case GitVersionVerbosity.Warn: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.Warn)); break; case GitVersionVerbosity.Error: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.Error)); break; } } else { switch (_log.Verbosity) { case Verbosity.Quiet: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.None)); break; case Verbosity.Diagnostic: case Verbosity.Verbose: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.Debug)); break; case Verbosity.Minimal: builder.Append(\"-verbosity\"); builder.Append(nameof(GitVersionVerbosity.Error)); break; } } return builder; } /// <summary> /// Gets the name of the tool. /// </summary> /// <returns>The name of the tool.</returns> protected override string GetToolName() { return \"GitVersion\"; } /// <summary> /// Gets the possible names of the tool executable. /// </summary> /// <returns>The tool executable name.</returns> protected override IEnumerable<string> GetToolExecutableNames() { return new[] { \"GitVersion.exe\", \"dotnet-gitversion\", \"dotnet-gitversion.exe\" }; } }", "label": "ComplexConditional"}
{"text": "public class TodoModule : NancyModule { private static readonly Logger Log = LogManager.GetCurrentClassLogger(); private readonly ITodoService _todoService; private readonly IServiceBus _bus; public TodoModule(IAppSettings appSettings, ITodoService todoService, IServiceBus bus) { _todoService = todoService; _bus = bus; Post[\"/todo\"] = _ => { var slashCommand = this.Bind<SlashCommand>(); if (slashCommand == null || slashCommand.command.Missing()) { Log.Info(\"Rejected an incoming slash command (unable to parse request body).\"); return HttpStatusCode.BadRequest.WithReason(\"Unable to parse slash command.\"); } if (!appSettings.Get(\"todo:slackSlashCommandToken\").Equals(slashCommand.token)) { Log.Info(\"Blocked an unauthorized slash command.\"); return HttpStatusCode.Unauthorized.WithReason(\"Missing or invalid token.\"); } if (!slashCommand.command.Equals(\"/todo\", StringComparison.InvariantCultureIgnoreCase)) { Log.Info(\"Rejected an incoming slash command ({0} is not handled by this module).\", slashCommand.command); return HttpStatusCode.BadRequest.WithReason(\"Unsupported slash command.\"); } var responseText = HandleTodo(slashCommand); if (responseText.Missing()) { return HttpStatusCode.OK; } return responseText; }; } private string HandleTodo(SlashCommand message) { var listId = message.channel_id; var list = _todoService.GetItems(message.user_id, listId).ToArray(); var @operator = message.text.SubstringByWords(0, 1); if (!@operator.Missing()) { @operator = @operator.ToLowerInvariant(); } switch (@operator) { case \"\": { // Just echo the list break; } case \"show\": { _bus.Publish(new MessageToSlack { channel = listId, text = list.ToSlackString() }); return null; } case \"add\": { var todoText = message.text.SubstringByWords(1); if (todoText.Missing()) { return null; } _todoService.AddItem(message.user_id, listId, todoText); break; } case \"tick\": { var todoItemId = message.text.SubstringByWords(1, 1); if (todoItemId.Missing()) { return null; } var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\"; try { _todoService.TickItem(message.user_id, listId, todoItemId, force); } catch (TodoItemClaimedBySomeoneElseException ex) { return string.Format( \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\", ex.UserId, @operator, todoItemId); } break; } case \"untick\": { var todoItemId = message.text.SubstringByWords(1, 1); if (todoItemId.Missing()) { return null; } _todoService.UntickItem(message.user_id, listId, todoItemId); break; } case \"remove\": { var todoItemId = message.text.SubstringByWords(1, 1); if (todoItemId.Missing()) { return null; } var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\"; try { _todoService.RemoveItem(message.user_id, listId, todoItemId, force); } catch (TodoItemClaimedBySomeoneElseException ex) { return string.Format( \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\", ex.UserId, @operator, todoItemId); } break; } case \"trim\": { _todoService.ClearItems(message.user_id, listId, includeUnticked: false, force: false); break; } case \"clear\": { var force = message.text.SubstringByWords(1, 1).ToLowerInvariant() == \"force\"; try { _todoService.ClearItems(message.user_id, listId, includeUnticked: true, force: force); } catch (TodoItemClaimedBySomeoneElseException ex) { return string.Format( \"There are tasks claimed by other people. Use `/todo {0} force` to override.\", @operator); } break; } case \"claim\": { var todoItemId = message.text.SubstringByWords(1, 1); if (todoItemId.Missing()) { return null; } var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\"; try { _todoService.ClaimItem(message.user_id, listId, todoItemId, force); } catch (TodoItemClaimedBySomeoneElseException ex) { return string.Format( \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\", ex.UserId, @operator, todoItemId); } break; } case \"free\": { var todoItemId = message.text.SubstringByWords(1, 1); if (todoItemId.Missing()) { return null; } var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\"; try { _todoService.FreeItem(message.user_id, listId, todoItemId, force); } catch (TodoItemClaimedBySomeoneElseException ex) { return string.Format( \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\", ex.UserId, @operator, todoItemId); } break; } case \"help\": { return \"TODO\"; // TODO Return usage info } default: { return \"Sorry, that is not a valid syntax for the `/todo` command. Use `/todo help` to see available operations.\"; } } list = _todoService.GetItems(message.user_id, listId).ToArray(); return list.ToSlackString(); } }", "label": "ComplexMethod"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class fetchMessages_args : TBase { private long _localTs; private int _count; public long LocalTs { get { return _localTs; } set { __isset.localTs = true; this._localTs = value; } } public int Count { get { return _count; } set { __isset.count = true; this._count = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool localTs; public bool count; } public fetchMessages_args() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 2: if (field.Type == TType.I64) { LocalTs = iprot.ReadI64(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 3: if (field.Type == TType.I32) { Count = iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"fetchMessages_args\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (__isset.localTs) { field.Name = \"localTs\"; field.Type = TType.I64; field.ID = 2; oprot.WriteFieldBegin(field); oprot.WriteI64(LocalTs); oprot.WriteFieldEnd(); } if (__isset.count) { field.Name = \"count\"; field.Type = TType.I32; field.ID = 3; oprot.WriteFieldBegin(field); oprot.WriteI32(Count); oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"fetchMessages_args(\"); sb.Append(\"LocalTs: \"); sb.Append(LocalTs); sb.Append(\",Count: \"); sb.Append(Count); sb.Append(\")\"); return sb.ToString(); } }", "label": "ComplexMethod"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class sendMessageIgnored_args : TBase { private int _seq; private string _consumer; private List<string> _messageIds; public int Seq { get { return _seq; } set { __isset.seq = true; this._seq = value; } } public string Consumer { get { return _consumer; } set { __isset.consumer = true; this._consumer = value; } } public List<string> MessageIds { get { return _messageIds; } set { __isset.messageIds = true; this._messageIds = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool seq; public bool consumer; public bool messageIds; } public sendMessageIgnored_args() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 1: if (field.Type == TType.I32) { Seq = iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 2: if (field.Type == TType.String) { Consumer = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 3: if (field.Type == TType.List) { { MessageIds = new List<string>(); TList _list393 = iprot.ReadListBegin(); for( int _i394 = 0; _i394 < _list393.Count; ++_i394) { string _elem395 = null; _elem395 = iprot.ReadString(); MessageIds.Add(_elem395); } iprot.ReadListEnd(); } } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"sendMessageIgnored_args\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (__isset.seq) { field.Name = \"seq\"; field.Type = TType.I32; field.ID = 1; oprot.WriteFieldBegin(field); oprot.WriteI32(Seq); oprot.WriteFieldEnd(); } if (Consumer != null && __isset.consumer) { field.Name = \"consumer\"; field.Type = TType.String; field.ID = 2; oprot.WriteFieldBegin(field); oprot.WriteString(Consumer); oprot.WriteFieldEnd(); } if (MessageIds != null && __isset.messageIds) { field.Name = \"messageIds\"; field.Type = TType.List; field.ID = 3; oprot.WriteFieldBegin(field); { oprot.WriteListBegin(new TList(TType.String, MessageIds.Count)); foreach (string _iter396 in MessageIds) { oprot.WriteString(_iter396); } oprot.WriteListEnd(); } oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"sendMessageIgnored_args(\"); sb.Append(\"Seq: \"); sb.Append(Seq); sb.Append(\",Consumer: \"); sb.Append(Consumer); sb.Append(\",MessageIds: \"); sb.Append(MessageIds); sb.Append(\")\"); return sb.ToString(); } }", "label": "ComplexConditional"}
{"text": "internal partial class ManagementController : IDisposable { private StorageManagementClient _storageManagementClient; private ComputeManagementClient _computeManagementClient; private PublishSettingsSubscriptionItem _publishSettingCreds; private ManagementControllerParameters _parameters; public ManagementController(ManagementControllerParameters parameters) { _parameters = parameters; // To authenticate against the Microsoft Azure service management API we require management certificate // load this from a publish settings file and later use it with the Service Management Libraries var credential = GetSubscriptionCloudCredentials(parameters.PublishSettingsFilePath); _storageManagementClient = CloudContext.Clients.CreateStorageManagementClient(credential); _computeManagementClient = CloudContext.Clients.CreateComputeManagementClient(credential); } private SubscriptionCloudCredentials GetSubscriptionCloudCredentials(string publishSettingsFilePath) { using (var fs = File.OpenRead(publishSettingsFilePath)) { var document = XDocument.Load(fs); var subscriptions = from e in document.Descendants(\"Subscription\") select e; if (subscriptions.Count() >= 1) { // use first subscription in the publish settings file var subscription = subscriptions.First(); _publishSettingCreds = new PublishSettingsSubscriptionItem { SubscriptionName = subscription.Attribute(\"Name\").Value, SubscriptionId = subscription.Attribute(\"Id\").Value, ManagementCertificate = subscription.Attribute(\"ManagementCertificate\").Value }; } else { Console.WriteLine(\"Invalid publishsettings file: Subscription not found.\"); } } return CertificateAuthenticationHelper.GetCredentials(_publishSettingCreds.SubscriptionId, _publishSettingCreds.ManagementCertificate); } internal async Task CreateStorageAccount() { //Create a storage account in the given region await _storageManagementClient.StorageAccounts.CreateAsync( new StorageAccountCreateParameters { Location = _parameters.Region, Name = _parameters.StorageAccountName, AccountType = _parameters.StorageAccountType, }); } internal async Task<string> GetStorageAccountConnectionString() { //Retrieve the storage account keys var keys = await _storageManagementClient.StorageAccounts.GetKeysAsync(_parameters.StorageAccountName); string connectionString = string.Format( CultureInfo.InvariantCulture, \"DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1}\", _parameters.StorageAccountName, keys.SecondaryKey); return connectionString; } internal async Task CreateCloudService() { //Create the hosted service await _computeManagementClient.HostedServices.CreateAsync(new HostedServiceCreateParameters { Location = _parameters.Region, ServiceName = _parameters.CloudServiceName }); } internal async Task<CloudBlockBlob> UploadDeploymentPackage() { //upload cloud service package and config to storage account var storageConnectionString = await GetStorageAccountConnectionString(); var account = CloudStorageAccount.Parse(storageConnectionString); var blobs = account.CreateCloudBlobClient(); var container = blobs.GetContainerReference(\"deployments\"); await container.CreateIfNotExistsAsync(); await container.SetPermissionsAsync( new BlobContainerPermissions() { PublicAccess = BlobContainerPublicAccessType.Container }); var blob = container.GetBlockBlobReference( Path.GetFileName(_parameters.ServicePackageFilePath)); await blob.UploadFromFileAsync(_parameters.ServicePackageFilePath, FileMode.Open); return blob; } internal async Task DeployCloudService(Uri blobUri) { //deploy the cloud service into the provisioned slot using the uploaded *.cspkg and *.cscfg await _computeManagementClient.Deployments.CreateAsync(_parameters.CloudServiceName, DeploymentSlot.Production, new DeploymentCreateParameters { Label = _parameters.CloudServiceName, Name = _parameters.CloudServiceName + \"Prod\", PackageUri = blobUri, Configuration = File.ReadAllText(_parameters.ServiceConfigurationFilePath), StartDeployment = true }); } internal void TearDown() { //tear down everything that was created _computeManagementClient.Deployments.DeleteBySlot(_parameters.CloudServiceName, DeploymentSlot.Production); _computeManagementClient.HostedServices.Delete(_parameters.CloudServiceName); _storageManagementClient.StorageAccounts.Delete(_parameters.StorageAccountName); } public void Dispose() { if (_storageManagementClient != null) _storageManagementClient.Dispose(); if (_computeManagementClient != null) _computeManagementClient.Dispose(); } }", "label": "ComplexMethod"}
{"text": "public class PkceTests : IdentityServerHostTest { const string Category = \"Conformance.PKCE\"; Client client; string client_id = \"codewithproofkey_client\"; string redirect_uri = \"https://code_client/callback\"; string code_verifier = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"; string client_secret = \"secret\"; string response_type = \"code\"; protected override void PreInit() { host.Scopes.Add(StandardScopes.OpenId); host.Clients.Add(client = new Client { Enabled = true, ClientId = client_id, ClientSecrets = new List<Secret> { new Secret(client_secret.Sha256()) }, Flow = Flows.AuthorizationCodeWithProofKey, AllowAccessToAllScopes = true, RequireConsent = false, RedirectUris = new List<string> { redirect_uri } }); } [Fact] [Trait(\"Category\", Category)] public void Client_can_use_plain_code_challenge_method() { host.Login(); var nonce = Guid.NewGuid().ToString(); var code_challenge = code_verifier; var codeQuery = host.RequestAuthorizationCode( client_id, redirect_uri, Constants.StandardScopes.OpenId, nonce, code_challenge, Constants.CodeChallengeMethods.Plain); var code = codeQuery[\"code\"]; host.NewRequest(); host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret); var result = host.PostForm(host.GetTokenUrl(), new { grant_type = \"authorization_code\", code, redirect_uri, code_verifier } ); result.StatusCode.Should().Be(HttpStatusCode.OK); var data = result.ReadJsonObject(); data[\"token_type\"].Should().NotBeNull(); data[\"token_type\"].ToString().Should().Be(\"Bearer\"); data[\"access_token\"].Should().NotBeNull(); data[\"expires_in\"].Should().NotBeNull(); data[\"id_token\"].Should().NotBeNull(); } [Fact] [Trait(\"Category\", Category)] public void Client_can_use_sha256_code_challenge_method() { host.Login(); var nonce = Guid.NewGuid().ToString(); var code_challenge = Sha256OfCodeVerifier(code_verifier); var codeQuery = host.RequestAuthorizationCode( client_id, redirect_uri, Constants.StandardScopes.OpenId, nonce, code_challenge, Constants.CodeChallengeMethods.SHA_256); var code = codeQuery[\"code\"]; host.NewRequest(); host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret); var result = host.PostForm(host.GetTokenUrl(), new { grant_type = \"authorization_code\", code, redirect_uri, code_verifier } ); result.StatusCode.Should().Be(HttpStatusCode.OK); var data = result.ReadJsonObject(); data[\"token_type\"].Should().NotBeNull(); data[\"token_type\"].ToString().Should().Be(\"Bearer\"); data[\"access_token\"].Should().NotBeNull(); data[\"expires_in\"].Should().NotBeNull(); data[\"id_token\"].Should().NotBeNull(); } [Fact] [Trait(\"Category\", Category)] public async Task Authorize_request_needs_code_challenge() { host.Login(); var nonce = Guid.NewGuid().ToString(); var authorizeUrl = host.GetAuthorizeUrl( client_id, redirect_uri, Constants.StandardScopes.OpenId, response_type, Guid.NewGuid().ToString(), Guid.NewGuid().ToString()); var result = await host.Client.GetAsync(authorizeUrl); result.StatusCode.Should().Be(HttpStatusCode.Found); var query = result.Headers.Location.ParseHashFragment(); query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest); query[\"error_description\"].Should().Be(\"code challenge required\"); } [Fact] [Trait(\"Category\", Category)] public async Task Authorize_request_code_challenge_cannot_be_too_short() { host.Login(); var nonce = Guid.NewGuid().ToString(); var authorizeUrl = host.GetAuthorizeUrl( client_id, redirect_uri, Constants.StandardScopes.OpenId, response_type, Guid.NewGuid().ToString(), Guid.NewGuid().ToString(), \"a\"); var result = await host.Client.GetAsync(authorizeUrl); result.StatusCode.Should().Be(HttpStatusCode.Found); var query = result.Headers.Location.ParseHashFragment(); query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest); } [Fact] [Trait(\"Category\", Category)] public async Task Authorize_request_code_challenge_cannot_be_too_long() { host.Login(); var nonce = Guid.NewGuid().ToString(); var authorizeUrl = host.GetAuthorizeUrl( client_id, redirect_uri, Constants.StandardScopes.OpenId, response_type, Guid.NewGuid().ToString(), Guid.NewGuid().ToString(), new string('a', host.Options.InputLengthRestrictions.CodeChallengeMaxLength + 1)); var result = await host.Client.GetAsync(authorizeUrl); result.StatusCode.Should().Be(HttpStatusCode.Found); var query = result.Headers.Location.ParseHashFragment(); query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest); } [Fact] [Trait(\"Category\", Category)] public async Task Authorize_request_needs_supported_code_challenge_method() { host.Login(); var nonce = Guid.NewGuid().ToString(); var code_challenge = code_verifier; var authorizeUrl = host.GetAuthorizeUrl( client_id, redirect_uri, Constants.StandardScopes.OpenId, response_type, Guid.NewGuid().ToString(), Guid.NewGuid().ToString(), code_challenge, \"unknown_code_challenge_method\"); var result = await host.Client.GetAsync(authorizeUrl); result.StatusCode.Should().Be(HttpStatusCode.Found); var query = result.Headers.Location.ParseHashFragment(); query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest); query[\"error_description\"].Should().Be(\"transform algorithm not supported\"); } [Fact] [Trait(\"Category\", Category)] public void Token_request_needs_code_verifier() { host.Login(); var nonce = Guid.NewGuid().ToString(); var code_challenge = code_verifier; var codeQuery = host.RequestAuthorizationCode( client_id, redirect_uri, Constants.StandardScopes.OpenId, nonce, code_challenge, Constants.CodeChallengeMethods.Plain); var code = codeQuery[\"code\"]; host.NewRequest(); host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret); var result = host.PostForm(host.GetTokenUrl(), new { grant_type = \"authorization_code\", code, redirect_uri } ); result.StatusCode.Should().Be(HttpStatusCode.BadRequest); var data = result.ReadJsonObject(); data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant); } [Fact] [Trait(\"Category\", Category)] public void Token_request_code_verifier_cannot_be_too_short() { host.Login(); var nonce = Guid.NewGuid().ToString(); var code_challenge = code_verifier; var codeQuery = host.RequestAuthorizationCode( client_id, redirect_uri, Constants.StandardScopes.OpenId, nonce, code_challenge, Constants.CodeChallengeMethods.Plain); var code = codeQuery[\"code\"]; host.NewRequest(); host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret); var result = host.PostForm(host.GetTokenUrl(), new { grant_type = \"authorization_code\", code, redirect_uri, code_verifier = \"a\" } ); result.StatusCode.Should().Be(HttpStatusCode.BadRequest); var data = result.ReadJsonObject(); data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant); } [Fact] [Trait(\"Category\", Category)] public void Token_request_code_verifier_cannot_be_too_long() { host.Login(); var nonce = Guid.NewGuid().ToString(); var code_challenge = code_verifier; var codeQuery = host.RequestAuthorizationCode( client_id, redirect_uri, Constants.StandardScopes.OpenId, nonce, code_challenge, Constants.CodeChallengeMethods.Plain); var code = codeQuery[\"code\"]; host.NewRequest(); host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret); var result = host.PostForm(host.GetTokenUrl(), new { grant_type = \"authorization_code\", code, redirect_uri, code_verifier = new string('a', host.Options.InputLengthRestrictions.CodeVerifierMaxLength + 1) } ); result.StatusCode.Should().Be(HttpStatusCode.BadRequest); var data = result.ReadJsonObject(); data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant); } [Fact] [Trait(\"Category\", Category)] public void Token_request_code_verifier_must_match_with_code_chalenge() { host.Login(); var nonce = Guid.NewGuid().ToString(); var code_challenge = code_verifier; var codeQuery = host.RequestAuthorizationCode( client_id, redirect_uri, Constants.StandardScopes.OpenId, nonce, code_challenge, Constants.CodeChallengeMethods.Plain); var code = codeQuery[\"code\"]; host.NewRequest(); host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret); var result = host.PostForm(host.GetTokenUrl(), new { grant_type = \"authorization_code\", code, redirect_uri, code_verifier = \"mismatched_code_verifier\" } ); result.StatusCode.Should().Be(HttpStatusCode.BadRequest); var data = result.ReadJsonObject(); data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant); } private static string Sha256OfCodeVerifier(string codeVerifier) { var codeVerifierBytes = Encoding.ASCII.GetBytes(codeVerifier); var hashedBytes = codeVerifierBytes.Sha256(); var transformedCodeVerifier = Base64Url.Encode(hashedBytes); return transformedCodeVerifier; } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Simple string input UI for initiating string-based searches. Users of the class match against /// the inputted string via the Matches() method.</summary> public class StringSearchInputUI : ToolStrip { /// <summary> /// Constructor</summary> public StringSearchInputUI() { m_patternTextRegex = string.Empty; Visible = true; GripStyle = ToolStripGripStyle.Hidden; RenderMode = ToolStripRenderMode.System; ToolStripDropDownButton dropDownButton = new ToolStripDropDownButton(); dropDownButton.DisplayStyle = ToolStripItemDisplayStyle.Image; dropDownButton.Image = ResourceUtil.GetImage16(Resources.SearchImage); dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta; dropDownButton.Name = \"SearchButton\"; dropDownButton.Size = new System.Drawing.Size(29, 22); dropDownButton.Text = \"Search\".Localize(\"'Search' is a verb\"); ToolStripButton clearSearchButton = new ToolStripButton(); clearSearchButton.DisplayStyle = ToolStripItemDisplayStyle.Image; clearSearchButton.Image = ResourceUtil.GetImage16(Resources.DeleteImage); dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta; clearSearchButton.Name = \"ClearSearchButton\"; clearSearchButton.Size = new System.Drawing.Size(29, 22); clearSearchButton.Text = \"Clear Search\".Localize(\"'Clear' is a verb\"); clearSearchButton.Click += clearSearchButton_Click; m_patternTextBox = new ToolStripAutoFitTextBox(); m_patternTextBox.KeyUp += patternTextBox_KeyUp; m_patternTextBox.TextChanged += patternTextBox_TextChanged; m_patternTextBox.TextBox.PreviewKeyDown += textBox_PreviewKeyDown; m_patternTextBox.MaximumWidth = 1080; Items.AddRange(new ToolStripItem[] { dropDownButton, m_patternTextBox, clearSearchButton }); } /// <summary> /// Event that is raised after text control is updated</summary> public event EventHandler Updated; /// <summary> /// Gets whether or not the textbox contains any input</summary> /// <returns>True if any sort of string is in the textbox</returns> public bool IsNullOrEmpty() { return m_textBoxEmpty; } /// <summary> /// Returns whether the specified string matches the pattern string in the text box</summary> /// <param name=\"inputString\">The string to test for match</param> /// <returns>True iff the text box pattern string matches with inputString</returns> public bool Matches(string inputString) { return Regex.Match(inputString, m_patternTextRegex, RegexOptions.IgnoreCase).Success; } /// <summary> /// Gets the search pattern</summary> public string SearchPattern { get { return m_patternTextBox.Text; } } /// <summary> /// Clears search results</summary> public void ClearSearch() { m_patternTextBox.Text = string.Empty; m_patternTextRegex = string.Empty; Updated.Raise(this, EventArgs.Empty); } /// <summary> /// Callback that performs custom actions when the 'clear' button has been pressed</summary> /// <param name=\"sender\">The sender of the event</param> /// <param name=\"e\">Arguments related to the event</param> private void clearSearchButton_Click(object sender, System.EventArgs e) { ClearSearch(); } /// <summary> /// Callback that performs custom actions when any keypress is completed in the text box</summary> /// <param name=\"sender\">The sender of the event</param> /// <param name=\"e\">Arguments related to the event</param> private void patternTextBox_KeyUp(object sender, KeyEventArgs e) { m_patternTextRegex = string.Empty; if (!string.IsNullOrEmpty(m_patternTextBox.Text)) { bool patternValid = true; m_patternTextRegex = m_patternTextBox.Text.Replace(\"*\", \"[\\\\w\\\\s]+\"); // test that the regex pattern is valid by running a match, and checking for an exception try { Regex.Match(String.Empty, m_patternTextRegex); } catch (ArgumentException) { patternValid = false; } m_patternTextRegex = (patternValid) ? m_patternTextRegex : Regex.Escape(m_patternTextBox.Text); } Updated.Raise(this, EventArgs.Empty); } /// <summary> /// Callback that performs custom actions after any text changed in the text box</summary> /// <param name=\"sender\">The sender of the event</param> /// <param name=\"e\">Arguments related to the event</param> void patternTextBox_TextChanged(object sender, EventArgs e) { m_textBoxEmpty = string.IsNullOrEmpty(m_patternTextBox.Text); } /// <summary> /// Callback that performs custom actions after the preview key is pressed</summary> /// <param name=\"sender\">The sender of the event</param> /// <param name=\"e\">Arguments related to the event</param> void textBox_PreviewKeyDown(object sender, PreviewKeyDownEventArgs e) { if (e.KeyData == Keys.Escape) clearSearchButton_Click(sender, e); } private readonly ToolStripAutoFitTextBox m_patternTextBox; private string m_patternTextRegex; private bool m_textBoxEmpty=true; }", "label": "ComplexConditional"}
{"text": "public class OrderAndPositionViewModel : BindableBase { private OrderTable _ordertable = new OrderTable(); private PositionTable _positiontable = new PositionTable(); private FillTable _filltable = new FillTable(); //private ResultTable _resulttable = new ResultTable(); System.Data.DataTable _resultstable = new System.Data.DataTable(\"ResultsTable\"); private EventAggregator _eventaggregator; private readonly ILoggerFacade _logger; private ConfigManager _configmanager; PositionTracker _positiontracker; OrderTracker _ordertracker; List<Trade> _tradelist = new List<Trade>(); PerformanceEvaluator _performevaluator; public OrderAndPositionViewModel() { _eventaggregator = ServiceLocator.Current.GetInstance<EventAggregator>(); _logger = ServiceLocator.Current.GetInstance<ILoggerFacade>(); _configmanager = ServiceLocator.Current.GetInstance<IConfigManager>() as ConfigManager; _ordertracker = new OrderTracker(_configmanager.DailyOrderCapacity); _ordertracker.SendDebugEvent += OnDebug; _positiontracker = new PositionTracker(_configmanager.DailyOrderCapacity); _eventaggregator.GetEvent<InitialPositionEvent>().Subscribe(ClientGotInitialPosition); //_eventaggregator.GetEvent<SendOrderEvent>().Subscribe(ClientGotOrder); _eventaggregator.GetEvent<OrderConfirmationEvent>().Subscribe(ClientGotOrder); _eventaggregator.GetEvent<OrderCancelConfirmationEvent>().Subscribe(ClientGotOrderCancelConfirmation); _eventaggregator.GetEvent<OrderFillEvent>().Subscribe(ClientGotOrderFilled); _eventaggregator.GetEvent<GenerateReportEvent>().Subscribe(GeneratePerformanceReport); _resultstable.Columns.Add(\"Statistics\"); _resultstable.Columns.Add(\"Result\"); } private void ClientGotInitialPosition(Position obj) { System.Windows.Application.Current.Dispatcher.Invoke(() => { if (_positiontracker.IsTracked(obj.FullSymbol)) { int pos = PositionTable.Select(row => row.Symbol).ToList().IndexOf(obj.FullSymbol); // should exist PositionTable[pos].AvgPrice = obj.AvgPrice; PositionTable[pos].Size = obj.Size; PositionTable[pos].ClosePL = obj.ClosedPL; PositionTable[pos].OpenPL = obj.OpenPL; } else { int count = PositionTable.Count; // ?? A first chance exception system notsupportedexception presentationframework dll ?? PositionTable.Add(new PositionEntry(count, obj.FullSymbol, obj.AvgPrice, obj.Size, obj.ClosedPL, obj.OpenPL)); } }); _positiontracker.Adjust(obj); } private void ClientGotOrder(Order o) { int pos = OrderTable.Select(row => row.OrderId).ToList().IndexOf(o.Id); System.Windows.Application.Current.Dispatcher.Invoke(() => { if (pos == -1) // not found { OnDebug(\"Order id \" + o.Id.ToString() + \" is not found in order table; possibly new order.\"); // it must be previous open order, or placed by tws // add to _ordertracker _ordertracker.GotOrder(o); // update status OrderTable.Add(new OrderEntry(o.Id, o.Account, o.FullSymbol, o.OrderType, o.Price, o.OrderSize, o.OrderTime, EnumDescConverter.GetEnumDescription(o.OrderStatus))); } else { OrderTable[pos].Status = EnumDescConverter.GetEnumDescription(o.OrderStatus); } }); } private void ClientGotOrderCancelConfirmation(long oid) { int pos = OrderTable.Select(row => row.OrderId).ToList().IndexOf(oid); System.Windows.Application.Current.Dispatcher.Invoke(() => { if (pos == -1) { OnDebug(\"Order id \" + oid.ToString() + \" is not found in order table; possibly new order.\"); } else { // order table _ordertracker.GotCancel(oid); OrderStatus status = OrderStatus.Canceled; OrderTable[pos].Status = EnumDescConverter.GetEnumDescription(status); } }); } private void ClientGotOrderFilled(Trade k) { _tradelist.Add(k); System.Windows.Application.Current.Dispatcher.Invoke(() => { // order table int pos = OrderTable.Select(row => row.OrderId).ToList().IndexOf(k.Id); if (pos == -1) { OnDebug(\"Order id \" + k.Id.ToString() + \" is not found in order table; possibly new order.\"); } else { _ordertracker.GotFill(k); if (_ordertracker[k.Id] == 0) { OrderStatus status = OrderStatus.Filled; OrderTable[pos].Status = EnumDescConverter.GetEnumDescription(status); } else { OrderStatus status = OrderStatus.PartiallyFilled; _ordertable[pos].Status = EnumDescConverter.GetEnumDescription(status); } } // position table only handles one account // but it is guarantteed by order id _positiontracker.Adjust(k); pos = PositionTable.Select(row => row.Symbol).ToList().IndexOf(k.FullSymbol); if (pos == -1) { // add new position int count = PositionTable.Count; PositionTable.Add(new PositionEntry(count, k.FullSymbol, _positiontracker[k.FullSymbol].AvgPrice, _positiontracker[k.FullSymbol].Size, _positiontracker[k.FullSymbol].ClosedPL, _positiontracker[k.FullSymbol].OpenPL)); } else { // adjust position PositionTable[pos].AvgPrice = _positiontracker[k.FullSymbol].AvgPrice; PositionTable[pos].Size = _positiontracker[k.FullSymbol].Size; PositionTable[pos].ClosePL = _positiontracker[k.FullSymbol].ClosedPL; PositionTable[pos].OpenPL = _positiontracker[k.FullSymbol].OpenPL; } FillTable.Add(new FillEntry(k.Id, k.TradeTime, k.FullSymbol, k.TradeSize, k.TradePrice)); }); } private void GeneratePerformanceReport(int time) { _performevaluator = new PerformanceEvaluator(); //_performevaluator.InitializePositions(); _performevaluator.GenerateReports(_tradelist); System.Windows.Application.Current.Dispatcher.Invoke(() => { _performevaluator.FillGrid(_resultstable); TabControlSelectedIndex = 3; }); } int _selectedOrderIndex = -1; public int SelectedOrderIndex { get { return _selectedOrderIndex; } set { if (value == _selectedOrderIndex) return; // index changed _selectedOrderIndex = value; _eventaggregator.GetEvent<OrderGridSelectionChangedEvent>().Publish(_ordertable[_selectedOrderIndex].OrderId); } } int _tabcontrolselectedindex = 0; public int TabControlSelectedIndex { get { return _tabcontrolselectedindex; } set { SetProperty(ref _tabcontrolselectedindex, value); } } private void OnDebug(string msg) { _logger.Log(msg, Category.Info, Priority.None); } public OrderTable OrderTable { get { return this._ordertable; } set { SetProperty(ref this._ordertable, value); } } public FillTable FillTable { get { return this._filltable; } set { SetProperty(ref this._filltable, value); } } public PositionTable PositionTable { get { return this._positiontable; } set { SetProperty(ref this._positiontable, value); } } public System.Data.DataTable ResultTable { get { return _resultstable; } } }", "label": "FeatureEnvy"}
{"text": "internal class PdfPrintDocument : PrintDocument { private readonly IPdfDocument _document; private readonly PdfPrintSettings _settings; private int _currentPage; public event QueryPageSettingsEventHandler BeforeQueryPageSettings; protected virtual void OnBeforeQueryPageSettings(QueryPageSettingsEventArgs e) { var ev = BeforeQueryPageSettings; if (ev != null) ev(this, e); } public event PrintPageEventHandler BeforePrintPage; protected virtual void OnBeforePrintPage(PrintPageEventArgs e) { var ev = BeforePrintPage; if (ev != null) ev(this, e); } public PdfPrintDocument(IPdfDocument document, PdfPrintSettings settings) { if (document == null) throw new ArgumentNullException(\"document\"); _document = document; _settings = settings; } protected override void OnBeginPrint(PrintEventArgs e) { _currentPage = PrinterSettings.FromPage == 0 ? 0 : PrinterSettings.FromPage - 1; base.OnBeginPrint(e); } protected override void OnQueryPageSettings(QueryPageSettingsEventArgs e) { OnBeforeQueryPageSettings(e); // Some printers misreport landscape. The below check verifies // whether the page rotation matches the landscape setting. bool inverseLandscape = e.PageSettings.Bounds.Width > e.PageSettings.Bounds.Height != e.PageSettings.Landscape; if (_settings.MultiplePages == null && _currentPage < _document.PageCount) { bool landscape = GetOrientation(_document.PageSizes[_currentPage]) == Orientation.Landscape; if (inverseLandscape) landscape = !landscape; e.PageSettings.Landscape = landscape; } base.OnQueryPageSettings(e); } protected override void OnPrintPage(PrintPageEventArgs e) { OnBeforePrintPage(e); if (_settings.MultiplePages != null) PrintMultiplePages(e); else PrintSinglePage(e); base.OnPrintPage(e); } private void PrintMultiplePages(PrintPageEventArgs e) { var settings = _settings.MultiplePages; int pagesPerPage = settings.Horizontal * settings.Vertical; int pageCount = (_document.PageCount - 1) / pagesPerPage + 1; if (_currentPage < pageCount) { double width = e.PageBounds.Width - e.PageSettings.HardMarginX * 2; double height = e.PageBounds.Height - e.PageSettings.HardMarginY * 2; double widthPerPage = (width - (settings.Horizontal - 1) * settings.Margin) / settings.Horizontal; double heightPerPage = (height - (settings.Vertical - 1) * settings.Margin) / settings.Vertical; for (int horizontal = 0; horizontal < settings.Horizontal; horizontal++) { for (int vertical = 0; vertical < settings.Vertical; vertical++) { int page = _currentPage * pagesPerPage; if (settings.Orientation == System.Windows.Forms.Orientation.Horizontal) page += vertical * settings.Vertical + horizontal; else page += horizontal * settings.Horizontal + vertical; if (page >= _document.PageCount) continue; double pageLeft = (widthPerPage + settings.Margin) * horizontal; double pageTop = (heightPerPage + settings.Margin) * vertical; RenderPage(e, page, pageLeft, pageTop, widthPerPage, heightPerPage); } } _currentPage++; } if (PrinterSettings.ToPage > 0) pageCount = Math.Min(PrinterSettings.ToPage, pageCount); e.HasMorePages = _currentPage < pageCount; } private void PrintSinglePage(PrintPageEventArgs e) { if (_currentPage < _document.PageCount) { var pageOrientation = GetOrientation(_document.PageSizes[_currentPage]); var printOrientation = GetOrientation(e.PageBounds.Size); e.PageSettings.Landscape = pageOrientation == Orientation.Landscape; double left; double top; double width; double height; if (_settings.Mode == PdfPrintMode.ShrinkToMargin) { left = 0; top = 0; width = e.PageBounds.Width - e.PageSettings.HardMarginX * 2; height = e.PageBounds.Height - e.PageSettings.HardMarginY * 2; } else { left = -e.PageSettings.HardMarginX; top = -e.PageSettings.HardMarginY; width = e.PageBounds.Width; height = e.PageBounds.Height; } if (pageOrientation != printOrientation) { Swap(ref height, ref width); Swap(ref left, ref top); } RenderPage(e, _currentPage, left, top, width, height); _currentPage++; } int pageCount = PrinterSettings.ToPage == 0 ? _document.PageCount : Math.Min(PrinterSettings.ToPage, _document.PageCount); e.HasMorePages = _currentPage < pageCount; } private void RenderPage(PrintPageEventArgs e, int page, double left, double top, double width, double height) { var size = _document.PageSizes[page]; double pageScale = size.Height / size.Width; double printScale = height / width; double scaledWidth = width; double scaledHeight = height; if (pageScale > printScale) scaledWidth = width * (printScale / pageScale); else scaledHeight = height * (pageScale / printScale); left += (width - scaledWidth) / 2; top += (height - scaledHeight) / 2; _document.Render( page, e.Graphics, e.Graphics.DpiX, e.Graphics.DpiY, new Rectangle( AdjustDpi(e.Graphics.DpiX, left), AdjustDpi(e.Graphics.DpiY, top), AdjustDpi(e.Graphics.DpiX, scaledWidth), AdjustDpi(e.Graphics.DpiY, scaledHeight) ), PdfRenderFlags.ForPrinting | PdfRenderFlags.Annotations ); } private static void Swap(ref double a, ref double b) { var tmp = a; a = b; b = tmp; } private static int AdjustDpi(double value, double dpi) { return (int)((value / 100.0) * dpi); } private Orientation GetOrientation(SizeF pageSize) { if (pageSize.Height > pageSize.Width) return Orientation.Portrait; return Orientation.Landscape; } private enum Orientation { Portrait, Landscape } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Implementation of the default tool resolution strategy. /// </summary> public sealed class ToolResolutionStrategy : IToolResolutionStrategy { private readonly IFileSystem _fileSystem; private readonly ICakeEnvironment _environment; private readonly IGlobber _globber; private readonly ICakeConfiguration _configuration; private readonly object _lock; private List<DirectoryPath> _path; /// <summary> /// Initializes a new instance of the <see cref=\"ToolResolutionStrategy\"/> class. /// </summary> /// <param name=\"fileSystem\">The file system.</param> /// <param name=\"environment\">The environment.</param> /// <param name=\"globber\">The globber.</param> /// <param name=\"configuration\">The configuration.</param> public ToolResolutionStrategy( IFileSystem fileSystem, ICakeEnvironment environment, IGlobber globber, ICakeConfiguration configuration) { if (fileSystem == null) { throw new ArgumentNullException(nameof(fileSystem)); } if (environment == null) { throw new ArgumentNullException(nameof(environment)); } if (globber == null) { throw new ArgumentNullException(nameof(globber)); } _fileSystem = fileSystem; _environment = environment; _globber = globber; _configuration = configuration; _lock = new object(); } /// <summary> /// Resolves the specified tool using the specified tool repository. /// </summary> /// <param name=\"repository\">The tool repository.</param> /// <param name=\"tool\">The tool.</param> /// <returns> /// The path to the tool; otherwise <c>null</c>. /// </returns> public FilePath Resolve(IToolRepository repository, string tool) { if (repository == null) { throw new ArgumentNullException(nameof(repository)); } if (tool == null) { throw new ArgumentNullException(nameof(tool)); } if (string.IsNullOrWhiteSpace(tool)) { throw new ArgumentException(\"Tool name cannot be empty.\", nameof(tool)); } // Does this file already have registrations? var resolve = LookInRegistrations(repository, tool); if (resolve == null) { // Look in ./tools/ resolve = LookInToolsDirectory(tool); if (resolve == null) { // Look in the path environment variable. resolve = LookInPath(tool); } } return resolve; } private static FilePath LookInRegistrations(IToolRepository repository, string tool) { return repository.Resolve(tool).LastOrDefault(); } private FilePath LookInToolsDirectory(string tool) { var pattern = string.Concat(GetToolsDirectory().FullPath, \"/**/\", tool); var toolPath = _globber.GetFiles(pattern).FirstOrDefault(); return toolPath?.MakeAbsolute(_environment); } private FilePath LookInPath(string tool) { lock (_lock) { if (_path == null) { _path = GetPathDirectories(); } foreach (var pathDir in _path) { var file = pathDir.CombineWithFilePath(tool); try { if (_fileSystem.Exist(file)) { return file.MakeAbsolute(_environment); } } catch { } } return null; } } private DirectoryPath GetToolsDirectory() { var toolPath = _configuration.GetValue(Constants.Paths.Tools); if (!string.IsNullOrWhiteSpace(toolPath)) { return new DirectoryPath(toolPath); } return new DirectoryPath(\"./tools\"); } private List<DirectoryPath> GetPathDirectories() { var result = new List<DirectoryPath>(); var path = _environment.GetEnvironmentVariable(\"PATH\"); if (!string.IsNullOrEmpty(path)) { var separator = new[] { _environment.Platform.IsUnix() ? ':' : ';' }; var paths = path.Split(separator, StringSplitOptions.RemoveEmptyEntries); foreach (var p in paths) { try { result.Add(new DirectoryPath(p.Trim(' ', '\"', '\\''))); } catch { } } } return result; } }", "label": "FeatureEnvy"}
{"text": "public class MeleeAttackBehavior : BehaviorBase { private static readonly ILog Log = LogManager.GetLogger(typeof(MeleeAttackBehavior)); protected readonly Mob _entity; private double _speedMultiplier; private readonly double _followRange; private int _attackCooldown; private int _delay; private Path _currentPath; private Vector3 _lastPlayerPos; public MeleeAttackBehavior(Mob entity, double speedMultiplier, double followRange) { _entity = entity; _speedMultiplier = speedMultiplier; _followRange = followRange; } public override bool ShouldStart() { var target = _entity.Target; if (target == null) return false; var pathfinder = new Pathfinder(); _currentPath = pathfinder.FindPath(_entity, target, _followRange); if (!_currentPath.HavePath()) return false; _lastPlayerPos = target.KnownPosition; return true; } public override void OnStart() { _delay = 0; } public override bool CanContinue() { return _entity.Target != null; } public override void OnTick(Entity[] entities) { Entity target = _entity.Target; if (target == null) return; double distanceToPlayer = _entity.DistanceTo(target); --_delay; float deltaDistance = Vector3.Distance(_lastPlayerPos, target.KnownPosition); bool canSee = _entity.CanSee(target); if (canSee || _delay <= 0 || deltaDistance > 1 || _entity.Level.Random.NextDouble() < 0.05) { var pathfinder = new Pathfinder(); Stopwatch sw = Stopwatch.StartNew(); _currentPath = pathfinder.FindPath(_entity, target, _followRange); if (Log.IsDebugEnabled) { sw.Stop(); if (sw.ElapsedMilliseconds > 5) Log.Warn($\"A* search for {_entity.GetType()} on a distance of {_followRange}. Spent {sw.ElapsedMilliseconds}ms and lenght of path is {_currentPath.Current.Count}\"); // DEBUG //_currentPath.PrintPath(_entity.Level); } _lastPlayerPos = target.KnownPosition; _delay = 4 + _entity.Level.Random.Next(7); if (distanceToPlayer > 32) { _delay += 10; } else if (distanceToPlayer > 16) { _delay += 5; } if (_currentPath.NoPath()) { _delay += 15; } } // Movement if (_currentPath.HavePath()) { if (_currentPath.GetNextTile(_entity, out Tile next /*, true*/)) { _entity.Controller.RotateTowards(new Vector3(next.X + 0.5f, _entity.KnownPosition.Y, next.Y + 0.5f)); _entity.Controller.MoveForward(_speedMultiplier, entities); } // else something is really wrong } else { _entity.Velocity = Vector3.Zero; } _entity.Controller.LookAt(target); _attackCooldown = Math.Max(_attackCooldown - 1, 0); if (_attackCooldown <= 0 && distanceToPlayer < GetAttackReach()) { var damage = _entity.AttackDamage; target.HealthManager.TakeHit(_entity, damage, DamageCause.EntityAttack); _attackCooldown = 20; } } private double GetAttackReach() { return _entity.Width * 2.0F + _entity.Target.Width; } public override void OnEnd() { _entity.Velocity = Vector3.Zero; _entity.KnownPosition.Pitch = 0; _attackCooldown = 0; _delay = 0; _currentPath = null; } }", "label": "FeatureEnvy"}
{"text": "/// <remarks>A PGP signature object.</remarks> public class PgpSignature { public const int BinaryDocument = 0x00; public const int CanonicalTextDocument = 0x01; public const int StandAlone = 0x02; public const int DefaultCertification = 0x10; public const int NoCertification = 0x11; public const int CasualCertification = 0x12; public const int PositiveCertification = 0x13; public const int SubkeyBinding = 0x18; public const int PrimaryKeyBinding = 0x19; public const int DirectKey = 0x1f; public const int KeyRevocation = 0x20; public const int SubkeyRevocation = 0x28; public const int CertificationRevocation = 0x30; public const int Timestamp = 0x40; private readonly SignaturePacket sigPck; private readonly int signatureType; private readonly TrustPacket trustPck; private ISigner sig; private byte lastb; // Initial value anything but '\\r' internal PgpSignature( BcpgInputStream bcpgInput) : this((SignaturePacket)bcpgInput.ReadPacket()) { } internal PgpSignature( SignaturePacket sigPacket) : this(sigPacket, null) { } internal PgpSignature( SignaturePacket sigPacket, TrustPacket trustPacket) { if (sigPacket == null) throw new ArgumentNullException(\"sigPacket\"); this.sigPck = sigPacket; this.signatureType = sigPck.SignatureType; this.trustPck = trustPacket; } private void GetSig() { this.sig = SignerUtilities.GetSigner( PgpUtilities.GetSignatureName(sigPck.KeyAlgorithm, sigPck.HashAlgorithm)); } /// <summary>The OpenPGP version number for this signature.</summary> public int Version { get { return sigPck.Version; } } /// <summary>The key algorithm associated with this signature.</summary> public PublicKeyAlgorithmTag KeyAlgorithm { get { return sigPck.KeyAlgorithm; } } /// <summary>The hash algorithm associated with this signature.</summary> public HashAlgorithmTag HashAlgorithm { get { return sigPck.HashAlgorithm; } } /// <summary>Return true if this signature represents a certification.</summary> public bool IsCertification() { return IsCertification(SignatureType); } public void InitVerify( PgpPublicKey pubKey) { lastb = 0; if (sig == null) { GetSig(); } try { sig.Init(false, pubKey.GetKey()); } catch (InvalidKeyException e) { throw new PgpException(\"invalid key.\", e); } } public void Update( byte b) { if (signatureType == CanonicalTextDocument) { doCanonicalUpdateByte(b); } else { sig.Update(b); } } private void doCanonicalUpdateByte( byte b) { if (b == '\\r') { doUpdateCRLF(); } else if (b == '\\n') { if (lastb != '\\r') { doUpdateCRLF(); } } else { sig.Update(b); } lastb = b; } private void doUpdateCRLF() { sig.Update((byte)'\\r'); sig.Update((byte)'\\n'); } public void Update( params byte[] bytes) { Update(bytes, 0, bytes.Length); } public void Update( byte[] bytes, int off, int length) { if (signatureType == CanonicalTextDocument) { int finish = off + length; for (int i = off; i != finish; i++) { doCanonicalUpdateByte(bytes[i]); } } else { sig.BlockUpdate(bytes, off, length); } } public bool Verify() { byte[] trailer = GetSignatureTrailer(); sig.BlockUpdate(trailer, 0, trailer.Length); return sig.VerifySignature(GetSignature()); } private void UpdateWithIdData( int header, byte[] idBytes) { this.Update( (byte) header, (byte)(idBytes.Length >> 24), (byte)(idBytes.Length >> 16), (byte)(idBytes.Length >> 8), (byte)(idBytes.Length)); this.Update(idBytes); } private void UpdateWithPublicKey( PgpPublicKey key) { byte[] keyBytes = GetEncodedPublicKey(key); this.Update( (byte) 0x99, (byte)(keyBytes.Length >> 8), (byte)(keyBytes.Length)); this.Update(keyBytes); } /// <summary> /// Verify the signature as certifying the passed in public key as associated /// with the passed in user attributes. /// </summary> /// <param name=\"userAttributes\">User attributes the key was stored under.</param> /// <param name=\"key\">The key to be verified.</param> /// <returns>True, if the signature matches, false otherwise.</returns> public bool VerifyCertification( PgpUserAttributeSubpacketVector userAttributes, PgpPublicKey key) { UpdateWithPublicKey(key); // // hash in the userAttributes // try { MemoryStream bOut = new MemoryStream(); foreach (UserAttributeSubpacket packet in userAttributes.ToSubpacketArray()) { packet.Encode(bOut); } UpdateWithIdData(0xd1, bOut.ToArray()); } catch (IOException e) { throw new PgpException(\"cannot encode subpacket array\", e); } this.Update(sigPck.GetSignatureTrailer()); return sig.VerifySignature(this.GetSignature()); } /// <summary> /// Verify the signature as certifying the passed in public key as associated /// with the passed in ID. /// </summary> /// <param name=\"id\">ID the key was stored under.</param> /// <param name=\"key\">The key to be verified.</param> /// <returns>True, if the signature matches, false otherwise.</returns> public bool VerifyCertification( string id, PgpPublicKey key) { UpdateWithPublicKey(key); // // hash in the id // UpdateWithIdData(0xb4, Strings.ToUtf8ByteArray(id)); Update(sigPck.GetSignatureTrailer()); return sig.VerifySignature(GetSignature()); } /// <summary>Verify a certification for the passed in key against the passed in master key.</summary> /// <param name=\"masterKey\">The key we are verifying against.</param> /// <param name=\"pubKey\">The key we are verifying.</param> /// <returns>True, if the certification is valid, false otherwise.</returns> public bool VerifyCertification( PgpPublicKey masterKey, PgpPublicKey pubKey) { UpdateWithPublicKey(masterKey); UpdateWithPublicKey(pubKey); Update(sigPck.GetSignatureTrailer()); return sig.VerifySignature(GetSignature()); } /// <summary>Verify a key certification, such as revocation, for the passed in key.</summary> /// <param name=\"pubKey\">The key we are checking.</param> /// <returns>True, if the certification is valid, false otherwise.</returns> public bool VerifyCertification( PgpPublicKey pubKey) { if (SignatureType != KeyRevocation && SignatureType != SubkeyRevocation) { throw new InvalidOperationException(\"signature is not a key signature\"); } UpdateWithPublicKey(pubKey); Update(sigPck.GetSignatureTrailer()); return sig.VerifySignature(GetSignature()); } public int SignatureType { get { return sigPck.SignatureType; } } /// <summary>The ID of the key that created the signature.</summary> public long KeyId { get { return sigPck.KeyId; } } [Obsolete(\"Use 'CreationTime' property instead\")] public DateTime GetCreationTime() { return CreationTime; } /// <summary>The creation time of this signature.</summary> public DateTime CreationTime { get { return DateTimeUtilities.UnixMsToDateTime(sigPck.CreationTime); } } public byte[] GetSignatureTrailer() { return sigPck.GetSignatureTrailer(); } /// <summary> /// Return true if the signature has either hashed or unhashed subpackets. /// </summary> public bool HasSubpackets { get { return sigPck.GetHashedSubPackets() != null || sigPck.GetUnhashedSubPackets() != null; } } public PgpSignatureSubpacketVector GetHashedSubPackets() { return createSubpacketVector(sigPck.GetHashedSubPackets()); } public PgpSignatureSubpacketVector GetUnhashedSubPackets() { return createSubpacketVector(sigPck.GetUnhashedSubPackets()); } private PgpSignatureSubpacketVector createSubpacketVector(SignatureSubpacket[] pcks) { return pcks == null ? null : new PgpSignatureSubpacketVector(pcks); } public byte[] GetSignature() { MPInteger[] sigValues = sigPck.GetSignature(); byte[] signature; if (sigValues != null) { if (sigValues.Length == 1) // an RSA signature { signature = sigValues[0].Value.ToByteArrayUnsigned(); } else { try { signature = new DerSequence( new DerInteger(sigValues[0].Value), new DerInteger(sigValues[1].Value)).GetEncoded(); } catch (IOException e) { throw new PgpException(\"exception encoding DSA sig.\", e); } } } else { signature = sigPck.GetSignatureBytes(); } return signature; } // TODO Handle the encoding stuff by subclassing BcpgObject? public byte[] GetEncoded() { MemoryStream bOut = new MemoryStream(); Encode(bOut); return bOut.ToArray(); } public void Encode( Stream outStream) { BcpgOutputStream bcpgOut = BcpgOutputStream.Wrap(outStream); bcpgOut.WritePacket(sigPck); if (trustPck != null) { bcpgOut.WritePacket(trustPck); } } private byte[] GetEncodedPublicKey( PgpPublicKey pubKey) { try { return pubKey.publicPk.GetEncodedContents(); } catch (IOException e) { throw new PgpException(\"exception preparing key.\", e); } } /// <summary> /// Return true if the passed in signature type represents a certification, false if the signature type is not. /// </summary> /// <param name=\"signatureType\"></param> /// <returns>true if signatureType is a certification, false otherwise.</returns> public static bool IsCertification(int signatureType) { switch (signatureType) { case DefaultCertification: case NoCertification: case CasualCertification: case PositiveCertification: return true; default: return false; } } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Interaction logic for MultipleCameraWnd.xaml /// </summary> public partial class MultipleCameraWnd : IWindow { public bool DisbleAutofocus { get; set; } public int DelaySec { get; set; } public int WaitSec { get; set; } public int NumOfPhotos { get; set; } ProgressWindow dlg = new ProgressWindow(); private System.Timers.Timer _timer = new System.Timers.Timer(1000); private int _secounter = 0; private int _photocounter = 0; public bool UseExternal { get; set; } public CustomConfig SelectedConfig { get; set; } public MultipleCameraWnd() { NumOfPhotos = 1; InitializeComponent(); _timer.Elapsed += new ElapsedEventHandler(_timer_Elapsed); } private void _timer_Elapsed(object sender, ElapsedEventArgs e) { _secounter++; if (_secounter > WaitSec) { _secounter = 0; _timer.Stop(); CapturePhotos(); } else { StaticHelper.Instance.SystemMessage = string.Format(\"Waiting {0})\", _secounter); } } #region Implementation of IWindow public void ExecuteCommand(string cmd, object param) { switch (cmd) { case WindowsCmdConsts.MultipleCamera_Start: Dispatcher.Invoke(() => btn_shot_Click(null, null)); break; case WindowsCmdConsts.MultipleCamera_Stop: Dispatcher.Invoke(() => btn_stop_Click(null, null)); break; case WindowsCmdConsts.MultipleCamera_Reset: Dispatcher.Invoke(() => btn_resetCounters_Click(null, null)); break; case WindowsCmdConsts.MultipleCameraWnd_Show: Dispatcher.Invoke(new Action(delegate { Owner = ServiceProvider.PluginManager.SelectedWindow as Window; Show(); Activate(); Focus(); })); break; case WindowsCmdConsts.MultipleCameraWnd_Hide: Hide(); break; case CmdConsts.All_Close: Dispatcher.Invoke(new Action(delegate { Hide(); Close(); })); break; } } #endregion private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e) { if (IsVisible) { e.Cancel = true; ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.MultipleCameraWnd_Hide); } } private void btn_shot_Click(object sender, RoutedEventArgs e) { if (UseExternal) { try { if (SelectedConfig != null) ServiceProvider.ExternalDeviceManager.AssertFocus(SelectedConfig); } catch (Exception exception) { Log.Error(\"Error set focus\", exception); StaticHelper.Instance.SystemMessage = \"Error set focus\" + exception.Message; } } _secounter = 0; _photocounter = 0; _timer.Start(); } private void CapturePhotos() { _photocounter++; StaticHelper.Instance.SystemMessage = string.Format(\"Capture started multiple cameras {0}\", _photocounter); Thread thread = new Thread(new ThreadStart(delegate { while (CamerasAreBusy()) { } try { if (UseExternal) { if (SelectedConfig != null) { ServiceProvider.ExternalDeviceManager. OpenShutter(SelectedConfig); Thread.Sleep(300); ServiceProvider.ExternalDeviceManager. CloseShutter(SelectedConfig); } } else { CameraHelper.CaptureAll(DelaySec); } } catch (Exception exception) { Log.Error(exception); } Thread.Sleep(DelaySec); if (_photocounter < NumOfPhotos) _timer.Start(); else { StopCapture(); } })); thread.Start(); } private bool CamerasAreBusy() { return ServiceProvider.DeviceManager.ConnectedDevices.Aggregate(false, (current, connectedDevice) => connectedDevice.IsBusy || current); } private void btn_stop_Click(object sender, RoutedEventArgs e) { _timer.Stop(); _photocounter = NumOfPhotos; StopCapture(); } private void StopCapture() { if (UseExternal && SelectedConfig != null) { ServiceProvider.ExternalDeviceManager.CloseShutter(SelectedConfig); ServiceProvider.ExternalDeviceManager.DeassertFocus(SelectedConfig); } StaticHelper.Instance.SystemMessage = \"All captures done !\"; } private void MenuItem_Click(object sender, RoutedEventArgs e) { //if (listBox1.SelectedItem != null) // ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.CameraPropertyWnd_Show, // listBox1.SelectedItem); } private void MenuItem_Click_1(object sender, RoutedEventArgs e) { //if (listBox1.SelectedItem != null) //{ // CameraPreset preset = new CameraPreset(); // preset.Get((ICameraDevice) listBox1.SelectedItem); // foreach (ICameraDevice connectedDevice in ServiceProvider.DeviceManager.ConnectedDevices) // { // if (connectedDevice.IsConnected && connectedDevice.IsChecked) // preset.Set(connectedDevice); // } //} } private void btn_help_Click(object sender, RoutedEventArgs e) { HelpProvider.Run(HelpSections.MultipleCamera); } private void btn_resetCounters_Click(object sender, RoutedEventArgs e) { foreach (ICameraDevice connectedDevice in ServiceProvider.DeviceManager.ConnectedDevices) { CameraProperty property = ServiceProvider.Settings.CameraProperties.Get(connectedDevice); property.Counter = 0; } } private void btn_set_counter_Click(object sender, RoutedEventArgs e) { int counter = 0; if (int.TryParse(txt_counter.Text, out counter)) { foreach (ICameraDevice connectedDevice in ServiceProvider.DeviceManager.ConnectedDevices) { CameraProperty property = ServiceProvider.Settings.CameraProperties.Get(connectedDevice); property.Counter = counter; } } } private void btn_focus_Click(object sender, RoutedEventArgs e) { if (SelectedConfig != null) ServiceProvider.ExternalDeviceManager.Focus(SelectedConfig); } private void btn_capture_Click(object sender, RoutedEventArgs e) { if (SelectedConfig != null) ServiceProvider.ExternalDeviceManager.Capture(SelectedConfig); } private void btn_liveview_Click(object sender, RoutedEventArgs e) { ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.MultipleLiveViewWnd_Show); ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.MultipleLiveViewWnd_Maximize); } private void chk_noautofocus_Checked(object sender, RoutedEventArgs e) { this.ShowMessageAsync(\"Warning\", \"This feature not working reliable \"); } private void btn_saveOrder_Click(object sender, RoutedEventArgs e) { for (int i = 0; i < ServiceProvider.DeviceManager.ConnectedDevices.Count; i++) { ServiceProvider.DeviceManager.ConnectedDevices[i].LoadProperties().SortOrder = i; } ServiceProvider.Settings.Save(); } private void btn_format_Click(object sender, RoutedEventArgs e) { if (MessageBox.Show(TranslationStrings.LabelAskForDelete, \"\", MessageBoxButtons.YesNo) != System.Windows.Forms.DialogResult.Yes) return; dlg.Show(); Thread thread = new Thread(Format); thread.Start(); Log.Debug(\"Start format multiple cameras\"); //thread.Join(); } private void Format() { //Dispatcher.Invoke(new Action(dlg.Show)); for (int i = 0; i < ServiceProvider.DeviceManager.ConnectedDevices.Count; i++) { ICameraDevice device = ServiceProvider.DeviceManager.ConnectedDevices[i]; if (!device.IsChecked) continue; dlg.Label = device.DisplayName; dlg.Progress = i; Thread thread = new Thread(() => FormatCard(device)); thread.Start(); thread.Join(5 * 1000); } Dispatcher.Invoke(new Action(dlg.Hide)); } private void FormatCard(ICameraDevice connectedDevice) { try { connectedDevice.IsBusy = true; Log.Debug(\"Start format\"); Log.Debug(connectedDevice.PortName); connectedDevice.FormatStorage(null); Thread.Sleep(200); Log.Debug(\"Format done\"); connectedDevice.IsBusy = false; } catch (Exception exception) { Log.Error(\"Unable to format device \", exception); } } private void MetroWindow_PreviewKeyDown(object sender, System.Windows.Input.KeyEventArgs e) { TriggerClass.KeyDown(e); } }", "label": "FeatureEnvy"}
{"text": "internal static class WriteDictionary<TSerializer> where TSerializer : ITypeSerializer { private static readonly ITypeSerializer Serializer = JsWriter.GetTypeSerializer<TSerializer>(); internal class MapKey { internal Type KeyType; internal Type ValueType; public MapKey(Type keyType, Type valueType) { KeyType = keyType; ValueType = valueType; } public bool Equals(MapKey other) { if (ReferenceEquals(null, other)) return false; if (ReferenceEquals(this, other)) return true; return Equals(other.KeyType, KeyType) && Equals(other.ValueType, ValueType); } public override bool Equals(object obj) { if (ReferenceEquals(null, obj)) return false; if (ReferenceEquals(this, obj)) return true; if (obj.GetType() != typeof(MapKey)) return false; return Equals((MapKey)obj); } public override int GetHashCode() { unchecked { return ((KeyType != null ? KeyType.GetHashCode() : 0) * 397) ^ (ValueType != null ? ValueType.GetHashCode() : 0); } } } static Dictionary<MapKey, WriteMapDelegate> CacheFns = new Dictionary<MapKey, WriteMapDelegate>(); public static Action<TextWriter, object, WriteObjectDelegate, WriteObjectDelegate> GetWriteGenericDictionary(Type keyType, Type valueType) { WriteMapDelegate writeFn; var mapKey = new MapKey(keyType, valueType); if (CacheFns.TryGetValue(mapKey, out writeFn)) return writeFn.Invoke; var genericType = typeof(ToStringDictionaryMethods<,,>).MakeGenericType(keyType, valueType, typeof(TSerializer)); var mi = genericType.GetPublicStaticMethod(\"WriteIDictionary\"); writeFn = (WriteMapDelegate)mi.MakeDelegate(typeof(WriteMapDelegate)); Dictionary<MapKey, WriteMapDelegate> snapshot, newCache; do { snapshot = CacheFns; newCache = new Dictionary<MapKey, WriteMapDelegate>(CacheFns); newCache[mapKey] = writeFn; } while (!ReferenceEquals( Interlocked.CompareExchange(ref CacheFns, newCache, snapshot), snapshot)); return writeFn.Invoke; } public static void WriteIDictionary(TextWriter writer, object oMap) { WriteObjectDelegate writeKeyFn = null; WriteObjectDelegate writeValueFn = null; writer.Write(JsWriter.MapStartChar); var encodeMapKey = false; Type lastKeyType = null; Type lastValueType = null; var map = (IDictionary)oMap; var ranOnce = false; foreach (var key in map.Keys) { var dictionaryValue = map[key]; var isNull = (dictionaryValue == null); if (isNull && !Serializer.IncludeNullValues) continue; var keyType = key.GetType(); if (writeKeyFn == null || lastKeyType != keyType) { lastKeyType = keyType; writeKeyFn = Serializer.GetWriteFn(keyType); encodeMapKey = Serializer.GetTypeInfo(keyType).EncodeMapKey; } JsWriter.WriteItemSeperatorIfRanOnce(writer, ref ranOnce); JsState.WritingKeyCount++; JsState.IsWritingValue = false; if (encodeMapKey) { JsState.IsWritingValue = true; //prevent \"\"null\"\" writer.Write(JsWriter.QuoteChar); writeKeyFn(writer, key); writer.Write(JsWriter.QuoteChar); } else { writeKeyFn(writer, key); } JsState.WritingKeyCount--; writer.Write(JsWriter.MapKeySeperator); if (isNull) { writer.Write(JsonUtils.Null); } else { var valueType = dictionaryValue.GetType(); if (writeValueFn == null || lastValueType != valueType) { lastValueType = valueType; writeValueFn = Serializer.GetWriteFn(valueType); } JsState.IsWritingValue = true; writeValueFn(writer, dictionaryValue); JsState.IsWritingValue = false; } } writer.Write(JsWriter.MapEndChar); } }", "label": "ComplexConditional"}
{"text": "public class LogStructureWithInput { private readonly LogFlowStructure _flowStructure; internal LogStructureWithInput(LogFlowStructure flowStructure) { _flowStructure = flowStructure; } public LogStructureWithInput Then(ILogProcessor processor) { processor.SetContext(_flowStructure.Context); _flowStructure.Processors.Add(processor); return new LogStructureWithInput(_flowStructure); } [Obsolete(\"Use then method\")] public void ToOutput(ILogOutput output) { output.SetContext(_flowStructure.Context); _flowStructure.Output = output; } }", "label": "ComplexMethod"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class reportContacts_args : TBase { private long _syncOpRevision; private SyncCategory _category; private List<ContactReport> _contactReports; private SyncActionType _actionType; public long SyncOpRevision { get { return _syncOpRevision; } set { __isset.syncOpRevision = true; this._syncOpRevision = value; } } /// <summary> /// /// <seealso cref=\"SyncCategory\"/> /// </summary> public SyncCategory Category { get { return _category; } set { __isset.category = true; this._category = value; } } public List<ContactReport> ContactReports { get { return _contactReports; } set { __isset.contactReports = true; this._contactReports = value; } } /// <summary> /// /// <seealso cref=\"SyncActionType\"/> /// </summary> public SyncActionType ActionType { get { return _actionType; } set { __isset.actionType = true; this._actionType = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool syncOpRevision; public bool category; public bool contactReports; public bool actionType; } public reportContacts_args() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 2: if (field.Type == TType.I64) { SyncOpRevision = iprot.ReadI64(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 3: if (field.Type == TType.I32) { Category = (SyncCategory)iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 4: if (field.Type == TType.List) { { ContactReports = new List<ContactReport>(); TList _list360 = iprot.ReadListBegin(); for( int _i361 = 0; _i361 < _list360.Count; ++_i361) { ContactReport _elem362 = new ContactReport(); _elem362 = new ContactReport(); _elem362.Read(iprot); ContactReports.Add(_elem362); } iprot.ReadListEnd(); } } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 5: if (field.Type == TType.I32) { ActionType = (SyncActionType)iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"reportContacts_args\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (__isset.syncOpRevision) { field.Name = \"syncOpRevision\"; field.Type = TType.I64; field.ID = 2; oprot.WriteFieldBegin(field); oprot.WriteI64(SyncOpRevision); oprot.WriteFieldEnd(); } if (__isset.category) { field.Name = \"category\"; field.Type = TType.I32; field.ID = 3; oprot.WriteFieldBegin(field); oprot.WriteI32((int)Category); oprot.WriteFieldEnd(); } if (ContactReports != null && __isset.contactReports) { field.Name = \"contactReports\"; field.Type = TType.List; field.ID = 4; oprot.WriteFieldBegin(field); { oprot.WriteListBegin(new TList(TType.Struct, ContactReports.Count)); foreach (ContactReport _iter363 in ContactReports) { _iter363.Write(oprot); } oprot.WriteListEnd(); } oprot.WriteFieldEnd(); } if (__isset.actionType) { field.Name = \"actionType\"; field.Type = TType.I32; field.ID = 5; oprot.WriteFieldBegin(field); oprot.WriteI32((int)ActionType); oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"reportContacts_args(\"); sb.Append(\"SyncOpRevision: \"); sb.Append(SyncOpRevision); sb.Append(\",Category: \"); sb.Append(Category); sb.Append(\",ContactReports: \"); sb.Append(ContactReports); sb.Append(\",ActionType: \"); sb.Append(ActionType); sb.Append(\")\"); return sb.ToString(); } }", "label": "FeatureEnvy"}
{"text": "public class Sample11_Logger { // UniRx.Diagnostics.Logger // logger is threadsafe, define per class with name. static readonly UniRx.Diagnostics.Logger logger = new UniRx.Diagnostics.Logger(\"Sample11\"); // call once at applicationinit public void ApplicationInitialize() { // Log as Stream, UniRx.Diagnostics.ObservableLogger.Listener is IObservable<LogEntry> // You can subscribe and output to any place. ObservableLogger.Listener.LogToUnityDebug(); // for example, filter only Exception and upload to web. // (make custom sink(IObserver<EventEntry>) is better to use) ObservableLogger.Listener .Where(x => x.LogType == LogType.Exception) .Subscribe(x => { // ObservableWWW.Post(\"\", null).Subscribe(); }); } public void Run() { // Debug is write only DebugBuild. logger.Debug(\"Debug Message\"); // or other logging methods logger.Log(\"Message\"); logger.Exception(new Exception(\"test exception\")); } }", "label": "FeatureEnvy"}
{"text": "public class TransactionService : ITransactionService { private readonly ILocalhost localhost; private readonly ITransfer transfer; private readonly ISearchService searchService; public TransactionService(ILocalhost localhost, ITransfer transfer, ISearchService searchService) { this.localhost = localhost; this.transfer = transfer; this.searchService = searchService; } public IList<Tuple<Entry, FhirResponse>> HandleTransaction(IList<Entry> interactions, IInteractionHandler interactionHandler) { if (interactionHandler == null) { throw new InvalidOperationException(\"Unable to run transaction operation\"); } return HandleTransaction(interactions, interactionHandler, null); } public FhirResponse HandleTransaction(ResourceManipulationOperation operation, IInteractionHandler interactionHandler) { return HandleOperation(operation, interactionHandler); } public FhirResponse HandleOperation(ResourceManipulationOperation operation, IInteractionHandler interactionHandler, Mapper<string, IKey> mapper = null) { IList<Entry> interactions = operation.GetEntries().ToList(); if(mapper != null) transfer.Internalize(interactions, mapper); FhirResponse response = null; foreach (Entry interaction in interactions) { response = MergeFhirResponse(response, interactionHandler.HandleInteraction(interaction)); if (!response.IsValid) throw new Exception(); interaction.Resource = response.Resource; } transfer.Externalize(interactions); return response; } private FhirResponse MergeFhirResponse(FhirResponse previousResponse, FhirResponse response) { //CCR: How to handle responses? //Currently we assume that all FhirResponses from one ResourceManipulationOperation should be equivalent - kind of hackish if (previousResponse == null) return response; if (!response.IsValid) return response; if(response.StatusCode != previousResponse.StatusCode) throw new Exception(\"Incompatible responses\"); if (response.Key != null && previousResponse.Key != null && response.Key.Equals(previousResponse.Key) == false) throw new Exception(\"Incompatible responses\"); if((response.Key != null && previousResponse.Key== null) || (response.Key == null && previousResponse.Key != null)) throw new Exception(\"Incompatible responses\"); return response; } private void AddMappingsForOperation(Mapper<string, IKey> mapper, ResourceManipulationOperation operation, IList<Entry> interactions) { if(mapper == null) return; if (interactions.Count() == 1) { Entry entry = interactions.First(); if (!entry.Key.Equals(operation.OperationKey)) { if (localhost.GetKeyKind(operation.OperationKey) == KeyKind.Temporary) { mapper.Remap(operation.OperationKey.ResourceId, entry.Key.WithoutVersion()); } else { mapper.Remap(operation.OperationKey.ToString(), entry.Key.WithoutVersion()); } } } } public IList<Tuple<Entry, FhirResponse>> HandleTransaction(Bundle bundle, IInteractionHandler interactionHandler) { if (interactionHandler == null) { throw new InvalidOperationException(\"Unable to run transaction operation\"); } var entries = new List<Entry>(); Mapper<string, IKey> mapper = new Mapper<string, IKey>(); foreach (var operation in bundle.Entry.Select(e => ResourceManipulationOperationFactory.GetManipulationOperation(e, localhost, searchService))) { IList<Entry> atomicOperations = operation.GetEntries().ToList(); AddMappingsForOperation(mapper, operation, atomicOperations); entries.AddRange(atomicOperations); } return HandleTransaction(entries, interactionHandler, mapper); } private IList<Tuple<Entry, FhirResponse>> HandleTransaction(IList<Entry> interactions, IInteractionHandler interactionHandler, Mapper<string, IKey> mapper) { List<Tuple<Entry, FhirResponse>> responses = new List<Tuple<Entry, FhirResponse>>(); transfer.Internalize(interactions, mapper); foreach (Entry interaction in interactions) { FhirResponse response = interactionHandler.HandleInteraction(interaction); if (!response.IsValid) throw new Exception(); interaction.Resource = response.Resource; response.Resource = null; responses.Add(new Tuple<Entry, FhirResponse>(interaction, response)); //CCR: How to handle responses for transactions? //The specifications says only one response should be sent per EntryComponent, //but one EntryComponent might correpond to multiple atomic entries (Entry) //Example: conditional delete } transfer.Externalize(interactions); return responses; } }", "label": "FeatureEnvy"}
{"text": "public static class Types { private static java.util.Map jclass2type; static Types() { jclass2type = java.util.Collections.synchronizedMap(new java.util.HashMap()); } public static Type GetTypeForJavaClass(java.lang.Class jclass) { if (jclass2type.containsKey(jclass)) return (Type)jclass2type.get(jclass); Type t = new InternalTypes.InternalType(jclass); jclass2type.put(jclass, t); return t; } }", "label": "FeatureEnvy"}
{"text": "class InvalidMDPhase : ProtectionPhase { RandomGenerator random; public InvalidMDPhase(InvalidMetadataProtection parent) : base(parent) { } public override ProtectionTargets Targets { get { return ProtectionTargets.Modules; } } public override string Name { get { return \"Invalid metadata addition\"; } } protected override void Execute(ConfuserContext context, ProtectionParameters parameters) { if (parameters.Targets.Contains(context.CurrentModule)) { random = context.Registry.GetService<IRandomService>().GetRandomGenerator(_FullId); context.CurrentModuleWriterListener.OnWriterEvent += OnWriterEvent; } } void Randomize<T>(MDTable<T> table) where T : IRawRow { List<T> rows = table.ToList(); random.Shuffle(rows); table.Reset(); foreach (T row in rows) table.Add(row); } void OnWriterEvent(object sender, ModuleWriterListenerEventArgs e) { var writer = (ModuleWriterBase)sender; if (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) { // These hurts reflection /* uint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1; uint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1; var root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow( 0, 0x7fff7fff, 0, 0x3FFFD, fieldLen, methodLen)); writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, root)); var namespaces = writer.MetaData.TablesHeap.TypeDefTable .Select(row => row.Namespace) .Distinct() .ToList(); foreach (var ns in namespaces) { if (ns == 0) continue; var type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow( 0, 0, ns, 0x3FFFD, fieldLen, methodLen)); writer.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, type)); } foreach (var row in writer.MetaData.TablesHeap.ParamTable) row.Name = 0x7fff7fff; */ writer.MetaData.TablesHeap.ModuleTable.Add(new RawModuleRow(0, 0x7fff7fff, 0, 0, 0)); writer.MetaData.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0, 0, 0, 0, 0, 0, 0, 0x7fff7fff, 0)); int r = random.NextInt32(8, 16); for (int i = 0; i < r; i++) writer.MetaData.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32(), random.NextUInt32())); r = random.NextInt32(8, 16); for (int i = 0; i < r; i++) writer.MetaData.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32())); //Randomize(writer.MetaData.TablesHeap.NestedClassTable); Randomize(writer.MetaData.TablesHeap.ManifestResourceTable); //Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable); writer.TheOptions.MetaDataOptions.TablesHeapOptions.ExtraData = random.NextUInt32(); writer.TheOptions.MetaDataOptions.TablesHeapOptions.UseENC = false; writer.TheOptions.MetaDataOptions.MetaDataHeaderOptions.VersionString += \"\\0\\0\\0\\0\"; /* We are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work. <sarcasm>UnConfuserEX is so well coded, it relies on static cmp between values</sarcasm> If you deobfuscate this tool, you can see that it check for #GUID size and compare it to '16', so we have to create a new array of byte wich size is exactly 16 and put it into our brand new Heap */ // writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#GUID\", Guid.NewGuid().ToByteArray())); // writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#Strings\", new byte[1])); writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#Blob\", new byte[1])); writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#Schema\", new byte[1])); } else if (e.WriterEvent == ModuleWriterEvent.MDOnAllTablesSorted) { writer.MetaData.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow( unchecked(0x7fff), 0xffff7fff, 0xffff7fff)); /* writer.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow( 0x7fff7fff, (uint)ManifestResourceAttributes.Private, 0x7fff7fff, 2)); */ } } }", "label": "FeatureEnvy"}
{"text": "public class LuaSvr { static public MainState mainState; public class MainState : LuaState { int errorReported = 0; protected override void tick() { base.tick (); #if !SLUA_STANDALONE LuaTimer.tick(Time.deltaTime); #endif checkTop (); } internal void checkTop() { if (LuaDLL.lua_gettop(L) != errorReported) { errorReported = LuaDLL.lua_gettop(L); Logger.LogError(string.Format(\"Some function not remove temp value({0}) from lua stack. You should fix it.\",LuaDLL.luaL_typename(L,errorReported))); } } } public LuaSvr() { mainState = new MainState(); mainState.Name = \"main\"; } static List<Action<IntPtr>> collectBindInfo() { List<Action<IntPtr>> list = new List<Action<IntPtr>>(); #if !SLUA_STANDALONE #if !USE_STATIC_BINDER Assembly[] ams = AppDomain.CurrentDomain.GetAssemblies(); List<Type> bindlist = new List<Type>(); for (int n = 0; n < ams.Length;n++ ) { Assembly a = ams[n]; Type[] ts = null; try { ts = a.GetExportedTypes(); } catch { continue; } for (int k = 0; k < ts.Length; k++) { Type t = ts[k]; if (t.IsDefined(typeof(LuaBinderAttribute), false)) { bindlist.Add(t); } } } bindlist.Sort(new System.Comparison<Type>((Type a, Type b) => { LuaBinderAttribute la = System.Attribute.GetCustomAttribute( a, typeof(LuaBinderAttribute) ) as LuaBinderAttribute; LuaBinderAttribute lb = System.Attribute.GetCustomAttribute( b, typeof(LuaBinderAttribute) ) as LuaBinderAttribute; return la.order.CompareTo(lb.order); })); for (int n = 0; n < bindlist.Count; n++) { Type t = bindlist[n]; var sublist = (Action<IntPtr>[])t.GetMethod(\"GetBindList\").Invoke(null, null); list.AddRange(sublist); } #else var assemblyName = \"Assembly-CSharp\"; Assembly assembly = Assembly.Load(assemblyName); list.AddRange(getBindList(assembly,\"SLua.BindUnity\")); list.AddRange(getBindList(assembly,\"SLua.BindUnityUI\")); list.AddRange(getBindList(assembly,\"SLua.BindDll\")); list.AddRange(getBindList(assembly,\"SLua.BindCustom\")); #endif #endif return list; } static internal void doBind(IntPtr L) { var list = collectBindInfo (); int count = list.Count; for (int n = 0; n < count; n++) { Action<IntPtr> action = list[n]; action(L); } } static internal IEnumerator doBind(IntPtr L,Action<int> _tick,Action complete) { Action<int> tick = (int p) => { if (_tick != null) _tick (p); }; tick (0); var list = collectBindInfo (); tick (2); int bindProgress = 2; int lastProgress = bindProgress; for (int n = 0; n < list.Count; n++) { Action<IntPtr> action = list[n]; action(L); bindProgress = (int)(((float)n / list.Count) * 98.0) + 2; if (_tick!=null && lastProgress != bindProgress && bindProgress % 5 == 0) { lastProgress = bindProgress; tick (bindProgress); yield return null; } } tick (100); complete (); } Action<IntPtr>[] getBindList(Assembly assembly,string ns) { Type t=assembly.GetType(ns); if(t!=null) return (Action<IntPtr>[]) t.GetMethod(\"GetBindList\").Invoke(null, null); return new Action<IntPtr>[0]; } protected void doinit(LuaState L,LuaSvrFlag flag) { L.openSluaLib (); LuaValueType.reg(L.L); if ((flag & LuaSvrFlag.LSF_EXTLIB)!=0) { L.openExtLib (); } if((flag & LuaSvrFlag.LSF_3RDDLL)!=0) Lua3rdDLL.open(L.L); } public void init(Action<int> tick,Action complete,LuaSvrFlag flag=LuaSvrFlag.LSF_BASIC|LuaSvrFlag.LSF_EXTLIB) { IntPtr L = mainState.L; LuaObject.init(L); #if SLUA_STANDALONE doBind(L); doinit(mainState, flag); complete(); mainState.checkTop(); #else #if UNITY_EDITOR if (!UnityEditor.EditorApplication.isPlaying) { doBind(L); doinit(mainState, flag); complete(); mainState.checkTop(); } else { #endif mainState.lgo.StartCoroutine(doBind(L,tick, () => { doinit(mainState, flag); complete(); mainState.checkTop(); })); #if UNITY_EDITOR } #endif #endif } public object start(string main) { if (main != null) { mainState.doFile(main); return mainState.run(\"main\"); } return null; } }", "label": "FeatureEnvy"}
{"text": "public class TrueTypeInterpreter { Typeface _currentTypeFace; SharpFontInterpreter _interpreter; public void SetTypeFace(Typeface typeface) { _currentTypeFace = typeface; Tables.MaxProfile maximumProfile = _currentTypeFace.MaxProfile; _interpreter = new SharpFontInterpreter( maximumProfile.MaxStackElements, maximumProfile.MaxStorage, maximumProfile.MaxFunctionDefs, maximumProfile.MaxInstructionDefs, maximumProfile.MaxTwilightPoints); // the fpgm table optionally contains a program to run at initialization time if (_currentTypeFace.FpgmProgramBuffer != null) { _interpreter.InitializeFunctionDefs(_currentTypeFace.FpgmProgramBuffer); } } public GlyphPointF[] HintGlyph(ushort glyphIndex, float glyphSizeInPixel) { Glyph glyph = _currentTypeFace.GetGlyphByIndex(glyphIndex); //------------------------------------------- //1. start with original points/contours from glyph int horizontalAdv = _currentTypeFace.GetHAdvanceWidthFromGlyphIndex(glyphIndex); int hFrontSideBearing = _currentTypeFace.GetHFrontSideBearingFromGlyphIndex(glyphIndex); return HintGlyph(horizontalAdv, hFrontSideBearing, glyph.MinX, glyph.MaxY, glyph.GlyphPoints, glyph.EndPoints, glyph.GlyphInstructions, glyphSizeInPixel); } public GlyphPointF[] HintGlyph( int horizontalAdv, int hFrontSideBearing, int minX, int maxY, GlyphPointF[] glyphPoints, ushort[] contourEndPoints, byte[] instructions, float glyphSizeInPixel) { //get glyph for its matrix //TODO: review here again int verticalAdv = 0; int vFrontSideBearing = 0; var pp1 = new GlyphPointF((minX - hFrontSideBearing), 0, true); var pp2 = new GlyphPointF(pp1.X + horizontalAdv, 0, true); var pp3 = new GlyphPointF(0, maxY + vFrontSideBearing, true); var pp4 = new GlyphPointF(0, pp3.Y - verticalAdv, true); //------------------------- //2. use a clone version extend org with 4 elems int orgLen = glyphPoints.Length; GlyphPointF[] newGlyphPoints = Utils.CloneArray(glyphPoints, 4); // add phantom points; these are used to define the extents of the glyph, // and can be modified by hinting instructions newGlyphPoints[orgLen] = pp1; newGlyphPoints[orgLen + 1] = pp2; newGlyphPoints[orgLen + 2] = pp3; newGlyphPoints[orgLen + 3] = pp4; //3. scale all point to target pixel size float pxScale = _currentTypeFace.CalculateScaleToPixel(glyphSizeInPixel); for (int i = orgLen + 3; i >= 0; --i) { newGlyphPoints[i].ApplyScale(pxScale); } //---------------------------------------------- //test : agg's vertical hint //apply large scale on horizontal axis only //translate and then scale back float agg_x_scale = 1000; // if (UseVerticalHinting) { ApplyScaleOnlyOnXAxis(newGlyphPoints, agg_x_scale); } //4. _interpreter.SetControlValueTable(_currentTypeFace.ControlValues, pxScale, glyphSizeInPixel, _currentTypeFace.PrepProgramBuffer); //-------------------------------------------------- //5. hint _interpreter.HintGlyph(newGlyphPoints, contourEndPoints, instructions); //6. scale back if (UseVerticalHinting) { ApplyScaleOnlyOnXAxis(newGlyphPoints, 1f / agg_x_scale); } return newGlyphPoints; } public bool UseVerticalHinting { get; set; } static void ApplyScaleOnlyOnXAxis(GlyphPointF[] glyphPoints, float xscale) { //TODO: review performance here for (int i = glyphPoints.Length - 1; i >= 0; --i) { glyphPoints[i].ApplyScaleOnlyOnXAxis(xscale); } } }", "label": "FeatureEnvy"}
{"text": "public class EDBFileWatchParser { private static readonly ILog _log = LogManager.GetLogger(typeof(EDBFileWatchParser)); private readonly EnvironmentWatchElement _environmentWatchElement; public EDBFileWatchParser(EnvironmentWatchElement environmentWatchElement) { _environmentWatchElement = environmentWatchElement; } public List<FileWatchElement> ToFileWatchCollection() { var environmentDataXml = LoadEDBXml(); var serversFiltered = environmentDataXml.Descendants(\"Servers\").Descendants(\"Server\").Where( server => { var serverName = server.Element(\"Name\").Value; var networkArea = server.Element(\"NetworkArea\").Value; return serverName.RegExMatches(_environmentWatchElement.ServerNames) && !serverName.RegExMatches(_environmentWatchElement.ServerNamesNotMatch) && networkArea.RegExMatches(_environmentWatchElement.NetworkAreas) && !networkArea.RegExMatches(_environmentWatchElement.NetworkAreasNotMatch); }).ToArray(); var watches = new List<FileWatchElement>(); foreach (var serverNode in serversFiltered) { var serverName = serverNode.Element(\"Name\").Value; var serverNetworkArea = serverNode.Element(\"NetworkArea\").Value; foreach (var serviceNode in serverNode.Descendants(\"Services\").Descendants(\"Entity\")) { var serviceName = serviceNode.Element(\"Name\").Value; if (!serviceName.RegExMatches(_environmentWatchElement.ServiceNames) || serviceName.RegExMatches(_environmentWatchElement.ServiceNamesNotMatch)) continue; var fields = new FieldCollection { new FieldElement { Key = \"host\", Value = serverName }, new FieldElement { Key = \"service\", Value = serviceName }, }; foreach (FieldElement field in _environmentWatchElement.Fields) { fields.Add(field); } var serviceLogFile = (string)serviceNode.Elements(\"LogPath\").FirstOrDefault(); var serviceLogType = (string)serviceNode.Elements(\"LogPathType\").FirstOrDefault(); var serviceLogFile1 = (string)serviceNode.Elements(\"LogPath1\").FirstOrDefault(); var serviceLogType1 = (string)serviceNode.Elements(\"LogPath1Type\").FirstOrDefault(); var serviceLogFile2 = (string)serviceNode.Elements(\"LogPath2\").FirstOrDefault(); var serviceLogType2 = (string)serviceNode.Elements(\"LogPath2Type\").FirstOrDefault(); AddFileWatchElementForLogFile(serviceLogFile, serviceLogType, watches, fields, serverNetworkArea, serverName, serviceName); AddFileWatchElementForLogFile(serviceLogFile1, serviceLogType1, watches, fields, serverNetworkArea, serverName, serviceName); AddFileWatchElementForLogFile(serviceLogFile2, serviceLogType2, watches, fields, serverNetworkArea, serverName, serviceName); } } return watches; } private void AddFileWatchElementForLogFile(string logFile, string logType, ICollection<FileWatchElement> watches, FieldCollection fields, string serverNetworkArea, string serverName, string serviceName) { //Don't ship logs without a type or with an empty type if (!string.IsNullOrEmpty(logType) && !string.IsNullOrWhiteSpace(logType)) { var newWatch = new FileWatchElement { Files = logFile, Type = logType, Fields = fields }; var overrideConfig = FindOverride(serviceName); if (overrideConfig != null) { newWatch.CloseWhenIdle = overrideConfig.CloseWhenIdle; if (overrideConfig.CustomNxlogConfig != null) { newWatch.CustomNxlogConfig = new CustomNxlogConfig { Value = overrideConfig.CustomNxlogConfig.Value }; } newWatch.SourceTailer = overrideConfig.SourceTailer; newWatch.MultilineRule = overrideConfig.MultilineRule; foreach (FieldElement overrideField in overrideConfig.Fields) { newWatch.Fields.Remove(overrideField.Key); newWatch.Fields.Add(new FieldElement { Key = overrideField.Key, Value = overrideField.Value }); } } watches.Add(newWatch); _log.DebugFormat( \"Added file watch from EDB: {0} ({1}) => Matched NetworkArea:{2} ~= {3}, ServerName:{4} ~= {5}, ServiceName:{6} ~= {7}\", logFile, logType, serverNetworkArea, _environmentWatchElement.NetworkAreas, serverName, _environmentWatchElement.ServerNames, serviceName, _environmentWatchElement.ServiceNames); } else { if (!string.IsNullOrEmpty(logFile)) { _log.DebugFormat( \"Ignored file watch from EDB because it has an empty type: {0} ({1})\", logFile, logType); } } } private XDocument LoadEDBXml() { XDocument environmentDataXml; var path = _environmentWatchElement.DataFile.Replace('\\\\', Path.DirectorySeparatorChar); //Use StreamReader to autodetect file encoding - http://stackoverflow.com/a/4569093/13238 using (var sr = new StreamReader(path, true)) { environmentDataXml = XDocument.Load(sr); } return environmentDataXml; } public IEnumerable<EDBEnvironment> GenerateLogsearchEnvironmentDiagram() { var environmentDataXml = LoadEDBXml(); /* NB Note how we force LINQ evaluation for each query by calling ToArray(). * Without this data seems to get duplicated. */ var networkAreas = (from server in environmentDataXml.Descendants(\"Servers\").Descendants(\"Server\") select new { Name = server.Element(\"NetworkArea\").Value } ).Distinct().ToArray(); var servers = (from server in environmentDataXml.Descendants(\"Servers\").Descendants(\"Server\") select new EdbServer { Name = server.Element(\"Name\").Value, Description = (string)server.Elements(\"Description\").FirstOrDefault(), Tags = (string)server.Elements(\"Tags\").FirstOrDefault(), Domain = server.Element(\"Domain\").Value, Environment = server.Element(\"Environment\").Value, NetworkArea = server.Element(\"NetworkArea\").Value, Services = (from service in server.Descendants(\"Services\").Descendants(\"Entity\") select service).ToList() }).Distinct().ToArray(); var environmentHierarchy = new List<EDBEnvironment> { new EDBEnvironment { Name = environmentDataXml.Element(\"Environment\").Element(\"Name\").Value, ServerGroups = (from serverGroup in networkAreas select new EDBServerGroup { Name = serverGroup.Name, Servers = (from server in servers where server.NetworkArea == serverGroup.Name select server).ToList(), }).ToList() } }; return environmentHierarchy.ToArray(); } OverrideConfig FindOverride(string serviceName) { var overrides = _environmentWatchElement.OverrideConfigs; foreach (var overrideConfig in overrides) { var regex = new Regex(overrideConfig.ForServiceNames); if (regex.Match(serviceName).Success) return overrideConfig; } return null; } }", "label": "FeatureEnvy"}
{"text": "internal sealed class GlobalSuppressMessageCodeAction : CodeAction { private readonly AbstractSuppressionCodeFixProvider _fixer; private readonly string _title; private readonly ISymbol _targetSymbol; private readonly Document _document; private readonly Diagnostic _diagnostic; public GlobalSuppressMessageCodeAction(AbstractSuppressionCodeFixProvider fixer, ISymbol targetSymbol, Document document, Diagnostic diagnostic) { _fixer = fixer; _targetSymbol = targetSymbol; _document = document; _diagnostic = diagnostic; _title = FeaturesResources.SuppressWithGlobalSuppressMessage; } protected override async Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken) { var changedSuppressionDocument = await GetChangedSuppressionDocumentAsync(cancellationToken).ConfigureAwait(false); return new CodeActionOperation[] { new ApplyChangesOperation(changedSuppressionDocument.Project.Solution), new OpenDocumentOperation(changedSuppressionDocument.Id, activateIfAlreadyOpen: true), new NavigationOperation(changedSuppressionDocument.Id, position: 0) }; } public override string Title { get { return _title; } } private async Task<Document> GetChangedSuppressionDocumentAsync(CancellationToken cancellationToken) { var suppressionsDoc = await GetOrCreateSuppressionsDocumentAsync(_document, cancellationToken).ConfigureAwait(false); var suppressionsRoot = await suppressionsDoc.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false); var newSuppressionsRoot = _fixer.AddGlobalSuppressMessageAttribute(suppressionsRoot, _targetSymbol, _diagnostic); return suppressionsDoc.WithSyntaxRoot(newSuppressionsRoot); } private async Task<Document> GetOrCreateSuppressionsDocumentAsync(Document document, CancellationToken c) { int index = 1; var suppressionsFileName = s_globalSuppressionsFileName + _fixer.DefaultFileExtension; if (document.Name == suppressionsFileName) { index++; suppressionsFileName = s_globalSuppressionsFileName + index.ToString() + _fixer.DefaultFileExtension; } Document suppressionsDoc = null; while (suppressionsDoc == null) { var hasDocWithSuppressionsName = false; foreach (var d in document.Project.Documents) { if (d.Name == suppressionsFileName) { // Existing global suppressions file, see if this file only has global assembly attributes. hasDocWithSuppressionsName = true; var t = await d.GetSyntaxTreeAsync(c).ConfigureAwait(false); var r = await t.GetRootAsync(c).ConfigureAwait(false); if (r.ChildNodes().All(n => _fixer.IsAttributeListWithAssemblyAttributes(n))) { suppressionsDoc = d; break; } } } if (suppressionsDoc == null) { if (hasDocWithSuppressionsName) { index++; suppressionsFileName = s_globalSuppressionsFileName + index.ToString() + _fixer.DefaultFileExtension; } else { // Create an empty global suppressions file. suppressionsDoc = document.Project.AddDocument(suppressionsFileName, string.Empty); } } } return suppressionsDoc; } }", "label": "FeatureEnvy"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class blockContact_args : TBase { private int _reqSeq; private string _id; public int ReqSeq { get { return _reqSeq; } set { __isset.reqSeq = true; this._reqSeq = value; } } public string Id { get { return _id; } set { __isset.id = true; this._id = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool reqSeq; public bool id; } public blockContact_args() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 1: if (field.Type == TType.I32) { ReqSeq = iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 2: if (field.Type == TType.String) { Id = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"blockContact_args\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (__isset.reqSeq) { field.Name = \"reqSeq\"; field.Type = TType.I32; field.ID = 1; oprot.WriteFieldBegin(field); oprot.WriteI32(ReqSeq); oprot.WriteFieldEnd(); } if (Id != null && __isset.id) { field.Name = \"id\"; field.Type = TType.String; field.ID = 2; oprot.WriteFieldBegin(field); oprot.WriteString(Id); oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"blockContact_args(\"); sb.Append(\"ReqSeq: \"); sb.Append(ReqSeq); sb.Append(\",Id: \"); sb.Append(Id); sb.Append(\")\"); return sb.ToString(); } }", "label": "FeatureEnvy"}
{"text": "public class RedisProvider : IRedisProvider { public bool IsConnected { get { return Client.IsConnected; } } public RedisClient Client { get; private set; } // private readonly Version _requiredMinimumVersion = new Version(2, 6); private readonly IRedisProviderConfig _config; private readonly ILogger _logger; public RedisProvider(IPoolConfig poolConfig, IRedisProviderConfig config) { _logger = Log.ForContext<RedisProvider>().ForContext(\"Component\", poolConfig.Coin.Name); _config = config; Initialize(); } private void Initialize() { try { Client = new RedisClient(_config.Host, _config.Port, _config.Password, \"version=2.6\"); // select the database Client.Select(_config.DatabaseId); /* // check the version var version = GetVersion(); if (version < _requiredMinimumVersion) throw new Exception(string.Format(\"You are using redis version {0}, minimum required version is 2.6\", version)); _logger.Information(\"Redis storage initialized: {0:l}:{1}, v{2:l}.\", _config.Host, _config.Port, version); */ _logger.Information(\"Redis storage initialized: {0:l}:{1}.\", _config.Host, _config.Port); } catch (Exception e) { _logger.Error(e,\"Redis storage initialization failed: {0:l}:{1}\", _config.Host, _config.Port); } } /* private Version GetVersion() { Version version = null; try { var info = Client.Info(\"server\"); var parts = info.Split(new[] { Environment.NewLine }, StringSplitOptions.None); foreach (var part in parts) { var data = part.Split(':'); if (data[0] != \"redis_version\") continue; version = new Version(data[1]); } } catch (Exception e) { _logger.Error(\"An exception occured while getting version info: {0:l}\", e.Message); } return version; } */ }", "label": "FeatureEnvy"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class registerWithSnsId_args : TBase { private SnsIdType _snsIdType; private string _snsAccessToken; private string _region; private string _udidHash; private DeviceInfo _deviceInfo; private string _mid; /// <summary> /// /// <seealso cref=\"SnsIdType\"/> /// </summary> public SnsIdType SnsIdType { get { return _snsIdType; } set { __isset.snsIdType = true; this._snsIdType = value; } } public string SnsAccessToken { get { return _snsAccessToken; } set { __isset.snsAccessToken = true; this._snsAccessToken = value; } } public string Region { get { return _region; } set { __isset.region = true; this._region = value; } } public string UdidHash { get { return _udidHash; } set { __isset.udidHash = true; this._udidHash = value; } } public DeviceInfo DeviceInfo { get { return _deviceInfo; } set { __isset.deviceInfo = true; this._deviceInfo = value; } } public string Mid { get { return _mid; } set { __isset.mid = true; this._mid = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool snsIdType; public bool snsAccessToken; public bool region; public bool udidHash; public bool deviceInfo; public bool mid; } public registerWithSnsId_args() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 2: if (field.Type == TType.I32) { SnsIdType = (SnsIdType)iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 3: if (field.Type == TType.String) { SnsAccessToken = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 4: if (field.Type == TType.String) { Region = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 5: if (field.Type == TType.String) { UdidHash = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 6: if (field.Type == TType.Struct) { DeviceInfo = new DeviceInfo(); DeviceInfo.Read(iprot); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 7: if (field.Type == TType.String) { Mid = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"registerWithSnsId_args\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (__isset.snsIdType) { field.Name = \"snsIdType\"; field.Type = TType.I32; field.ID = 2; oprot.WriteFieldBegin(field); oprot.WriteI32((int)SnsIdType); oprot.WriteFieldEnd(); } if (SnsAccessToken != null && __isset.snsAccessToken) { field.Name = \"snsAccessToken\"; field.Type = TType.String; field.ID = 3; oprot.WriteFieldBegin(field); oprot.WriteString(SnsAccessToken); oprot.WriteFieldEnd(); } if (Region != null && __isset.region) { field.Name = \"region\"; field.Type = TType.String; field.ID = 4; oprot.WriteFieldBegin(field); oprot.WriteString(Region); oprot.WriteFieldEnd(); } if (UdidHash != null && __isset.udidHash) { field.Name = \"udidHash\"; field.Type = TType.String; field.ID = 5; oprot.WriteFieldBegin(field); oprot.WriteString(UdidHash); oprot.WriteFieldEnd(); } if (DeviceInfo != null && __isset.deviceInfo) { field.Name = \"deviceInfo\"; field.Type = TType.Struct; field.ID = 6; oprot.WriteFieldBegin(field); DeviceInfo.Write(oprot); oprot.WriteFieldEnd(); } if (Mid != null && __isset.mid) { field.Name = \"mid\"; field.Type = TType.String; field.ID = 7; oprot.WriteFieldBegin(field); oprot.WriteString(Mid); oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"registerWithSnsId_args(\"); sb.Append(\"SnsIdType: \"); sb.Append(SnsIdType); sb.Append(\",SnsAccessToken: \"); sb.Append(SnsAccessToken); sb.Append(\",Region: \"); sb.Append(Region); sb.Append(\",UdidHash: \"); sb.Append(UdidHash); sb.Append(\",DeviceInfo: \"); sb.Append(DeviceInfo== null ? \"<null>\" : DeviceInfo.ToString()); sb.Append(\",Mid: \"); sb.Append(Mid); sb.Append(\")\"); return sb.ToString(); } }", "label": "FeatureEnvy"}
{"text": "internal abstract class AppInstaller<T> : IPackageInstaller where T : IApplication { private static ILogger logger = Logger.GetLogger(\"WinAppDriver\"); private T app; private IDriverContext context; private IUtils utils; private bool prepared = false; public AppInstaller(IDriverContext context, T app, IUtils utils) { this.context = context; this.app = app; this.utils = utils; } private string CurrentFile { get { return Path.Combine(this.context.GetAppWorkingDir(this.app), \"Current.txt\"); } } private string PackageDir { get { return Path.Combine(this.context.GetAppWorkingDir(this.app), \"InstallationPackage\"); } } private string PackageInfoFile { get { return Path.Combine(this.PackageDir, \"Info.txt\"); } } public bool IsBuildChanged() { string currentChecksum; if (!this.TryReadCurrent(out currentChecksum)) { logger.Info( \"Build changed, because current build (checksum) is unknown; app = [{0}]\", this.app.DriverAppID); return true; } string cachedChecksum; string package = this.PrepareInstallationPackage(out cachedChecksum); bool changed = currentChecksum != cachedChecksum; logger.Info( \"Build changed? {0}; app = [{1}], current checksum = [{2}], cached checksum = [{3}]\", changed, this.app.DriverAppID, currentChecksum, cachedChecksum); return changed; } public void Install() { string checksum; string package = this.PrepareInstallationPackage(out checksum); this.InstallImpl(package, checksum); this.UpdateCurrent(checksum); System.Threading.Thread.Sleep(5000); // TODO avoid timing issue, esp. for store apps } protected internal abstract void InstallImpl(string package, string checksum); protected internal void UpdateCurrent(string checksum) { string path = this.CurrentFile; checksum = checksum.ToLower(); logger.Debug(\"Update current build (checksum); app = [{0}], checksum = [{1}]\", this.app.DriverAppID, checksum); File.WriteAllText(path, checksum); } private bool TryReadCurrent(out string checksum) { string path = this.CurrentFile; logger.Debug(\"Current file: [{0}]; app = [{1}]\", path, this.app.DriverAppID); if (!File.Exists(path)) { logger.Debug(\"Current file does not exist.\"); checksum = null; return false; } checksum = File.ReadAllText(path); logger.Debug(\"Current build (checksum): [{0}]\", checksum); return true; } private string PrepareInstallationPackage(out string checksum) { string baseDir = this.PackageDir; var caps = this.app.Capabilities; logger.Debug( \"Prepare installation package; app = [{0}], base dir = [{1}], caps.App = [{2}], caps.AppChecksum = [{3}]\", this.app.DriverAppID, baseDir, caps.App, caps.AppChecksum); string filename; string fullpath; bool cached = this.TryReadCachedPackageInfo(out filename, out checksum); if (this.prepared && cached) { fullpath = Path.Combine(baseDir, filename); logger.Debug( \"Alread prepared; path = [{0}], checksum = [{1}]\", fullpath, checksum); return fullpath; } // Quick comparison if (caps.AppChecksum != null && cached) { logger.Debug(\"Checksum matching (case-insensitive); caps.AppChecksum = [{0}], cached checksum = [{1}]\", caps.AppChecksum, checksum); fullpath = Path.Combine(baseDir, filename); if (checksum == caps.AppChecksum.ToLower()) { logger.Info( \"The cached installation package of app '{0}' ({1}) can be reused, because of matched checksums.\", this.app.DriverAppID, fullpath); this.prepared = true; return fullpath; } else { logger.Info( \"The cached installation package of app '{0}' ({1}) can not be reused, because of unmatched checksums.\", this.app.DriverAppID, fullpath); } } // Download the installation package logger.Info( \"Start downloading installation pacakge of app '{0}' from {1}.\", this.app.DriverAppID, caps.App); string downloaded = this.utils.GetAppFileFromWeb(caps.App, caps.AppChecksum); filename = Path.GetFileName(downloaded); // TODO Preserve original filename, and replace invalid characters checksum = caps.AppChecksum != null ? caps.AppChecksum.ToLower() : this.utils.GetFileMD5(downloaded); logger.Info(\"Installation package downloaded: {0} ({1}).\", downloaded, checksum); // Discard cached installation package if (Directory.Exists(baseDir)) { Directory.Delete(baseDir, true); } Directory.CreateDirectory(baseDir); // Update cached package information. fullpath = Path.Combine(baseDir, filename); logger.Info(\"Cache the installation package: {0}.\", fullpath); File.Move(downloaded, fullpath); this.WriteCachedPackageInfo(filename, checksum); this.prepared = true; return fullpath; } private bool TryReadCachedPackageInfo(out string filename, out string checksum) { string path = this.PackageInfoFile; logger.Debug(\"Cached package info file: [{0}]; app = [{1}]\", path, this.app.DriverAppID); if (!File.Exists(path)) { logger.Debug(\"Cached package info file does not exist.\"); filename = null; checksum = null; return false; } string[] lines = File.ReadAllLines(path, Encoding.UTF8); filename = lines[0]; checksum = lines[1]; logger.Debug(\"Cached package info: filename = [{0}], checksum = [{1}]\", filename, checksum); return true; } private void WriteCachedPackageInfo(string filename, string checksum) { string path = this.PackageInfoFile; string[] lines = { filename, checksum }; logger.Debug( \"Write cached package info; app = [{0}], path = [{1}], filename = [{2}], checksum = [{3}]\", this.app.DriverAppID, path, filename, checksum); File.WriteAllLines(path, lines, Encoding.UTF8); } }", "label": "ComplexMethod"}
{"text": "public class PullToRefreshScrollViewRenderer : ScrollViewRenderer { private FormsUIRefreshControl _refreshControl; protected override void OnElementChanged(VisualElementChangedEventArgs e) { base.OnElementChanged(e); if (_refreshControl != null) return; var pullToRefreshScrollView = (PullToRefreshScrollView)Element; if (pullToRefreshScrollView != null) { pullToRefreshScrollView.PropertyChanged += OnElementPropertyChanged; _refreshControl = new FormsUIRefreshControl { RefreshCommand = pullToRefreshScrollView.RefreshCommand, Message = pullToRefreshScrollView.Message }; AlwaysBounceVertical = true; AddSubview(_refreshControl); } } private void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e) { var pullToRefreshScrollView = Element as PullToRefreshScrollView; if (pullToRefreshScrollView == null) return; if (e.PropertyName == PullToRefreshScrollView.IsRefreshingProperty.PropertyName) _refreshControl.IsRefreshing = pullToRefreshScrollView.IsRefreshing; if (e.PropertyName == PullToRefreshScrollView.MessageProperty.PropertyName) _refreshControl.Message = pullToRefreshScrollView.Message; if (e.PropertyName == PullToRefreshScrollView.RefreshCommandProperty.PropertyName) _refreshControl.RefreshCommand = pullToRefreshScrollView.RefreshCommand; } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Vector clock /// </summary> public class VectorClock : IEquatable<VectorClock> { /// <summary> /// The result of comparing two times /// either t1 is before t2, /// t1 is after t2, /// or t1 happens concurrently to t2 /// </summary> public enum Occured { /// <summary> /// Event occurred before /// </summary> Before = -1, /// <summary> /// Event occurred after /// </summary> After = 1, /// <summary> /// Event occurred independantly /// </summary> Concurrently = 0 } private const int MaxVersions = Int16.MaxValue; public readonly Lst<ClockEntry> Versions; public static readonly VectorClock Empty = new VectorClock(); /// <summary> /// Ctor /// </summary> VectorClock() : this(List.empty<ClockEntry>()) { } /// <summary> /// Ctor /// </summary> VectorClock(Lst<ClockEntry> versions) { Versions = versions; } /// <summary> /// Increment the version info associated with the given node /// </summary> /// <param name=\"nodeId\">Node to increment</param> public VectorClock Incr(int nodeId) { // stop on the index greater or equal to the node int index = 0; bool found = false; var versions = Versions; foreach(var version in versions) { if (version.NodeId == nodeId) { found = true; break; } else if (version.NodeId > nodeId) { break; } index++; } if (found) { versions = versions.SetItem(index, versions[index].Incr()); } else if (index < versions.Count - 1) { versions = versions.Insert(index, new ClockEntry(nodeId, 1)); } else { // we don't already have a version for this, so add it if (versions.Count > MaxVersions) throw new ArgumentOutOfRangeException(\"Vector clock is full\"); versions.Add(new ClockEntry(nodeId, 1)); } return new VectorClock(versions); } /// <summary> /// ToString /// </summary> public override string ToString() { var builder = new StringBuilder(); builder.Append(\"version(\"); if (Versions.Count > 0) { for (int i = 0; i < Versions.Count - 1; i++) { builder.Append(Versions[i]); builder.Append(\", \"); } builder.Append(Versions[Versions.Count - 1]); } builder.Append(\")\"); return builder.ToString(); } /// <summary> /// Merge clocks /// </summary> public VectorClock Merge(VectorClock clock) { int i = 0; int j = 0; var versions = Versions.ToArray(); var clockVersions = clock.Versions.ToArray(); var newClockVersions = List.empty<ClockEntry>(); while (i < versions.Count && j < clockVersions.Count) { var v1 = versions[i]; var v2 = clockVersions[j]; if (v1.NodeId == v2.NodeId) { var nc = new ClockEntry(v1.NodeId, (int)Math.Max(v1.Version, v2.Version)); newClockVersions = newClockVersions.Add(nc); i++; j++; } else if (v1.NodeId < v2.NodeId) { newClockVersions = newClockVersions.Add(v1); i++; } else { newClockVersions = newClockVersions.Add(v2); j++; } } // Okay now there may be leftovers on one or the other list remaining for (int k = i; k < versions.Count; k++) { newClockVersions = newClockVersions.Add(versions[k]); } for (int k = j; k < clockVersions.Count; k++) { newClockVersions = newClockVersions.Add(clockVersions[k]); } return new VectorClock(newClockVersions); } /// <summary> /// <para> /// Is this reflexive, antisymetic, and transitive? Compare two VectorClocks, /// the outcomes will be one of the following: /// </para> /// <para> /// * Clock 1 is /before/ clock 2 /// if there exists an i such that c1(i) &lt;= c(2) and there does not /// exist a j such that c1(j) > c2(j). /// </para> /// <para> /// * Clock 1 is /concurrent/ to clock 2 if there exists an i, j such that /// c1(i) &lt; c2(i) and c1(j) > c2(j) /// </para> /// <para> /// * Clock 1 is /after/ clock 2 otherwise /// </para> /// </summary> /// <param name=\"v1\">The first VectorClock</param> /// <param name=\"v2\">The second VectorClock</param> /// <returns>Whether the change occured before, after or concurrently</returns> public static Occured Compare(VectorClock v1, VectorClock v2) { if (v1 == null || v2 == null) throw new ArgumentException(\"Can't compare null vector clocks!\"); // We do two checks: v1 <= v2 and v2 <= v1 if both are true then bool v1Bigger = false; bool v2Bigger = false; int p1 = 0; int p2 = 0; while (p1 < v1.Versions.Count && p2 < v2.Versions.Count) { ClockEntry ver1 = v1.Versions[p1]; ClockEntry ver2 = v2.Versions[p2]; if (ver1.NodeId == ver2.NodeId) { if (ver1.Version > ver2.Version) v1Bigger = true; else if (ver2.Version > ver1.Version) v2Bigger = true; p1++; p2++; } else if (ver1.NodeId > ver2.NodeId) { // since ver1 is bigger that means it is missing a version that ver2 has v2Bigger = true; p2++; } else { // this means ver2 is bigger which means it is missing a version ver1 has v1Bigger = true; p1++; } } // Check for left overs if (p1 < v1.Versions.Count) { v1Bigger = true; } else if (p2 < v2.Versions.Count) { v2Bigger = true; } // This is the case where they are equal, return BEFORE arbitrarily if (!v1Bigger && !v2Bigger) { return Occured.Before; } // This is the case where v1 is a successor clock to v2 else if (v1Bigger && !v2Bigger) { return Occured.After; } // This is the case where v2 is a successor clock to v1 else if (!v1Bigger && v2Bigger) { return Occured.Before; } // This is the case where both clocks are parallel to one another else { return Occured.Concurrently; } } /// <summary> /// Equality test /// </summary> /// <param name=\"obj\"></param> /// <returns></returns> public override bool Equals(object obj) => obj is VectorClock ? Equals((VectorClock)obj) : false; public bool Equals(VectorClock rhs) { if (ReferenceEquals(this, rhs)) return true; if (ReferenceEquals(rhs, null)) return false; if (Versions.Count != rhs.Versions.Count) return false; if (Versions.Zip(rhs.Versions, (x, y) => x == y).Exists(x => !x)) return false; return true; } public override int GetHashCode() => Versions.Fold(13, (s, x) => s * Math.Max(1, x.GetHashCode())); }", "label": "FeatureEnvy"}
{"text": "#endregion #region -- class LuaTableHashValueCollection -------------------------------------- /////////////////////////////////////////////////////////////////////////////// /// <summary></summary> public class LuaTableHashValueCollection : ICollection<object> { private LuaTable t; internal LuaTableHashValueCollection(LuaTable t) { this.t = t; } // ctor /// <summary></summary> /// <param name=\"value\"></param> /// <returns></returns> public bool Contains(object value) { for (var i = 0; i < t.arrayList.Length; i++) { if (t.arrayList[i] != null && comparerObject.Equals(t.arrayList[i], value)) return true; } for (var i = hiddenMemberCount; i < t.classDefinition.Count; i++) { if (comparerObject.Equals(t.GetClassMemberValue(i, t.entries[i].key, true), value)) return true; } for (var i = t.classDefinition.Count; i < t.entries.Length; i++) { if (t.entries[i].hashCode != -1 && comparerObject.Equals(t.entries[i].value, value)) return true; } return false; } // func Contains /// <summary></summary> /// <param name=\"array\"></param> /// <param name=\"arrayIndex\"></param> public void CopyTo(object[] array, int arrayIndex) { if (arrayIndex < 0 || arrayIndex + Count > array.Length) throw new ArgumentOutOfRangeException(); for (var i = 0; i < t.arrayList.Length; i++) { if (t.arrayList[i] != null) array[arrayIndex++] = t.arrayList[i]; } for (var i = hiddenMemberCount; i < t.classDefinition.Count; i++) { array[arrayIndex++] = t.GetClassMemberValue(i, t.entries[i].key, true); } for (var i = t.classDefinition.Count; i < t.entries.Length; i++) { if (t.entries[i].hashCode != -1) array[arrayIndex++] = t.entries[i].value; } } // proc CopyTo /// <summary></summary> /// <returns></returns> public IEnumerator<object> GetEnumerator() { var version = t.version; for (var i = 0; i < t.arrayList.Length; i++) { if (version != t.version) throw new InvalidOperationException(\"table changed\"); if (t.arrayList[i] != null) yield return t.arrayList[i]; } for (var i = hiddenMemberCount; i < t.classDefinition.Count; i++) { if (version != t.version) throw new InvalidOperationException(\"table changed\"); yield return t.GetClassMemberValue(i, t.entries[i].key, true); } for (var i = t.classDefinition.Count; i < t.entries.Length; i++) { if (version != t.version) throw new InvalidOperationException(\"table changed\"); if (t.entries[i].hashCode != -1) yield return t.entries[i].value; } } // func GetEnumerator IEnumerator IEnumerable.GetEnumerator() => GetEnumerator(); void ICollection<object>.Add(object item) { throw new NotSupportedException(); } bool ICollection<object>.Remove(object item) { throw new NotSupportedException(); } void ICollection<object>.Clear() { throw new NotSupportedException(); } /// <summary></summary> public int Count => t.count - hiddenMemberCount; /// <summary>Always true</summary> public bool IsReadOnly => true; } // class LuaTableHashValueCollection", "label": "FeatureEnvy"}
{"text": "internal class ClusterFit : ColourFit { const int MaxIterations = 8; #region Fields private int _IterationCount; private Vector3 _Principle; private byte[] _Order = new byte[16 * MaxIterations]; private Vector4[] _PointsWeight = new Vector4[16]; private Vector4 _XSumWSum; private Vector4 _Metric; private Vector4 _BestError; #endregion #region Constructor protected ClusterFit(ColourSet colours, SquishOptions flags) : base(colours, flags) { // Set the iteration count. this._IterationCount = flags.HasFlag(SquishOptions.ColourIterativeClusterFit) ? MaxIterations : 1; // Initialise the best error. this._BestError = new Vector4(float.MaxValue); // Initialize the metric var perceptual = flags.HasFlag(SquishOptions.ColourMetricPerceptual); if (perceptual) this._Metric = new Vector4(0.2126f, 0.7152f, 0.0722f, 0.0f); else this._Metric = new Vector4(1.0f); // Get the covariance matrix. var covariance = Sym3x3.ComputeWeightedCovariance(colours.Count, colours.Points, colours.Weights); // Compute the principle component this._Principle = Sym3x3.ComputePrincipledComponent(covariance); } #endregion #region Methods protected bool ConstructOrdering(Vector3 axis, int iteration) { // Build the list of dot products. var dps = new float[16]; var ordOff = 16 * iteration; for (int i = 0; i < _Colours.Count; ++i) { dps[i] = Vector3.Dot(_Colours.Points[i], axis); this._Order[ordOff + i] = (byte)i; } // Stable sort using them. for (int i = 0; i < _Colours.Count; ++i) { for (int j = i; j > 0 && dps[j] < dps[j - 1]; --j) { var _dps = dps[j]; var _order = _Order[ordOff + j]; dps[j] = dps[j - 1]; dps[j - 1] = _dps; _Order[ordOff + j] = _Order[ordOff + j - 1]; _Order[ordOff + j - 1] = _order; } } // Check this ordering is unique for (int it = 0; it < iteration; ++it) { var prevOff = 16 * it; var same = true; for (int i = 0; i < _Colours.Count; ++i) { if (_Order[ordOff + i] != _Order[prevOff + i]) { same = false; break; } } if (same) return false; } // Copy the ordering and weight all the points this._XSumWSum = new Vector4(0f); for (int i = 0; i < _Colours.Count; ++i) { var j = _Order[ordOff + i]; var p = new Vector4(_Colours.Points[j].X, _Colours.Points[j].Y, _Colours.Points[j].Z, 1f); var w = new Vector4(_Colours.Weights[j]); var x = p * w; this._PointsWeight[i] = x; this._XSumWSum += x; } return true; } protected override void Compress3(byte[] block) { // Declare variables var count = _Colours.Count; var zero = new Vector4(0f); var half = new Vector4(.5f); var one = new Vector4(1f); var two = new Vector4(2f); var half_half2 = new Vector4(.5f, .5f, .5f, .25f); var grid = new Vector4(31f, 63f, 31f, 0f); var gridrcp = new Vector4(1f / 31f, 1f / 63f, 1f / 31f, 0f); // Prepare the ordering using the principle axis. ConstructOrdering(_Principle, 0); // Check all possible clusters and iterate on the total order. var bestStart = zero; var bestEnd = zero; var bestError = this._BestError; var bestIndices = new byte[16]; var bestIteration = 0; int besti = 0, bestj = 0; // Loop over iterations (we avoid the case that all points in first or last cluster) for (int iterationIndex = 0; ; ) { throw new NotImplementedException(); } } protected override void Compress4(byte[] block) { throw new NotImplementedException(); } #endregion }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Controller for handling minified/combined responses /// </summary> [AddCompressionHeader(Order = 0)] [AddExpiryHeaders(Order = 1)] [CheckNotModified(Order = 2)] [CompositeFileCacheFilter(Order = 3)] public class SmidgeController : Controller { private readonly FileSystemHelper _fileSystemHelper; private readonly IBundleManager _bundleManager; private readonly IBundleFileSetGenerator _fileSetGenerator; private readonly PreProcessPipelineFactory _processorFactory; private readonly PreProcessManager _preProcessManager; private readonly ILogger _logger; /// <summary> /// Constructor /// </summary> /// <param name=\"fileSystemHelper\"></param> /// <param name=\"bundleManager\"></param> /// <param name=\"fileSetGenerator\"></param> /// <param name=\"processorFactory\"></param> /// <param name=\"preProcessManager\"></param> /// <param name=\"logger\"></param> public SmidgeController( FileSystemHelper fileSystemHelper, IBundleManager bundleManager, IBundleFileSetGenerator fileSetGenerator, PreProcessPipelineFactory processorFactory, PreProcessManager preProcessManager, ILogger<SmidgeController> logger) { if (fileSystemHelper == null) throw new ArgumentNullException(nameof(fileSystemHelper)); if (bundleManager == null) throw new ArgumentNullException(nameof(bundleManager)); if (fileSetGenerator == null) throw new ArgumentNullException(nameof(fileSetGenerator)); if (processorFactory == null) throw new ArgumentNullException(nameof(processorFactory)); if (preProcessManager == null) throw new ArgumentNullException(nameof(preProcessManager)); _fileSystemHelper = fileSystemHelper; _bundleManager = bundleManager; _fileSetGenerator = fileSetGenerator; _processorFactory = processorFactory; _preProcessManager = preProcessManager; _logger = logger; } /// <summary> /// Handles requests for named bundles /// </summary> /// <param name=\"bundle\">The bundle model</param> /// <returns></returns> public async Task<IActionResult> Bundle( [FromServices]BundleRequestModel bundle) { if (!_bundleManager.TryGetValue(bundle.FileKey, out Bundle foundBundle)) { return NotFound(); } var bundleOptions = foundBundle.GetBundleOptions(_bundleManager, bundle.Debug); //now we need to determine if this bundle has already been created var compositeFilePath = new FileInfo(_fileSystemHelper.GetCurrentCompositeFilePath(bundle.CacheBuster, bundle.Compression, bundle.FileKey)); if (compositeFilePath.Exists) { _logger.LogDebug($\"Returning bundle '{bundle.FileKey}' from cache\"); //this is already processed, return it return File(compositeFilePath.OpenRead(), bundle.Mime); } //the bundle doesn't exist so we'll go get the files, process them and create the bundle //TODO: We should probably lock here right?! we don't want multiple threads trying to do this at the same time, we'll need a dictionary of locks to do this effectively //get the files for the bundle var files = _fileSetGenerator.GetOrderedFileSet(foundBundle, _processorFactory.CreateDefault( //the file type in the bundle will always be the same foundBundle.Files[0].DependencyType)) .ToArray(); if (files.Length == 0) { return NotFound(); } using (var bundleContext = new BundleContext(bundle, compositeFilePath)) { var watch = new Stopwatch(); watch.Start(); _logger.LogDebug($\"Processing bundle '{bundle.FileKey}', debug? {bundle.Debug} ...\"); //we need to do the minify on the original files foreach (var file in files) { await _preProcessManager.ProcessAndCacheFileAsync(file, bundleOptions, bundleContext); } //Get each file path to it's hashed location since that is what the pre-processed file will be saved as Lazy<IFileInfo> fi; var filePaths = files.Select( x => _fileSystemHelper.GetCacheFilePath(x, bundleOptions.FileWatchOptions.Enabled, Path.GetExtension(x.FilePath), bundle.CacheBuster, out fi)); using (var resultStream = await GetCombinedStreamAsync(filePaths, bundleContext)) { //compress the response (if enabled) var compressedStream = await Compressor.CompressAsync( //do not compress anything if it's not enabled in the bundle options bundleOptions.CompressResult ? bundle.Compression : CompressionType.none, resultStream); //save the resulting compressed file, if compression is not enabled it will just save the non compressed format // this persisted file will be used in the CheckNotModifiedAttribute which will short circuit the request and return // the raw file if it exists for further requests to this path await CacheCompositeFileAsync(compositeFilePath, compressedStream); _logger.LogDebug($\"Processed bundle '{bundle.FileKey}' in {watch.ElapsedMilliseconds}ms\"); //return the stream return File(compressedStream, bundle.Mime); } } } /// <summary> /// Handles requests for composite files (non-named bundles) /// </summary> /// <param name=\"file\"></param> /// <returns></returns> public async Task<IActionResult> Composite( [FromServices]CompositeFileModel file) { if (!file.ParsedPath.Names.Any()) { return NotFound(); } var compositeFilePath = new FileInfo(_fileSystemHelper.GetCurrentCompositeFilePath(file.CacheBuster, file.Compression, file.FileKey)); if (compositeFilePath.Exists) { //this is already processed, return it return File(compositeFilePath.OpenRead(), file.Mime); } using (var bundleContext = new BundleContext(file, compositeFilePath)) { var filePaths = file.ParsedPath.Names.Select(filePath => Path.Combine( _fileSystemHelper.CurrentCacheFolder, file.ParsedPath.Version, filePath + file.Extension)); using (var resultStream = await GetCombinedStreamAsync(filePaths, bundleContext)) { var compressedStream = await Compressor.CompressAsync(file.Compression, resultStream); await CacheCompositeFileAsync(compositeFilePath, compressedStream); return File(compressedStream, file.Mime); } } } private static async Task CacheCompositeFileAsync(FileInfo compositeFilePath, Stream compositeStream) { //ensure it exists compositeFilePath.Directory.Create(); compositeStream.Position = 0; using (var fs = compositeFilePath.Create()) { await compositeStream.CopyToAsync(fs); } compositeStream.Position = 0; } /// <summary> /// Combines files into a single stream /// </summary> /// <param name=\"filePaths\"></param> /// <param name=\"bundleContext\"></param> /// <returns></returns> private async Task<Stream> GetCombinedStreamAsync(IEnumerable<string> filePaths, BundleContext bundleContext) { //TODO: Here we need to be able to prepend/append based on a \"BundleContext\" (or similar) List<Stream> inputs = null; try { inputs = filePaths.Where(System.IO.File.Exists) .Select(System.IO.File.OpenRead) .Cast<Stream>() .ToList(); var delimeter = bundleContext.BundleRequest.Extension == \".js\" ? \";\" : \"\\n\"; var combined = await bundleContext.GetCombinedStreamAsync(inputs, delimeter); return combined; } finally { if (inputs != null) { foreach (var input in inputs) { input.Dispose(); } } } } }", "label": "FeatureEnvy"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class ContactReport : TBase { private string _mid; private bool _exists; private Contact _contact; public string Mid { get { return _mid; } set { __isset.mid = true; this._mid = value; } } public bool Exists { get { return _exists; } set { __isset.exists = true; this._exists = value; } } public Contact Contact { get { return _contact; } set { __isset.contact = true; this._contact = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool mid; public bool exists; public bool contact; } public ContactReport() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 1: if (field.Type == TType.String) { Mid = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 2: if (field.Type == TType.Bool) { Exists = iprot.ReadBool(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 3: if (field.Type == TType.Struct) { Contact = new Contact(); Contact.Read(iprot); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"ContactReport\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (Mid != null && __isset.mid) { field.Name = \"mid\"; field.Type = TType.String; field.ID = 1; oprot.WriteFieldBegin(field); oprot.WriteString(Mid); oprot.WriteFieldEnd(); } if (__isset.exists) { field.Name = \"exists\"; field.Type = TType.Bool; field.ID = 2; oprot.WriteFieldBegin(field); oprot.WriteBool(Exists); oprot.WriteFieldEnd(); } if (Contact != null && __isset.contact) { field.Name = \"contact\"; field.Type = TType.Struct; field.ID = 3; oprot.WriteFieldBegin(field); Contact.Write(oprot); oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"ContactReport(\"); sb.Append(\"Mid: \"); sb.Append(Mid); sb.Append(\",Exists: \"); sb.Append(Exists); sb.Append(\",Contact: \"); sb.Append(Contact== null ? \"<null>\" : Contact.ToString()); sb.Append(\")\"); return sb.ToString(); } }", "label": "FeatureEnvy"}
{"text": "public class Channel : BasicChannel { private readonly InterlockedBoolean initialized = new InterlockedBoolean(); private readonly InterlockedBoolean disposed = new InterlockedBoolean(); private readonly BehaviorSubject<BridgedChannel> bridgedChannelsSubject = new BehaviorSubject<BridgedChannel>(null); private string bridgedUUID; protected internal Channel(OutboundSocket outboundSocket) : this(outboundSocket.ChannelData, outboundSocket) { } protected internal Channel(ChannelEvent eventMessage, EventSocket eventSocket) : base(eventMessage, eventSocket) { LingerTime = 10; } internal static async Task<Channel> Create(OutboundSocket outboundSocket) { var channel = new Channel(outboundSocket); channel.ExitOnHangup = true; await outboundSocket.Linger().ConfigureAwait(false); await outboundSocket.SubscribeEvents( EventName.ChannelProgress, EventName.ChannelBridge, EventName.ChannelUnbridge, EventName.ChannelAnswer, EventName.ChannelHangup, EventName.ChannelHangupComplete, EventName.Dtmf).ConfigureAwait(false); //subscribe to minimum events await outboundSocket.Filter(HeaderNames.UniqueId, outboundSocket.ChannelData.UUID).ConfigureAwait(false); //filter for our unique id (in case using full socket mode) await outboundSocket.Filter(HeaderNames.OtherLegUniqueId, outboundSocket.ChannelData.UUID).ConfigureAwait(false); //filter for channels bridging to our unique id await outboundSocket.Filter(HeaderNames.ChannelCallUniqueId, outboundSocket.ChannelData.UUID).ConfigureAwait(false); //filter for channels bridging to our unique id channel.InitializeSubscriptions(); return channel; } ~Channel() { Dispose(false); } public IObservable<ChannelEvent> Events { get { return Socket.ChannelEvents.Where(x => x.UUID == UUID).AsObservable(); } } public IObservable<BridgedChannel> BridgedChannels { get { return bridgedChannelsSubject.Where(x => x != null).AsObservable(); } } public BridgedChannel OtherLeg => bridgedChannelsSubject.Value; public bool ExitOnHangup { get; set; } public int LingerTime { get; set; } public async Task BridgeTo(string destination, BridgeOptions options, Action<EventMessage> onProgress = null) { if (!IsAnswered && !IsPreAnswered) { return; } Log.Debug(() => \"Channel {0} is attempting a bridge to {1}\".Fmt(UUID, destination)); if (string.IsNullOrEmpty(options.UUID)) { options.UUID = Guid.NewGuid().ToString(); } var subscriptions = new CompositeDisposable(); if (onProgress != null) { subscriptions.Add( eventSocket.ChannelEvents.Where(x => x.UUID == options.UUID && x.EventName == EventName.ChannelProgress) .Take(1) .Subscribe(onProgress)); } var bridgedChannel = this.BridgedChannels.FirstAsync(x => x.UUID == options.UUID); var result = await eventSocket.Bridge(UUID, destination, options).ConfigureAwait(false); Log.Debug(() => \"Channel {0} bridge complete {1} {2}\".Fmt(UUID, result.Success, result.ResponseText)); subscriptions.Dispose(); if (result.Success) { //wait for this.OtherLeg to be set before completing await bridgedChannel; } } public Task Execute(string application, string args) { return eventSocket.ExecuteApplication(UUID, application, args); } public Task Execute(string uuid, string application, string args) { return eventSocket.ExecuteApplication(uuid, application, args); } public Task HoldToggle() { return RunIfAnswered(() => eventSocket.SendApi(\"uuid_hold toggle \" + UUID)); } public Task HoldOn() { return RunIfAnswered(() => eventSocket.SendApi(\"uuid_hold \" + UUID)); } public Task HoldOff() { return RunIfAnswered(() => eventSocket.SendApi(\"uuid_hold off \" + UUID)); } public Task Park() { return RunIfAnswered(() => eventSocket.ExecuteApplication(UUID, \"park\")); } public Task RingReady() { return eventSocket.ExecuteApplication(UUID, \"ring_ready\"); } public Task Answer() { return eventSocket.ExecuteApplication(UUID, \"answer\"); } public Task EnableHeartBeat(int intervalSeconds = 60) { return RunIfAnswered( async () => { await eventSocket.SubscribeEvents(EventName.SessionHeartbeat).ConfigureAwait(false); await eventSocket.ExecuteApplication(UUID, \"enable_heartbeat\", intervalSeconds.ToString()).ConfigureAwait(false); }, true); } public Task PreAnswer() { return eventSocket.ExecuteApplication(UUID, \"pre_answer\"); } public Task Sleep(int milliseconds) { return eventSocket.ExecuteApplication(UUID, \"sleep\", milliseconds.ToString()); } public new void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if (disposed != null && !disposed.EnsureCalledOnce()) { if (disposing) { if (!Disposables.IsDisposed) { Disposables.Dispose(); } OtherLeg?.Dispose(); bridgedChannelsSubject.Dispose(); } if (eventSocket != null && eventSocket is OutboundSocket) { // todo: should we close the socket associated with the channel here? eventSocket.Dispose(); } eventSocket = null; Log.Debug(() => \"Channel Disposed.\"); } base.Dispose(disposing); } private void InitializeSubscriptions() { if (initialized.EnsureCalledOnce()) { Log.Warn(() => \"Channel already initialized\"); return; } Disposables.Add( eventSocket.ChannelEvents.Where(x => x.UUID == UUID && x.EventName == EventName.ChannelBridge && x.OtherLegUUID != bridgedUUID) .Subscribe( async x => { Log.Info(() => \"Channel [{0}] Bridged to [{1}] CHANNEL_BRIDGE\".Fmt(UUID, x.GetHeader(HeaderNames.OtherLegUniqueId))); var apiResponse = await eventSocket.Api(\"uuid_dump\", x.OtherLegUUID); if (apiResponse.Success && apiResponse.BodyText != \"+OK\") { var eventMessage = new ChannelEvent(apiResponse); bridgedChannelsSubject.OnNext(new BridgedChannel(eventMessage, eventSocket)); } else { Log.Error(() => \"Unable to get CHANNEL_DATA info from 'api uuid_dump {0}' - received '{1}'.\".Fmt(x.OtherLegUUID, apiResponse.BodyText)); } })); Disposables.Add( eventSocket.ChannelEvents.Where(x => x.UUID == UUID && x.EventName == EventName.ChannelUnbridge && x.GetVariable(\"bridge_hangup_cause\") != null) .Subscribe( x => { /* side effects: * the att_xfer application is evil * if after speaking to C, B presses '#' to cancel, * the A channel fires an unbridge event, even though it is still bridged to B * in this case, bridge_hangup_cause will be empty so we'll ignore those events * however, this may break if this channel has had any completed bridges before this. */ Log.Info( () => \"Channel [{0}] Unbridged from [{1}] {2}\".Fmt( UUID, x.GetVariable(\"last_bridge_to\"), x.GetVariable(\"bridge_hangup_cause\"))); bridgedChannelsSubject.OnNext(null); //clears out OtherLeg })); Disposables.Add(BridgedChannels.Subscribe( async b => { if (bridgedUUID != null && bridgedUUID != b.UUID) { await eventSocket.FilterDelete(HeaderNames.UniqueId, bridgedUUID).ConfigureAwait(false); await eventSocket.FilterDelete(HeaderNames.OtherLegUniqueId, bridgedUUID).ConfigureAwait(false); await eventSocket.FilterDelete(HeaderNames.ChannelCallUniqueId, bridgedUUID).ConfigureAwait(false); } bridgedUUID = b.UUID; await eventSocket.Filter(HeaderNames.UniqueId, bridgedUUID).ConfigureAwait(false); await eventSocket.Filter(HeaderNames.OtherLegUniqueId, bridgedUUID).ConfigureAwait(false); await eventSocket.Filter(HeaderNames.ChannelCallUniqueId, bridgedUUID).ConfigureAwait(false); Log.Trace(() => \"Channel [{0}] setting OtherLeg to [{1}]\".Fmt(UUID, b.UUID)); })); Disposables.Add( eventSocket.ChannelEvents.Where( x => x.EventName == EventName.ChannelBridge && x.UUID != UUID && x.GetHeader(HeaderNames.OtherLegUniqueId) == UUID && x.UUID != bridgedUUID) .Subscribe( x => { //there is another channel out there that has bridged to us but we didn't get the CHANNEL_BRIDGE event on this channel Log.Info(() => \"Channel [{0}] bridged to [{1}]] on CHANNEL_BRIDGE received on other channel\".Fmt(UUID, x.UUID)); bridgedChannelsSubject.OnNext(new BridgedChannel(x, eventSocket)); })); if (eventSocket is OutboundSocket) { Disposables.Add( eventSocket.ChannelEvents.Where(x => x.UUID == UUID && x.EventName == EventName.ChannelHangupComplete) .Subscribe( async e => { if (ExitOnHangup) { //give event subscribers time to complete if (LingerTime > 0) { Log.Debug(() => \"Channel[{0}] will exit in {1} seconds...\".Fmt(UUID, LingerTime)); await Task.Delay(LingerTime * 1000); } if (eventSocket != null) { Log.Info(() => \"Channel [{0}] exiting\".Fmt(UUID)); await eventSocket.Exit().ConfigureAwait(false); } Dispose(); } })); } Log.Trace(() => \"Channel [{0}] subscriptions initialized\".Fmt(UUID)); } }", "label": "FeatureEnvy"}
{"text": "#if !SILVERLIGHT [Serializable] #endif public partial class buyMustbuyProduct_args : TBase { private string _receiverMid; private string _productId; private int _messageTemplate; private string _language; private string _country; private long _packageId; private string _serialNumber; public string ReceiverMid { get { return _receiverMid; } set { __isset.receiverMid = true; this._receiverMid = value; } } public string ProductId { get { return _productId; } set { __isset.productId = true; this._productId = value; } } public int MessageTemplate { get { return _messageTemplate; } set { __isset.messageTemplate = true; this._messageTemplate = value; } } public string Language { get { return _language; } set { __isset.language = true; this._language = value; } } public string Country { get { return _country; } set { __isset.country = true; this._country = value; } } public long PackageId { get { return _packageId; } set { __isset.packageId = true; this._packageId = value; } } public string SerialNumber { get { return _serialNumber; } set { __isset.serialNumber = true; this._serialNumber = value; } } public Isset __isset; #if !SILVERLIGHT [Serializable] #endif public struct Isset { public bool receiverMid; public bool productId; public bool messageTemplate; public bool language; public bool country; public bool packageId; public bool serialNumber; } public buyMustbuyProduct_args() { } public void Read (TProtocol iprot) { TField field; iprot.ReadStructBegin(); while (true) { field = iprot.ReadFieldBegin(); if (field.Type == TType.Stop) { break; } switch (field.ID) { case 2: if (field.Type == TType.String) { ReceiverMid = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 3: if (field.Type == TType.String) { ProductId = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 4: if (field.Type == TType.I32) { MessageTemplate = iprot.ReadI32(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 5: if (field.Type == TType.String) { Language = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 6: if (field.Type == TType.String) { Country = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 7: if (field.Type == TType.I64) { PackageId = iprot.ReadI64(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; case 8: if (field.Type == TType.String) { SerialNumber = iprot.ReadString(); } else { TProtocolUtil.Skip(iprot, field.Type); } break; default: TProtocolUtil.Skip(iprot, field.Type); break; } iprot.ReadFieldEnd(); } iprot.ReadStructEnd(); } public void Write(TProtocol oprot) { TStruct struc = new TStruct(\"buyMustbuyProduct_args\"); oprot.WriteStructBegin(struc); TField field = new TField(); if (ReceiverMid != null && __isset.receiverMid) { field.Name = \"receiverMid\"; field.Type = TType.String; field.ID = 2; oprot.WriteFieldBegin(field); oprot.WriteString(ReceiverMid); oprot.WriteFieldEnd(); } if (ProductId != null && __isset.productId) { field.Name = \"productId\"; field.Type = TType.String; field.ID = 3; oprot.WriteFieldBegin(field); oprot.WriteString(ProductId); oprot.WriteFieldEnd(); } if (__isset.messageTemplate) { field.Name = \"messageTemplate\"; field.Type = TType.I32; field.ID = 4; oprot.WriteFieldBegin(field); oprot.WriteI32(MessageTemplate); oprot.WriteFieldEnd(); } if (Language != null && __isset.language) { field.Name = \"language\"; field.Type = TType.String; field.ID = 5; oprot.WriteFieldBegin(field); oprot.WriteString(Language); oprot.WriteFieldEnd(); } if (Country != null && __isset.country) { field.Name = \"country\"; field.Type = TType.String; field.ID = 6; oprot.WriteFieldBegin(field); oprot.WriteString(Country); oprot.WriteFieldEnd(); } if (__isset.packageId) { field.Name = \"packageId\"; field.Type = TType.I64; field.ID = 7; oprot.WriteFieldBegin(field); oprot.WriteI64(PackageId); oprot.WriteFieldEnd(); } if (SerialNumber != null && __isset.serialNumber) { field.Name = \"serialNumber\"; field.Type = TType.String; field.ID = 8; oprot.WriteFieldBegin(field); oprot.WriteString(SerialNumber); oprot.WriteFieldEnd(); } oprot.WriteFieldStop(); oprot.WriteStructEnd(); } public override string ToString() { StringBuilder sb = new StringBuilder(\"buyMustbuyProduct_args(\"); sb.Append(\"ReceiverMid: \"); sb.Append(ReceiverMid); sb.Append(\",ProductId: \"); sb.Append(ProductId); sb.Append(\",MessageTemplate: \"); sb.Append(MessageTemplate); sb.Append(\",Language: \"); sb.Append(Language); sb.Append(\",Country: \"); sb.Append(Country); sb.Append(\",PackageId: \"); sb.Append(PackageId); sb.Append(\",SerialNumber: \"); sb.Append(SerialNumber); sb.Append(\")\"); return sb.ToString(); } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// 建造のレコードです。 /// </summary> [DebuggerDisplay(\"{Record.Count} Records\")] public class DevelopmentRecord : RecordBase { [DebuggerDisplay(\"[{EquipmentID}] : {EquipmentName}\")] public sealed class DevelopmentElement : RecordElementBase { /// <summary> /// 開発した装備のID /// </summary> public int EquipmentID { get; set; } /// <summary> /// 開発した装備の名前 /// </summary> public string EquipmentName { get; set; } /// <summary> /// 開発日時 /// </summary> public DateTime Date { get; set; } /// <summary> /// 投入燃料 /// </summary> public int Fuel { get; set; } /// <summary> /// 投入弾薬 /// </summary> public int Ammo { get; set; } /// <summary> /// 投入鋼材 /// </summary> public int Steel { get; set; } /// <summary> /// 投入ボーキサイト /// </summary> public int Bauxite { get; set; } /// <summary> /// 旗艦の艦船ID /// </summary> public int FlagshipID { get; set; } /// <summary> /// 旗艦の艦名 /// </summary> public string FlagshipName { get; set; } /// <summary> /// 旗艦の艦種 /// </summary> public int FlagshipType { get; set; } /// <summary> /// 司令部Lv. /// </summary> public int HQLevel { get; set; } public DevelopmentElement() { EquipmentID = -1; Date = DateTime.Now; } public DevelopmentElement(string line) : this() { LoadLine(line); } public DevelopmentElement(int equipmentID, int fuel, int ammo, int steel, int bauxite, int flagshipID, int hqLevel) { EquipmentID = equipmentID; Fuel = fuel; Ammo = ammo; Steel = steel; Bauxite = bauxite; FlagshipID = flagshipID; HQLevel = hqLevel; SetSubParameters(); } public override void LoadLine(string line) { string[] elem = CsvHelper.ParseCsvLine(line).ToArray(); if (elem.Length < 11) throw new ArgumentException(\"要素数が少なすぎます。\"); EquipmentID = int.Parse(elem[0]); EquipmentName = elem[1]; Date = DateTimeHelper.CSVStringToTime(elem[2]); Fuel = int.Parse(elem[3]); Ammo = int.Parse(elem[4]); Steel = int.Parse(elem[5]); Bauxite = int.Parse(elem[6]); FlagshipID = int.Parse(elem[7]); FlagshipName = elem[8]; FlagshipType = int.Parse(elem[9]); HQLevel = int.Parse(elem[10]); } public override string SaveLine() { return string.Join(\",\", EquipmentID, CsvHelper.EscapeCsvCell(EquipmentName), DateTimeHelper.TimeToCSVString(Date), Fuel, Ammo, Steel, Bauxite, FlagshipID, CsvHelper.EscapeCsvCell(FlagshipName), FlagshipType, HQLevel); } /// <summary> /// 艦名などのパラメータを現在のIDをもとに設定します。 /// </summary> public void SetSubParameters() { var eq = KCDatabase.Instance.MasterEquipments[EquipmentID]; var flagship = KCDatabase.Instance.MasterShips[FlagshipID]; EquipmentName = EquipmentID == -1 ? \"(失敗)\" : eq?.Name ?? \"???\"; FlagshipName = flagship?.NameWithClass ?? \"???\"; FlagshipType = (int?)flagship?.ShipType ?? -1; } } public List<DevelopmentElement> Record { get; private set; } private DevelopmentElement tempElement; private int LastSavedCount; public DevelopmentRecord() { Record = new List<DevelopmentElement>(); tempElement = null; } public override void RegisterEvents() { APIObserver ao = APIObserver.Instance; ao.APIList[\"api_req_kousyou/createitem\"].RequestReceived += DevelopmentStart; ao.APIList[\"api_req_kousyou/createitem\"].ResponseReceived += DevelopmentEnd; } public DevelopmentElement this[int i] { get { return Record[i]; } set { Record[i] = value; } } private void DevelopmentStart(string apiname, dynamic data) { tempElement = new DevelopmentElement { Fuel = int.Parse(data[\"api_item1\"]), Ammo = int.Parse(data[\"api_item2\"]), Steel = int.Parse(data[\"api_item3\"]), Bauxite = int.Parse(data[\"api_item4\"]) }; } private void DevelopmentEnd(string apiname, dynamic data) { if (tempElement == null) return; if ((int)data.api_create_flag == 0) { tempElement.EquipmentID = -1; } else { tempElement.EquipmentID = (int)data.api_slot_item.api_slotitem_id; } ShipData flagship = KCDatabase.Instance.Fleet[1].MembersInstance[0]; tempElement.FlagshipID = flagship.ShipID; tempElement.HQLevel = KCDatabase.Instance.Admiral.Level; tempElement.SetSubParameters(); Record.Add(tempElement); tempElement = null; } protected override void LoadLine(string line) { Record.Add(new DevelopmentElement(line)); } protected override string SaveLinesAll() { var sb = new StringBuilder(); foreach (var elem in Record.OrderBy(r => r.Date)) { sb.AppendLine(elem.SaveLine()); } return sb.ToString(); } protected override string SaveLinesPartial() { var sb = new StringBuilder(); foreach (var elem in Record.Skip(LastSavedCount).OrderBy(r => r.Date)) { sb.AppendLine(elem.SaveLine()); } return sb.ToString(); } protected override void UpdateLastSavedIndex() { LastSavedCount = Record.Count; } public override bool NeedToSave => LastSavedCount < Record.Count; public override bool SupportsPartialSave => true; protected override void ClearRecord() { Record.Clear(); LastSavedCount = 0; } public override string RecordHeader => \"装備ID,装備名,開発日時,燃料,弾薬,鋼材,ボーキ,旗艦ID,旗艦名,旗艦艦種,司令部Lv\"; public override string FileName => \"DevelopmentRecord.csv\"; }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Interaction logic for Preferences.xaml /// </summary> public partial class Preferences : Window { Settings local; public Theme[] theme_list = new Theme[] { Theme.Aero, Theme.Aero2, Theme.Classic, Theme.Luna, Theme.Royale }; public string[] TrayIconBehaviorsReadable = new string[] { \"Show/Hide ByteFlood\", \"Show context menu\", \"Do nothing\" }; public TrayIconBehavior[] TrayIconBehaviors = (TrayIconBehavior[])Enum.GetValues(typeof(TrayIconBehavior)); public string[] WindowBehaviorsReadable = new string[] { \"Minimize to tray\", \"Minimize to taskbar\", \"Exit\" }; public WindowBehavior[] WindowBehaviors = (WindowBehavior[])Enum.GetValues(typeof(WindowBehavior)); public ComboBox[] TrayIconComboBoxes; public ComboBox[] WindowComboBoxes; public string[] EncryptionTypesReadable = new string[] { \"Forced\", \"Preferred\", \"Doesn't matter\" }; public Preferences() { InitializeComponent(); } private void Window_Loaded(object sender, RoutedEventArgs e) { local = (Settings)Utility.CloneObject(App.Settings); this.DataContext = local; this.themeCombox.ItemsSource = theme_list; this.themeCombox.SelectedItem = local.Theme; TrayIconComboBoxes = new ComboBox[] { tcb, tdcb, trcb }; WindowComboBoxes = new ComboBox[] { mb, cb }; Utility.SetItemsSource<ComboBox>(TrayIconComboBoxes, TrayIconBehaviorsReadable); Utility.SetItemsSource<ComboBox>(WindowComboBoxes, WindowBehaviorsReadable); enctype.ItemsSource = EncryptionTypesReadable; LoadNetworkInterfaces(); styleCombox.SelectedIndex = local.ApplicationStyle; styleCombox.SelectionChanged += this.ReloadStyle; LoadLangs(); } private void LoadNetworkInterfaces() { foreach (var iface in Utility.GetValidNetworkInterfaces()) { ComboBoxItem bi = new ComboBoxItem(); bi.Content = iface.Name; bi.Tag = iface; interfaces.Items.Add(bi); if (iface.Id == local.NetworkInterfaceID) { interfaces.SelectedItem = bi; } } if (interfaces.SelectedIndex == -1) { interfaces.SelectedIndex = 0; } interfaces.SelectionChanged += interfaces_SelectionChanged; } private void LoadLangs() { string[] langs = Utility.GetAvailableLanguages(); this.langCombox.ItemsSource = langs; this.langCombox.SelectedIndex = Array.IndexOf(langs, App.Settings.DefaultLanguage); } void interfaces_SelectionChanged(object sender, SelectionChangedEventArgs e) { ComboBoxItem bi = interfaces.SelectedItem as ComboBoxItem; var iface = bi.Tag as System.Net.NetworkInformation.NetworkInterface; local.NetworkInterfaceID = iface.Id; if (iface.OperationalStatus != System.Net.NetworkInformation.OperationalStatus.Up) { iface_error.Visibility = Visibility.Visible; } else { iface_error.Visibility = Visibility.Collapsed; } } private void UpdateDataContext(Settings s) { this.DataContext = s; this.themeCombox.SelectedItem = s == null ? Theme.Aero2 : s.Theme; } private void SelectDownloadColor(object sender, RoutedEventArgs e) { local.DownloadColor = GetNewColor(local.DownloadColor); downcolor.GetBindingExpression(Button.BackgroundProperty).UpdateTarget(); } public Color GetNewColor(Color current) { ColorDialog cd = new ColorDialog(); cd.Color = current.ToWinFormColor(); cd.AllowFullOpen = true; cd.FullOpen = true; cd.SolidColorOnly = true; cd.ShowDialog(); return cd.Color.ToWPFColor(); } private void SelectUploadColor(object sender, RoutedEventArgs e) { local.UploadColor = GetNewColor(local.UploadColor); upcolor.GetBindingExpression(Button.BackgroundProperty).UpdateTarget(); } private void PickPath(object sender, RoutedEventArgs e) { string new_path = Utility.PromptFolderSelection(\"Choose default download path\", local.DefaultDownloadPath, this); if (new_path != null) { local.DefaultDownloadPath = new_path; downpath.GetBindingExpression(TextBox.TextProperty).UpdateTarget(); } } private void ImportTorrents(object sender, RoutedEventArgs e) { MainWindow mw = (App.Current.MainWindow as MainWindow); if (!mw.ImportTorrents()) { MessageBox.Show(\"resume.dat not found! You either have no torrents or have not installed uTorrent.\", \"Error\", MessageBoxButton.OK, MessageBoxImage.Error); } } private void ReloadTheme(object sender, SelectionChangedEventArgs e) { var t = (Theme)themeCombox.SelectedItem; Utility.ReloadTheme(t); } private void ChangeDefaultSettings(object sender, RoutedEventArgs e) { var editor = new TorrentPropertiesEditor(local.DefaultTorrentProperties) { Owner = this, Icon = this.Icon }; editor.ShowDialog(); } private void SaveSettings(object sender, RoutedEventArgs e) { local.TrayIconClickBehavior = TrayIconBehaviors[tcb.SelectedIndex]; local.TrayIconRightClickBehavior = TrayIconBehaviors[trcb.SelectedIndex]; local.TrayIconDoubleClickBehavior = TrayIconBehaviors[tdcb.SelectedIndex]; local.MinimizeBehavior = WindowBehaviors[mb.SelectedIndex]; local.ExitBehavior = WindowBehaviors[cb.SelectedIndex]; local.EncryptionType = (EncryptionTypeEnum)enctype.SelectedIndex; MainWindow mw = (App.Current.MainWindow as MainWindow); local.Theme = (Theme)themeCombox.SelectedItem; if (this.langCombox.SelectedIndex > -1) { string new_choice = this.langCombox.SelectedValue.ToString(); if (new_choice != local.DefaultLanguage) { local.DefaultLanguage = new_choice; if (App.CurrentLanguage != null) { App.CurrentLanguage.ReloadLang(local.DefaultLanguage); } else { App.CurrentLanguage = LanguageEngine.LoadDefault(); } } } if (local.CheckForUpdates) { mw.StartAutoUpdater(); } else { mw.StopAutoUpdater(); } if (local.EnableDHT) mw.state.LibtorrentSession.StartDht(); else mw.state.LibtorrentSession.StopDht(); if (local.EnableLSD) mw.state.LibtorrentSession.StartLsd(); else mw.state.LibtorrentSession.StopLsd(); if (local.EnableNAT_PMP) mw.state.LibtorrentSession.StartNatPmp(); else mw.state.LibtorrentSession.StopNatPmp(); if (local.Enable_UPNP) mw.state.LibtorrentSession.StartUpnp(); else mw.state.LibtorrentSession.StopUpnp(); App.Settings = (Settings)Utility.CloneObject(local); this.Close(); } private void DiscardSettings(object sender, RoutedEventArgs e) { this.Close(); } private void ResetToDefaultSettings(object sender, RoutedEventArgs e) { local = (Settings)Utility.CloneObject(Settings.DefaultSettings); UpdateDataContext(null); UpdateDataContext(local); } private void AssociateFiles(object sender, RoutedEventArgs e) { Utility.FileAssociate(); Utility.MagnetAssociate(); } private void RefreshNetworkInterfaces(object sender, RoutedEventArgs e) { interfaces.SelectionChanged -= interfaces_SelectionChanged; interfaces.Items.Clear(); LoadNetworkInterfaces(); } private void ReloadStyle(object sender, SelectionChangedEventArgs e) { ComboBox s = (sender as ComboBox); if (s != null) { (App.Current.MainWindow as MainWindow).UpdateAppStyle(s.SelectedIndex); local.ApplicationStyle = s.SelectedIndex; } } }", "label": "ComplexConditional"}
{"text": "class Program { public static AriClient ActionClient; public static Bridge SimpleBridge; private const string AppName = \"bridge_test\"; static void Main(string[] args) { try { // Create a message actionClient to receive events on ActionClient = new AriClient(new StasisEndpoint(\"127.0.0.1\", 8088, \"dev\", \"test\"), AppName); ActionClient.OnStasisStartEvent += c_OnStasisStartEvent; ActionClient.OnStasisEndEvent += c_OnStasisEndEvent; ActionClient.Connect(); // Create simple bridge SimpleBridge = ActionClient.Bridges.Create(\"mixing\", Guid.NewGuid().ToString(), AppName); // subscribe to bridge events ActionClient.Applications.Subscribe(AppName, \"bridge:\" + SimpleBridge.Id); // start MOH on bridge ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\"); var done = false; while (!done) { var lastKey = Console.ReadKey(); switch(lastKey.KeyChar.ToString()) { case \"*\": done = true; break; case \"1\": ActionClient.Bridges.StopMoh(SimpleBridge.Id); break; case \"2\": ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\"); break; case \"3\": // Mute all channels on bridge var bridgeMute = ActionClient.Bridges.Get(SimpleBridge.Id); foreach (var chan in bridgeMute.Channels) ActionClient.Channels.Mute(chan, \"in\"); break; case \"4\": // Unmute all channels on bridge var bridgeUnmute = ActionClient.Bridges.Get(SimpleBridge.Id); foreach (var chan in bridgeUnmute.Channels) ActionClient.Channels.Unmute(chan, \"in\"); break; } } ActionClient.Bridges.Destroy(SimpleBridge.Id); ActionClient.Disconnect(); } catch (Exception ex) { Console.WriteLine(ex.ToString()); Console.ReadKey(); } } static void c_OnStasisEndEvent(object sender, AsterNET.ARI.Models.StasisEndEvent e) { // remove from bridge ActionClient.Bridges.RemoveChannel(SimpleBridge.Id, e.Channel.Id); // hangup ActionClient.Channels.Hangup(e.Channel.Id, \"normal\"); } static void c_OnStasisStartEvent(object sender, AsterNET.ARI.Models.StasisStartEvent e) { // answer channel ActionClient.Channels.Answer(e.Channel.Id); // add to bridge ActionClient.Bridges.AddChannel(SimpleBridge.Id, e.Channel.Id, \"member\"); } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// TODO this class is deprecated by virtue of StreamingInputStage. Still used by Reporting, but that can be fixed. /// </summary> internal class InputStage<TRecord> : InputStage, IObserver<IEnumerable<TRecord>>, IObserver<TRecord> { private readonly KeyValuePair<int,InputVertex<TRecord>>[] localVertices; internal InputVertex<TRecord> GetInputVertex(int vertexId) { foreach (var vertex in localVertices) if (vertexId == vertex.Key) return vertex.Value; throw new Exception(String.Format(\"Vertex {0} not found in Input {1} on Process {2}\", vertexId, stage.StageId, stage.InternalComputation.Controller.Configuration.ProcessID)); } public int InputId { get { return this.stage.StageId; } } private int currentEpoch; private bool completedCalled; public bool Completed { get { return this.completedCalled; } } private bool hasActivatedProgressTracker; private readonly Stream<TRecord, Epoch> output; public Stream<TRecord, Epoch> Stream { get { return output; } } public static implicit operator Stream<TRecord, Epoch>(InputStage<TRecord> stage) { return stage.Stream; } public TimeContext<Epoch> Context { get { return this.stage.Context; } } internal InternalComputation InternalComputation { get { return this.stage.InternalComputation; } } public Placement Placement { get { return this.stage.Placement; } } private readonly string inputName; public string InputName { get { return this.inputName; } } private readonly Stage<InputVertex<TRecord>, Epoch> stage; internal InputStage(Placement placement, InternalComputation internalComputation, string inputName) { this.inputName = inputName; stage = Foundry.NewStage(new TimeContext<Epoch>(internalComputation.ContextManager.RootContext), (i, v) => new InputVertex<TRecord>(i, v), this.inputName); this.output = stage.NewOutput(vertex => vertex.Output); stage.Materialize(); this.localVertices = placement.Where(x => x.ProcessId == internalComputation.Controller.Configuration.ProcessID) .Select(x => new KeyValuePair<int, InputVertex<TRecord>>(x.VertexId, stage.GetVertex(x.VertexId) as InputVertex<TRecord>)) .ToArray(); this.completedCalled = false; this.hasActivatedProgressTracker = false; this.currentEpoch = 0; // results in pointstamps comparisons which assert w/o this. this.InternalComputation.Reachability.UpdateReachabilityPartialOrder(internalComputation); this.InternalComputation.Reachability.DoNotImpersonate(stage.StageId); var initialVersion = new Runtime.Progress.Pointstamp(stage.StageId, new int[] { 0 }); //if (this.Controller.Configuration.Impersonation) //{ // foreach (var version in Reachability.EnumerateImpersonations(initialVersion)) // controller.BroadcastUpdate(version, placement.Count); //} //else internalComputation.ProgressTracker.BroadcastProgressUpdate(initialVersion, placement.Count); } private void EnsureProgressTrackerActivated() { if (!this.hasActivatedProgressTracker) { stage.InternalComputation.Activate(); this.hasActivatedProgressTracker = true; } } public void OnNext() { this.OnNext(new TRecord[] { }); } public void OnNext(TRecord record) { this.OnNext(new[] { record }); } public void OnNext(IEnumerable<TRecord> batch) { //Debug.Assert(!this.completedCalled); this.EnsureProgressTrackerActivated(); var array = batch == null ? new TRecord[] { } : batch.ToArray(); lock (this) { var arrayCursor = 0; for (int i = 0; i < this.localVertices.Length; i++) { var toEat = (array.Length / this.localVertices.Length) + ((i < (array.Length % this.localVertices.Length)) ? 1 : 0); var chunk = new TRecord[toEat]; Array.Copy(array, arrayCursor, chunk, 0, toEat); arrayCursor += toEat; this.localVertices[i].Value.OnNext(chunk); } ++this.currentEpoch; } } public void OnCompleted() { //Debug.Assert(!this.completedCalled); if (!this.completedCalled) { this.EnsureProgressTrackerActivated(); this.completedCalled = true; for (int i = 0; i < this.localVertices.Length; i++) this.localVertices[i].Value.OnCompleted(); } } public void OnCompleted(TRecord record) { this.OnCompleted(new[] { record }); } public void OnCompleted(IEnumerable<TRecord> batch) { if (!this.completedCalled) { this.EnsureProgressTrackerActivated(); this.completedCalled = true; var array = batch == null ? new TRecord[] { } : batch.ToArray(); lock (this) { ++this.currentEpoch; var arrayCursor = 0; for (int i = 0; i < this.localVertices.Length; i++) { var toEat = (array.Length / this.localVertices.Length) + ((i < (array.Length % this.localVertices.Length)) ? 1 : 0); var chunk = new TRecord[toEat]; Array.Copy(array, arrayCursor, chunk, 0, toEat); arrayCursor += toEat; this.localVertices[i].Value.OnCompleted(chunk); } } } } public void OnError(Exception error) { throw error; } public bool IsCompleted { get { return this.completedCalled; } } public int CurrentEpoch { get { return this.currentEpoch; } } public int MaximumValidEpoch { get { return this.currentEpoch - 1; } } public void Checkpoint(NaiadWriter writer) { writer.Write(currentEpoch, this.InternalComputation.SerializationFormat.GetSerializer<int>()); writer.Write(completedCalled, this.InternalComputation.SerializationFormat.GetSerializer<bool>()); writer.Write(hasActivatedProgressTracker, this.InternalComputation.SerializationFormat.GetSerializer<bool>()); } public void Restore(NaiadReader reader) { this.currentEpoch = reader.Read<int>(this.InternalComputation.SerializationFormat.GetSerializer<int>()); this.completedCalled = reader.Read<bool>(this.InternalComputation.SerializationFormat.GetSerializer<bool>()); this.hasActivatedProgressTracker = reader.Read<bool>(this.InternalComputation.SerializationFormat.GetSerializer<bool>()); } public bool Stateful { get { return true; } } public override string ToString() { return string.Format(\"{0} (current epoch = {1})\", base.ToString(), this.currentEpoch); } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Summary description for DeflaterOutputStream. /// </summary> [Obsolete(\"Use 'ZInputStream' instead\")] public class ZInflaterInputStream : Stream { protected ZStream z=new ZStream(); protected int flushLevel=JZlib.Z_NO_FLUSH; private const int BUFSIZE = 4192; protected byte[] buf=new byte[BUFSIZE]; private byte[] buf1=new byte[1]; protected Stream inp=null; private bool nomoreinput=false; public ZInflaterInputStream(Stream inp) : this(inp, false) { } public ZInflaterInputStream(Stream inp, bool nowrap) { this.inp=inp; z.inflateInit(nowrap); z.next_in=buf; z.next_in_index=0; z.avail_in=0; } public override bool CanRead { get { // TODO: Add DeflaterOutputStream.CanRead getter implementation return true; } } public override bool CanSeek { get { // TODO: Add DeflaterOutputStream.CanSeek getter implementation return false; } } public override bool CanWrite { get { // TODO: Add DeflaterOutputStream.CanWrite getter implementation return false; } } public override long Length { get { // TODO: Add DeflaterOutputStream.Length getter implementation return 0; } } public override long Position { get { // TODO: Add DeflaterOutputStream.Position getter implementation return 0; } set { // TODO: Add DeflaterOutputStream.Position setter implementation } } public override void Write(byte[] b, int off, int len) { } public override long Seek(long offset, SeekOrigin origin) { // TODO: Add DeflaterOutputStream.Seek implementation return 0; } public override void SetLength(long value) { // TODO: Add DeflaterOutputStream.SetLength implementation } public override int Read(byte[] b, int off, int len) { if(len==0) return(0); int err; z.next_out=b; z.next_out_index=off; z.avail_out=len; do { if((z.avail_in==0)&&(!nomoreinput)) { // if buffer is empty and more input is avaiable, refill it z.next_in_index=0; z.avail_in=inp.Read(buf, 0, BUFSIZE);//(BUFSIZE<z.avail_out ? BUFSIZE : z.avail_out)); if(z.avail_in<=0) { z.avail_in=0; nomoreinput=true; } } err=z.inflate(flushLevel); if(nomoreinput&&(err==JZlib.Z_BUF_ERROR)) return(0); if(err!=JZlib.Z_OK && err!=JZlib.Z_STREAM_END) throw new IOException(\"inflating: \"+z.msg); if((nomoreinput||err==JZlib.Z_STREAM_END)&&(z.avail_out==len)) return(0); } while(z.avail_out==len&&err==JZlib.Z_OK); //System.err.print(\"(\"+(len-z.avail_out)+\")\"); return(len-z.avail_out); } public override void Flush() { inp.Flush(); } public override void WriteByte(byte b) { } public override void Close() { inp.Close(); } public override int ReadByte() { if(Read(buf1, 0, 1)<=0) return -1; return(buf1[0]&0xFF); } }", "label": "FeatureEnvy"}
{"text": "public class DataGridViewLiveOutput : DataGridView { private List<string> idsList = new List<string>(); private readonly List<StatusInfo> ListStatus = new List<StatusInfo>(); private static SortableBindingList<LiveOutputEntry> _MyObservLiveOutputs; private static int _itemssperpage = 50; //nb of items per page private static readonly int _pagecount = 1; private static int _currentpage = 1; private static bool _initialized = false; private static bool _refreshedatleastonetime = false; private static string _statefilter = \"All\"; private static SearchObject _searchinname = new SearchObject { SearchType = SearchIn.LiveOutputName, Text = string.Empty }; private static string _timefilter = FilterTime.LastWeek; private static TimeRangeValue _timefilterTimeRange = new TimeRangeValue(DateTime.Now.ToLocalTime().AddDays(-7).Date, null); private static BackgroundWorker WorkerRefreshChannels; public string _published = \"Published\"; private static readonly Bitmap Streaminglocatorimage = Bitmaps.streaming_locator; private static enumDisplayProgram _anyChannel = enumDisplayProgram.Selected; private AMSClientV3 _client; public List<string> LiveEventSourceNames { get => idsList; set => idsList = value; } public int ItemsPerPage { get => _itemssperpage; set => _itemssperpage = value; } public int PageCount => _pagecount; public int CurrentPage => _currentpage; public enumDisplayProgram DisplayLiveEvent { get => _anyChannel; set => _anyChannel = value; } public string FilterState { get => _statefilter; set => _statefilter = value; } public SearchObject SearchInName { get => _searchinname; set => _searchinname = value; } public bool Initialized => _initialized; public string TimeFilter { get => _timefilter; set => _timefilter = value; } public TimeRangeValue TimeFilterTimeRange { get => _timefilterTimeRange; set => _timefilterTimeRange = value; } public int DisplayedCount => _MyObservLiveOutputs != null ? _MyObservLiveOutputs.Count() : 0; public void Init(AMSClientV3 client) { IEnumerable<LiveOutputEntry> programquery; client.RefreshTokenIfNeeded(); _client = client; _client.RefreshTokenIfNeeded(); List<LiveEvent> ListEvents = _client.AMSclient.LiveEvents.List(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName).ToList(); List<Program.LiveOutputExt> LOList = new List<Program.LiveOutputExt>(); foreach (LiveEvent le in ListEvents) { List<LiveOutput> plist = _client.AMSclient.LiveOutputs.List(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, le.Name).ToList(); plist.ForEach(p => LOList.Add(new Program.LiveOutputExt() { LiveOutputItem = p, LiveEventName = le.Name })); } programquery = from c in (LOList.Take(0)) //orderby c.LastModified descending select new LiveOutputEntry { Name = c.LiveOutputItem.Name, State = c.LiveOutputItem.ResourceState, Description = c.LiveOutputItem.Description, ArchiveWindowLength = c.LiveOutputItem.ArchiveWindowLength, LastModified = c.LiveOutputItem.LastModified != null ? (DateTime?)((DateTime)c.LiveOutputItem.LastModified).ToLocalTime() : null, Published = null, LiveEventName = c.LiveEventName }; DataGridViewCellStyle cellstyle = new DataGridViewCellStyle() { NullValue = null, Alignment = DataGridViewContentAlignment.MiddleCenter }; DataGridViewImageColumn imageCol = new DataGridViewImageColumn() { DefaultCellStyle = cellstyle, Name = _published, DataPropertyName = _published, }; Columns.Add(imageCol); SortableBindingList<LiveOutputEntry> MyObservProgramInPage = new SortableBindingList<LiveOutputEntry>(programquery.Take(0).ToList()); DataSource = MyObservProgramInPage; //this.Columns[\"LiveEventName\"].Visible = false; Columns[_published].DisplayIndex = ColumnCount - 3; Columns[_published].DefaultCellStyle.NullValue = null; Columns[_published].HeaderText = _published; Columns[\"LastModified\"].Width = 130; Columns[\"LastModified\"].HeaderText = \"Last modified\"; Columns[\"Description\"].Width = 150; Columns[\"ArchiveWindowLength\"].Width = 130; Columns[\"ArchiveWindowLength\"].HeaderText = \"Archive window\"; Columns[\"LiveEventName\"].HeaderText = \"Live event name\"; WorkerRefreshChannels = new BackgroundWorker { WorkerSupportsCancellation = true }; WorkerRefreshChannels.DoWork += new System.ComponentModel.DoWorkEventHandler(WorkerRefreshChannels_DoWork); _initialized = true; } public void DisplayPage(int page) { if (!_initialized) { return; } if (!_refreshedatleastonetime) { return; } if ((page <= _pagecount) && (page > 0)) { _currentpage = page; DataSource = new BindingList<LiveOutputEntry>(_MyObservLiveOutputs.Skip(_itemssperpage * (page - 1)).Take(_itemssperpage).ToList()); } } public void RefreshProgram(string liveeventName, LiveOutput program) { int index = -1; if (_MyObservLiveOutputs != null) { foreach (LiveOutputEntry CE in _MyObservLiveOutputs) // let's search for index { if (CE.Name == program.Name) { index = _MyObservLiveOutputs.IndexOf(CE); break; } } } if (index >= 0) // we found it { // we update the observation collection _client.RefreshTokenIfNeeded(); program = _client.AMSclient.LiveOutputs.Get(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, liveeventName, program.Name); //refresh if (program != null) { try // sometimes, index could be wrong id program has been deleted { _MyObservLiveOutputs[index].State = program.ResourceState; _MyObservLiveOutputs[index].Description = program.Description; _MyObservLiveOutputs[index].ArchiveWindowLength = program.ArchiveWindowLength; _MyObservLiveOutputs[index].LastModified = program.LastModified != null ? (DateTime?)((DateTime)program.LastModified).ToLocalTime() : null; Refresh(); } catch { } } } } private void WorkerRefreshChannels_DoWork(object sender, DoWorkEventArgs e) { Debug.WriteLine(\"WorkerRefreshChannels_DoWork\"); BackgroundWorker worker = sender as BackgroundWorker; LiveOutput liveOutputItem; _client.RefreshTokenIfNeeded(); foreach (LiveOutputEntry CE in _MyObservLiveOutputs) { liveOutputItem = null; try { liveOutputItem = _client.AMSclient.LiveOutputs.Get(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, CE.LiveEventName, CE.Name); if (liveOutputItem != null) { CE.State = liveOutputItem.ResourceState; BeginInvoke(new Action(() => Refresh()), null); } } catch // in some case, we have a timeout on Assets.Where... { } if (worker.CancellationPending == true) { e.Cancel = true; return; } } BeginInvoke(new Action(() => Refresh()), null); } private void RefreshPrograms() // all assets are refreshed { Task.Run(async () => await RefreshLiveOutputsAsync(_currentpage)); } public async Task RefreshLiveOutputsAsync(int pagetodisplay) // all assets are refreshed { if (!_initialized) { return; } if (idsList.Count == 0) { return; } Debug.WriteLine(\"RefreshPrograms : start\"); BeginInvoke(new Action(() => FindForm().Cursor = Cursors.WaitCursor)); await _client.RefreshTokenIfNeededAsync(); IEnumerable<LiveEvent> ListEvents; if (_anyChannel == enumDisplayProgram.None) { ListEvents = new List<LiveEvent>(); } else { ListEvents = (await _client.AMSclient.LiveEvents.ListAsync(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName)) .ToList() .Where(l => _anyChannel == enumDisplayProgram.Any || (_anyChannel == enumDisplayProgram.Selected && LiveEventSourceNames.Contains(l.Name))); } List<Program.LiveOutputExt> LOList = new List<Program.LiveOutputExt>(); foreach (LiveEvent le in ListEvents) { List<LiveOutput> plist = (await _client.AMSclient.LiveOutputs.ListAsync(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, le.Name)) .ToList(); plist.ForEach(p => LOList.Add(new Program.LiveOutputExt() { LiveOutputItem = p, LiveEventName = le.Name })); } IEnumerable<LiveOutputEntry> programquery = from c in (LOList) //orderby c.LastModified descending select new LiveOutputEntry { Name = c.LiveOutputItem.Name, State = c.LiveOutputItem.ResourceState, Description = c.LiveOutputItem.Description, ArchiveWindowLength = c.LiveOutputItem.ArchiveWindowLength, LastModified = c.LiveOutputItem.LastModified != null ? (DateTime?)((DateTime)c.LiveOutputItem.LastModified).ToLocalTime() : null, Published = DataGridViewAssets.BuildBitmapPublication(c.LiveOutputItem.AssetName, _client).bitmap, LiveEventName = c.LiveEventName }; _MyObservLiveOutputs = new SortableBindingList<LiveOutputEntry>(programquery.ToList()); BeginInvoke(new Action(() => DataSource = _MyObservLiveOutputs)); _refreshedatleastonetime = true; BeginInvoke(new Action(() => FindForm().Cursor = Cursors.Default)); Debug.WriteLine(\"RefreshPrograms : end\"); } }", "label": "FeatureEnvy"}
{"text": "internal class CachedPropertyDictionary : IPropertyDictionary { private Dictionary<PropertyKey, object> _properties; private IPropertyStore _propertyStoreInteface; public CachedPropertyDictionary() { ComThread.Assert(); _properties = new Dictionary<PropertyKey, object>(); } public AccessMode Mode { get; private set; } public int Count => _properties?.Count ?? 0; public object this[PropertyKey key] { get { if (_properties.ContainsKey(key)) return _properties[key]; return null; } set { if (Mode == AccessMode.Read) return; SetValue(key, value); } } public bool Contains(PropertyKey key) { return _properties.ContainsKey(key); } public void Dispose() { _properties = null; ComThread.BeginInvoke(() => { _propertyStoreInteface = null; }); } /// <summary> /// Will attempt to load the properties from the MMDevice. If it can't open, or the device is in /// an invalid state it will continue to use it's current internal property cache /// </summary> /// <param name=\"device\"></param> public void TryLoadFrom(IMultimediaDevice device) { var properties = GetProperties(device); if (properties.Count > 0) _properties = properties; } private Dictionary<PropertyKey, object> GetProperties(IMultimediaDevice device) { var properties = new Dictionary<PropertyKey, object>(); //Opening in write mode, can cause exceptions to be thrown when not run as admin. //This tries to open in write mode if available try { device.OpenPropertyStore(StorageAccessMode.ReadWrite, out _propertyStoreInteface); Mode = AccessMode.ReadWrite; } catch { Debug.WriteLine(\"Cannot open property store in write mode\"); } if (_propertyStoreInteface == null) { Marshal.ThrowExceptionForHR(device.OpenPropertyStore(StorageAccessMode.Read, out _propertyStoreInteface)); Mode = AccessMode.Read; } try { uint count; _propertyStoreInteface.GetCount(out count); for (uint i = 0; i < count; i++) { PropertyKey key; PropVariant variant; _propertyStoreInteface.GetAt(i, out key); _propertyStoreInteface.GetValue(ref key, out variant); if (variant.IsSupported()) properties.Add(key, variant.Value); } } catch(Exception) { Debug.WriteLine(\"Cannot get property values\"); return new Dictionary<PropertyKey, object>(); } return properties; } /// <summary> /// Sets property value of the property /// </summary> /// <returns>Property value</returns> public void SetValue(PropertyKey key, object value) { ComThread.Assert(); if (Mode == AccessMode.Read) return; if (!Contains(key)) return; Marshal.ThrowExceptionForHR(_propertyStoreInteface.SetValue(ref key, ref value)); _propertyStoreInteface.Commit(); } }", "label": "ComplexConditional"}
{"text": "public bool UpdateBuffers(DeviceContextProxy context, IDeviceResources deviceResources) { if(SpriteCount == 0 || IndexCount == 0 || Sprites == null || Indices == null || Sprites.Length < SpriteCount || Indices.Length < IndexCount) { return false; } vertextBuffer.UploadDataToBuffer(context, Sprites, SpriteCount); IndexBuffer.UploadDataToBuffer(context, Indices, IndexCount); return true; }", "label": "ComplexMethod"}
{"text": "public SRes LzmaEnc_SetProps(CLzmaEncProps props2) { TR(\"LzmaEnc_SetProps:level\", props2.mLevel); TR(\"LzmaEnc_SetProps:dictSize\", props2.mDictSize); TR(\"LzmaEnc_SetProps:lc\", props2.mLC); TR(\"LzmaEnc_SetProps:lp\", props2.mLP); TR(\"LzmaEnc_SetProps:pb\", props2.mPB); TR(\"LzmaEnc_SetProps:algo\", props2.mAlgo); TR(\"LzmaEnc_SetProps:fb\", props2.mFB); TR(\"LzmaEnc_SetProps:btMode\", props2.mBtMode); TR(\"LzmaEnc_SetProps:numHashBytes\", props2.mNumHashBytes); TR(\"LzmaEnc_SetProps:mc\", props2.mMC); TR(\"LzmaEnc_SetProps:writeEndMark\", props2.mWriteEndMark); TR(\"LzmaEnc_SetProps:numThreads\", props2.mNumThreads); CLzmaEncProps props = new CLzmaEncProps(props2); props.LzmaEncProps_Normalize(); if (props.mLC > LZMA_LC_MAX || props.mLP > LZMA_LP_MAX || props.mPB > LZMA_PB_MAX || props.mDictSize > (1u << kDicLogSizeMaxCompress) || props.mDictSize > (1u << 30)) return SZ_ERROR_PARAM; mDictSize = props.mDictSize; uint fb = (uint)props.mFB; if (fb < 5) fb = 5; if (fb > LZMA_MATCH_LEN_MAX) fb = LZMA_MATCH_LEN_MAX; mNumFastBytes = fb; mLC = props.mLC; mLP = props.mLP; mPB = props.mPB; mFastMode = (props.mAlgo == 0); mMatchFinderBase.mBtMode = (props.mBtMode != 0); uint numHashBytes = 4; if (props.mBtMode != 0) { if (props.mNumHashBytes < 2) numHashBytes = 2; else if (props.mNumHashBytes < 4) numHashBytes = (uint)props.mNumHashBytes; } mMatchFinderBase.mNumHashBytes = numHashBytes; mMatchFinderBase.mCutValue = props.mMC; mWriteEndMark = (props.mWriteEndMark != 0); #if !_7ZIP_ST mMultiThread = (props.mNumThreads > 1); #endif return SZ_OK; }", "label": "ComplexMethod"}
{"text": "public override void OnMovement(Mobile m, Point3D oldLocation) { if (this.TurnedOn && this.IsLockedDown && (!m.Hidden || m.IsPlayer()) && Utility.InRange(m.Location, this.Location, 2) && !Utility.InRange(oldLocation, this.Location, 2)) Effects.PlaySound(this.Location, this.Map, m_Sounds[Utility.Random(m_Sounds.Length)]); base.OnMovement(m, oldLocation); }", "label": "ComplexConditional"}
{"text": "// // carry out the combo defenses // // If you add a new combo, you must add the code here to define what it actually does when it is activated // public void DoComboDefense(Mobile attacker, Mobile defender, BaseWeapon weapon, int damageGiven, ComboDefense combo) { if(attacker == null || defender == null || weapon == null || combo == null) return; defender.SendMessage(\"You unleash the combo defense {0}!\",combo.Name); // apply the combo defense switch(combo.DefenseID) { case ComboDefenses.ColdWind: { // 5 sec paralyze attacker.FixedEffect( 0x376A, 9, 32 ); attacker.PlaySound( 0x204 ); attacker.Freeze( TimeSpan.FromSeconds(5) ); // 7x stam drain attacker.Stam -= weapon.MaxDamage*7; break; } } }", "label": "ComplexMethod"}
{"text": "internal DataGridColumn GetLastColumn(bool? isVisible, bool? isFrozen, bool? isReadOnly) { Debug.Assert(ItemsInternal.Count == DisplayIndexMap.Count); int index = DisplayIndexMap.Count - 1; while (index >= 0) { DataGridColumn dataGridColumn = GetColumnAtDisplayIndex(index); if ((isVisible == null || (dataGridColumn.IsVisible) == isVisible) && (isFrozen == null || dataGridColumn.IsFrozen == isFrozen) && (isReadOnly == null || dataGridColumn.IsReadOnly == isReadOnly)) { return dataGridColumn; } index--; } return null; }", "label": "ComplexConditional"}
{"text": "private void UnreferencedFunction(JsVariableField variableField, JsFunctionObject functionObject) { // if there is no name, then ignore this declaration because it's malformed. // (won't be a function expression because those are automatically referenced). // also ignore ghosted function fields. if (functionObject.Name != null && variableField.FieldType != JsFieldType.GhostFunction) { // if the function name isn't a simple identifier, then leave it there and mark it as // not renamable because it's probably one of those darn IE-extension event handlers or something. if (JsScanner.IsValidIdentifier(functionObject.Name)) { // unreferenced function declaration. fire a warning. var ctx = functionObject.IdContext ?? variableField.OriginalContext; ctx.HandleError(JsError.FunctionNotReferenced, false); // hide it from the output if our settings say we can. // we don't want to delete it, per se, because we still want it to // show up in the scope report so the user can see that it was unreachable // in case they are wondering where it went. // ES6 has the notion of block-scoped function declarations. ES5 says functions can't // be defined inside blocks -- only at the root level of the global scope or function scopes. // so if this is a block scope, don't hide the function, even if it is unreferenced because // of the cross-browser difference. if (this.IsKnownAtCompileTime && m_settings.MinifyCode && m_settings.RemoveUnneededCode && !(this is JsBlockScope)) { functionObject.HideFromOutput = true; } } else { // not a valid identifier name for this function. Don't rename it because it's // malformed and we don't want to mess up the developer's intent. variableField.CanCrunch = false; } } }", "label": "FeatureEnvy"}
{"text": "/* ** Disable a term in the WHERE clause. Except, do not disable the term ** if it controls a LEFT OUTER JOIN and it did not originate in the ON ** or USING clause of that join. ** ** Consider the term t2.z='ok' in the following queries: ** ** (1) SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok' ** (2) SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok' ** (3) SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok' ** ** The t2.z='ok' is disabled in the in (2) because it originates ** in the ON clause. The term is disabled in (3) because it is not part ** of a LEFT OUTER JOIN. In (1), the term is not disabled. ** ** IMPLEMENTATION-OF: R-24597-58655 No tests are done for terms that are ** completely satisfied by indices. ** ** Disabling a term causes that term to not be tested in the inner loop ** of the join. Disabling is an optimization. When terms are satisfied ** by indices, we disable them to prevent redundant tests in the inner ** loop. We would get the correct results if nothing were ever disabled, ** but joins might run a little slower. The trick is to disable as much ** as we can without disabling too much. If we disabled in (1), we'd get ** the wrong answer. See ticket #813. */ private static void disableTerm(WhereLevel pLevel, WhereTerm pTerm) { if (pTerm != null && (pTerm.wtFlags & TERM_CODED) == 0 && (pLevel.iLeftJoin == 0 || ExprHasProperty(pTerm.pExpr, EP_FromJoin))) { pTerm.wtFlags |= TERM_CODED; if (pTerm.iParent >= 0) { WhereTerm pOther = pTerm.pWC.a[pTerm.iParent]; if ((--pOther.nChild) == 0) { disableTerm(pLevel, pOther); } } } }", "label": "ComplexConditional"}
{"text": "private void Settings_SettingChanged(object sender, StringEventArgs e) { string settingsKey = e.Data; // Invalidate bed textures on related settings change if (settingsKey == SettingsKey.t0_inset || settingsKey == SettingsKey.t1_inset || settingsKey == SettingsKey.bed_size || settingsKey == SettingsKey.print_center || settingsKey == SettingsKey.extruder_count || settingsKey == SettingsKey.bed_shape) { activeBedToolClippingImage = int.MinValue; // Force texture rebuild, don't clear allowing redraws of the stale data until rebuilt bedTextures = null; this.EnsureBedTexture(sceneContext.Scene.SelectedItem, clearToPlaceholderImage: false); } }", "label": "ComplexMethod"}
{"text": "//This function resets the UV state for the specified tile locations (as well as nearby tiles) such that the UV cache must be re-evaluated public static void ResetUVCache(WorldViewModel _wvm, int tileStartX, int tileStartY, int regionWidth, int regionHeight) { if (_wvm.TilePicker.PaintMode == PaintMode.TileAndWall) { //Reset UV Cache for nearby tiles and walls for (int x = -1; x < regionWidth + 1; x++) { int tilex = x + tileStartX; for (int y = -1; y < regionHeight + 1; y++) { int tiley = y + tileStartY; if (tilex < 0 || tiley < 0 || tilex >= _wvm.CurrentWorld.TilesWide || tiley >= _wvm.CurrentWorld.TilesHigh) { continue; } Tile curtile = _wvm.CurrentWorld.Tiles[tilex, tiley]; if (_wvm.TilePicker.TileStyleActive) { curtile.uvTileCache = 0xFFFF; curtile.lazyMergeId = 0xFF; curtile.hasLazyChecked = false; } if (_wvm.TilePicker.WallStyleActive) curtile.uvWallCache = 0xFFFF; } } } }", "label": "ComplexConditional"}
{"text": "private static void ParseVersion() { if ((Version == null || Version < _INITVersion) && RootDirectory != null && RootDirectory.Exists) { var files = RootDirectory.GetFiles(\"VERSION\", SearchOption.TopDirectoryOnly); foreach (var file in files.Where(f => String.Equals(\"VERSION\", f.Name) && String.IsNullOrWhiteSpace(f.Extension))) { using (var stream = file.OpenText()) { string ver = stream.ReadToEnd().Trim(); VersionInfo v; if (!VersionInfo.TryParse(ver, out v)) { continue; } Version = v; break; } } } if (Version == null || Version < _INITVersion) { Version = _INITVersion; } }", "label": "ComplexMethod"}
{"text": "private IEnumerable<KeyValuePair<HelpPageSampleKey, object>> GetAllActionSamples(string controllerName, string actionName, IEnumerable<string> parameterNames, SampleDirection sampleDirection) { HashSet<string> parameterNamesSet = new HashSet<string>(parameterNames, StringComparer.OrdinalIgnoreCase); foreach (var sample in ActionSamples) { HelpPageSampleKey sampleKey = sample.Key; if (String.Equals(controllerName, sampleKey.ControllerName, StringComparison.OrdinalIgnoreCase) && String.Equals(actionName, sampleKey.ActionName, StringComparison.OrdinalIgnoreCase) && (sampleKey.ParameterNames.SetEquals(new[] { \"*\" }) || parameterNamesSet.SetEquals(sampleKey.ParameterNames)) && sampleDirection == sampleKey.SampleDirection) { yield return sample; } } }", "label": "ComplexConditional"}
{"text": "public void Resolve(IList<ISymbol> results) { if (string.IsNullOrEmpty(_name)) { return; } // Try to parse the name as declaration ID generated from symbol's documentation comment Id. List<ISymbol> docIdResults; if (DocumentationCommentId.TryGetSymbolsForDeclarationId(RemovePrefix(_name, s_suppressionPrefix), _compilation, out docIdResults)) { foreach (var result in docIdResults) { results.Add(result); } return; } // Parse 'e:' prefix used by FxCop to differentiate between event and non-event symbols of the same name. bool isEvent = false; if (_name.Length >= 2 && _name[0] == 'e' && _name[1] == ':') { isEvent = true; _index = 2; } INamespaceOrTypeSymbol containingSymbol = _compilation.GlobalNamespace; bool? segmentIsNamedTypeName = null; while (true) { var segment = ParseNextNameSegment(); // Special case: Roslyn names indexers \"this[]\" in CSharp, FxCop names them \"Item\" with parameters in [] brackets bool isIndexerProperty = false; if (segment == \"Item\" && PeekNextChar() == '[') { isIndexerProperty = true; if (_compilation.Language == LanguageNames.CSharp) { segment = \"this[]\"; } } var candidateMembers = containingSymbol.GetMembers(segment); if (candidateMembers.Length == 0) { return; } if (segmentIsNamedTypeName.HasValue) { candidateMembers = segmentIsNamedTypeName.Value ? candidateMembers.Where(s => s.Kind == SymbolKind.NamedType).ToImmutableArray() : candidateMembers.Where(s => s.Kind != SymbolKind.NamedType).ToImmutableArray(); segmentIsNamedTypeName = null; } int? arity = null; ParameterInfo[] parameters = null; // Check for generic arity if (_scope != TargetScope.Namespace && PeekNextChar() == '`') { ++_index; arity = ReadNextInteger(); } // Check for method or indexer parameter list var nextChar = PeekNextChar(); if (!isIndexerProperty && nextChar == '(' || isIndexerProperty && nextChar == '[') { parameters = ParseParameterList(); if (parameters == null) { // Failed to resolve parameter list return; } } else if (nextChar == '.' || nextChar == '+') { ++_index; if (arity > 0 || nextChar == '+') { // The name continues and either has an arity or specifically continues with a '+' // so segment must be the name of a named type containingSymbol = GetFirstMatchingNamedType(candidateMembers, arity ?? 0); } else { // The name continues with a '.' and does not specify a generic arity // so segment must be the name of a namespace or a named type containingSymbol = GetFirstMatchingNamespaceOrType(candidateMembers); } if (containingSymbol == null) { // If we cannot resolve the name on the left of the delimiter, we have no // hope of finding the symbol. return; } else if (containingSymbol.Kind == SymbolKind.NamedType) { // If segment resolves to a named type, that restricts what the next segment // can resolve to depending on whether the name continues with '+' or '.' segmentIsNamedTypeName = nextChar == '+'; } continue; } if (_scope == TargetScope.Member && !isIndexerProperty && parameters != null) { TypeInfo? returnType = null; if (PeekNextChar() == ':') { ++_index; returnType = ParseNamedType(null); } foreach (var method in GetMatchingMethods(candidateMembers, arity, parameters, returnType)) { results.Add(method); } return; } ISymbol singleResult = null; switch (_scope) { case TargetScope.Namespace: singleResult = candidateMembers.FirstOrDefault(s => s.Kind == SymbolKind.Namespace); break; case TargetScope.Type: singleResult = GetFirstMatchingNamedType(candidateMembers, arity ?? 0); break; case TargetScope.Member: if (isIndexerProperty) { singleResult = GetFirstMatchingIndexer(candidateMembers, parameters); } else if (isEvent) { singleResult = candidateMembers.FirstOrDefault(s => s.Kind == SymbolKind.Event); } else { singleResult = candidateMembers.FirstOrDefault(s => s.Kind != SymbolKind.Namespace && s.Kind != SymbolKind.NamedType); } break; default: throw ExceptionUtilities.UnexpectedValue(_scope); } if (singleResult != null) { results.Add(singleResult); } return; } }", "label": "ComplexConditional"}
{"text": "public string ResolveUrl(RequireSettings settings, string applicationPath) { string url; if (_urlResolveCache.TryGetValue(settings, out url)) { return url; } // Url priority: if (settings.DebugMode) { url = settings.CdnMode ? Coalesce(UrlCdnDebug, UrlDebug, UrlCdn, Url) : Coalesce(UrlDebug, Url, UrlCdnDebug, UrlCdn); } else { url = settings.CdnMode ? Coalesce(UrlCdn, Url, UrlCdnDebug, UrlDebug) : Coalesce(Url, UrlDebug, UrlCdn, UrlCdnDebug); } if (String.IsNullOrEmpty(url)) { return null; } if (!String.IsNullOrEmpty(settings.Culture)) { string nearestCulture = FindNearestCulture(settings.Culture); if (!String.IsNullOrEmpty(nearestCulture)) { url = Path.ChangeExtension(url, nearestCulture + Path.GetExtension(url)); } } if (!Uri.IsWellFormedUriString(url, UriKind.Absolute) && !VirtualPathUtility.IsAbsolute(url) && !VirtualPathUtility.IsAppRelative(url) && !String.IsNullOrEmpty(BasePath)) { // relative urls are relative to the base path of the module that defined the manifest url = VirtualPathUtility.Combine(BasePath, url); } if (VirtualPathUtility.IsAppRelative(url)) { url = VirtualPathUtility.ToAbsolute(url, applicationPath); } _urlResolveCache[settings] = url; return url; }", "label": "ComplexConditional"}
{"text": "public override void OnDoubleClick(Mobile from) { if (!from.InRange(this.GetWorldLocation(), 2) || !from.InLOS(this)) { from.LocalOverheadMessage(MessageType.Regular, 0x3B2, 1019045); // I can't reach that } else if (this.Visible && (this.ItemID == 4656 || this.ItemID == 4702) && DateTime.UtcNow >= this.m_NextUse) { Point3D p = this.GetWorldLocation(); if (1 > Utility.Random(Math.Max(Math.Abs(from.X - p.X), Math.Abs(from.Y - p.Y)))) { Effects.PlaySound(from.Location, from.Map, from.GetHurtSound()); from.PublicOverheadMessage(MessageType.Regular, from.SpeechHue, true, \"Ouch!\"); Spells.SpellHelper.Damage(TimeSpan.FromSeconds(0.5), from, Utility.Dice(2, 10, 5)); } Effects.PlaySound(this.GetWorldLocation(), this.Map, 0x387); Timer.DelayCall(TimeSpan.FromSeconds(0.25), new TimerCallback(Down1)); Timer.DelayCall(TimeSpan.FromSeconds(0.50), new TimerCallback(Down2)); Timer.DelayCall(TimeSpan.FromSeconds(5.00), new TimerCallback(BackUp)); this.m_NextUse = DateTime.UtcNow + TimeSpan.FromSeconds(10.0); } }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Determine whether we can resolve a particular typeKey /// </summary> bool IRegistrationContext.CanResolve(Type type, string key) { IRegistrationCollection registrations; if (this.registrations.TryGetValue(new TypeKey(type.TypeHandle, key), out registrations) || this.TryCreateFuncFactory(type, key, out registrations) || this.TryCreateGenericTypesForUnboundGeneric(type, key, out registrations) || this.TryCreateSelfBinding(type, key, out registrations)) { return true; } // Is it a 'get all' request? IRegistration registration; return this.TryRetrieveGetAllRegistration(type, key, out registration); }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Convert an object to a non-null double value. /// </summary> /// <param name=\"value\">Object to convert.</param> /// <returns>Converted double value.</returns> private static double ValueAsDouble(object value) { if (value == null) { throw new FormatException(Strings.GeoJsonReader_InvalidNullElement); } // At this point we are expecting them to only be numeric, so verify that. if (value is String || value is IDictionary<string, object> || value is IEnumerable || value is bool) { throw new FormatException(Strings.GeoJsonReader_ExpectedNumeric); } // value is already a numeric value at this point, so can safely convert it using InvariantCulture. return Convert.ToDouble(value, CultureInfo.InvariantCulture); }", "label": "ComplexConditional"}
{"text": "#endregion void AddBeaches([NotNull] Map map) { if (map == null) throw new ArgumentNullException(\"map\"); int beachExtentSqr = (args.BeachExtent + 1) * (args.BeachExtent + 1); for (int x = 0; x < map.Width; x++) { for (int y = 0; y < map.Length; y++) { for (int z = args.WaterLevel; z <= args.WaterLevel + args.BeachHeight; z++) { if (map.GetBlock(x, y, z) != bGroundSurface) continue; bool found = false; for (int dx = -args.BeachExtent; !found && dx <= args.BeachExtent; dx++) { for (int dy = -args.BeachExtent; !found && dy <= args.BeachExtent; dy++) { for (int dz = -args.BeachHeight; dz <= 0; dz++) { if (dx * dx + dy * dy + dz * dz > beachExtentSqr) continue; int xx = x + dx; int yy = y + dy; int zz = z + dz; if (xx < 0 || xx >= map.Width || yy < 0 || yy >= map.Length || zz < 0 || zz >= map.Height) continue; Block block = map.GetBlock(xx, yy, zz); if (block == bWater || block == bWaterSurface) { found = true; break; } } } } if (found) { map.SetBlock(x, y, z, bSeaFloor); if (z > 0 && map.GetBlock(x, y, z - 1) == bGround) { map.SetBlock(x, y, z - 1, bSeaFloor); } } } } } }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Called when the game receives a window message. /// </summary> /// <param name=\"message\"> /// The message. /// </param> /// <param name=\"cursorPos\"> /// The cursor position. /// </param> /// <param name=\"key\"> /// The key. /// </param> /// <param name=\"wndArgs\"> /// The windows arguments. /// </param> internal void OnReceiveMessage( WindowsMessages message, Vector2 cursorPos, uint key, WndEventComposition wndArgs) { if (message == WindowsMessages.WM_MOUSEMOVE) { if (this.Visible && this.IsInside(cursorPos)) { if (cursorPos.X > this.Position.X + this.Width - 67 && cursorPos.X < this.Position.X + this.Width - 67 + this.Height + 8) { this.ShowTooltip(); } } else { this.ShowTooltip(true); } } switch (this.ValueType) { case MenuValueType.Boolean: if (message != WindowsMessages.WM_LBUTTONDOWN) { return; } if (!this.Visible) { return; } if (!this.IsInside(cursorPos)) { return; } if (cursorPos.X > this.Position.X + this.Width) { break; } if (cursorPos.X > this.Position.X + this.Width - this.Height) { this.SetValue(!this.GetValue<bool>()); } break; case MenuValueType.Slider: if (!this.Visible) { this.Interacting = false; return; } if (message == WindowsMessages.WM_MOUSEMOVE && this.Interacting || message == WindowsMessages.WM_LBUTTONDOWN && !this.Interacting && this.IsInside(cursorPos)) { var val = this.GetValue<Slider>(); var t = val.MinValue + ((cursorPos.X - this.Position.X) * (val.MaxValue - val.MinValue)) / this.Width; val.Value = (int)t; this.SetValue(val); } if (message != WindowsMessages.WM_LBUTTONDOWN && message != WindowsMessages.WM_LBUTTONUP) { return; } if (!this.IsInside(cursorPos) && message == WindowsMessages.WM_LBUTTONDOWN) { return; } this.Interacting = message == WindowsMessages.WM_LBUTTONDOWN; break; case MenuValueType.Color: if (message != WindowsMessages.WM_LBUTTONDOWN) { return; } if (!this.Visible) { return; } if (!this.IsInside(cursorPos)) { return; } if (cursorPos.X > this.Position.X + this.Width) { break; } if (cursorPos.X > this.Position.X + this.Width - this.Height) { var c = this.GetValue<System.Drawing.Color>(); ColorPicker.Load(delegate(System.Drawing.Color args) { this.SetValue(args); }, c); } break; case MenuValueType.Circle: if (message != WindowsMessages.WM_LBUTTONDOWN) { return; } if (!this.Visible) { return; } if (!this.IsInside(cursorPos)) { return; } if (cursorPos.X > this.Position.X + this.Width) { break; } if (cursorPos.X - this.Position.X > this.Width - this.Height) { var val = this.GetValue<Circle>(); val.Active = !val.Active; this.SetValue(val); } else if (cursorPos.X - this.Position.X > this.Width - 2 * this.Height) { var c = this.GetValue<Circle>(); ColorPicker.Load( delegate(System.Drawing.Color args) { var val = this.GetValue<Circle>(); val.Color = args; this.SetValue(val); }, c.Color); } break; case MenuValueType.KeyBind: if (!MenuGUI.IsChatOpen && !MenuGUI.IsShopOpen) { switch (message) { case WindowsMessages.WM_KEYDOWN: var val = this.GetValue<KeyBind>(); if (key == val.Key || key == val.SecondaryKey) { if (val.Type == KeyBindType.Press) { if (!val.Active) { val.Active = true; this.SetValue(val); } } } break; case WindowsMessages.WM_KEYUP: var val2 = this.GetValue<KeyBind>(); if (key == val2.Key || key == val2.SecondaryKey) { if (val2.Type == KeyBindType.Press) { val2.Active = false; this.SetValue(val2); } else { val2.Active = !val2.Active; this.SetValue(val2); } } break; } } if (key == 8 && message == WindowsMessages.WM_KEYUP && this.Interacting) { var val = this.GetValue<KeyBind>(); val.Key = 0; val.SecondaryKey = 0; this.SetValue(val); this.Interacting = false; this.KeybindSettingStage = KeybindSetStage.NotSetting; } if (message == WindowsMessages.WM_KEYUP && this.Interacting && this.KeybindSettingStage != KeybindSetStage.NotSetting) { if (this.KeybindSettingStage == KeybindSetStage.Keybind1) { var val = this.GetValue<KeyBind>(); val.Key = key; this.SetValue(val); this.KeybindSettingStage = KeybindSetStage.Keybind2; } else if (this.KeybindSettingStage == KeybindSetStage.Keybind2) { var val = this.GetValue<KeyBind>(); val.SecondaryKey = key; this.SetValue(val); this.Interacting = false; this.KeybindSettingStage = KeybindSetStage.NotSetting; } } if (message == WindowsMessages.WM_KEYUP && this.Interacting && this.KeybindSettingStage == KeybindSetStage.NotSetting) { var val = this.GetValue<KeyBind>(); val.Key = key; val.SecondaryKey = 0; this.SetValue(val); this.Interacting = false; } if (!this.Visible) { return; } if (message != WindowsMessages.WM_LBUTTONDOWN && wndArgs.Msg != WindowsMessages.WM_RBUTTONDOWN) { return; } if (!this.IsInside(cursorPos)) { return; } if (cursorPos.X > this.Position.X + this.Width) { break; } if (cursorPos.X > this.Position.X + this.Width - this.Height) { var val = this.GetValue<KeyBind>(); val.Active = !val.Active; this.SetValue(val); } else { if (wndArgs.Msg == WindowsMessages.WM_RBUTTONDOWN) { this.KeybindSettingStage = KeybindSetStage.Keybind1; } //this.Stage = KeybindSetStage.NotSetting; this.Interacting = !this.Interacting; } break; case MenuValueType.StringList: if (!this.Visible) { return; } if (message != WindowsMessages.WM_LBUTTONDOWN) { return; } if (!this.IsInside(cursorPos)) { return; } if (cursorPos.X > this.Position.X + this.Width) { break; } var slVal = this.GetValue<StringList>(); if (cursorPos.X > this.Position.X + this.Width - this.Height) { slVal.SelectedIndex = slVal.SelectedIndex == slVal.SList.Length - 1 ? 0 : (slVal.SelectedIndex + 1); this.SetValue(slVal); } else if (cursorPos.X > this.Position.X + this.Width - 2 * this.Height) { slVal.SelectedIndex = slVal.SelectedIndex == 0 ? slVal.SList.Length - 1 : (slVal.SelectedIndex - 1); this.SetValue(slVal); } break; } }", "label": "ComplexConditional"}
{"text": "public override bool OnMoveOver(Mobile m) { if (m is BaseCreature && !((BaseCreature)m).Controlled) { return (!Alive || !m.Alive || IsDeadBondedPet || m.IsDeadBondedPet) || (Hidden && IsStaff()); } #region Dueling if (Region.IsPartOf(typeof(SafeZone)) && m is PlayerMobile) { PlayerMobile pm = (PlayerMobile)m; if (pm.DuelContext == null || pm.DuelPlayer == null || !pm.DuelContext.Started || pm.DuelContext.Finished || pm.DuelPlayer.Eliminated) { return true; } } #endregion return base.OnMoveOver(m); }", "label": "ComplexMethod"}
{"text": "static MultiData() { string idxPath = Core.FindDataFile(\"multi.idx\"); string mulPath = Core.FindDataFile(\"multi.mul\"); if (File.Exists(idxPath) && File.Exists(mulPath)) { m_Index = new FileStream(idxPath, FileMode.Open, FileAccess.Read, FileShare.Read); m_IndexReader = new BinaryReader(m_Index); m_Stream = new FileStream(mulPath, FileMode.Open, FileAccess.Read, FileShare.Read); m_StreamReader = new BinaryReader(m_Stream); m_Components = new MultiComponentList[(int)(m_Index.Length / 12)]; string vdPath = Core.FindDataFile(\"verdata.mul\"); if (File.Exists(vdPath)) { using (var fs = new FileStream(vdPath, FileMode.Open, FileAccess.Read, FileShare.Read)) { var bin = new BinaryReader(fs); int count = bin.ReadInt32(); for (int i = 0; i < count; ++i) { int file = bin.ReadInt32(); int index = bin.ReadInt32(); int lookup = bin.ReadInt32(); int length = bin.ReadInt32(); int extra = bin.ReadInt32(); if (file == 14 && index >= 0 && index < m_Components.Length && lookup >= 0 && length > 0) { bin.BaseStream.Seek(lookup, SeekOrigin.Begin); m_Components[index] = new MultiComponentList(bin, length / 12); bin.BaseStream.Seek(24 + (i * 20), SeekOrigin.Begin); } } bin.Close(); } } } else { Console.WriteLine(\"Warning: Multi data files not found\"); m_Components = new MultiComponentList[0]; } }", "label": "ComplexConditional"}
{"text": "/// <summary> /// This method is an optimization that /// skips matching elements at the end of the /// two arrays being diff'ed. /// Care's taken so that this will never /// overlap with the pre-skip. /// </summary> private void CalculatePostSkip() { int leftLen = _left.Count; int rightLen = _right.Count; while (_postSkip < leftLen && _postSkip < rightLen && _postSkip < (leftLen - _preSkip) && _compareFunc(_left[leftLen - _postSkip - 1], _right[rightLen - _postSkip - 1])) { _postSkip++; } }", "label": "ComplexMethod"}
{"text": "protected virtual void OnDeathDeny(Mobile m) { if (m == null || m.Deleted) { return; } PlayerMobile pm = m as PlayerMobile; PvPTeam team; if (pm == null || !IsParticipant(pm, out team) || team == null || team.Deleted) { return; } pm.SendMessage(\"You have been spared death, this time...\"); team.OnMemberDeath(pm); }", "label": "ComplexConditional"}
{"text": "private CursPos CursorPosition() { if (RealCursorPosition.X > CurrentTopLeft.X - 10 && RealCursorPosition.X < CurrentTopLeft.X + 10 && RealCursorPosition.Y > CurrentTopLeft.Y + 10 && RealCursorPosition.Y < CurrentBottomRight.Y - 10) { Cursor = Cursors.SizeWE; return CursPos.LeftLine; } if (RealCursorPosition.X >= CurrentTopLeft.X - 10 && RealCursorPosition.X <= CurrentTopLeft.X + 10 && RealCursorPosition.Y >= CurrentTopLeft.Y - 10 && RealCursorPosition.Y <= CurrentTopLeft.Y + 10) { Cursor = Cursors.SizeNWSE; return CursPos.TopLeft; } if (RealCursorPosition.X >= CurrentTopLeft.X - 10 && RealCursorPosition.X <= CurrentTopLeft.X + 10 && RealCursorPosition.Y >= CurrentBottomRight.Y - 10 && RealCursorPosition.Y <= CurrentBottomRight.Y + 10) { Cursor = Cursors.SizeNESW; return CursPos.BottomLeft; } if (RealCursorPosition.X > CurrentBottomRight.X - 10 && RealCursorPosition.X < CurrentBottomRight.X + 10 && RealCursorPosition.Y > CurrentTopLeft.Y + 10 && RealCursorPosition.Y < CurrentBottomRight.Y - 10) { Cursor = Cursors.SizeWE; return CursPos.RightLine; } if (RealCursorPosition.X >= CurrentBottomRight.X - 10 && RealCursorPosition.X <= CurrentBottomRight.X + 10 && RealCursorPosition.Y >= CurrentTopLeft.Y - 10 && RealCursorPosition.Y <= CurrentTopLeft.Y + 10) { Cursor = Cursors.SizeNESW; return CursPos.TopRight; } if (RealCursorPosition.X >= CurrentBottomRight.X - 10 && RealCursorPosition.X <= CurrentBottomRight.X + 10 && RealCursorPosition.Y >= CurrentBottomRight.Y - 10 && RealCursorPosition.Y <= CurrentBottomRight.Y + 10) { Cursor = Cursors.SizeNWSE; return CursPos.BottomRight; } if (RealCursorPosition.Y > CurrentTopLeft.Y - 10 && RealCursorPosition.Y < CurrentTopLeft.Y + 10 && RealCursorPosition.X > CurrentTopLeft.X + 10 && RealCursorPosition.X < CurrentBottomRight.X - 10) { Cursor = Cursors.SizeNS; return CursPos.TopLine; } if (RealCursorPosition.Y > CurrentBottomRight.Y - 10 && RealCursorPosition.Y < CurrentBottomRight.Y + 10 && RealCursorPosition.X > CurrentTopLeft.X + 10 && RealCursorPosition.X < CurrentBottomRight.X - 10) { Cursor = Cursors.SizeNS; return CursPos.BottomLine; } if (RealCursorPosition.X >= CurrentTopLeft.X + 10 && RealCursorPosition.X <= CurrentBottomRight.X - 10 && RealCursorPosition.Y >= CurrentTopLeft.Y + 10 && RealCursorPosition.Y <= CurrentBottomRight.Y - 10) { Cursor = Cursors.Hand; return CursPos.WithinSelectionArea; } Cursor = Cursors.No; return CursPos.OutsideSelectionArea; }", "label": "ComplexMethod"}
{"text": "private static void Farm_skills(Spell spell, bool skillshot = false) { if (!_q.IsReady()) return; var allMinions = MinionManager.GetMinions(ObjectManager.Player.ServerPosition, _q.Range, MinionTypes.All); foreach (var minion in allMinions) { if (!minion.IsValidTarget()) continue; var minionInRangeAa = Orbwalking.InAutoAttackRange(minion); var minionInRangeSpell = minion.Distance(ObjectManager.Player) <= spell.Range; var minionKillableAa = _player.GetAutoAttackDamage(minion, true) - 30 >= minion.Health; var minionKillableSpell = _player.GetSpellDamage(minion, SpellSlot.Q) - 30 >= minion.Health; var lastHit = _orbwalker.ActiveMode == Orbwalking.OrbwalkingMode.LastHit; var laneClear = _orbwalker.ActiveMode == Orbwalking.OrbwalkingMode.LaneClear; if ((lastHit && minionInRangeSpell && minionKillableSpell) && _q.GetPrediction(minion).CollisionObjects.Count > 0 && skillshot) { spell.Cast(minion.Position); } if (laneClear && minionInRangeSpell) { if (minionKillableSpell && _q.GetPrediction(minion).CollisionObjects.Count > 0 && skillshot) spell.Cast(minion.Position); else spell.Cast(minion); } } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// An event was received from the filesystem watcher, analyze the change and apply it. /// <returns>Whether the move has now been synchronized, so that no further action is needed</returns> /// </summary> private bool WatchSyncMove(string remoteFolder, string localFolder, string oldPathname, string newPathname, Grace grace) { bool success = true; SleepWhileSuspended(); try { // Old item. string oldDirectory = Path.GetDirectoryName(oldPathname); string oldFilename = Path.GetFileName(oldPathname); string oldLocalName = oldPathname.Substring(localFolder.Length + 1); SyncItem oldItem = database.GetSyncItemFromLocalPath(oldPathname); if (oldItem == null) { // The change is about a file which was not in database yet, we can't move it. Further action is needed. return false; } string oldRemoteName = oldItem.RemotePath; string oldRemoteBaseName = CmisUtils.GetUpperFolderOfCmisPath(oldRemoteName); bool oldPathnameWorthSyncing = Utils.WorthSyncing(oldDirectory, oldFilename, repoInfo); // New item. bool isFolder = Utils.IsFolder(newPathname); string newDirectory = Path.GetDirectoryName(newPathname); // TODO do this only if isFolder is true, modify rest of the logic accordingly. string newFilename = Path.GetFileName(newPathname); string newLocalName = newPathname.Substring(localFolder.Length + 1); SyncItem newItem = SyncItemFactory.CreateFromLocalPath(newPathname, isFolder, repoInfo, database); string newRemoteName = newItem.RemotePath; string newRemoteBaseName = CmisUtils.GetUpperFolderOfCmisPath(newRemoteName); bool newPathnameWorthSyncing = Utils.WorthSyncing(newDirectory, newFilename, repoInfo); // Operations. bool rename = oldDirectory.Equals(newDirectory) && !oldFilename.Equals(newFilename); bool move = !oldDirectory.Equals(newDirectory) && oldFilename.Equals(newFilename); if ((rename && move) || (!rename && !move)) { Logger.ErrorFormat(\"Not a valid rename/move: {0} -> {1}\", oldPathname, newPathname); return true; // It is not our problem that watcher data is not valid. } if (oldPathnameWorthSyncing && newPathnameWorthSyncing) { if (database.ContainsLocalFile(oldPathname)) { if (database.ContainsLocalFile(newPathname)) { //database already contains path so revert back to delete/update success &= WatcherSyncDelete(remoteFolder, localFolder, oldPathname, grace); success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname); } else { if (rename) { //rename file... IDocument remoteDocument = (IDocument)session.GetObjectByPath(oldRemoteName, true); success &= RenameFile(oldDirectory, newFilename, remoteDocument); } else //move { //move file... IDocument remoteDocument = (IDocument)session.GetObjectByPath(oldRemoteName, true); IFolder oldRemoteFolder = (IFolder)session.GetObjectByPath(oldRemoteBaseName, true); IFolder newRemoteFolder = (IFolder)session.GetObjectByPath(newRemoteBaseName, true); success &= MoveFile(oldDirectory, newDirectory, oldRemoteFolder, newRemoteFolder, remoteDocument); } } } else if (database.ContainsFolder(oldPathname)) { if (database.ContainsFolder(newPathname)) { //database already contains path so revert back to delete/update success &= WatcherSyncDelete(remoteFolder, localFolder, oldPathname, grace); success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname); } else { if (rename) { //rename folder... IFolder remoteFolderObject = (IFolder)session.GetObjectByPath(oldRemoteName, true); success &= RenameFolder(oldDirectory, newFilename, remoteFolderObject); } else //move { //move folder... IFolder remoteFolderObject = (IFolder)session.GetObjectByPath(oldRemoteName, true); IFolder oldRemoteFolder = (IFolder)session.GetObjectByPath(oldRemoteBaseName, true); IFolder newRemoteFolder = (IFolder)session.GetObjectByPath(newRemoteBaseName, true); success &= MoveFolder(oldDirectory, newDirectory, oldRemoteFolder, newRemoteFolder, remoteFolderObject); } } } else { //File/Folder has not been synced before so simply update success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname); } } else if (oldPathnameWorthSyncing && !newPathnameWorthSyncing) { //New path not worth syncing success &= WatcherSyncDelete(remoteFolder, localFolder, oldPathname, grace); } else if (!oldPathnameWorthSyncing && newPathnameWorthSyncing) { //Old path not worth syncing success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname); } else { //Neither old or new path worth syncing } } catch (FileNotFoundException e) { success = false; Logger.Warn(\"Could process watcher sync move, file or folder not found: \" + oldPathname + \" -> \" + newPathname, e); } catch (Exception e) { success = false; ProcessRecoverableException(\"Could not process watcher sync move: \" + oldPathname + \" -> \" + newPathname, e); } return success; }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Get the Ampersand if buffer == \"&amp;\" /// </summary> private int GetAmpersandCharEntity(int iOffset, int length) { byte[] iBuffer = this.buffer; if (length != 5 || iBuffer[offset + 1] != (byte)'a' || iBuffer[offset + 2] != (byte)'m' || iBuffer[offset + 3] != (byte)'p') throw new Exception(\"XmlExceptionHelper.ThrowInvalidCharRef(this.reader);\"); return Keys.Ampersand; }", "label": "ComplexMethod"}
{"text": "public OnChartBarAnnotation BarAnnotationAddOrModify(int barIndex, string barAnnotationId, string barAnnotationText, Font font, Color colorForeground, Color colorBackground, bool aboveBar = true, int verticalPadding = 5, bool popupParametersDidntChange = false) { //Add() candidate starts below if (this.OnChartBarAnnotations_byBar.ContainsKey(barIndex) == false) { this.OnChartBarAnnotations_byBar.Add(barIndex, new SortedDictionary<string, OnChartBarAnnotation>()); } SortedDictionary<string, OnChartBarAnnotation> annotationsForBar = this.OnChartBarAnnotations_byBar[barIndex]; if (annotationsForBar.ContainsKey(barAnnotationId) == false) { OnChartBarAnnotation barAnnotationCreated = new OnChartBarAnnotation( barAnnotationId, barAnnotationText, font, colorForeground, colorBackground, aboveBar, verticalPadding, popupParametersDidntChange); annotationsForBar.Add(barAnnotationId, barAnnotationCreated); return barAnnotationCreated; } //Modify() candidate starts below OnChartBarAnnotation barAnnotationToModify = annotationsForBar[barAnnotationId]; if ( barAnnotationToModify.BarAnnotationText == barAnnotationText && barAnnotationToModify.Font == font && barAnnotationToModify.ColorForeground == colorForeground && barAnnotationToModify.ColorBackground == colorBackground && barAnnotationToModify.AboveBar == aboveBar && barAnnotationToModify.VerticalPaddingPx == verticalPadding //NOT_VALUABLE_PARAMETER_TO_HIDE_REPORTING && barAnnotationToModify.ReportDidntChangeStatus == reportDidntChangeStatus ) { barAnnotationToModify.Status = OnChartObjectOperationStatus.OnChartObjectNotModifiedSinceParametersDidntChange; if (barAnnotationToModify.DebugParametersDidntChange) { Assembler.PopupException(barAnnotationToModify.ToString() + \" //BarAnnotationAddOrModify()\"); } return barAnnotationToModify; } barAnnotationToModify.Status = OnChartObjectOperationStatus.OnChartObjectModified; if (barAnnotationToModify.BarAnnotationText != barAnnotationText) barAnnotationToModify.BarAnnotationText = barAnnotationText; if (barAnnotationToModify.Font != font) barAnnotationToModify.Font = font; if (barAnnotationToModify.ColorForeground != colorForeground) barAnnotationToModify.ColorForeground = colorForeground; if (barAnnotationToModify.ColorBackground != colorBackground) barAnnotationToModify.ColorBackground = colorBackground; if (barAnnotationToModify.AboveBar != aboveBar) barAnnotationToModify.AboveBar = aboveBar; if (barAnnotationToModify.VerticalPaddingPx != verticalPadding) barAnnotationToModify.VerticalPaddingPx = verticalPadding; if (barAnnotationToModify.DebugParametersDidntChange!= popupParametersDidntChange) barAnnotationToModify.DebugParametersDidntChange = popupParametersDidntChange; return barAnnotationToModify; }", "label": "ComplexMethod"}
{"text": "protected Option (string prototype, string description) : this (prototype, description, 1, false) { }protected Option (string prototype, string description, int maxValueCount) : this (prototype, description, maxValueCount, false) { }protected Option (string prototype, string description, int maxValueCount, bool hidden) { if (prototype == null) throw new ArgumentNullException (\"prototype\"); if (prototype.Length == 0) throw new ArgumentException (\"Cannot be the empty string.\", \"prototype\"); if (maxValueCount < 0) throw new ArgumentOutOfRangeException (\"maxValueCount\"); this.prototype = prototype; this.description = description; this.count = maxValueCount; this.names = (this is OptionSet.Category) // append GetHashCode() so that \"duplicate\" categories have distinct // names, e.g. adding multiple \"\" categories should be valid. ? new[]{prototype + this.GetHashCode ()} : prototype.Split ('|'); if (this is OptionSet.Category || this is CommandOption) return; this.type = ParsePrototype (); this.hidden = hidden; if (this.count == 0 && type != OptionValueType.None) throw new ArgumentException ( \"Cannot provide maxValueCount of 0 for OptionValueType.Required or \" + \"OptionValueType.Optional.\", \"maxValueCount\"); if (this.type == OptionValueType.None && maxValueCount > 1) throw new ArgumentException ( string.Format (\"Cannot provide maxValueCount of {0} for OptionValueType.None.\", maxValueCount), \"maxValueCount\"); if (Array.IndexOf (names, \"<>\") >= 0 && ((names.Length == 1 && this.type != OptionValueType.None) || (names.Length > 1 && this.MaxValueCount > 1))) throw new ArgumentException ( \"The default option handler '<>' cannot require values.\", \"prototype\"); }", "label": "FeatureEnvy"}
{"text": "public override void OnGotMeleeAttack(Mobile attacker) { base.OnGotMeleeAttack(attacker); if (attacker != null && attacker.Alive && attacker.Weapon is BaseRanged && 0.4 > Utility.RandomDouble()) { ThrowHatchet(attacker); } }", "label": "ComplexConditional"}
{"text": "internal override SqlExpression VisitNew(SqlNew sox) { for (int i = 0, n = sox.Args.Count; i < n; i++) { if (inGroupBy) { // we don't want to fetch expressions for group by, // since we want links to remain links so SqlFlattener // can deal with them properly sox.Args[i] = this.VisitExpression(sox.Args[i]); } else { sox.Args[i] = this.FetchExpression(sox.Args[i]); } } for (int i = 0, n = sox.Members.Count; i < n; i++) { SqlMemberAssign ma = sox.Members[i]; MetaDataMember mm = sox.MetaType.GetDataMember(ma.Member); MetaType otherType = mm.DeclaringType.InheritanceRoot; if (mm.IsAssociation && ma.Expression != null && ma.Expression.NodeType != SqlNodeType.Link && this.shape != null && this.shape.IsPreloaded(mm.Member) && mm.LoadMethod == null && this.alreadyIncluded != null && !this.alreadyIncluded.Contains(otherType)) { // The expression is already fetched, add it to the alreadyIncluded set. this.alreadyIncluded.Add(otherType); ma.Expression = this.VisitExpression(ma.Expression); this.alreadyIncluded.Remove(otherType); } else if (mm.IsAssociation || mm.IsDeferred) { ma.Expression = this.VisitExpression(ma.Expression); } else { ma.Expression = this.FetchExpression(ma.Expression); } } return sox; }", "label": "ComplexMethod"}
{"text": "public override void OnClick() { if (!m_Familiar.Deleted && m_Familiar.Controlled && m_From == m_Familiar.ControlMaster && m_From.CheckAlive()) { m_Familiar.BeginRelease(m_From); } }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Split an individual face /// </summary> /// <param name=\"faceIndex\">face index in the array of faces</param> /// <param name=\"segment1\">segment representing the intersection of the face with the plane</param> /// <param name=\"segment2\">segment representing the intersection of other face with the plane of the current face plane</param> private bool SplitFace(CsgFace face, Segment segment1, Segment segment2, Stack<CsgFace> facesFromSplit) { Vector3 startPos, endPos; SegmentEnd startType, endType, middleType; double startDist, endDist; Vertex startVertex = segment1.StartVertex; Vertex endVertex = segment1.EndVertex; //starting point: deeper starting point if (segment2.StartDistance > segment1.StartDistance + EqualityTolerance) { startDist = segment2.StartDistance; startType = segment1.MiddleType; startPos = segment2.StartPosition; } else { startDist = segment1.StartDistance; startType = segment1.StartType; startPos = segment1.StartPosition; } //ending point: deepest ending point if (segment2.EndDistance < segment1.EndDistance - EqualityTolerance) { endDist = segment2.EndDistance; endType = segment1.MiddleType; endPos = segment2.EndPosition; } else { endDist = segment1.EndDistance; endType = segment1.EndType; endPos = segment1.EndPosition; } middleType = segment1.MiddleType; if (startType == SegmentEnd.Vertex) { //set vertex to BOUNDARY if it is start type startVertex.Status = FaceStatus.Boundary; } if (endType == SegmentEnd.Vertex) { //set vertex to BOUNDARY if it is end type endVertex.Status = FaceStatus.Boundary; } if (startType == SegmentEnd.Vertex && endType == SegmentEnd.Vertex) { //VERTEX-_______-VERTEX return false; } else if (middleType == SegmentEnd.Edge) { //______-EDGE-______ //gets the edge int splitEdge; if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v1)) { splitEdge = 1; } else if ((startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v2)) { splitEdge = 2; } else { splitEdge = 3; } if (startType == SegmentEnd.Vertex) { //VERTEX-EDGE-EDGE return BreakFaceInTwo(face, endPos, splitEdge, facesFromSplit); } else if (endType == SegmentEnd.Vertex) { //EDGE-EDGE-VERTEX return BreakFaceInTwo(face, startPos, splitEdge, facesFromSplit); } else if (startDist == endDist) { // EDGE-EDGE-EDGE return BreakFaceInTwo(face, endPos, splitEdge, facesFromSplit); } else { if ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1)) { return BreakFaceInThree(face, startPos, endPos, splitEdge, facesFromSplit); } else { return BreakFaceInThree(face, endPos, startPos, splitEdge, facesFromSplit); } } } //______-FACE-______ else if (startType == SegmentEnd.Vertex && endType == SegmentEnd.Edge) { //VERTEX-FACE-EDGE return BreakFaceInTwo(face, endPos, endVertex, facesFromSplit); } else if (startType == SegmentEnd.Edge && endType == SegmentEnd.Vertex) { //EDGE-FACE-VERTEX return BreakFaceInTwo(face, startPos, startVertex, facesFromSplit); } else if (startType == SegmentEnd.Vertex && endType == SegmentEnd.Face) { //VERTEX-FACE-FACE return BreakFaceInThree(face, endPos, facesFromSplit); } else if (startType == SegmentEnd.Face && endType == SegmentEnd.Vertex) { //FACE-FACE-VERTEX return BreakFaceInThree(face, startPos, facesFromSplit); } else if (startType == SegmentEnd.Edge && endType == SegmentEnd.Edge) { //EDGE-FACE-EDGE return BreakFaceInThree(face, startPos, endPos, startVertex, endVertex, facesFromSplit); } else if (startType == SegmentEnd.Edge && endType == SegmentEnd.Face) { //EDGE-FACE-FACE return BreakFaceInFour(face, startPos, endPos, startVertex, facesFromSplit); } else if (startType == SegmentEnd.Face && endType == SegmentEnd.Edge) { //FACE-FACE-EDGE return BreakFaceInFour(face, endPos, startPos, endVertex, facesFromSplit); } else if (startType == SegmentEnd.Face && endType == SegmentEnd.Face) { //FACE-FACE-FACE Vector3 segmentVector = new Vector3(startPos.X - endPos.X, startPos.Y - endPos.Y, startPos.Z - endPos.Z); //if the intersection segment is a point only... if (Math.Abs(segmentVector.X) < EqualityTolerance && Math.Abs(segmentVector.Y) < EqualityTolerance && Math.Abs(segmentVector.Z) < EqualityTolerance) { return BreakFaceInThree(face, startPos, facesFromSplit); } //gets the vertex more lined with the intersection segment double dot1 = Math.Abs(Vector3Ex.Dot(segmentVector, (endPos - face.v1.Position).GetNormal())); double dot2 = Math.Abs(Vector3Ex.Dot(segmentVector, (endPos - face.v2.Position).GetNormal())); double dot3 = Math.Abs(Vector3Ex.Dot(segmentVector, (endPos - face.v3.Position).GetNormal())); int linedVertex; Vector3 linedVertexPos; if (dot1 > dot2 && dot1 > dot3) { linedVertex = 1; linedVertexPos = face.v1.Position; } else if (dot2 > dot3 && dot2 > dot1) { linedVertex = 2; linedVertexPos = face.v2.Position; } else { linedVertex = 3; linedVertexPos = face.v3.Position; } // Now find which of the intersection endpoints is nearest to that vertex. if ((linedVertexPos - startPos).Length > (linedVertexPos - endPos).Length) { return BreakFaceInFive(face, startPos, endPos, linedVertex, facesFromSplit); } else { return BreakFaceInFive(face, endPos, startPos, linedVertex, facesFromSplit); } } return false; }", "label": "ComplexConditional"}
{"text": "private bool CreateTextureResources(RenderContext context, DeviceContextProxy deviceContext) { var currSampleDesc = context.RenderHost.RenderBuffer.ColorBufferSampleDesc; #if MSAASEPARATE hasMSAA = currSampleDesc.Count > 1 || currSampleDesc.Quality > 0; #endif if (width != (int)context.ActualWidth || height != (int)context.ActualHeight || sampleDesc.Count != currSampleDesc.Count || sampleDesc.Quality != currSampleDesc.Quality) { RemoveAndDispose(ref colorTarget); RemoveAndDispose(ref alphaTarget); RemoveAndDispose(ref colorTargetNoMSAA); RemoveAndDispose(ref alphaTargetNoMSAA); sampleDesc = currSampleDesc; width = (int)context.ActualWidth; height = (int)context.ActualHeight; colorDesc.Width = alphaDesc.Width = width; colorDesc.Height = alphaDesc.Height = height; colorDesc.SampleDescription = alphaDesc.SampleDescription = sampleDesc; #if MSAASEPARATE if (hasMSAA) { colorDesc.BindFlags = alphaDesc.BindFlags = BindFlags.RenderTarget; } else #endif { colorDesc.BindFlags = alphaDesc.BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource; } colorTarget = Collect(new ShaderResourceViewProxy(Device, colorDesc)); alphaTarget = Collect(new ShaderResourceViewProxy(Device, alphaDesc)); colorTarget.CreateRenderTargetView(); alphaTarget.CreateRenderTargetView(); #if MSAASEPARATE if (!hasMSAA) #endif { alphaTarget.CreateTextureView(); colorTarget.CreateTextureView(); colorTargetNoMSAA = colorTarget; alphaTargetNoMSAA = alphaTarget; } #if MSAASEPARATE else { colorDesc.SampleDescription = alphaDesc.SampleDescription = new SampleDescription(1, 0); colorDesc.BindFlags = alphaDesc.BindFlags = BindFlags.ShaderResource; colorTargetNoMSAA = Collect(new ShaderResourceViewProxy(Device, colorDesc)); alphaTargetNoMSAA = Collect(new ShaderResourceViewProxy(Device, alphaDesc)); colorTargetNoMSAA.CreateTextureView(); alphaTargetNoMSAA.CreateTextureView(); } #endif RaiseInvalidateRender(); return true; // Skip this frame if texture resized to reduce latency. } return false; }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Hits the test. /// </summary> /// <param name=\"context\">The context.</param> /// <param name=\"modelMatrix\">The model matrix.</param> /// <param name=\"rayWS\">The ray ws.</param> /// <param name=\"hits\">The hits.</param> /// <param name=\"originalSource\">The original source.</param> /// <param name=\"fixedSize\">if set to <c>true</c> [fixed size].</param> /// <returns></returns> public override bool HitTest(RenderContext context, Matrix modelMatrix, ref Ray rayWS, ref List<HitTestResult> hits, object originalSource, bool fixedSize) { if (!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS))) { return false; } return fixedSize ? HitTestFixedSize(context, ref modelMatrix, ref rayWS, ref hits, originalSource, BillboardVertices.Count) : HitTestNonFixedSize(context, ref modelMatrix, ref rayWS, ref hits, originalSource, BillboardVertices.Count); }", "label": "ComplexMethod"}
{"text": "private (Type applicationType, Type authorizationType, Type scopeType, Type tokenType) GetEntityTypes(Type keyType) { Type applicationType = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:ApplicationType\"), authorizationType = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:AuthorizationType\"), scopeType = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:ScopeType\"), tokenType = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:TokenType\"); if (applicationType != null && authorizationType != null && scopeType != null && tokenType != null) { return (applicationType, authorizationType, scopeType, tokenType); } if (keyType == typeof(string)) { return ( applicationType: typeof(OpenIddictApplication), authorizationType: typeof(OpenIddictAuthorization), scopeType: typeof(OpenIddictScope), tokenType: typeof(OpenIddictToken)); } return ( applicationType: typeof(OpenIddictApplication<>).MakeGenericType(keyType), authorizationType: typeof(OpenIddictAuthorization<>).MakeGenericType(keyType), scopeType: typeof(OpenIddictScope<>).MakeGenericType(keyType), tokenType: typeof(OpenIddictToken<>).MakeGenericType(keyType)); }", "label": "ComplexMethod"}
{"text": "protected virtual async Task<byte[]> DownloadAsync(string url, CancellationToken token, HttpClient client, TaskParameter parameters, DownloadInformation downloadInformation) { if (!parameters.Preload) { await Task.Delay(25).ConfigureAwait(false); token.ThrowIfCancellationRequested(); } var progressAction = parameters.OnDownloadProgress; using (var httpHeadersTimeoutTokenSource = new CancellationTokenSource()) using (var headersTimeoutTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token, httpHeadersTimeoutTokenSource.Token)) { httpHeadersTimeoutTokenSource.CancelAfter(TimeSpan.FromSeconds(Configuration.HttpHeadersTimeout)); try { var headerTimeoutToken = headersTimeoutTokenSource.Token; using (var response = await client.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, headerTimeoutToken).ConfigureAwait(false)) { headerTimeoutToken.ThrowIfCancellationRequested(); if (!response.IsSuccessStatusCode) { if (response.Content == null) throw new DownloadHttpStatusCodeException(response.StatusCode); using (response.Content) { var content = await response.Content.ReadAsStringAsync().ConfigureAwait(false); throw new DownloadHttpStatusCodeException(response.StatusCode, content); } } if (response.Content == null) throw new DownloadException(\"No content\"); var mediaType = response.Content.Headers?.ContentType?.MediaType; if (!string.IsNullOrWhiteSpace(mediaType) && !mediaType.StartsWith(\"image/\", StringComparison.OrdinalIgnoreCase)) { if (InvalidContentTypes.Any(v => mediaType.StartsWith(v, StringComparison.OrdinalIgnoreCase))) throw new DownloadException($\"Invalid response content type ({mediaType})\"); } if (!parameters.CacheDuration.HasValue && Configuration.TryToReadDiskCacheDurationFromHttpHeaders && response.Headers?.CacheControl?.MaxAge != null && response.Headers.CacheControl.MaxAge > TimeSpan.Zero) { downloadInformation.CacheValidity = response.Headers.CacheControl.MaxAge.Value; } ModifyParametersAfterResponse(response, parameters); using (var httpReadTimeoutTokenSource = new CancellationTokenSource()) using (var readTimeoutTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token, httpReadTimeoutTokenSource.Token)) { var readTimeoutToken = readTimeoutTokenSource.Token; var httpReadTimeoutToken = httpReadTimeoutTokenSource.Token; var total = (int)(response.Content.Headers.ContentLength ?? -1); var canReportProgress = progressAction != null; httpReadTimeoutTokenSource.CancelAfter(TimeSpan.FromSeconds(Configuration.HttpReadTimeout)); readTimeoutToken.ThrowIfCancellationRequested(); try { using (var outputStream = new MemoryStream()) using (var sourceStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false)) { httpReadTimeoutToken.Register(() => sourceStream.TryDispose()); var totalRead = 0; var buffer = new byte[Configuration.HttpReadBufferSize]; var read = 0; while ((read = await sourceStream.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) > 0) { readTimeoutToken.ThrowIfCancellationRequested(); outputStream.Write(buffer, 0, read); totalRead += read; if (canReportProgress) progressAction(new DownloadProgress(totalRead, total)); } if (outputStream.Length == 0) throw new DownloadException(\"Zero length stream\"); if (outputStream.Length < 32) throw new DownloadException(\"Invalid stream\"); return outputStream.ToArray(); } } catch (Exception ex) when (ex is OperationCanceledException || ex is ObjectDisposedException) { if (httpReadTimeoutTokenSource.IsCancellationRequested) throw new DownloadReadTimeoutException(); throw; } } } } catch (OperationCanceledException) { if (httpHeadersTimeoutTokenSource.IsCancellationRequested) throw new DownloadHeadersTimeoutException(); else throw; } } }", "label": "ComplexConditional"}
{"text": "private void TreeContextMenu_Opening(object sender, CancelEventArgs e) { var root = JsonTreeView.SelectedNode; dynamic json = root.Tag; // root is array, children > 0, root[0](=child) is object or array if ( root.GetNodeCount(false) > 0 && json != null && json is Codeplex.Data.DynamicJson && json.IsArray && root.FirstNode.Tag != null && root.FirstNode.Tag is Codeplex.Data.DynamicJson && (((dynamic)root.FirstNode.Tag).IsArray || ((dynamic)root.FirstNode.Tag).IsObject)) { TreeContextMenu_OutputCSV.Enabled = true; } else { TreeContextMenu_OutputCSV.Enabled = false; } }", "label": "ComplexMethod"}
{"text": "public static bool ValueEquals(object objA, object objB) { if (objA == null && objB == null) return true; if (objA != null && objB == null) return false; if (objA == null && objB != null) return false; // comparing an Int32 and Int64 both of the same value returns false // make types the same then compare if (objA.GetType() != objB.GetType()) { if (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB)) return Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture)); else if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal)) return MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture)); else return false; } return objA.Equals(objB); }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Internal use only /// </summary> /// <param name=\"type\"></param> /// <param name=\"reader\"></param> /// <param name=\"startBound\"></param> /// <param name=\"length\"></param> /// <param name=\"returnNullIfFirstMissing\"></param> /// <returns></returns> public static Func<IDataReader, object> GetTypeDeserializer( #if CSHARP30 Type type, IDataReader reader, int startBound, int length, bool returnNullIfFirstMissing #else Type type, IDataReader reader, int startBound = 0, int length = -1, bool returnNullIfFirstMissing = false #endif ) { var dm = new DynamicMethod(string.Format(\"Deserialize{0}\", Guid.NewGuid()), typeof(object), new[] { typeof(IDataReader) }, true); var il = dm.GetILGenerator(); il.DeclareLocal(typeof(int)); il.DeclareLocal(type); il.Emit(OpCodes.Ldc_I4_0); il.Emit(OpCodes.Stloc_0); if (length == -1) { length = reader.FieldCount - startBound; } if (reader.FieldCount <= startBound) { throw MultiMapException(reader); } var names = Enumerable.Range(startBound, length).Select(i => reader.GetName(i)).ToArray(); ITypeMap typeMap = GetTypeMap(type); int index = startBound; ConstructorInfo specializedConstructor = null; bool supportInitialize = false; if (type.IsValueType) { il.Emit(OpCodes.Ldloca_S, (byte)1); il.Emit(OpCodes.Initobj, type); } else { var types = new Type[length]; for (int i = startBound; i < startBound + length; i++) { types[i - startBound] = reader.GetFieldType(i); } var explicitConstr = typeMap.FindExplicitConstructor(); if (explicitConstr != null) { var structLocals = new Dictionary<Type, LocalBuilder>(); var consPs = explicitConstr.GetParameters(); foreach(var p in consPs) { if(!p.ParameterType.IsValueType) { il.Emit(OpCodes.Ldnull); } else { LocalBuilder loc; if(!structLocals.TryGetValue(p.ParameterType, out loc)) { structLocals[p.ParameterType] = loc = il.DeclareLocal(p.ParameterType); } il.Emit(OpCodes.Ldloca, (short)loc.LocalIndex); il.Emit(OpCodes.Initobj, p.ParameterType); il.Emit(OpCodes.Ldloca, (short)loc.LocalIndex); il.Emit(OpCodes.Ldobj, p.ParameterType); } } il.Emit(OpCodes.Newobj, explicitConstr); il.Emit(OpCodes.Stloc_1); supportInitialize = typeof(ISupportInitialize).IsAssignableFrom(type); if (supportInitialize) { il.Emit(OpCodes.Ldloc_1); il.EmitCall(OpCodes.Callvirt, typeof(ISupportInitialize).GetMethod(\"BeginInit\"), null); } } else { var ctor = typeMap.FindConstructor(names, types); if (ctor == null) { string proposedTypes = \"(\" + string.Join(\", \", types.Select((t, i) => t.FullName + \" \" + names[i]).ToArray()) + \")\"; throw new InvalidOperationException(string.Format(\"A parameterless default constructor or one matching signature {0} is required for {1} materialization\", proposedTypes, type.FullName)); } if (ctor.GetParameters().Length == 0) { il.Emit(OpCodes.Newobj, ctor); il.Emit(OpCodes.Stloc_1); supportInitialize = typeof(ISupportInitialize).IsAssignableFrom(type); if (supportInitialize) { il.Emit(OpCodes.Ldloc_1); il.EmitCall(OpCodes.Callvirt, typeof(ISupportInitialize).GetMethod(\"BeginInit\"), null); } } else { specializedConstructor = ctor; } } } il.BeginExceptionBlock(); if (type.IsValueType) { il.Emit(OpCodes.Ldloca_S, (byte)1);// [target] } else if (specializedConstructor == null) { il.Emit(OpCodes.Ldloc_1);// [target] } var members = (specializedConstructor != null ? names.Select(n => typeMap.GetConstructorParameter(specializedConstructor, n)) : names.Select(n => typeMap.GetMember(n))).ToList(); // stack is now [target] bool first = true; var allDone = il.DefineLabel(); int enumDeclareLocal = -1, valueCopyLocal = il.DeclareLocal(typeof(object)).LocalIndex; foreach (var item in members) { if (item != null) { if (specializedConstructor == null) il.Emit(OpCodes.Dup); // stack is now [target][target] Label isDbNullLabel = il.DefineLabel(); Label finishLabel = il.DefineLabel(); il.Emit(OpCodes.Ldarg_0); // stack is now [target][target][reader] EmitInt32(il, index); // stack is now [target][target][reader][index] il.Emit(OpCodes.Dup);// stack is now [target][target][reader][index][index] il.Emit(OpCodes.Stloc_0);// stack is now [target][target][reader][index] il.Emit(OpCodes.Callvirt, getItem); // stack is now [target][target][value-as-object] il.Emit(OpCodes.Dup); // stack is now [target][target][value-as-object][value-as-object] StoreLocal(il, valueCopyLocal); Type colType = reader.GetFieldType(index); Type memberType = item.MemberType; if (memberType == typeof(char) || memberType == typeof(char?)) { il.EmitCall(OpCodes.Call, typeof(SqlMapper).GetMethod( memberType == typeof(char) ? \"ReadChar\" : \"ReadNullableChar\", BindingFlags.Static | BindingFlags.Public), null); // stack is now [target][target][typed-value] } else { il.Emit(OpCodes.Dup); // stack is now [target][target][value][value] il.Emit(OpCodes.Isinst, typeof(DBNull)); // stack is now [target][target][value-as-object][DBNull or null] il.Emit(OpCodes.Brtrue_S, isDbNullLabel); // stack is now [target][target][value-as-object] // unbox nullable enums as the primitive, i.e. byte etc var nullUnderlyingType = Nullable.GetUnderlyingType(memberType); var unboxType = nullUnderlyingType != null && nullUnderlyingType.IsEnum ? nullUnderlyingType : memberType; if (unboxType.IsEnum) { Type numericType = Enum.GetUnderlyingType(unboxType); if(colType == typeof(string)) { if (enumDeclareLocal == -1) { enumDeclareLocal = il.DeclareLocal(typeof(string)).LocalIndex; } il.Emit(OpCodes.Castclass, typeof(string)); // stack is now [target][target][string] StoreLocal(il, enumDeclareLocal); // stack is now [target][target] il.Emit(OpCodes.Ldtoken, unboxType); // stack is now [target][target][enum-type-token] il.EmitCall(OpCodes.Call, typeof(Type).GetMethod(\"GetTypeFromHandle\"), null);// stack is now [target][target][enum-type] LoadLocal(il, enumDeclareLocal); // stack is now [target][target][enum-type][string] il.Emit(OpCodes.Ldc_I4_1); // stack is now [target][target][enum-type][string][true] il.EmitCall(OpCodes.Call, enumParse, null); // stack is now [target][target][enum-as-object] il.Emit(OpCodes.Unbox_Any, unboxType); // stack is now [target][target][typed-value] } else { FlexibleConvertBoxedFromHeadOfStack(il, colType, unboxType, numericType); } if (nullUnderlyingType != null) { il.Emit(OpCodes.Newobj, memberType.GetConstructor(new[] { nullUnderlyingType })); // stack is now [target][target][typed-value] } } else if (memberType.FullName == LinqBinary) { il.Emit(OpCodes.Unbox_Any, typeof(byte[])); // stack is now [target][target][byte-array] il.Emit(OpCodes.Newobj, memberType.GetConstructor(new Type[] { typeof(byte[]) }));// stack is now [target][target][binary] } else { TypeCode dataTypeCode = Type.GetTypeCode(colType), unboxTypeCode = Type.GetTypeCode(unboxType); bool hasTypeHandler; if ((hasTypeHandler = typeHandlers.ContainsKey(unboxType)) || colType == unboxType || dataTypeCode == unboxTypeCode || dataTypeCode == Type.GetTypeCode(nullUnderlyingType)) { if (hasTypeHandler) { #pragma warning disable 618 il.EmitCall(OpCodes.Call, typeof(TypeHandlerCache<>).MakeGenericType(unboxType).GetMethod(\"Parse\"), null); // stack is now [target][target][typed-value] #pragma warning restore 618 } else { il.Emit(OpCodes.Unbox_Any, unboxType); // stack is now [target][target][typed-value] } } else { // not a direct match; need to tweak the unbox FlexibleConvertBoxedFromHeadOfStack(il, colType, nullUnderlyingType ?? unboxType, null); if (nullUnderlyingType != null) { il.Emit(OpCodes.Newobj, unboxType.GetConstructor(new[] { nullUnderlyingType })); // stack is now [target][target][typed-value] } } } } if (specializedConstructor == null) { // Store the value in the property/field if (item.Property != null) { if (type.IsValueType) { il.Emit(OpCodes.Call, DefaultTypeMap.GetPropertySetter(item.Property, type)); // stack is now [target] } else { il.Emit(OpCodes.Callvirt, DefaultTypeMap.GetPropertySetter(item.Property, type)); // stack is now [target] } } else { il.Emit(OpCodes.Stfld, item.Field); // stack is now [target] } } il.Emit(OpCodes.Br_S, finishLabel); // stack is now [target] il.MarkLabel(isDbNullLabel); // incoming stack: [target][target][value] if (specializedConstructor != null) { il.Emit(OpCodes.Pop); if (item.MemberType.IsValueType) { int localIndex = il.DeclareLocal(item.MemberType).LocalIndex; LoadLocalAddress(il, localIndex); il.Emit(OpCodes.Initobj, item.MemberType); LoadLocal(il, localIndex); } else { il.Emit(OpCodes.Ldnull); } } else { il.Emit(OpCodes.Pop); // stack is now [target][target] il.Emit(OpCodes.Pop); // stack is now [target] } if (first && returnNullIfFirstMissing) { il.Emit(OpCodes.Pop); il.Emit(OpCodes.Ldnull); // stack is now [null] il.Emit(OpCodes.Stloc_1); il.Emit(OpCodes.Br, allDone); } il.MarkLabel(finishLabel); } first = false; index += 1; } if (type.IsValueType) { il.Emit(OpCodes.Pop); } else { if (specializedConstructor != null) { il.Emit(OpCodes.Newobj, specializedConstructor); } il.Emit(OpCodes.Stloc_1); // stack is empty if (supportInitialize) { il.Emit(OpCodes.Ldloc_1); il.EmitCall(OpCodes.Callvirt, typeof(ISupportInitialize).GetMethod(\"EndInit\"), null); } } il.MarkLabel(allDone); il.BeginCatchBlock(typeof(Exception)); // stack is Exception il.Emit(OpCodes.Ldloc_0); // stack is Exception, index il.Emit(OpCodes.Ldarg_0); // stack is Exception, index, reader LoadLocal(il, valueCopyLocal); // stack is Exception, index, reader, value il.EmitCall(OpCodes.Call, typeof(SqlMapper).GetMethod(\"ThrowDataException\"), null); il.EndExceptionBlock(); il.Emit(OpCodes.Ldloc_1); // stack is [rval] if (type.IsValueType) { il.Emit(OpCodes.Box, type); } il.Emit(OpCodes.Ret); return (Func<IDataReader, object>)dm.CreateDelegate(typeof(Func<IDataReader, object>)); }", "label": "FeatureEnvy"}
{"text": "#endregion #region ----- SearchBracketBackward ----- /// <summary> /// Finds the offset of the opening bracket in the block defined by offset skipping /// brackets, strings and comments. /// </summary> /// <param name=\"document\">The document.</param> /// <param name=\"offset\">The offset of an position in the block (before the closing bracket).</param> /// <param name=\"openBracket\">The character for the opening bracket.</param> /// <param name=\"closingBracket\">The character for the closing bracket.</param> /// <returns> /// Returns the offset of the opening bracket or -1 if no matching bracket was found. /// </returns> public override int SearchBracketBackward(IDocument document, int offset, char openBracket, char closingBracket) { if (offset >= document.TextLength) return -1; // first try \"quick find\" - find the matching bracket if there is no string/comment in the way int quickResult = base.SearchBracketBackward(document, offset, openBracket, closingBracket); if (quickResult >= 0) return quickResult; // we need to parse the line from the beginning, so get the line start position int linestart = ScanLineStart(document, offset + 1); // we need to know where offset is - in a string/comment or in normal code? // ignore cases where offset is in a block comment int starttype = GetStartType(document, linestart, offset + 1); if (starttype != 0) return -1; // start position is in a comment/string // I don't see any possibility to parse a C# document backwards... // We have to do it forwards and push all bracket positions on a stack. Stack bracketStack = new Stack(); bool blockComment = false; bool lineComment = false; bool inChar = false; bool inString = false; bool verbatim = false; for (int i = 0; i <= offset; ++i) { char ch = document.GetCharAt(i); switch (ch) { case '\\r': case '\\n': lineComment = false; inChar = false; if (!verbatim) inString = false; break; case '/': if (blockComment) { Debug.Assert(i > 0); if (document.GetCharAt(i - 1) == '*') { blockComment = false; } } if (!inString && !inChar && i + 1 < document.TextLength) { if (!blockComment && document.GetCharAt(i + 1) == '/') { lineComment = true; } if (!lineComment && document.GetCharAt(i + 1) == '*') { blockComment = true; } } break; case '\"': if (!(inChar || lineComment || blockComment)) { if (inString && verbatim) { if (i + 1 < document.TextLength && document.GetCharAt(i + 1) == '\"') { ++i; // skip escaped quote inString = false; // let the string go } else { verbatim = false; } } else if (!inString && offset > 0 && document.GetCharAt(i - 1) == '@') { verbatim = true; } inString = !inString; } break; case '\\'': if (!(inString || lineComment || blockComment)) { inChar = !inChar; } break; case '\\\\': if ((inString && !verbatim) || inChar) ++i; // skip next character break; default: if (ch == openBracket) { if (!(inString || inChar || lineComment || blockComment)) { bracketStack.Push(i); } } else if (ch == closingBracket) { if (!(inString || inChar || lineComment || blockComment)) { if (bracketStack.Count > 0) bracketStack.Pop(); } } break; } } if (bracketStack.Count > 0) return (int) bracketStack.Pop(); return -1; }", "label": "ComplexMethod"}
{"text": "public override void OnResponse(NetState state, RelayInfo info) { if (this.m_State == null) return; Mobile focus = this.m_State.Mobile; Mobile from = state.Mobile; if (focus == null) { from.SendMessage(\"That character is no longer online.\"); return; } else if (focus.Deleted) { from.SendMessage(\"That character no longer exists.\"); return; } else if (from != focus && focus.Hidden && from.AccessLevel < focus.AccessLevel && (!(focus is PlayerMobile) || !((PlayerMobile)focus).VisibilityList.Contains(from))) { from.SendMessage(\"That character is no longer visible.\"); return; } switch ( info.ButtonID ) { case 1: // Tell { TextRelay text = info.GetTextEntry(0); if (text != null) { focus.SendMessage(0x482, \"{0} tells you:\", from.Name); focus.SendMessage(0x482, text.Text); CommandLogging.WriteLine(from, \"{0} {1} telling {2} \\\"{3}\\\" \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus), text.Text); } from.SendGump(new ClientGump(from, this.m_State)); break; } case 4: // Props { this.Resend(from, info); if (!BaseCommand.IsAccessible(from, focus)) from.SendMessage(\"That is not accessible.\"); else { from.SendGump(new PropertiesGump(from, focus)); CommandLogging.WriteLine(from, \"{0} {1} opening properties gump of {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus)); } break; } case 5: // Go to { if (focus.Map == null || focus.Map == Map.Internal) { from.SendMessage(\"That character is not in the world.\"); } else { from.MoveToWorld(focus.Location, focus.Map); this.Resend(from, info); CommandLogging.WriteLine(from, \"{0} {1} going to {2}, Location {3}, Map {4}\", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus), focus.Location, focus.Map); } break; } case 6: // Get { if (from.Map == null || from.Map == Map.Internal) { from.SendMessage(\"You cannot bring that person here.\"); } else { focus.MoveToWorld(from.Location, from.Map); this.Resend(from, info); CommandLogging.WriteLine(from, \"{0} {1} bringing {2} to Location {3}, Map {4}\", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus), from.Location, from.Map); } break; } case 7: // Move { from.Target = new MoveTarget(focus); this.Resend(from, info); break; } case 8: // Kick { if (from.AccessLevel >= AccessLevel.GameMaster && from.AccessLevel > focus.AccessLevel) { focus.Say(\"I've been kicked!\"); this.m_State.Dispose(); CommandLogging.WriteLine(from, \"{0} {1} kicking {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus)); } break; } case 9: // Kill { if (from.AccessLevel >= AccessLevel.GameMaster && from.AccessLevel > focus.AccessLevel) { focus.Kill(); CommandLogging.WriteLine(from, \"{0} {1} killing {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus)); } this.Resend(from, info); break; } case 10: //Res { if (from.AccessLevel >= AccessLevel.GameMaster && from.AccessLevel > focus.AccessLevel) { focus.PlaySound(0x214); focus.FixedEffect(0x376A, 10, 16); focus.Resurrect(); CommandLogging.WriteLine(from, \"{0} {1} resurrecting {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus)); } this.Resend(from, info); break; } case 11: // Skills { this.Resend(from, info); if (from.AccessLevel > focus.AccessLevel) { from.SendGump(new SkillsGump(from, (Mobile)focus)); CommandLogging.WriteLine(from, \"{0} {1} Opening Skills gump of {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus)); } break; } } }", "label": "ComplexMethod"}
{"text": "#endregion #region \"Declaration Conflicts\" public bool LocalVariableConflict( SyntaxToken token) { if (token.Parent.IsKind(SyntaxKind.IdentifierName) && token.Parent.IsParentKind(SyntaxKind.InvocationExpression) && token.GetPreviousToken().Kind() != SyntaxKind.DotToken && token.GetNextToken().Kind() != SyntaxKind.DotToken) { var expression = (ExpressionSyntax)token.Parent; var enclosingMemberDeclaration = expression.FirstAncestorOrSelf<MemberDeclarationSyntax>(); if (enclosingMemberDeclaration != null) { var locals = enclosingMemberDeclaration.GetLocalDeclarationMap()[token.ValueText]; if (locals.Length > 0) { return true; } } } return false; }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Copy the dependent files with relative locations in the mapfile. /// </summary> /// <param name=\"oldFile\">The old file name</param> /// <param name=\"newFile\">The new file name</param> private void CopyDependentFiles(string oldFile, string newFile) { if (oldFile == \"new.map\") oldFile = Application.StartupPath + \"\\\\templates\\\\new.map\"; // template string oldPath = oldFile.Substring(0, oldFile.LastIndexOf('\\\\')); string newPath = newFile.Substring(0, newFile.LastIndexOf('\\\\')); mapObj map = mapControl.Target; string file = map.fontset.filename; if (file != null && !File.Exists(file) && !File.Exists(Path.Combine(newPath, file)) && File.Exists(Path.Combine(oldPath, file))) File.Copy(Path.Combine(oldPath, file), Path.Combine(newPath, file)); file = map.symbolset.filename; if (file != null && !File.Exists(file) && !File.Exists(Path.Combine(newPath, file)) && File.Exists(Path.Combine(oldPath, file))) { File.Copy(Path.Combine(oldPath, file), Path.Combine(newPath, file)); // copy the images defined in the symbol file for (int i = 0; i < map.symbolset.numsymbols; i++) { symbolObj sym = map.symbolset.getSymbol(i); if (sym.type == (int)MS_SYMBOL_TYPE.MS_SYMBOL_PIXMAP && sym.imagepath != null) { file = sym.imagepath; if (!File.Exists(file) && !File.Exists(Path.Combine(newPath, file)) && File.Exists(Path.Combine(oldPath, file))) File.Copy(Path.Combine(oldPath, file), Path.Combine(newPath, file)); } } } }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Reads the next value as an Enumerated value with tag UNIVERSAL 10, converting it to /// the non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <typeparamref name=\"TEnum\"/>. /// </summary> /// <typeparam name=\"TEnum\">Destination enum type</typeparam> /// <returns> /// the Enumerated value converted to a <typeparamref name=\"TEnum\"/>. /// </returns> /// <remarks> /// This method does not validate that the return value is defined within /// <typeparamref name=\"TEnum\"/>. /// </remarks> /// <exception cref=\"CryptographicException\"> /// the next value does not have the correct tag --OR-- /// the length encoding is not valid under the current encoding rules --OR-- /// the contents are not valid under the current encoding rules --OR-- /// the encoded value is too big to fit in a <typeparamref name=\"TEnum\"/> value /// </exception> /// <exception cref=\"ArgumentException\"> /// <typeparamref name=\"TEnum\"/> is not an enum type --OR-- /// <typeparamref name=\"TEnum\"/> was declared with <see cref=\"FlagsAttribute\"/> /// </exception> /// <seealso cref=\"ReadEnumeratedValue{TEnum}(Asn1Tag)\"/> public TEnum ReadEnumeratedValue<TEnum>() where TEnum : struct { Type tEnum = typeof(TEnum); return (TEnum)Enum.ToObject(tEnum, ReadEnumeratedValue(tEnum)); }/// <summary> /// Reads the next value as an Enumerated with tag UNIVERSAL 10, converting it to the /// non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <typeparamref name=\"TEnum\"/>. /// </summary> /// <param name=\"expectedTag\">The tag to check for before reading.</param> /// <typeparam name=\"TEnum\">Destination enum type</typeparam> /// <returns> /// the Enumerated value converted to a <typeparamref name=\"TEnum\"/>. /// </returns> /// <remarks> /// This method does not validate that the return value is defined within /// <typeparamref name=\"TEnum\"/>. /// </remarks> /// <exception cref=\"CryptographicException\"> /// the next value does not have the correct tag --OR-- /// the length encoding is not valid under the current encoding rules --OR-- /// the contents are not valid under the current encoding rules --OR-- /// the encoded value is too big to fit in a <typeparamref name=\"TEnum\"/> value /// </exception> /// <exception cref=\"ArgumentException\"> /// <typeparamref name=\"TEnum\"/> is not an enum type --OR-- /// <typeparamref name=\"TEnum\"/> was declared with <see cref=\"FlagsAttribute\"/> /// --OR-- /// <paramref name=\"expectedTag\"/>.<see cref=\"Asn1Tag.TagClass\"/> is /// <see cref=\"TagClass.Universal\"/>, but /// <paramref name=\"expectedTag\"/>.<see cref=\"Asn1Tag.TagValue\"/> is not correct for /// the method /// </exception> public TEnum ReadEnumeratedValue<TEnum>(Asn1Tag expectedTag) where TEnum : struct { Type tEnum = typeof(TEnum); return (TEnum)Enum.ToObject(tEnum, ReadEnumeratedValue(expectedTag, tEnum)); }/// <summary> /// Reads the next value as an Enumerated value with tag UNIVERSAL 10, converting it to /// the non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <paramref name=\"tEnum\"/>. /// </summary> /// <param name=\"tEnum\">Type object representing the destination type.</param> /// <returns> /// the Enumerated value converted to a <paramref name=\"tEnum\"/>. /// </returns> /// <remarks> /// This method does not validate that the return value is defined within /// <paramref name=\"tEnum\"/>. /// </remarks> /// <exception cref=\"CryptographicException\"> /// the next value does not have the correct tag --OR-- /// the length encoding is not valid under the current encoding rules --OR-- /// the contents are not valid under the current encoding rules --OR-- /// the encoded value is too big to fit in a <paramref name=\"tEnum\"/> value /// </exception> /// <exception cref=\"ArgumentException\"> /// <paramref name=\"tEnum\"/> is not an enum type --OR-- /// <paramref name=\"tEnum\"/> was declared with <see cref=\"FlagsAttribute\"/> /// </exception> /// <seealso cref=\"ReadEnumeratedValue(Asn1Tag, Type)\"/> public Enum ReadEnumeratedValue(Type tEnum) => ReadEnumeratedValue(Asn1Tag.Enumerated, tEnum);/// <summary> /// Reads the next value as an Enumerated with tag UNIVERSAL 10, converting it to the /// non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <paramref name=\"tEnum\"/>. /// </summary> /// <param name=\"expectedTag\">The tag to check for before reading.</param> /// <param name=\"tEnum\">Type object representing the destination type.</param> /// <returns> /// the Enumerated value converted to a <paramref name=\"tEnum\"/>. /// </returns> /// <remarks> /// This method does not validate that the return value is defined within /// <paramref name=\"tEnum\"/>. /// </remarks> /// <exception cref=\"CryptographicException\"> /// the next value does not have the correct tag --OR-- /// the length encoding is not valid under the current encoding rules --OR-- /// the contents are not valid under the current encoding rules --OR-- /// the encoded value is too big to fit in a <paramref name=\"tEnum\"/> value /// </exception> /// <exception cref=\"ArgumentException\"> /// <paramref name=\"tEnum\"/> is not an enum type --OR-- /// <paramref name=\"tEnum\"/> was declared with <see cref=\"FlagsAttribute\"/> /// --OR-- /// <paramref name=\"tEnum\"/>.<see cref=\"Asn1Tag.TagClass\"/> is /// <see cref=\"TagClass.Universal\"/>, but /// <paramref name=\"tEnum\"/>.<see cref=\"Asn1Tag.TagValue\"/> is not correct for /// the method /// </exception> public Enum ReadEnumeratedValue(Asn1Tag expectedTag, Type tEnum) { const UniversalTagNumber tagNumber = UniversalTagNumber.Enumerated; // This will throw an ArgumentException if TEnum isn't an enum type, // so we don't need to validate it. Type backingType = tEnum.GetEnumUnderlyingType(); if (tEnum.IsDefined(typeof(FlagsAttribute), false)) { throw new ArgumentException( SR.Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum, nameof(tEnum)); } // T-REC-X.690-201508 sec 8.4 says the contents are the same as for integers. int sizeLimit = Marshal.SizeOf(backingType); if (backingType == typeof(int) || backingType == typeof(long) || backingType == typeof(short) || backingType == typeof(sbyte)) { if (!TryReadSignedInteger(sizeLimit, expectedTag, tagNumber, out long value)) { throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding); } return (Enum)Enum.ToObject(tEnum, value); } if (backingType == typeof(uint) || backingType == typeof(ulong) || backingType == typeof(ushort) || backingType == typeof(byte)) { if (!TryReadUnsignedInteger(sizeLimit, expectedTag, tagNumber, out ulong value)) { throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding); } return (Enum)Enum.ToObject(tEnum, value); } Debug.Fail($\"No handler for type {backingType.Name}\"); throw new CryptographicException(); }", "label": "ComplexMethod"}
{"text": "public bool CheckAllowedProjectile(Item projectile) { if (projectile == null || AllowedProjectiles == null) return false; for (int i = 0; i < AllowedProjectiles.Length; i++) { Type t = AllowedProjectiles[i]; Type pt = projectile.GetType(); if (t == null || pt == null) continue; if (pt.IsSubclassOf(t) || pt.Equals(t) || (t.IsInterface && ContainsInterface(pt.GetInterfaces(), t))) { return true; } } return false; }", "label": "ComplexMethod"}
{"text": "public override void OnResponse(NetState sender, RelayInfo info) { Mobile from = sender.Mobile; if (info.ButtonID == 0 || this.m_Plant.Deleted || this.m_Plant.PlantStatus >= PlantStatus.DecorativePlant) return; if (((info.ButtonID >= 6 && info.ButtonID <= 10) || info.ButtonID == 12) && !from.InRange(this.m_Plant.GetWorldLocation(), 3)) { from.LocalOverheadMessage(MessageType.Regular, 0x3E9, 500446); // That is too far away. return; } if (!this.m_Plant.IsUsableBy(from)) { this.m_Plant.LabelTo(from, 1061856); // You must have the item in your backpack or locked down in order to use it. return; } switch ( info.ButtonID ) { case 1: // Reproduction menu { if (this.m_Plant.PlantStatus > PlantStatus.BowlOfDirt) { from.SendGump(new ReproductionGump(this.m_Plant)); } else { from.SendLocalizedMessage(1061885); // You need to plant a seed in the bowl first. from.SendGump(new MainPlantGump(this.m_Plant)); } break; } case 2: // Infestation { from.Send(new DisplayHelpTopic(54, true)); // INFESTATION LEVEL from.SendGump(new MainPlantGump(this.m_Plant)); break; } case 3: // Fungus { from.Send(new DisplayHelpTopic(56, true)); // FUNGUS LEVEL from.SendGump(new MainPlantGump(this.m_Plant)); break; } case 4: // Poison { from.Send(new DisplayHelpTopic(58, true)); // POISON LEVEL from.SendGump(new MainPlantGump(this.m_Plant)); break; } case 5: // Disease { from.Send(new DisplayHelpTopic(60, true)); // DISEASE LEVEL from.SendGump(new MainPlantGump(this.m_Plant)); break; } case 6: // Water { Item[] item = from.Backpack.FindItemsByType(typeof(BaseBeverage)); bool foundUsableWater = false; if (item != null && item.Length > 0) { for (int i = 0; i < item.Length; ++i) { BaseBeverage beverage = (BaseBeverage)item[i]; if (!beverage.IsEmpty && beverage.Pourable && beverage.Content == BeverageType.Water) { foundUsableWater = true; this.m_Plant.Pour(from, beverage); break; } } } if (!foundUsableWater) { from.Target = new PlantPourTarget(this.m_Plant); from.SendLocalizedMessage(1060808, \"#\" + this.m_Plant.GetLocalizedPlantStatus().ToString()); // Target the container you wish to use to water the ~1_val~. } from.SendGump(new MainPlantGump(this.m_Plant)); break; } case 7: // Poison potion { this.AddPotion(from, PotionEffect.PoisonGreater, PotionEffect.PoisonDeadly); break; } case 8: // Cure potion { this.AddPotion(from, PotionEffect.CureGreater); break; } case 9: // Heal potion { this.AddPotion(from, PotionEffect.HealGreater); break; } case 10: // Strength potion { this.AddPotion(from, PotionEffect.StrengthGreater); break; } case 11: // Help { from.Send(new DisplayHelpTopic(48, true)); // PLANT GROWING from.SendGump(new MainPlantGump(this.m_Plant)); break; } case 12: // Empty the bowl { from.SendGump(new EmptyTheBowlGump(this.m_Plant)); break; } } }", "label": "ComplexMethod"}
{"text": "private string GetIndent(Paragraph para, IEnumerable<Style> docStyles) { string indent = string.Empty; if (para != null && para.ParagraphProperties != null && para.ParagraphProperties.Indentation != null) { var indentation = para.ParagraphProperties.Indentation; if (indentation.Left != null && indentation.Left.HasValue) { indent = WordListManager.TwipsToSpaces(indentation.Left); } else if (indentation.Start != null && indentation.Start.HasValue) { indent = WordListManager.TwipsToSpaces(indentation.Start); } } if (para != null && para.ParagraphProperties != null && para.ParagraphProperties.ParagraphStyleId != null && para.ParagraphProperties.ParagraphStyleId.Val != null && para.ParagraphProperties.ParagraphStyleId.Val.HasValue) { var style = docStyles.Where(r => r.StyleId == para.ParagraphProperties.ParagraphStyleId.Val.Value) .Select(r => r).FirstOrDefault(); if (style != null) { var pp = style.Where(r => r is StyleParagraphProperties) .Select(r => r as StyleParagraphProperties).FirstOrDefault(); if (pp != null && pp.Indentation != null) { if (pp.Indentation.Left != null && pp.Indentation.Left.HasValue) { indent = WordListManager.TwipsToSpaces(pp.Indentation.Left); } else if (pp.Indentation.Start != null && pp.Indentation.Start.HasValue) { indent = WordListManager.TwipsToSpaces(pp.Indentation.Start); } } } } return indent; }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Draw the this <see cref=\"CurveItem\"/> to the specified <see cref=\"Graphics\"/> /// device. The format (stair-step or line) of the curve is /// defined by the <see cref=\"StepType\"/> property. The routine /// only draws the line segments; the symbols are drawn by the /// <see cref=\"Symbol.Draw\"/> method. This method /// is normally only called by the Draw method of the /// <see cref=\"CurveItem\"/> object /// </summary> /// <param name=\"g\"> /// A graphic device object to be drawn into. This is normally e.Graphics from the /// PaintEventArgs argument to the Paint() method. /// </param> /// <param name=\"scaleFactor\"> /// The scaling factor to be used for rendering objects. This is calculated and /// passed down by the parent <see cref=\"GraphPane\"/> object using the /// <see cref=\"PaneBase.CalcScaleFactor\"/> method, and is used to proportionally adjust /// font sizes, etc. according to the actual size of the graph. /// </param> /// <param name=\"pane\"> /// A reference to the <see cref=\"GraphPane\"/> object that is the parent or /// owner of this object. /// </param> /// <param name=\"curve\">A <see cref=\"LineItem\"/> representing this /// curve.</param> public void DrawCurve( Graphics g, GraphPane pane, CurveItem curve, float scaleFactor ) { Line source = this; if ( curve.IsSelected ) source = Selection.Line; // switch to int to optimize drawing speed (per Dale-a-b) int tmpX, tmpY, lastX = int.MaxValue, lastY = int.MaxValue; double curX, curY, lowVal; PointPair curPt, lastPt = new PointPair(); bool lastBad = true; IPointList points = curve.Points; ValueHandler valueHandler = new ValueHandler( pane, false ); Axis yAxis = curve.GetYAxis( pane ); Axis xAxis = curve.GetXAxis( pane ); bool xIsLog = xAxis._scale.IsLog; bool yIsLog = yAxis._scale.IsLog; // switch to int to optimize drawing speed (per Dale-a-b) int minX = (int)pane.Chart.Rect.Left; int maxX = (int)pane.Chart.Rect.Right; int minY = (int)pane.Chart.Rect.Top; int maxY = (int)pane.Chart.Rect.Bottom; using ( Pen pen = source.GetPen( pane, scaleFactor ) ) { if ( points != null && !_color.IsEmpty && this.IsVisible ) { //bool lastOut = false; bool isOut; bool isOptDraw = _isOptimizedDraw && points.Count > 1000; // (Dale-a-b) we'll set an element to true when it has been drawn bool[,] isPixelDrawn = null; if ( isOptDraw ) isPixelDrawn = new bool[maxX + 1, maxY + 1]; // Loop over each point in the curve for ( int i = 0; i < points.Count; i++ ) { curPt = points[i]; if ( pane.LineType == LineType.Stack ) { if ( !valueHandler.GetValues( curve, i, out curX, out lowVal, out curY ) ) { curX = PointPair.Missing; curY = PointPair.Missing; } } else { curX = curPt.X; curY = curPt.Y; } // Any value set to double max is invalid and should be skipped // This is used for calculated values that are out of range, divide // by zero, etc. // Also, any value <= zero on a log scale is invalid if ( curX == PointPair.Missing || curY == PointPair.Missing || System.Double.IsNaN( curX ) || System.Double.IsNaN( curY ) || System.Double.IsInfinity( curX ) || System.Double.IsInfinity( curY ) || ( xIsLog && curX <= 0.0 ) || ( yIsLog && curY <= 0.0 ) ) { // If the point is invalid, then make a linebreak only if IsIgnoreMissing is false // LastX and LastY are always the last valid point, so this works out lastBad = lastBad || !pane.IsIgnoreMissing; isOut = true; } else { // Transform the current point from user scale units to // screen coordinates tmpX = (int) xAxis.Scale.Transform( curve.IsOverrideOrdinal, i, curX ); tmpY = (int) yAxis.Scale.Transform( curve.IsOverrideOrdinal, i, curY ); // Maintain an array of \"used\" pixel locations to avoid duplicate drawing operations // contributed by Dale-a-b if ( isOptDraw && tmpX >= minX && tmpX <= maxX && tmpY >= minY && tmpY <= maxY ) // guard against the zoom-in case { if ( isPixelDrawn[tmpX, tmpY] ) continue; isPixelDrawn[tmpX, tmpY] = true; } isOut = ( tmpX < minX && lastX < minX ) || ( tmpX > maxX && lastX > maxX ) || ( tmpY < minY && lastY < minY ) || ( tmpY > maxY && lastY > maxY ); if ( !lastBad ) { try { // GDI+ plots the data wrong and/or throws an exception for // outrageous coordinates, so we do a sanity check here if ( lastX > 5000000 || lastX < -5000000 || lastY > 5000000 || lastY < -5000000 || tmpX > 5000000 || tmpX < -5000000 || tmpY > 5000000 || tmpY < -5000000 ) InterpolatePoint( g, pane, curve, lastPt, scaleFactor, pen, lastX, lastY, tmpX, tmpY ); else if ( !isOut ) { if ( !curve.IsSelected && this._gradientFill.IsGradientValueType ) { using ( Pen tPen = GetPen( pane, scaleFactor, lastPt ) ) { if ( this.StepType == StepType.NonStep ) { g.DrawLine( tPen, lastX, lastY, tmpX, tmpY ); } else if ( this.StepType == StepType.ForwardStep ) { g.DrawLine( tPen, lastX, lastY, tmpX, lastY ); g.DrawLine( tPen, tmpX, lastY, tmpX, tmpY ); } else if ( this.StepType == StepType.RearwardStep ) { g.DrawLine( tPen, lastX, lastY, lastX, tmpY ); g.DrawLine( tPen, lastX, tmpY, tmpX, tmpY ); } else if ( this.StepType == StepType.ForwardSegment ) { g.DrawLine( tPen, lastX, lastY, tmpX, lastY ); } else { g.DrawLine( tPen, lastX, tmpY, tmpX, tmpY ); } } } else { if ( this.StepType == StepType.NonStep ) { g.DrawLine( pen, lastX, lastY, tmpX, tmpY ); } else if ( this.StepType == StepType.ForwardStep ) { g.DrawLine( pen, lastX, lastY, tmpX, lastY ); g.DrawLine( pen, tmpX, lastY, tmpX, tmpY ); } else if ( this.StepType == StepType.RearwardStep ) { g.DrawLine( pen, lastX, lastY, lastX, tmpY ); g.DrawLine( pen, lastX, tmpY, tmpX, tmpY ); } else if ( this.StepType == StepType.ForwardSegment ) { g.DrawLine( pen, lastX, lastY, tmpX, lastY ); } else if ( this.StepType == StepType.RearwardSegment ) { g.DrawLine( pen, lastX, tmpY, tmpX, tmpY ); } } } } catch { InterpolatePoint( g, pane, curve, lastPt, scaleFactor, pen, lastX, lastY, tmpX, tmpY ); } } lastPt = curPt; lastX = tmpX; lastY = tmpY; lastBad = false; //lastOut = isOut; } } } } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Job that will run quick SQL queries on a schedule. /// /// Called by the <see cref=\"IScheduler\" /> when a /// <see cref=\"ITrigger\" /> fires that is associated with /// the <see cref=\"IJob\" />. /// </summary> public virtual void Execute( IJobExecutionContext context ) { JobDataMap dataMap = context.JobDetail.JobDataMap; Guid? entryWorkflowType = dataMap.GetString( \"EraEntryWorkflow\" ).AsGuidOrNull(); Guid? exitWorkflowType = dataMap.GetString( \"EraExitWorkflow\" ).AsGuidOrNull(); bool updateVisitDates = dataMap.GetBooleanValue( \"SetVisitDates\" ); int commandTimeout = dataMap.GetString( \"CommandTimeout\" ).AsIntegerOrNull() ?? 3600; // configuration // // giving int exitGivingCount = 1; // attendance int exitAttendanceCountShort = 1; int exitAttendanceCountLong = 8; // get era dataset from stored proc var resultContext = new RockContext(); var eraAttribute = AttributeCache.Get( SystemGuid.Attribute.PERSON_ERA_CURRENTLY_AN_ERA.AsGuid() ); var eraStartAttribute = AttributeCache.Get( SystemGuid.Attribute.PERSON_ERA_START_DATE.AsGuid() ); var eraEndAttribute = AttributeCache.Get( SystemGuid.Attribute.PERSON_ERA_END_DATE.AsGuid() ); if (eraAttribute == null || eraStartAttribute == null || eraEndAttribute == null) { throw new Exception( \"Family analytic attributes could not be found\" ); } resultContext.Database.CommandTimeout = commandTimeout; context.UpdateLastStatusMessage( \"Getting Family Analytics Era Dataset...\" ); var results = resultContext.Database.SqlQuery<EraResult>( \"spCrm_FamilyAnalyticsEraDataset\" ).ToList(); int personEntityTypeId = EntityTypeCache.Get( \"Rock.Model.Person\" ).Id; int attributeEntityTypeId = EntityTypeCache.Get( \"Rock.Model.Attribute\" ).Id; int eraAttributeId = eraAttribute.Id; int personAnalyticsCategoryId = CategoryCache.Get( SystemGuid.Category.HISTORY_PERSON_ANALYTICS.AsGuid() ).Id; int progressPosition = 0; int progressTotal = results.Count; foreach (var result in results ) { progressPosition++; // create new rock context for each family (https://weblog.west-wind.com/posts/2014/Dec/21/Gotcha-Entity-Framework-gets-slow-in-long-Iteration-Loops) RockContext updateContext = new RockContext(); updateContext.SourceOfChange = SOURCE_OF_CHANGE; updateContext.Database.CommandTimeout = commandTimeout; var attributeValueService = new AttributeValueService( updateContext ); var historyService = new HistoryService( updateContext ); // if era ensure it still meets requirements if ( result.IsEra ) { if (result.ExitGiftCountDuration < exitGivingCount && result.ExitAttendanceCountDurationShort < exitAttendanceCountShort && result.ExitAttendanceCountDurationLong < exitAttendanceCountLong ) { // exit era (delete attribute value from each person in family) var family = new GroupService( updateContext ).Queryable( \"Members, Members.Person\" ).AsNoTracking().Where( m => m.Id == result.FamilyId ).FirstOrDefault(); if ( family != null ) { foreach ( var person in family.Members.Select( m => m.Person ) ) { // remove the era flag var eraAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraAttribute.Id && v.EntityId == person.Id ).FirstOrDefault(); if ( eraAttributeValue != null ) { attributeValueService.Delete( eraAttributeValue ); } // set end date var eraEndAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraEndAttribute.Id && v.EntityId == person.Id ).FirstOrDefault(); if ( eraEndAttributeValue == null ) { eraEndAttributeValue = new AttributeValue(); eraEndAttributeValue.EntityId = person.Id; eraEndAttributeValue.AttributeId = eraEndAttribute.Id; attributeValueService.Add( eraEndAttributeValue ); } eraEndAttributeValue.Value = RockDateTime.Now.ToString(); // add a history record if ( personAnalyticsCategoryId != 0 && personEntityTypeId != 0 && attributeEntityTypeId != 0 && eraAttributeId != 0 ) { History historyRecord = new History(); historyService.Add( historyRecord ); historyRecord.EntityTypeId = personEntityTypeId; historyRecord.EntityId = person.Id; historyRecord.CreatedDateTime = RockDateTime.Now; historyRecord.CreatedByPersonAliasId = person.PrimaryAliasId; historyRecord.Caption = \"eRA\"; historyRecord.Verb = \"EXITED\"; historyRecord.ChangeType = History.HistoryChangeType.Attribute.ConvertToString(); historyRecord.ValueName = \"eRA\"; historyRecord.NewValue = \"Exited\"; historyRecord.RelatedEntityTypeId = attributeEntityTypeId; historyRecord.RelatedEntityId = eraAttributeId; historyRecord.CategoryId = personAnalyticsCategoryId; historyRecord.SourceOfChange = SOURCE_OF_CHANGE; } updateContext.SaveChanges(); } // launch exit workflow if ( exitWorkflowType.HasValue ) { LaunchWorkflow( exitWorkflowType.Value, family ); } } } } else { // entered era var family = new GroupService( updateContext ).Queryable( \"Members\" ).AsNoTracking().Where( m => m.Id == result.FamilyId ).FirstOrDefault(); if ( family != null ) { foreach ( var person in family.Members.Where( m => ! m.Person.IsDeceased ).Select( m => m.Person ) ) { // set era attribute to true var eraAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraAttribute.Id && v.EntityId == person.Id ).FirstOrDefault(); if ( eraAttributeValue == null ) { eraAttributeValue = new AttributeValue(); eraAttributeValue.EntityId = person.Id; eraAttributeValue.AttributeId = eraAttribute.Id; attributeValueService.Add( eraAttributeValue ); } eraAttributeValue.Value = bool.TrueString; // add start date var eraStartAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraStartAttribute.Id && v.EntityId == person.Id ).FirstOrDefault(); if (eraStartAttributeValue == null ) { eraStartAttributeValue = new AttributeValue(); eraStartAttributeValue.EntityId = person.Id; eraStartAttributeValue.AttributeId = eraStartAttribute.Id; attributeValueService.Add( eraStartAttributeValue ); } eraStartAttributeValue.Value = RockDateTime.Now.ToString(); // delete end date if it exists var eraEndAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraEndAttribute.Id && v.EntityId == person.Id ).FirstOrDefault(); if ( eraEndAttributeValue != null ) { attributeValueService.Delete( eraEndAttributeValue ); } // add a history record if ( personAnalyticsCategoryId != 0 && personEntityTypeId != 0 && attributeEntityTypeId != 0 && eraAttributeId != 0 ) { History historyRecord = new History(); historyService.Add( historyRecord ); historyRecord.EntityTypeId = personEntityTypeId; historyRecord.EntityId = person.Id; historyRecord.CreatedDateTime = RockDateTime.Now; historyRecord.CreatedByPersonAliasId = person.PrimaryAliasId; historyRecord.Caption = \"eRA\"; historyRecord.Verb = \"ENTERED\"; historyRecord.ChangeType = History.HistoryChangeType.Attribute.ConvertToString(); historyRecord.RelatedEntityTypeId = attributeEntityTypeId; historyRecord.RelatedEntityId = eraAttributeId; historyRecord.CategoryId = personAnalyticsCategoryId; historyRecord.SourceOfChange = SOURCE_OF_CHANGE; } updateContext.SaveChanges(); } // launch entry workflow if ( entryWorkflowType.HasValue ) { LaunchWorkflow( entryWorkflowType.Value, family ); } } } // update stats context.UpdateLastStatusMessage( $\"Updating eRA {progressPosition} of {progressTotal}\" ); } // load giving attributes context.UpdateLastStatusMessage( \"Updating Giving...\" ); resultContext.Database.ExecuteSqlCommand( \"spCrm_FamilyAnalyticsGiving\" ); // load attendance attributes context.UpdateLastStatusMessage( \"Updating Attendance...\" ); resultContext.Database.ExecuteSqlCommand( \"spCrm_FamilyAnalyticsAttendance\" ); // process visit dates if ( updateVisitDates ) { context.UpdateLastStatusMessage( \"Updating Visit Dates...\" ); resultContext.Database.ExecuteSqlCommand( \"spCrm_FamilyAnalyticsUpdateVisitDates\" ); } context.UpdateLastStatusMessage( \"\" ); }", "label": "ComplexMethod"}
{"text": "private static void AntiGapcloser_OnEnemyGapcloser(ActiveGapcloser gapcloser) { var pos = _e.GetPrediction(gapcloser.Sender).CastPosition; if (_config.Item(\"Gap_E\").GetValue<bool>()) { if (_e.IsReady() && gapcloser.Sender.IsValidTarget(_e.Range) && _w.IsReady()) { _e.CastIfHitchanceEquals(gapcloser.Sender, HitChance.High, Packets()); Utility.DelayAction.Add(50, () => _w.Cast(new Vector3(pos.X - 2, pos.Y - 2, pos.Z), Packets())); Utility.DelayAction.Add(150, () => _w.Cast(new Vector3(pos.X + 2, pos.Y + 2, pos.Z), Packets())); } else if (_e.IsReady() && gapcloser.Sender.IsValidTarget(_e.Range)) { _e.CastIfHitchanceEquals(gapcloser.Sender, HitChance.High, Packets()); } } if (Items.HasItem(3092) && Items.CanUseItem(3092) && _config.Item(\"usefrostq\").GetValue<bool>() && gapcloser.Sender.IsValidTarget(800)) { _frostqueen.Cast(gapcloser.Sender); } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Gets the automatic attack damage. /// </summary> /// <param name=\"source\">The source.</param> /// <param name=\"target\">The target.</param> /// <param name=\"includePassive\">if set to <c>true</c> [include passive].</param> /// <returns></returns> public static double GetAutoAttackDamage( this Obj_AI_Base source, Obj_AI_Base target, bool includePassive = false) { double result = source.TotalAttackDamage; var k = 1d; if (source.CharData.BaseSkinName == \"Kalista\") { k = 0.9d; } if (source.CharData.BaseSkinName == \"Kled\" && ObjectManager.Player.Spellbook.GetSpell(SpellSlot.Q).Name == \"KledRiderQ\") { k = 0.8d; } if (!includePassive) { return CalcPhysicalDamage(source, target, result*k); } var reduction = 0d; var hero = source as Obj_AI_Hero; if (hero != null) { // Spoils of War var minionTarget = target as Obj_AI_Minion; if (hero.IsMelee() && minionTarget != null && minionTarget.IsEnemy && minionTarget.Team != GameObjectTeam.Neutral && hero.Buffs.Any(buff => buff.Name == \"talentreaperdisplay\" && buff.Count > 0)) { if ( HeroManager.AllHeroes.Any( h => h.NetworkId != source.NetworkId && h.Team == source.Team && h.Distance(minionTarget.Position) < 1100)) { var value = 0; if (Items.HasItem(3302, hero)) { value = 200; // Relic Shield } else if (Items.HasItem(3097, hero)) { value = 240; // Targon's Brace } else if (Items.HasItem(3401, hero)) { value = 400; // Face of the Mountain } return value + hero.TotalAttackDamage; } } //Champions passive damages: result += AttackPassives.Where( p => (p.ChampionName == \"\" || p.ChampionName == hero.ChampionName) && p.IsActive(hero, target)) .Sum(passive => passive.GetDamage(hero, target)); // BotRK if (Items.HasItem(3153, hero)) { var d = 0.06*target.Health; if (target is Obj_AI_Minion) { d = Math.Min(d, 60); } result += d; } } var targetHero = target as Obj_AI_Hero; if (targetHero != null) { // Ninja tabi if (Items.HasItem(3047, targetHero)) { k *= 0.9d; } // Nimble Fighter if (targetHero.ChampionName == \"Fizz\") { var f = new int[] {4, 6, 8, 10, 12, 14}; reduction += f[(targetHero.Level - 1)/3]; } } //TODO: need to check if there are items or spells in game that reduce magical dmg % or by amount if (hero != null && hero.ChampionName == \"Corki\") { return CalcMixedDamage(source, target, (result - reduction)*k, result*k); } return CalcPhysicalDamage(source, target, (result - reduction)*k + PassiveFlatMod(source, target)); }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Gets the Leases, if any persisted to file, for an event hub partitions in the current namespace. /// </summary> /// <param name=\"ns\">Namespace name.</param> /// <param name=\"eventHub\">Event hub name.</param> /// <param name=\"consumerGroup\"></param> /// <returns>The in-memory or persisted lease for the event hub partition.</returns> public static Dictionary<string, Lease> GetLease(string ns, string eventHub, string consumerGroup) { if (string.IsNullOrWhiteSpace(ns) || string.IsNullOrWhiteSpace(eventHub) || string.IsNullOrWhiteSpace(consumerGroup)) { return null; } var key = string.Format(KeyFormat, ns, eventHub, consumerGroup); return mapDictionary.ContainsKey(key) ? mapDictionary[key].Leases : null; }/// <summary> /// Gets the Lease, if any persisted to file, for an event hub partition in the current namespace. /// </summary> /// <param name=\"ns\">Namespace name.</param> /// <param name=\"eventHub\">Event hub name.</param> /// <param name=\"consumerGroup\">Consumer group</param> /// <param name=\"partitionId\">Partition Id.</param> /// <returns>The in-memory or persisted lease for the event hub partition.</returns> public static Lease GetLease(string ns, string eventHub, string consumerGroup, string partitionId) { if (string.IsNullOrWhiteSpace(ns) || string.IsNullOrWhiteSpace(eventHub) || string.IsNullOrWhiteSpace(consumerGroup) || string.IsNullOrWhiteSpace(partitionId)) { return null; } var key = string.Format(KeyFormat, ns, eventHub, consumerGroup); var value = mapDictionary.ContainsKey(key) && mapDictionary[key].Leases != null && mapDictionary[key].Leases.ContainsKey(partitionId) ? mapDictionary[key].Leases[partitionId] : GetDefaultLease(partitionId); return value; }", "label": "ComplexMethod"}
{"text": "// When the ScrollViewer zooms in or out, we update DpiScale on our CanvasVirtualControl // to match. This adjusts its pixel density to match the current zoom level. But its size // in dips stays the same, so layout and scroll position are not affected by the zoom. void ScrollViewer_ViewChanged(object sender, ScrollViewerViewChangedEventArgs e) { // Cancel out the display DPI, so our fractal always renders at 96 DPI regardless of display // configuration. This boosts performance on high DPI displays, at the cost of visual quality. // For even better performance (but lower quality) this value could be further reduced. float dpiAdjustment = 96 / displayDpi; // Adjust DPI to match the current zoom level. float dpiScale = dpiAdjustment * scrollViewer.ZoomFactor; // To boost performance during pinch-zoom manipulations, we only update DPI when it has // changed by more than 20%, or at the end of the zoom (when e.IsIntermediate reports false). // Smaller changes will just scale the existing bitmap, which is much faster than recomputing // the fractal at a different resolution. To trade off between zooming perf vs. smoothness, // adjust the thresholds used in this ratio comparison. var ratio = canvas.DpiScale / dpiScale; if (e == null || !e.IsIntermediate || ratio <= 0.8 || ratio >= 1.25) { canvas.DpiScale = dpiScale; } }", "label": "ComplexMethod"}
{"text": "private int Internal_ExecCall(int argsCount, int instructionPtr, CallbackFunction handler = null, CallbackFunction continuation = null, bool thisCall = false, string debugText = null, DynValue unwindHandler = null) { DynValue fn = m_ValueStack.Peek(argsCount); CallStackItemFlags flags = (thisCall ? CallStackItemFlags.MethodCall : CallStackItemFlags.None); // if TCO threshold reached if ((m_ExecutionStack.Count > this.m_Script.Options.TailCallOptimizationThreshold && m_ExecutionStack.Count > 1) || (m_ValueStack.Count > this.m_Script.Options.TailCallOptimizationThreshold && m_ValueStack.Count > 1)) { // and the \"will-be\" return address is valid (we don't want to crash here) if (instructionPtr >= 0 && instructionPtr < this.m_RootChunk.Code.Count) { Instruction I = this.m_RootChunk.Code[instructionPtr]; // and we are followed *exactly* by a RET 1 if (I.OpCode == OpCode.Ret && I.NumVal == 1) { CallStackItem csi = m_ExecutionStack.Peek(); // if the current stack item has no \"odd\" things pending and neither has the new coming one.. if (csi.ClrFunction == null && csi.Continuation == null && csi.ErrorHandler == null && csi.ErrorHandlerBeforeUnwind == null && continuation == null && unwindHandler == null && handler == null) { instructionPtr = PerformTCO(instructionPtr, argsCount); flags |= CallStackItemFlags.TailCall; } } } } if (fn.Type == DataType.ClrFunction) { //IList<DynValue> args = new Slice<DynValue>(m_ValueStack, m_ValueStack.Count - argsCount, argsCount, false); IList<DynValue> args = CreateArgsListForFunctionCall(argsCount, 0); // we expand tuples before callbacks // args = DynValue.ExpandArgumentsToList(args); SourceRef sref = GetCurrentSourceRef(instructionPtr); m_ExecutionStack.Push(new CallStackItem() { ClrFunction = fn.Callback, ReturnAddress = instructionPtr, CallingSourceRef = sref, BasePointer = -1, ErrorHandler = handler, Continuation = continuation, ErrorHandlerBeforeUnwind = unwindHandler, Flags = flags, }); var ret = fn.Callback.Invoke(new ScriptExecutionContext(this, fn.Callback, sref), args, isMethodCall: thisCall); m_ValueStack.RemoveLast(argsCount + 1); m_ValueStack.Push(ret); m_ExecutionStack.Pop(); return Internal_CheckForTailRequests(null, instructionPtr); } else if (fn.Type == DataType.Function) { m_ValueStack.Push(DynValue.NewNumber(argsCount)); m_ExecutionStack.Push(new CallStackItem() { BasePointer = m_ValueStack.Count, ReturnAddress = instructionPtr, Debug_EntryPoint = fn.Function.EntryPointByteCodeLocation, CallingSourceRef = GetCurrentSourceRef(instructionPtr), ClosureScope = fn.Function.ClosureContext, ErrorHandler = handler, Continuation = continuation, ErrorHandlerBeforeUnwind = unwindHandler, Flags = flags, }); return fn.Function.EntryPointByteCodeLocation; } // fallback to __call metamethod var m = GetMetamethod(fn, \"__call\"); if (m != null && m.IsNotNil()) { DynValue[] tmp = new DynValue[argsCount + 1]; for (int i = 0; i < argsCount + 1; i++) tmp[i] = m_ValueStack.Pop(); m_ValueStack.Push(m); for (int i = argsCount; i >= 0; i--) m_ValueStack.Push(tmp[i]); return Internal_ExecCall(argsCount + 1, instructionPtr, handler, continuation); } throw ScriptRuntimeException.AttemptToCallNonFunc(fn.Type, debugText); }", "label": "ComplexMethod"}
{"text": "private void update() { double epsilon = 1e-30; if (Math.Abs(m_world_x1 - m_world_x2) < epsilon || Math.Abs(m_world_y1 - m_world_y2) < epsilon || Math.Abs(m_device_x1 - m_device_x2) < epsilon || Math.Abs(m_device_y1 - m_device_y2) < epsilon) { m_wx1 = m_world_x1; m_wy1 = m_world_y1; m_wx2 = m_world_x1 + 1.0; m_wy2 = m_world_y2 + 1.0; m_dx1 = m_device_x1; m_dy1 = m_device_y1; m_kx = 1.0; m_ky = 1.0; m_is_valid = false; return; } double world_x1 = m_world_x1; double world_y1 = m_world_y1; double world_x2 = m_world_x2; double world_y2 = m_world_y2; double device_x1 = m_device_x1; double device_y1 = m_device_y1; double device_x2 = m_device_x2; double device_y2 = m_device_y2; if (m_aspect != aspect_ratio_e.aspect_ratio_stretch) { double d; m_kx = (device_x2 - device_x1) / (world_x2 - world_x1); m_ky = (device_y2 - device_y1) / (world_y2 - world_y1); if ((m_aspect == aspect_ratio_e.aspect_ratio_meet) == (m_kx < m_ky)) { d = (world_y2 - world_y1) * m_ky / m_kx; world_y1 += (world_y2 - world_y1 - d) * m_align_y; world_y2 = world_y1 + d; } else { d = (world_x2 - world_x1) * m_kx / m_ky; world_x1 += (world_x2 - world_x1 - d) * m_align_x; world_x2 = world_x1 + d; } } m_wx1 = world_x1; m_wy1 = world_y1; m_wx2 = world_x2; m_wy2 = world_y2; m_dx1 = device_x1; m_dy1 = device_y1; m_kx = (device_x2 - device_x1) / (world_x2 - world_x1); m_ky = (device_y2 - device_y1) / (world_y2 - world_y1); m_is_valid = true; }", "label": "ComplexMethod"}
{"text": "public static void Reduce32(uint x, uint[] z) { long cc = 0; if (x != 0) { long xx12 = x; cc += (long)z[0] + xx12; z[0] = (uint)cc; cc >>= 32; cc += (long)z[1] - xx12; z[1] = (uint)cc; cc >>= 32; if (cc != 0) { cc += (long)z[2]; z[2] = (uint)cc; cc >>= 32; } cc += (long)z[3] + xx12; z[3] = (uint)cc; cc >>= 32; cc += (long)z[4] + xx12; z[4] = (uint)cc; cc >>= 32; Debug.Assert(cc == 0 || cc == 1); } if ((cc != 0 && Nat.IncAt(12, z, 5) != 0) || (z[11] == P11 && Nat.Gte(12, z, P))) { AddPInvTo(z); } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Constructs a Segment based on elements obtained from the two planes relations /// </summary> /// <param name=\"line\"></param> /// <param name=\"face\"></param> /// <param name=\"side1\"></param> /// <param name=\"side2\"></param> /// <param name=\"side3\"></param> public Segment(Line line, CsgFace face, PlaneSide side1, PlaneSide side2, PlaneSide side3) { this.line = line; index = 0; //VERTEX is an end if (side1 == PlaneSide.On) { SetVertex(face.v1); //other vertices on the same side - VERTEX-VERTEX VERTEX if (side2 == side3) { SetVertex(face.v1); } } //VERTEX is an end if (side2 == PlaneSide.On) { SetVertex(face.v2); //other vertices on the same side - VERTEX-VERTEX VERTEX if (side1 == side3) { SetVertex(face.v2); } } //VERTEX is an end if (side3 == PlaneSide.On) { SetVertex(face.v3); //other vertices on the same side - VERTEX-VERTEX VERTEX if (side1 == side2) { SetVertex(face.v3); } } //There are undefined ends - one or more edges cut the planes intersection line if (GetNumEndsSet() != 2) { //EDGE is an end if ((side1 == PlaneSide.Front && side2 == PlaneSide.Back) || (side1 == PlaneSide.Back && side2 == PlaneSide.Front)) { SetEdge(face.v1, face.v2); } //EDGE is an end if ((side2 == PlaneSide.Front && side3 == PlaneSide.Back) || (side2 == PlaneSide.Back && side3 == PlaneSide.Front)) { SetEdge(face.v2, face.v3); } //EDGE is an end if ((side3 == PlaneSide.Front && side1 == PlaneSide.Back) || (side3 == PlaneSide.Back && side1 == PlaneSide.Front)) { SetEdge(face.v3, face.v1); } } }", "label": "ComplexMethod"}
{"text": "/// <summary> /// Updates the selection set, given the hit object and the modifier keys</summary> /// <param name=\"hitRecord\">HitRecord</param> /// <param name=\"modifiers\">Modifier keys</param> private void UpdateSelection(HitRecord hitRecord, Keys modifiers) { TimelinePath hitObject = hitRecord.HitPath; bool hitIsValidAnchor = true; switch (hitRecord.Type) { case HitType.GroupMove: SelectGroups(hitObject); break; case HitType.TrackMove: SelectTracks(hitObject); break; case HitType.Interval: case HitType.Key: case HitType.Marker: SelectEvents(hitObject); Owner.Constrain = (modifiers & Owner.ConstrainModifierKeys) != 0; break; default: Anchor = null; hitIsValidAnchor = false; break; } if (hitIsValidAnchor) { // If the Shift key is not held down or the current Anchor is null, or the user // has switched between track and group, or the user has picked an event, then // update the Anchor. IEvents are always additive with the shift key. if ((modifiers & Keys.Shift) == 0 || Anchor == null || (Anchor.Last is IGroup && hitObject.Last is ITrack) || (Anchor.Last is ITrack && hitObject.Last is IGroup) || (Anchor.Last is IEvent && hitObject.Last is IEvent)) { Anchor = hitObject; } } }", "label": "ComplexMethod"}
{"text": "void RegisterRenamers(ConfuserContext context, NameService service) { bool wpf = false, caliburn = false, winforms = false, json = false; foreach (var module in context.Modules) foreach (var asmRef in module.GetAssemblyRefs()) { if (asmRef.Name == \"WindowsBase\" || asmRef.Name == \"PresentationCore\" || asmRef.Name == \"PresentationFramework\" || asmRef.Name == \"System.Xaml\") { wpf = true; } else if (asmRef.Name == \"Caliburn.Micro\") { caliburn = true; } else if (asmRef.Name == \"System.Windows.Forms\") { winforms = true; } else if (asmRef.Name == \"Newtonsoft.Json\") { json = true; } } if (wpf) { var wpfAnalyzer = new WPFAnalyzer(); context.Logger.Debug(\"WPF found, enabling compatibility.\"); service.Renamers.Add(wpfAnalyzer); if (caliburn) { context.Logger.Debug(\"Caliburn.Micro found, enabling compatibility.\"); service.Renamers.Add(new CaliburnAnalyzer(wpfAnalyzer)); } } if (winforms) { var winformsAnalyzer = new WinFormsAnalyzer(); context.Logger.Debug(\"WinForms found, enabling compatibility.\"); service.Renamers.Add(winformsAnalyzer); } if (json) { var jsonAnalyzer = new JsonAnalyzer(); context.Logger.Debug(\"Newtonsoft.Json found, enabling compatibility.\"); service.Renamers.Add(jsonAnalyzer); } }", "label": "ComplexConditional"}
{"text": "/// <summary>Represents the abstract base class from which all implementations of symmetric algorithms must inherit.</summary> [ComVisibleAttribute(true)] public abstract class SymmetricAlgorithm : IDisposable { /// <summary>Represents the block size, in bits, of the cryptographic operation.</summary> protected int BlockSizeValue; /// <summary>Represents the feedback size, in bits, of the cryptographic operation.</summary> protected int FeedbackSizeValue; /// <summary>Represents the initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />) for the symmetric algorithm.</summary> protected byte[] IVValue; /// <summary>Represents the secret key for the symmetric algorithm.</summary> protected byte[] KeyValue; /// <summary>Specifies the block sizes, in bits, that are supported by the symmetric algorithm.</summary> protected KeySizes[] LegalBlockSizesValue; /// <summary>Specifies the key sizes, in bits, that are supported by the symmetric algorithm.</summary> protected KeySizes[] LegalKeySizesValue; /// <summary>Represents the size, in bits, of the secret key used by the symmetric algorithm.</summary> protected int KeySizeValue; /// <summary>Represents the cipher mode used in the symmetric algorithm.</summary> protected CipherMode ModeValue; /// <summary>Represents the padding mode used in the symmetric algorithm.</summary> protected PaddingMode PaddingValue; /// <summary>Gets or sets the block size, in bits, of the cryptographic operation.</summary><returns>The block size, in bits.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The block size is invalid. </exception> public virtual int BlockSize { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } /// <summary>Gets or sets the feedback size, in bits, of the cryptographic operation.</summary><returns>The feedback size in bits.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The feedback size is larger than the block size. </exception> public virtual int FeedbackSize { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } /// <summary>Gets or sets the initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />) for the symmetric algorithm.</summary><returns>The initialization vector.</returns><exception cref=\"T:System.ArgumentNullException\">An attempt was made to set the initialization vector to null. </exception><exception cref=\"T:System.Security.Cryptography.CryptographicException\">An attempt was made to set the initialization vector to an invalid size. </exception> public virtual byte[] IV { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } /// <summary>Gets or sets the secret key for the symmetric algorithm.</summary><returns>The secret key to use for the symmetric algorithm.</returns><exception cref=\"T:System.ArgumentNullException\">An attempt was made to set the key to null. </exception><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The key size is invalid.</exception> public virtual byte[] Key { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } /// <summary>Gets the block sizes, in bits, that are supported by the symmetric algorithm.</summary><returns>An array that contains the block sizes supported by the algorithm.</returns> public virtual KeySizes[] LegalBlockSizes { get { throw new NotImplementedException(); } } /// <summary>Gets the key sizes, in bits, that are supported by the symmetric algorithm.</summary><returns>An array that contains the key sizes supported by the algorithm.</returns> public virtual KeySizes[] LegalKeySizes { get { throw new NotImplementedException(); } } /// <summary>Gets or sets the size, in bits, of the secret key used by the symmetric algorithm.</summary><returns>The size, in bits, of the secret key used by the symmetric algorithm.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The key size is not valid. </exception> public virtual int KeySize { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } /// <summary>Gets or sets the mode for operation of the symmetric algorithm.</summary><returns>The mode for operation of the symmetric algorithm. The default is <see cref=\"F:System.Security.Cryptography.CipherMode.CBC\" />.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The cipher mode is not one of the <see cref=\"T:System.Security.Cryptography.CipherMode\" /> values. </exception> public virtual CipherMode Mode { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } /// <summary>Gets or sets the padding mode used in the symmetric algorithm.</summary><returns>The padding mode used in the symmetric algorithm. The default is <see cref=\"F:System.Security.Cryptography.PaddingMode.PKCS7\" />.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The padding mode is not one of the <see cref=\"T:System.Security.Cryptography.PaddingMode\" /> values. </exception> public virtual PaddingMode Padding { get { throw new NotImplementedException(); } set { throw new NotImplementedException(); } } protected SymmetricAlgorithm() { throw new NotImplementedException(); } public void Dispose() { throw new NotImplementedException(); } public void Clear() { throw new NotImplementedException(); } /// <summary>Releases the unmanaged resources used by the <see cref=\"T:System.Security.Cryptography.SymmetricAlgorithm\" /> and optionally releases the managed resources.</summary><param name=\"disposing\">true to release both managed and unmanaged resources; false to release only unmanaged resources. </param> protected virtual void Dispose(bool disposing) { throw new NotImplementedException(); } /// <summary>Determines whether the specified key size is valid for the current algorithm.</summary><returns>true if the specified key size is valid for the current algorithm; otherwise, false.</returns><param name=\"bitLength\">The length, in bits, to check for a valid key size. </param> public bool ValidKeySize(int bitLength) { throw new NotImplementedException(); } public static SymmetricAlgorithm Create() { throw new NotImplementedException(); } /// <summary>Creates the specified cryptographic object used to perform the symmetric algorithm.</summary><returns>A cryptographic object used to perform the symmetric algorithm.</returns><param name=\"algName\">The name of the specific implementation of the <see cref=\"T:System.Security.Cryptography.SymmetricAlgorithm\" /> class to use. </param> public static SymmetricAlgorithm Create(string algName) { throw new NotImplementedException(); } public virtual ICryptoTransform CreateEncryptor() { throw new NotImplementedException(); } /// <summary>When overridden in a derived class, creates a symmetric encryptor object with the specified <see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.Key\" /> property and initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />).</summary><returns>A symmetric encryptor object.</returns><param name=\"rgbKey\">The secret key to use for the symmetric algorithm. </param><param name=\"rgbIV\">The initialization vector to use for the symmetric algorithm. </param> public abstract ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV); public virtual ICryptoTransform CreateDecryptor() { throw new NotImplementedException(); } /// <summary>When overridden in a derived class, creates a symmetric decryptor object with the specified <see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.Key\" /> property and initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />).</summary><returns>A symmetric decryptor object.</returns><param name=\"rgbKey\">The secret key to use for the symmetric algorithm. </param><param name=\"rgbIV\">The initialization vector to use for the symmetric algorithm. </param> public abstract ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV); public abstract void GenerateKey(); public abstract void GenerateIV(); }", "label": "FeatureEnvy"}
{"text": "private static class Log { public static class EventIds { public static readonly EventId EndpointsFound = new EventId(100, \"EndpointsFound\"); public static readonly EventId EndpointsNotFound = new EventId(101, \"EndpointsNotFound\"); public static readonly EventId TemplateSucceeded = new EventId(102, \"TemplateSucceeded\"); public static readonly EventId TemplateFailedRequiredValues = new EventId(103, \"TemplateFailedRequiredValues\"); public static readonly EventId TemplateFailedConstraint = new EventId(103, \"TemplateFailedConstraint\"); public static readonly EventId TemplateFailedExpansion = new EventId(104, \"TemplateFailedExpansion\"); public static readonly EventId LinkGenerationSucceeded = new EventId(105, \"LinkGenerationSucceeded\"); public static readonly EventId LinkGenerationFailed = new EventId(106, \"LinkGenerationFailed\"); } private static readonly Action<ILogger, IEnumerable<string>, object, Exception> _endpointsFound = LoggerMessage.Define<IEnumerable<string>, object>( LogLevel.Debug, EventIds.EndpointsFound, \"Found the endpoints {Endpoints} for address {Address}\"); private static readonly Action<ILogger, object, Exception> _endpointsNotFound = LoggerMessage.Define<object>( LogLevel.Debug, EventIds.EndpointsNotFound, \"No endpoints found for address {Address}\"); private static readonly Action<ILogger, string, string, string, string, Exception> _templateSucceeded = LoggerMessage.Define<string, string, string, string>( LogLevel.Debug, EventIds.TemplateSucceeded, \"Successfully processed template {Template} for {Endpoint} resulting in {Path} and {Query}\"); private static readonly Action<ILogger, string, string, string, string, string, Exception> _templateFailedRequiredValues = LoggerMessage.Define<string, string, string, string, string>( LogLevel.Debug, EventIds.TemplateFailedRequiredValues, \"Failed to process the template {Template} for {Endpoint}. \" + \"A required route value is missing, or has a different value from the required default values.\" + \"Supplied ambient values {AmbientValues} and {Values} with default values {Defaults}\"); private static readonly Action<ILogger, string, string, IRouteConstraint, string, string, Exception> _templateFailedConstraint = LoggerMessage.Define<string, string, IRouteConstraint, string, string>( LogLevel.Debug, EventIds.TemplateFailedConstraint, \"Failed to process the template {Template} for {Endpoint}. \" + \"The constraint {Constraint} for parameter {ParameterName} failed with values {Values}\"); private static readonly Action<ILogger, string, string, string, Exception> _templateFailedExpansion = LoggerMessage.Define<string, string, string>( LogLevel.Debug, EventIds.TemplateFailedExpansion, \"Failed to process the template {Template} for {Endpoint}. \" + \"The failure occured while expanding the template with values {Values} \" + \"This is usually due to a missing or empty value in a complex segment\"); private static readonly Action<ILogger, IEnumerable<string>, string, Exception> _linkGenerationSucceeded = LoggerMessage.Define<IEnumerable<string>, string>( LogLevel.Debug, EventIds.LinkGenerationSucceeded, \"Link generation succeeded for endpoints {Endpoints} with result {URI}\"); private static readonly Action<ILogger, IEnumerable<string>, Exception> _linkGenerationFailed = LoggerMessage.Define<IEnumerable<string>>( LogLevel.Debug, EventIds.LinkGenerationFailed, \"Link generation failed for endpoints {Endpoints}\"); public static void EndpointsFound(ILogger logger, object address, IEnumerable<Endpoint> endpoints) { // Checking level again to avoid allocation on the common path if (logger.IsEnabled(LogLevel.Debug)) { _endpointsFound(logger, endpoints.Select(e => e.DisplayName), address, null); } } public static void EndpointsNotFound(ILogger logger, object address) { _endpointsNotFound(logger, address, null); } public static void TemplateSucceeded(ILogger logger, RouteEndpoint endpoint, PathString path, QueryString query) { _templateSucceeded(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, path.Value, query.Value, null); } public static void TemplateFailedRequiredValues(ILogger logger, RouteEndpoint endpoint, RouteValueDictionary ambientValues, RouteValueDictionary values) { // Checking level again to avoid allocation on the common path if (logger.IsEnabled(LogLevel.Debug)) { _templateFailedRequiredValues(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, FormatRouteValues(ambientValues), FormatRouteValues(values), FormatRouteValues(endpoint.RoutePattern.Defaults), null); } } public static void TemplateFailedConstraint(ILogger logger, RouteEndpoint endpoint, string parameterName, IRouteConstraint constraint, RouteValueDictionary values) { // Checking level again to avoid allocation on the common path if (logger.IsEnabled(LogLevel.Debug)) { _templateFailedConstraint(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, constraint, parameterName, FormatRouteValues(values), null); } } public static void TemplateFailedExpansion(ILogger logger, RouteEndpoint endpoint, RouteValueDictionary values) { // Checking level again to avoid allocation on the common path if (logger.IsEnabled(LogLevel.Debug)) { _templateFailedExpansion(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, FormatRouteValues(values), null); } } public static void LinkGenerationSucceeded(ILogger logger, IEnumerable<Endpoint> endpoints, string uri) { // Checking level again to avoid allocation on the common path if (logger.IsEnabled(LogLevel.Debug)) { _linkGenerationSucceeded(logger, endpoints.Select(e => e.DisplayName), uri, null); } } public static void LinkGenerationFailed(ILogger logger, IEnumerable<Endpoint> endpoints) { // Checking level again to avoid allocation on the common path if (logger.IsEnabled(LogLevel.Debug)) { _linkGenerationFailed(logger, endpoints.Select(e => e.DisplayName), null); } } // EXPENSIVE: should only be used at Debug and higher levels of logging. private static string FormatRouteValues(IReadOnlyDictionary<string, object> values) { if (values == null || values.Count == 0) { return \"{ }\"; } var builder = new StringBuilder(); builder.Append(\"{ \"); foreach (var kvp in values.OrderBy(kvp => kvp.Key)) { builder.Append(\"\\\"\"); builder.Append(kvp.Key); builder.Append(\"\\\"\"); builder.Append(\":\"); builder.Append(\" \"); builder.Append(\"\\\"\"); builder.Append(kvp.Value); builder.Append(\"\\\"\"); builder.Append(\", \"); } // Trim trailing \", \" builder.Remove(builder.Length - 2, 2); builder.Append(\" }\"); return builder.ToString(); } } private static class Log { private static readonly Action<ILogger, string, Exception> _executingEndpoint = LoggerMessage.Define<string>( LogLevel.Information, new EventId(0, \"ExecutingEndpoint\"), \"Executing endpoint '{EndpointName}'\"); private static readonly Action<ILogger, string, Exception> _executedEndpoint = LoggerMessage.Define<string>( LogLevel.Information, new EventId(1, \"ExecutedEndpoint\"), \"Executed endpoint '{EndpointName}'\"); public static void ExecutingEndpoint(ILogger logger, Endpoint endpoint) { _executingEndpoint(logger, endpoint.DisplayName, null); } public static void ExecutedEndpoint(ILogger logger, Endpoint endpoint) { _executedEndpoint(logger, endpoint.DisplayName, null); } } private static class Log { private static readonly Action<ILogger, string, Exception> _matchSuccess = LoggerMessage.Define<string>( LogLevel.Debug, new EventId(1, \"MatchSuccess\"), \"Request matched endpoint '{EndpointName}'\"); private static readonly Action<ILogger, Exception> _matchFailure = LoggerMessage.Define( LogLevel.Debug, new EventId(2, \"MatchFailure\"), \"Request did not match any endpoints\"); public static void MatchSuccess(ILogger logger, EndpointSelectorContext context) { _matchSuccess(logger, context.Endpoint.DisplayName, null); } public static void MatchFailure(ILogger logger) { _matchFailure(logger, null); } }", "label": "FeatureEnvy"}
{"text": "/// <summary> /// Description of Update. /// </summary> public static class UpdateHelper { private const string uacRegistryKey = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System\"; private const string uacRegistryValue = \"EnableLUA\"; private const string uninstallRegistryKey = \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\"; private static uint STANDARD_RIGHTS_READ = 0x00020000; private static uint TOKEN_QUERY = 0x0008; private static uint TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY); [DllImport(\"advapi32.dll\", SetLastError = true)] [return: MarshalAs(UnmanagedType.Bool)] static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle); [DllImport(\"advapi32.dll\", SetLastError = true)] public static extern bool GetTokenInformation(IntPtr TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, IntPtr TokenInformation, uint TokenInformationLength, out uint ReturnLength); public enum TOKEN_INFORMATION_CLASS { TokenUser = 1, TokenGroups, TokenPrivileges, TokenOwner, TokenPrimaryGroup, TokenDefaultDacl, TokenSource, TokenType, TokenImpersonationLevel, TokenStatistics, TokenRestrictedSids, TokenSessionId, TokenGroupsAndPrivileges, TokenSessionReference, TokenSandBoxInert, TokenAuditPolicy, TokenOrigin, TokenElevationType, TokenLinkedToken, TokenElevation, TokenHasRestrictions, TokenAccessInformation, TokenVirtualizationAllowed, TokenVirtualizationEnabled, TokenIntegrityLevel, TokenUIAccess, TokenMandatoryPolicy, TokenLogonSid, MaxTokenInfoClass } public enum TOKEN_ELEVATION_TYPE { TokenElevationTypeDefault = 1, TokenElevationTypeFull, TokenElevationTypeLimited } public static bool IsUacEnabled { get { RegistryKey uacKey = Registry.LocalMachine.OpenSubKey(uacRegistryKey, false); bool result = uacKey.GetValue(uacRegistryValue).Equals(1); return result; } } public static bool IsProcessElevated { get { if (IsUacEnabled) { IntPtr tokenHandle; if (!OpenProcessToken(Process.GetCurrentProcess().Handle, TOKEN_READ, out tokenHandle)) { throw new ApplicationException(\"Could not get process token. Win32 Error Code: \" + Marshal.GetLastWin32Error()); } TOKEN_ELEVATION_TYPE elevationResult = TOKEN_ELEVATION_TYPE.TokenElevationTypeDefault; int elevationResultSize = Marshal.SizeOf((int)elevationResult); uint returnedSize = 0; IntPtr elevationTypePtr = Marshal.AllocHGlobal(elevationResultSize); bool success = GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenElevationType, elevationTypePtr, (uint)elevationResultSize, out returnedSize); if (success) { elevationResult = (TOKEN_ELEVATION_TYPE)Marshal.ReadInt32(elevationTypePtr); bool isProcessAdmin = elevationResult == TOKEN_ELEVATION_TYPE.TokenElevationTypeFull; return isProcessAdmin; } else { throw new ApplicationException(\"Unable to determine the current elevation.\"); } } else { WindowsIdentity identity = WindowsIdentity.GetCurrent(); WindowsPrincipal principal = new WindowsPrincipal(identity); bool result = principal.IsInRole(WindowsBuiltInRole.Administrator); return result; } } } public static bool HasWriteAccessToFolder(string strPath) { try { bool writeable = false; WindowsPrincipal principal = new WindowsPrincipal(WindowsIdentity.GetCurrent()); DirectorySecurity security = Directory.GetAccessControl(strPath); AuthorizationRuleCollection authRules = security.GetAccessRules(true, true, typeof(SecurityIdentifier)); foreach (FileSystemAccessRule accessRule in authRules) { if (principal.IsInRole(accessRule.IdentityReference as SecurityIdentifier)) { if ((FileSystemRights.WriteData & accessRule.FileSystemRights) == FileSystemRights.WriteData) { if (accessRule.AccessControlType == AccessControlType.Allow) { writeable = true; } else if (accessRule.AccessControlType == AccessControlType.Deny) { //Deny usually overrides any Allow return false; } } } } return writeable; } catch (UnauthorizedAccessException) { return false; } } public static void RunElevated() { RunElevated(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppDomain.CurrentDomain.FriendlyName), \"\"); } public static void RunElevated(string command) { RunElevated(command, \"\"); } public static void RunElevated(string[] arguments) { RunElevated(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppDomain.CurrentDomain.FriendlyName), String.Join(\" \", arguments)); } public static void RunElevated(string command, string arguments) { Process p = new Process(); p.StartInfo.Verb = \"runas\"; p.StartInfo.FileName = command; p.StartInfo.Arguments = arguments; p.StartInfo.UseShellExecute = true; p.Start(); } public static void Restart() { Process.Start(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppDomain.CurrentDomain.FriendlyName)); Process.GetCurrentProcess().Kill(); } public static object[] LegacyIDs = { \"Generic Mod Manager_is1\", \"{F97B1D1B-F722-4F37-902E-9FB501FADD0E}_is1\" }; public static bool IsLegacyFommInstalled { get { bool bLegacyInstalled = false; string SubKey; SubKey = String.Format(\"{0}\\\\{1}_is1\", uninstallRegistryKey, \"Generic Mod Manager\"); bLegacyInstalled |= (Registry.LocalMachine.OpenSubKey(SubKey, false) != null); SubKey = String.Format(\"{0}\\\\{{{1}}}_is1\", uninstallRegistryKey, Fomm.ProductInfo.GUID.ToString()); bLegacyInstalled |= (Registry.LocalMachine.OpenSubKey(SubKey, false) != null); return bLegacyInstalled; } } private static UninstallInfo uiFomm = new UninstallInfo(Fomm.ProductInfo.GUID); public static UninstallInfo FommUninstallInfo { get { return uiFomm; } } public static void Associate(string[] formats) { } }", "label": "FeatureEnvy"}
{"text": "internal class Natives { #region Consts private const int SOURCE_COPY = 0x00CC0020; private const int BI_RGB = 0; private const int DIB_RGB_COLORS = 0; private const int DTT_COMPOSITED = ( int ) ( 1UL << 13 ); private const int DTT_GLOWSIZE = ( int ) ( 1UL << 11 ); private const int DT_SINGLELINE = 0x00000020; private const int DT_CENTER = 0x00000001; private const int DT_VCENTER = 0x00000004; private const int DT_NOPREFIX = 0x00000800; public const int WM_NCHITTEST = 0x84; public const int WM_NCLBUTTONUP = 0x00A2; public const int WM_NCLBUTTONDOWN = 0x00A1; public const int WM_NCLBUTTONDBLCLK = 0x00A3; public const int HTCAPTION = 2; public const int HTCLIENT = 1; public const int S_OK = 0x0; public const int EP_EDITTEXT = 1; public const int ETS_DISABLED = 4; public const int ETS_NORMAL = 1; public const int ETS_READONLY = 6; public const int WM_THEMECHANGED = 0x031A; public const int WM_NCPAINT = 0x85; public const int WM_NCCALCSIZE = 0x83; public const int WS_EX_CLIENTEDGE = 0x200; public const int WVR_HREDRAW = 0x100; public const int WVR_VREDRAW = 0x200; public const int WVR_REDRAW = ( WVR_HREDRAW | WVR_VREDRAW ); #endregion #region Enums/Structs [StructLayout( LayoutKind.Sequential )] public struct DLLVersionInfo { public int cbSize; public int dwMajorVersion; public int dwMinorVersion; public int dwBuildNumber; public int dwPlatformID; } [StructLayout( LayoutKind.Sequential )] public struct NCCALCSIZE_PARAMS { public RECT rgrc0, rgrc1, rgrc2; public IntPtr lppos; } #endregion #region P/Invoke API Calls [DllImport( \"dwmapi.dll\", PreserveSig = false )] private static extern bool DwmIsCompositionEnabled(); [DllImport( \"dwmapi.dll\" )] private static extern void DwmExtendFrameIntoClientArea( IntPtr hWnd, ref Margins margin ); [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )] private static extern int SaveDC( IntPtr hdc ); [DllImport( \"user32.dll\", ExactSpelling = true, SetLastError = true )] private static extern int ReleaseDC( IntPtr hdc, int state ); [DllImport( \"user32.dll\", ExactSpelling = true, SetLastError = true )] private static extern IntPtr GetDC( IntPtr hdc ); [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )] private static extern IntPtr CreateCompatibleDC( IntPtr hDC ); [DllImport( \"gdi32.dll\", ExactSpelling = true )] private static extern IntPtr SelectObject( IntPtr hDC, IntPtr hObject ); [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )] private static extern bool DeleteObject( IntPtr hObject ); [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )] private static extern bool DeleteDC( IntPtr hdc ); [DllImport( \"gdi32.dll\" )] private static extern bool BitBlt( IntPtr hdc, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, uint dwRop ); [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )] private static extern IntPtr CreateDIBSection( IntPtr hdc, uint iUsage, int ppvBits, IntPtr hSection, uint dwOffset ); [DllImport( \"user32.dll\", CharSet = CharSet.Auto, SetLastError = false )] public static extern IntPtr SendMessage( IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam ); [DllImport( \"user32.dll\", SetLastError = false )] public static extern bool PostMessage( IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam ); [DllImport( \"UxTheme.dll\", ExactSpelling = true, SetLastError = true, CharSet = CharSet.Unicode )] private static extern int DrawThemeTextEx( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, string text, int iCharCount, int dwFlags, ref RECT pRect); [DllImport( \"UxTheme.dll\", CharSet = CharSet.Auto )] public static extern bool IsAppThemed(); [DllImport( \"UxTheme.dll\", CharSet = CharSet.Auto )] public static extern bool IsThemeActive(); [DllImport( \"comctl32.dll\", CharSet = CharSet.Auto )] public static extern int DllGetVersion( ref DLLVersionInfo version ); [DllImport( \"uxtheme.dll\", ExactSpelling = true, CharSet = CharSet.Unicode )] public static extern IntPtr OpenThemeData( IntPtr hWnd, String classList ); [DllImport( \"uxtheme.dll\", ExactSpelling = true )] public extern static Int32 CloseThemeData( IntPtr hTheme ); [DllImport( \"uxtheme\", ExactSpelling = true )] public extern static Int32 DrawThemeBackground( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, ref RECT pRect, IntPtr pClipRect ); [DllImport( \"uxtheme\", ExactSpelling = true )] public extern static int IsThemeBackgroundPartiallyTransparent( IntPtr hTheme, int iPartId, int iStateId ); [DllImport( \"uxtheme\", ExactSpelling = true )] public extern static Int32 GetThemeBackgroundContentRect( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, ref RECT pBoundingRect, out RECT pContentRect ); [DllImport( \"uxtheme\", ExactSpelling = true )] public extern static Int32 DrawThemeParentBackground( IntPtr hWnd, IntPtr hdc, ref RECT pRect ); [DllImport( \"uxtheme\", ExactSpelling = true )] public extern static Int32 DrawThemeBackground( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, ref RECT pRect, ref RECT pClipRect ); [DllImport( \"user32.dll\" )] public static extern IntPtr GetWindowDC( IntPtr hWnd ); [DllImport( \"user32.dll\" )] public static extern int ReleaseDC( IntPtr hWnd, IntPtr hDC ); [DllImport( \"user32.dll\" )] public static extern bool GetWindowRect( IntPtr hWnd, out RECT lpRect ); [DllImport( \"gdi32.dll\" )] public static extern int ExcludeClipRect( IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect ); #endregion #region Drawing / Utils //Most methods have been snipped public static bool CanRender() { Type t = typeof(Application); System.Reflection.PropertyInfo pi = t.GetProperty(\"RenderWithVisualStyles\"); if (pi == null) { OperatingSystem os = System.Environment.OSVersion; if (os.Platform == PlatformID.Win32NT && (((os.Version.Major == 5) && (os.Version.Minor >= 1)) || (os.Version.Major > 5))) { DLLVersionInfo version = new DLLVersionInfo(); version.cbSize = Marshal.SizeOf(typeof(DLLVersionInfo)); if (DllGetVersion(ref version) == 0) { return (version.dwMajorVersion > 5) && IsThemeActive() && IsAppThemed(); } } return false; } else { bool result = (bool)pi.GetValue(null, null); return result; } } #endregion }", "label": "FeatureEnvy"}
{"text": "/// <summary>Class which represents the entity 'BusinessEntityContact', mapped on table 'AdventureWorks.Person.BusinessEntityContact'.</summary> [Table(Name=\"[Person].[BusinessEntityContact]\")] public partial class BusinessEntityContact : INotifyPropertyChanging, INotifyPropertyChanged { #region Events /// <summary>Event which is raised when a property value is changing.</summary> public event PropertyChangingEventHandler PropertyChanging; /// <summary>Event which is raised when a property value changes.</summary> public event PropertyChangedEventHandler PropertyChanged; #endregion #region Class Member Declarations private System.Int32 _businessEntityId; private System.Int32 _contactTypeId; private System.DateTime _modifiedDate; private System.Int32 _personId; private System.Guid _rowguid; private EntityRef <BusinessEntity> _businessEntity; private EntityRef <ContactType> _contactType; private EntityRef <Person> _person; #endregion #region Extensibility Method Definitions partial void OnLoaded(); partial void OnValidate(System.Data.Linq.ChangeAction action); partial void OnCreated(); partial void OnBusinessEntityIdChanging(System.Int32 value); partial void OnBusinessEntityIdChanged(); partial void OnContactTypeIdChanging(System.Int32 value); partial void OnContactTypeIdChanged(); partial void OnModifiedDateChanging(System.DateTime value); partial void OnModifiedDateChanged(); partial void OnPersonIdChanging(System.Int32 value); partial void OnPersonIdChanged(); partial void OnRowguidChanging(System.Guid value); partial void OnRowguidChanged(); #endregion /// <summary>Initializes a new instance of the <see cref=\"BusinessEntityContact\"/> class.</summary> public BusinessEntityContact() { _businessEntity = default(EntityRef<BusinessEntity>); _contactType = default(EntityRef<ContactType>); _person = default(EntityRef<Person>); OnCreated(); } /// <summary>Raises the PropertyChanging event</summary> /// <param name=\"propertyName\">name of the property which is changing</param> protected virtual void SendPropertyChanging(string propertyName) { if((this.PropertyChanging != null)) { this.PropertyChanging(this, new PropertyChangingEventArgs(propertyName)); } } /// <summary>Raises the PropertyChanged event for the property specified</summary> /// <param name=\"propertyName\">name of the property which was changed</param> protected virtual void SendPropertyChanged(string propertyName) { if((this.PropertyChanged != null)) { this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } } #region Class Property Declarations /// <summary>Gets or sets the BusinessEntityId field. Mapped on target field 'BusinessEntityID'. </summary> [Column(Name=\"BusinessEntityID\", Storage=\"_businessEntityId\", CanBeNull=false, DbType=\"int NOT NULL\", IsPrimaryKey=true)] public System.Int32 BusinessEntityId { get { return _businessEntityId; } set { if((_businessEntityId != value)) { if(_businessEntity.HasLoadedOrAssignedValue) { throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException(); } OnBusinessEntityIdChanging(value); SendPropertyChanging(\"BusinessEntityId\"); _businessEntityId = value; SendPropertyChanged(\"BusinessEntityId\"); OnBusinessEntityIdChanged(); } } } /// <summary>Gets or sets the ContactTypeId field. Mapped on target field 'ContactTypeID'. </summary> [Column(Name=\"ContactTypeID\", Storage=\"_contactTypeId\", CanBeNull=false, DbType=\"int NOT NULL\", IsPrimaryKey=true)] public System.Int32 ContactTypeId { get { return _contactTypeId; } set { if((_contactTypeId != value)) { if(_contactType.HasLoadedOrAssignedValue) { throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException(); } OnContactTypeIdChanging(value); SendPropertyChanging(\"ContactTypeId\"); _contactTypeId = value; SendPropertyChanged(\"ContactTypeId\"); OnContactTypeIdChanged(); } } } /// <summary>Gets or sets the ModifiedDate field. Mapped on target field 'ModifiedDate'. </summary> [Column(Name=\"ModifiedDate\", Storage=\"_modifiedDate\", CanBeNull=false, DbType=\"datetime NOT NULL\")] public System.DateTime ModifiedDate { get { return _modifiedDate; } set { if((_modifiedDate != value)) { OnModifiedDateChanging(value); SendPropertyChanging(\"ModifiedDate\"); _modifiedDate = value; SendPropertyChanged(\"ModifiedDate\"); OnModifiedDateChanged(); } } } /// <summary>Gets or sets the PersonId field. Mapped on target field 'PersonID'. </summary> [Column(Name=\"PersonID\", Storage=\"_personId\", CanBeNull=false, DbType=\"int NOT NULL\", IsPrimaryKey=true)] public System.Int32 PersonId { get { return _personId; } set { if((_personId != value)) { if(_person.HasLoadedOrAssignedValue) { throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException(); } OnPersonIdChanging(value); SendPropertyChanging(\"PersonId\"); _personId = value; SendPropertyChanged(\"PersonId\"); OnPersonIdChanged(); } } } /// <summary>Gets or sets the Rowguid field. Mapped on target field 'rowguid'. </summary> [Column(Name=\"rowguid\", Storage=\"_rowguid\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"uniqueidentifier NOT NULL\", IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)] public System.Guid Rowguid { get { return _rowguid; } set { if((_rowguid != value)) { OnRowguidChanging(value); SendPropertyChanging(\"Rowguid\"); _rowguid = value; SendPropertyChanged(\"Rowguid\"); OnRowguidChanged(); } } } /// <summary>Represents the navigator which is mapped onto the association 'BusinessEntityContact.BusinessEntity - BusinessEntity.BusinessEntityContacts (m:1)'</summary> [Association(Name=\"BusinessEntityContact_BusinessEntity64816da69dbd4c27a5e5b66d1c074092\", Storage=\"_businessEntity\", ThisKey=\"BusinessEntityId\", IsForeignKey=true)] public BusinessEntity BusinessEntity { get { return _businessEntity.Entity; } set { BusinessEntity previousValue = _businessEntity.Entity; if((previousValue != value) || (_businessEntity.HasLoadedOrAssignedValue == false)) { this.SendPropertyChanging(\"BusinessEntity\"); if(previousValue != null) { _businessEntity.Entity = null; previousValue.BusinessEntityContacts.Remove(this); } _businessEntity.Entity = value; if(value == null) { _businessEntityId = default(System.Int32); } else { value.BusinessEntityContacts.Add(this); _businessEntityId = value.BusinessEntityId; } this.SendPropertyChanged(\"BusinessEntity\"); } } } /// <summary>Represents the navigator which is mapped onto the association 'BusinessEntityContact.ContactType - ContactType.BusinessEntityContacts (m:1)'</summary> [Association(Name=\"BusinessEntityContact_ContactType9e4dc4bf61a84ab4adc3b76ed46315bd\", Storage=\"_contactType\", ThisKey=\"ContactTypeId\", IsForeignKey=true)] public ContactType ContactType { get { return _contactType.Entity; } set { ContactType previousValue = _contactType.Entity; if((previousValue != value) || (_contactType.HasLoadedOrAssignedValue == false)) { this.SendPropertyChanging(\"ContactType\"); if(previousValue != null) { _contactType.Entity = null; previousValue.BusinessEntityContacts.Remove(this); } _contactType.Entity = value; if(value == null) { _contactTypeId = default(System.Int32); } else { value.BusinessEntityContacts.Add(this); _contactTypeId = value.ContactTypeId; } this.SendPropertyChanged(\"ContactType\"); } } } /// <summary>Represents the navigator which is mapped onto the association 'BusinessEntityContact.Person - Person.BusinessEntityContacts (m:1)'</summary> [Association(Name=\"BusinessEntityContact_Personf81c089467ff45ab81dafb455497a611\", Storage=\"_person\", ThisKey=\"PersonId\", IsForeignKey=true)] public Person Person { get { return _person.Entity; } set { Person previousValue = _person.Entity; if((previousValue != value) || (_person.HasLoadedOrAssignedValue == false)) { this.SendPropertyChanging(\"Person\"); if(previousValue != null) { _person.Entity = null; previousValue.BusinessEntityContacts.Remove(this); } _person.Entity = value; if(value == null) { _personId = default(System.Int32); } else { value.BusinessEntityContacts.Add(this); _personId = value.BusinessEntityId; } this.SendPropertyChanged(\"Person\"); } } } #endregion }", "label": "FeatureEnvy"}
{"text": "public class ControllerBase : Controller { private static readonly Logger log = LogManager.GetCurrentClassLogger(); protected static readonly TimeSpan imageExpirationTime = TimeSpan.FromMinutes(5); protected const int entriesPerPage = 30; protected const int invalidId = 0; protected static readonly TimeSpan pictureCacheDuration = TimeSpan.FromDays(30); protected const int pictureCacheDurationSec = 30 * 24 * 60 * 60; protected const int statsCacheDurationSec = 24 * 60 * 60; protected ControllerBase() { PageProperties.OpenGraph.Image = VocaUriBuilder.StaticResource(\"/img/vocaDB-title-large.png\"); } protected string Hostname => WebHelper.GetRealHost(Request); protected int LoggedUserId { get { PermissionContext.VerifyLogin(); return PermissionContext.LoggedUser.Id; } } protected PagePropertiesData PageProperties => PagePropertiesData.Get(ViewBag); protected IUserPermissionContext PermissionContext => MvcApplication.LoginManager; protected string GetHostnameForValidHit() { return WebHelper.IsValidHit(Request) ? WebHelper.GetRealHost(Request) : string.Empty; } protected ActionResult NoId() { return HttpNotFound(\"No ID specified\"); } protected void AddFormSubmissionError(string details) { log.Warn(\"Form submission error: {0}\", details); ModelState.AddModelError(string.Empty, string.Format(\"Error while sending form contents - please try again. Diagnostic error message: {0}.\", details)); } protected ActionResult Picture(EntryForPictureDisplayContract contract) { ParamIs.NotNull(() => contract); // Allow images to be cached by public proxies, images shouldn't contain anything sensitive so this should be ok. Response.Cache.SetCacheability(HttpCacheability.Public); Response.Cache.SetETag(string.Format(\"{0}{1}v{2}\", contract.EntryType, contract.EntryId, contract.Version)); // Cached version indicated by the \"v\" request parameter. // If no version is specified, assume no caching. if (contract.Version > 0 && !string.IsNullOrEmpty(Request.Params[\"v\"])) Response.Cache.SetMaxAge(pictureCacheDuration); return Picture(contract.Picture, contract.Name); } protected void CheckConcurrentEdit(EntryType entryType, int id) { Login.Manager.VerifyLogin(); var conflictingEditor = ConcurrentEntryEditManager.CheckConcurrentEdits(new EntryRef(entryType, id), Login.User); if (conflictingEditor.UserId != ConcurrentEntryEditManager.Nothing.UserId) { var ago = DateTime.Now - conflictingEditor.Time; if (ago.TotalMinutes < 1) { TempData.SetStatusMessage(string.Format(ViewRes.EntryEditStrings.ConcurrentEditWarningNow, conflictingEditor.UserName)); } else { TempData.SetStatusMessage(string.Format(ViewRes.EntryEditStrings.ConcurrentEditWarning, conflictingEditor.UserName, (int)ago.TotalMinutes)); } } } protected bool CheckUploadedPicture(HttpPostedFileBase pictureUpload, string fieldName) { bool errors = false; if (pictureUpload.ContentLength > ImageHelper.MaxImageSizeBytes) { ModelState.AddModelError(fieldName, \"Picture file is too large.\"); errors = true; } if (!ImageHelper.IsValidImageExtension(pictureUpload.FileName)) { ModelState.AddModelError(fieldName, \"Picture format is not valid.\"); errors = true; } return !errors; } protected ActionResult HttpStatusCodeResult(HttpStatusCode code, string message) { Response.StatusCode = (int)code; Response.StatusDescription = message; return Content((int)code + \": \" + message); } protected void ParseAdditionalPictures(HttpPostedFileBase mainPic, IList<EntryPictureFileContract> pictures) { ParamIs.NotNull(() => mainPic); ParamIs.NotNull(() => pictures); var additionalPics = Enumerable.Range(0, Request.Files.Count) .Select(i => Request.Files.Get(i)) .Where(f => f != null && f.FileName != mainPic.FileName) .ToArray(); var newPics = pictures.Where(p => p.Id == 0).ToArray(); for (int i = 0; i < additionalPics.Length; ++i) { if (i >= newPics.Length) break; var contract = ParsePicture(additionalPics[i], \"Pictures\"); if (contract != null) { newPics[i].OriginalFileName = contract.OriginalFileName; newPics[i].UploadedFile = contract.UploadedFile; newPics[i].Mime = contract.Mime; newPics[i].ContentLength = contract.ContentLength; } } CollectionHelper.RemoveAll(pictures, p => p.Id == 0 && p.UploadedFile == null); } protected EntryPictureFileContract ParsePicture(HttpPostedFileBase pictureUpload, string fieldName) { EntryPictureFileContract pictureData = null; if (Request.Files.Count > 0 && pictureUpload != null && pictureUpload.ContentLength > 0) { if (pictureUpload.ContentLength > ImageHelper.MaxImageSizeBytes) { ModelState.AddModelError(fieldName, \"Picture file is too large.\"); return null; } if (!ImageHelper.IsValidImageExtension(pictureUpload.FileName)) { ModelState.AddModelError(fieldName, \"Picture format is not valid.\"); return null; } pictureData = new EntryPictureFileContract(); pictureData.OriginalFileName = pictureUpload.FileName; pictureData.UploadedFile = pictureUpload.InputStream; pictureData.Mime = pictureUpload.ContentType ?? string.Empty; pictureData.ContentLength = pictureUpload.ContentLength; } return pictureData; } protected ActionResult Picture(PictureContract pictureData, string title) { if (pictureData?.Bytes == null || string.IsNullOrEmpty(pictureData.Mime)) return File(Server.MapPath(\"~/Content/unknown.png\"), \"image/png\"); var ext = ImageHelper.GetExtensionFromMime(pictureData.Mime); if (!string.IsNullOrEmpty(ext)) { //var encoded = Url.Encode(title); // Note: there is no good way to encode content-disposition filename (see http://stackoverflow.com/a/216777) Response.AddHeader(\"content-disposition\", string.Format(\"inline;filename=\\\"{0}{1}\\\"\", title, ext)); } return File(pictureData.Bytes, pictureData.Mime); } protected ActionResult LowercaseJson(object obj) { return new JsonNetResult { Data = obj }; } protected new ActionResult Json(object obj) { return Content(JsonConvert.SerializeObject(obj), \"application/json\"); } protected new ActionResult Json(object obj, string jsonPCallback) { if (string.IsNullOrEmpty(jsonPCallback)) return Json(obj); return Content(string.Format(\"{0}({1})\", jsonPCallback, JsonConvert.SerializeObject(obj)), \"application/json\"); } protected string RenderPartialViewToString(string viewName, object model) { if (string.IsNullOrEmpty(viewName)) viewName = ControllerContext.RouteData.GetRequiredString(\"action\"); ViewData.Model = model; using (var sw = new StringWriter()) { var viewResult = ViewEngines.Engines.FindPartialView(ControllerContext, viewName); var viewContext = new ViewContext(ControllerContext, viewResult.View, ViewData, TempData, sw); viewResult.View.Render(viewContext, sw); return sw.GetStringBuilder().ToString(); } } protected void RestoreErrorsFromTempData() { var list = TempData[\"ModelErrors\"] as ModelStateList; if (list == null) return; foreach (var state in list.ModelStates) { if (ModelState[state.Key] == null || !ModelState[state.Key].Errors.Any()) { foreach (var err in state.Errors) { if (err.Exception != null) ModelState.AddModelError(state.Key, err.Exception); else ModelState.AddModelError(state.Key, err.ErrorMessage); } } } } protected void SaveErrorsToTempData() { var list = new ModelStateList { ModelStates = ViewData.ModelState.Select(m => new ModelStateErrors(m.Key, m.Value)).ToArray() }; TempData[\"ModelErrors\"] = list; } protected void SetSearchEntryType(EntryType entryType) { PageProperties.GlobalSearchType = entryType; } protected VocaUrlMapper UrlMapper => new VocaUrlMapper(); protected ActionResult Xml(string content) { if (string.IsNullOrEmpty(content)) return new EmptyResult(); return new ContentResult { ContentType = \"text/xml\", Content = content, ContentEncoding = Encoding.UTF8 }; } }", "label": "ComplexConditional"}
{"text": "[Serializable] [TypeConverterAttribute(typeof(UriTypeConverter))] public class Uri : ISerializable { public static readonly string UriSchemeFile; public static readonly string UriSchemeFtp; public static readonly string UriSchemeGopher; public static readonly string UriSchemeHttp; public static readonly string UriSchemeHttps; public static readonly string UriSchemeMailto; public static readonly string UriSchemeNews; public static readonly string UriSchemeNntp; public static readonly string UriSchemeNetTcp; public static readonly string UriSchemeNetPipe; public static readonly string SchemeDelimiter; public string AbsolutePath { get { throw new NotImplementedException(); } } public string AbsoluteUri { get { throw new NotImplementedException(); } } public string LocalPath { get { throw new NotImplementedException(); } } public string Authority { get { throw new NotImplementedException(); } } public UriHostNameType HostNameType { get { throw new NotImplementedException(); } } public bool IsDefaultPort { get { throw new NotImplementedException(); } } public bool IsFile { get { throw new NotImplementedException(); } } public bool IsLoopback { get { throw new NotImplementedException(); } } public string PathAndQuery { get { throw new NotImplementedException(); } } public string[] Segments { get { throw new NotImplementedException(); } } public bool IsUnc { get { throw new NotImplementedException(); } } public string Host { get { throw new NotImplementedException(); } } public int Port { get { throw new NotImplementedException(); } } public string Query { get { throw new NotImplementedException(); } } public string Fragment { get { throw new NotImplementedException(); } } public string Scheme { get { throw new NotImplementedException(); } } public string OriginalString { get { throw new NotImplementedException(); } } public string DnsSafeHost { get { throw new NotImplementedException(); } } public bool IsAbsoluteUri { get { throw new NotImplementedException(); } } public bool UserEscaped { get { throw new NotImplementedException(); } } public string UserInfo { get { throw new NotImplementedException(); } } public Uri(string uriString) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202\")] public Uri(string uriString, bool dontEscape) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202\")] public Uri(Uri baseUri, string relativeUri, bool dontEscape) { throw new NotImplementedException(); } public Uri(string uriString, UriKind uriKind) { throw new NotImplementedException(); } public Uri(Uri baseUri, string relativeUri) { throw new NotImplementedException(); } public Uri(Uri baseUri, Uri relativeUri) { throw new NotImplementedException(); } protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext) { throw new NotImplementedException(); } protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext) { throw new NotImplementedException(); } public static UriHostNameType CheckHostName(string name) { throw new NotImplementedException(); } public string GetLeftPart(UriPartial part) { throw new NotImplementedException(); } public static string HexEscape(char character) { throw new NotImplementedException(); } public static char HexUnescape(string pattern, ref int index) { throw new NotImplementedException(); } public static bool IsHexEncoding(string pattern, int index) { throw new NotImplementedException(); } public static bool CheckSchemeName(string schemeName) { throw new NotImplementedException(); } public static bool IsHexDigit(char character) { throw new NotImplementedException(); } public static int FromHex(char digit) { throw new NotImplementedException(); } public override int GetHashCode() { throw new NotImplementedException(); } public override string ToString() { throw new NotImplementedException(); } public static bool operator ==(Uri uri1, Uri uri2) { throw new NotImplementedException(); } public static bool operator !=(Uri uri1, Uri uri2) { throw new NotImplementedException(); } public override bool Equals(object comparand) { throw new NotImplementedException(); } public Uri MakeRelativeUri(Uri uri) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202\")] public string MakeRelative(Uri toUri) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")] protected virtual void Parse() { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")] protected virtual void Canonicalize() { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")] protected virtual void Escape() { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202\")] protected virtual string Unescape(string path) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202\")] protected static string EscapeString(string str) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")] protected virtual void CheckSecurity() { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")] protected virtual bool IsReservedCharacter(char character) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")] protected static bool IsExcludedCharacter(char character) { throw new NotImplementedException(); } [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")] protected virtual bool IsBadFileSystemCharacter(char character) { throw new NotImplementedException(); } public static bool TryCreate(string uriString, UriKind uriKind, ref Uri result) { throw new NotImplementedException(); } public static bool TryCreate(Uri baseUri, string relativeUri, ref Uri result) { throw new NotImplementedException(); } public static bool TryCreate(Uri baseUri, Uri relativeUri, ref Uri result) { throw new NotImplementedException(); } public string GetComponents(UriComponents components, UriFormat format) { throw new NotImplementedException(); } public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType) { throw new NotImplementedException(); } public bool IsWellFormedOriginalString() { throw new NotImplementedException(); } public static bool IsWellFormedUriString(string uriString, UriKind uriKind) { throw new NotImplementedException(); } public static string UnescapeDataString(string stringToUnescape) { throw new NotImplementedException(); } public static string EscapeUriString(string stringToEscape) { throw new NotImplementedException(); } public static string EscapeDataString(string stringToEscape) { throw new NotImplementedException(); } public bool IsBaseOf(Uri uri) { throw new NotImplementedException(); } void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) { throw new NotImplementedException(); } }", "label": "FeatureEnvy"}
{"text": "internal sealed partial class Payload : pb::IMessage<Payload> { private static readonly pb::MessageParser<Payload> _parser = new pb::MessageParser<Payload>(() => new Payload()); [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public static pb::MessageParser<Payload> Parser { get { return _parser; } } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public static pbr::MessageDescriptor Descriptor { get { return global::Akka.Streams.Serialization.Proto.Msg.StreamRefMessagesReflection.Descriptor.MessageTypes[4]; } } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] pbr::MessageDescriptor pb::IMessage.Descriptor { get { return Descriptor; } } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public Payload() { OnConstruction(); } partial void OnConstruction(); [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public Payload(Payload other) : this() { enclosedMessage_ = other.enclosedMessage_; serializerId_ = other.serializerId_; messageManifest_ = other.messageManifest_; } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public Payload Clone() { return new Payload(this); } /// <summary>Field number for the \"enclosedMessage\" field.</summary> public const int EnclosedMessageFieldNumber = 1; private pb::ByteString enclosedMessage_ = pb::ByteString.Empty; [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public pb::ByteString EnclosedMessage { get { return enclosedMessage_; } set { enclosedMessage_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\"); } } /// <summary>Field number for the \"serializerId\" field.</summary> public const int SerializerIdFieldNumber = 2; private int serializerId_; [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public int SerializerId { get { return serializerId_; } set { serializerId_ = value; } } /// <summary>Field number for the \"messageManifest\" field.</summary> public const int MessageManifestFieldNumber = 3; private pb::ByteString messageManifest_ = pb::ByteString.Empty; [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public pb::ByteString MessageManifest { get { return messageManifest_; } set { messageManifest_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\"); } } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public override bool Equals(object other) { return Equals(other as Payload); } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public bool Equals(Payload other) { if (ReferenceEquals(other, null)) { return false; } if (ReferenceEquals(other, this)) { return true; } if (EnclosedMessage != other.EnclosedMessage) return false; if (SerializerId != other.SerializerId) return false; if (MessageManifest != other.MessageManifest) return false; return true; } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public override int GetHashCode() { int hash = 1; if (EnclosedMessage.Length != 0) hash ^= EnclosedMessage.GetHashCode(); if (SerializerId != 0) hash ^= SerializerId.GetHashCode(); if (MessageManifest.Length != 0) hash ^= MessageManifest.GetHashCode(); return hash; } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public override string ToString() { return pb::JsonFormatter.ToDiagnosticString(this); } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public void WriteTo(pb::CodedOutputStream output) { if (EnclosedMessage.Length != 0) { output.WriteRawTag(10); output.WriteBytes(EnclosedMessage); } if (SerializerId != 0) { output.WriteRawTag(16); output.WriteInt32(SerializerId); } if (MessageManifest.Length != 0) { output.WriteRawTag(26); output.WriteBytes(MessageManifest); } } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public int CalculateSize() { int size = 0; if (EnclosedMessage.Length != 0) { size += 1 + pb::CodedOutputStream.ComputeBytesSize(EnclosedMessage); } if (SerializerId != 0) { size += 1 + pb::CodedOutputStream.ComputeInt32Size(SerializerId); } if (MessageManifest.Length != 0) { size += 1 + pb::CodedOutputStream.ComputeBytesSize(MessageManifest); } return size; } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public void MergeFrom(Payload other) { if (other == null) { return; } if (other.EnclosedMessage.Length != 0) { EnclosedMessage = other.EnclosedMessage; } if (other.SerializerId != 0) { SerializerId = other.SerializerId; } if (other.MessageManifest.Length != 0) { MessageManifest = other.MessageManifest; } } [global::System.Diagnostics.DebuggerNonUserCodeAttribute] public void MergeFrom(pb::CodedInputStream input) { uint tag; while ((tag = input.ReadTag()) != 0) { switch (tag) { default: input.SkipLastField(); break; case 10: { EnclosedMessage = input.ReadBytes(); break; } case 16: { SerializerId = input.ReadInt32(); break; } case 26: { MessageManifest = input.ReadBytes(); break; } } } } }", "label": "ComplexConditional"}
{"text": "/// <summary>Class which represents the entity 'SalesTaxRate', mapped on table 'AdventureWorks.Sales.SalesTaxRate'.</summary> [Table(Name=\"[Sales].[SalesTaxRate]\")] public partial class SalesTaxRate : INotifyPropertyChanging, INotifyPropertyChanged { #region Events /// <summary>Event which is raised when a property value is changing.</summary> public event PropertyChangingEventHandler PropertyChanging; /// <summary>Event which is raised when a property value changes.</summary> public event PropertyChangedEventHandler PropertyChanged; #endregion #region Class Member Declarations private System.DateTime _modifiedDate; private System.String _name; private System.Guid _rowguid; private System.Int32 _salesTaxRateId; private System.Int32 _stateProvinceId; private System.Decimal _taxRate; private System.Byte _taxType; private EntityRef <StateProvince> _stateProvince; #endregion #region Extensibility Method Definitions partial void OnLoaded(); partial void OnValidate(System.Data.Linq.ChangeAction action); partial void OnCreated(); partial void OnModifiedDateChanging(System.DateTime value); partial void OnModifiedDateChanged(); partial void OnNameChanging(System.String value); partial void OnNameChanged(); partial void OnRowguidChanging(System.Guid value); partial void OnRowguidChanged(); partial void OnSalesTaxRateIdChanging(System.Int32 value); partial void OnSalesTaxRateIdChanged(); partial void OnStateProvinceIdChanging(System.Int32 value); partial void OnStateProvinceIdChanged(); partial void OnTaxRateChanging(System.Decimal value); partial void OnTaxRateChanged(); partial void OnTaxTypeChanging(System.Byte value); partial void OnTaxTypeChanged(); #endregion /// <summary>Initializes a new instance of the <see cref=\"SalesTaxRate\"/> class.</summary> public SalesTaxRate() { _stateProvince = default(EntityRef<StateProvince>); OnCreated(); } /// <summary>Raises the PropertyChanging event</summary> /// <param name=\"propertyName\">name of the property which is changing</param> protected virtual void SendPropertyChanging(string propertyName) { if((this.PropertyChanging != null)) { this.PropertyChanging(this, new PropertyChangingEventArgs(propertyName)); } } /// <summary>Raises the PropertyChanged event for the property specified</summary> /// <param name=\"propertyName\">name of the property which was changed</param> protected virtual void SendPropertyChanged(string propertyName) { if((this.PropertyChanged != null)) { this.PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); } } #region Class Property Declarations /// <summary>Gets or sets the ModifiedDate field. Mapped on target field 'ModifiedDate'. </summary> [Column(Name=\"ModifiedDate\", Storage=\"_modifiedDate\", CanBeNull=false, DbType=\"datetime NOT NULL\")] public System.DateTime ModifiedDate { get { return _modifiedDate; } set { if((_modifiedDate != value)) { OnModifiedDateChanging(value); SendPropertyChanging(\"ModifiedDate\"); _modifiedDate = value; SendPropertyChanged(\"ModifiedDate\"); OnModifiedDateChanged(); } } } /// <summary>Gets or sets the Name field. Mapped on target field 'Name'. </summary> [Column(Name=\"Name\", Storage=\"_name\", CanBeNull=false, DbType=\"nvarchar(50) NOT NULL\")] public System.String Name { get { return _name; } set { if((_name != value)) { OnNameChanging(value); SendPropertyChanging(\"Name\"); _name = value; SendPropertyChanged(\"Name\"); OnNameChanged(); } } } /// <summary>Gets or sets the Rowguid field. Mapped on target field 'rowguid'. </summary> [Column(Name=\"rowguid\", Storage=\"_rowguid\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"uniqueidentifier NOT NULL\", IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)] public System.Guid Rowguid { get { return _rowguid; } set { if((_rowguid != value)) { OnRowguidChanging(value); SendPropertyChanging(\"Rowguid\"); _rowguid = value; SendPropertyChanged(\"Rowguid\"); OnRowguidChanged(); } } } /// <summary>Gets or sets the SalesTaxRateId field. Mapped on target field 'SalesTaxRateID'. </summary> [Column(Name=\"SalesTaxRateID\", Storage=\"_salesTaxRateId\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"int NOT NULL IDENTITY\", IsPrimaryKey=true, IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)] public System.Int32 SalesTaxRateId { get { return _salesTaxRateId; } set { if((_salesTaxRateId != value)) { OnSalesTaxRateIdChanging(value); SendPropertyChanging(\"SalesTaxRateId\"); _salesTaxRateId = value; SendPropertyChanged(\"SalesTaxRateId\"); OnSalesTaxRateIdChanged(); } } } /// <summary>Gets or sets the StateProvinceId field. Mapped on target field 'StateProvinceID'. </summary> [Column(Name=\"StateProvinceID\", Storage=\"_stateProvinceId\", CanBeNull=false, DbType=\"int NOT NULL\")] public System.Int32 StateProvinceId { get { return _stateProvinceId; } set { if((_stateProvinceId != value)) { if(_stateProvince.HasLoadedOrAssignedValue) { throw new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException(); } OnStateProvinceIdChanging(value); SendPropertyChanging(\"StateProvinceId\"); _stateProvinceId = value; SendPropertyChanged(\"StateProvinceId\"); OnStateProvinceIdChanged(); } } } /// <summary>Gets or sets the TaxRate field. Mapped on target field 'TaxRate'. </summary> [Column(Name=\"TaxRate\", Storage=\"_taxRate\", CanBeNull=false, DbType=\"smallmoney NOT NULL\")] public System.Decimal TaxRate { get { return _taxRate; } set { if((_taxRate != value)) { OnTaxRateChanging(value); SendPropertyChanging(\"TaxRate\"); _taxRate = value; SendPropertyChanged(\"TaxRate\"); OnTaxRateChanged(); } } } /// <summary>Gets or sets the TaxType field. Mapped on target field 'TaxType'. </summary> [Column(Name=\"TaxType\", Storage=\"_taxType\", CanBeNull=false, DbType=\"tinyint NOT NULL\")] public System.Byte TaxType { get { return _taxType; } set { if((_taxType != value)) { OnTaxTypeChanging(value); SendPropertyChanging(\"TaxType\"); _taxType = value; SendPropertyChanged(\"TaxType\"); OnTaxTypeChanged(); } } } /// <summary>Represents the navigator which is mapped onto the association 'SalesTaxRate.StateProvince - StateProvince.SalesTaxRates (m:1)'</summary> [Association(Name=\"SalesTaxRate_StateProvince2631d9a0bd4a4b9989375b6925a20368\", Storage=\"_stateProvince\", ThisKey=\"StateProvinceId\", IsForeignKey=true)] public StateProvince StateProvince { get { return _stateProvince.Entity; } set { StateProvince previousValue = _stateProvince.Entity; if((previousValue != value) || (_stateProvince.HasLoadedOrAssignedValue == false)) { this.SendPropertyChanging(\"StateProvince\"); if(previousValue != null) { _stateProvince.Entity = null; previousValue.SalesTaxRates.Remove(this); } _stateProvince.Entity = value; if(value == null) { _stateProvinceId = default(System.Int32); } else { value.SalesTaxRates.Add(this); _stateProvinceId = value.StateProvinceId; } this.SendPropertyChanged(\"StateProvince\"); } } } #endregion }", "label": "ComplexConditional"}
{"text": "public class MvcForumMembershipProvider : MembershipProvider { // MSDN how to implement a custom provider: http://msdn.microsoft.com/en-us/library/6tc47t75.aspx // ALL THE METHODS MUST BE USED WITHIN A UNIT OF WORK IN THE CONTROLLERS // TODO - Need to implement this properly private string _applicationName; private bool _enablePasswordReset; private int _maxInvalidPasswordAttempts; private int _minRequiredNonAlphanumericCharacters; private int _minRequiredPasswordLength; private int _passwordAttemptWindow; private bool _requiresQuestionAndAnswer; private bool _requiresUniqueEmail; // Use Dependency Resolver //public IUnitOfWorkManager UnitOfWorkManager //{ // get { return UnityHelper.Container.Resolve<IUnitOfWorkManager>(); } //} public IMembershipService MembershipService => UnityHelper.Container.Resolve<IMembershipService>(); public override int MinRequiredPasswordLength => _minRequiredPasswordLength; public override int MaxInvalidPasswordAttempts => _maxInvalidPasswordAttempts; public override string ApplicationName { get { return _applicationName; } set { _applicationName = value; } } public override bool EnablePasswordReset => _enablePasswordReset; public override bool EnablePasswordRetrieval { get; } = false; public override int MinRequiredNonAlphanumericCharacters => _minRequiredNonAlphanumericCharacters; public override int PasswordAttemptWindow => _passwordAttemptWindow; public override MembershipPasswordFormat PasswordFormat { get { throw new NotImplementedException(); } } public override string PasswordStrengthRegularExpression { get { throw new NotImplementedException(); } } public override bool RequiresQuestionAndAnswer { get { throw new NotImplementedException(); } } public override bool RequiresUniqueEmail { get { throw new NotImplementedException(); } } /// <summary> /// Read a config file value /// </summary> /// <param name=\"configValue\"></param> /// <param name=\"defaultValue\"></param> /// <returns></returns> private static string GetConfigValue(string configValue, string defaultValue) { return string.IsNullOrWhiteSpace(configValue) ? defaultValue : configValue; } /// <summary> /// Initialise membership properties from config file /// </summary> /// <param name=\"name\"></param> /// <param name=\"config\"></param> public override void Initialize(string name, NameValueCollection config) { if (config == null) { throw new ArgumentNullException(\"config\"); } if (string.IsNullOrWhiteSpace(name)) { name = \"n3oSqlMembershipProvider\"; } if (string.IsNullOrWhiteSpace(config[\"description\"])) { config.Remove(\"description\"); config.Add(\"description\", \"MvcForum Standard Membership Provider\"); } // Initialize the abstract base class. base.Initialize(name, config); _applicationName = GetConfigValue(config[\"applicationName\"], HostingEnvironment.ApplicationVirtualPath); _maxInvalidPasswordAttempts = Convert.ToInt32(GetConfigValue(config[\"maxInvalidPasswordAttempts\"], \"5\")); _passwordAttemptWindow = Convert.ToInt32(GetConfigValue(config[\"passwordAttemptWindow\"], \"10\")); _minRequiredNonAlphanumericCharacters = Convert.ToInt32(GetConfigValue(config[\"minRequiredNonAlphanumericCharacters\"], \"1\")); _minRequiredPasswordLength = Convert.ToInt32(GetConfigValue(config[\"minRequiredPasswordLength\"], \"7\")); _requiresQuestionAndAnswer = Convert.ToBoolean(GetConfigValue(config[\"requiresQuestionAndAnswer\"], \"false\")); _requiresUniqueEmail = Convert.ToBoolean(GetConfigValue(config[\"requiresUniqueEmail\"], \"true\")); _enablePasswordReset = Convert.ToBoolean(GetConfigValue(config[\"enablePasswordReset\"], \"true\")); } //var user = MembershipService.GetUser(username); //if (user != null) //{ // return //} //return false; /// <summary> /// Validate the user (required for membership in MVC) /// </summary> /// <param name=\"username\"></param> /// <param name=\"password\"></param> /// <returns></returns> public override bool ValidateUser(string username, string password) { // use the data in the graph object to authorise the user return MembershipService.ValidateUser(username, password, MaxInvalidPasswordAttempts); } public override bool ChangePassword(string username, string oldPassword, string newPassword) { var user = MembershipService.GetUser(username); if (user != null) { return MembershipService.ChangePassword(user, oldPassword, newPassword); } return false; } public override bool ChangePasswordQuestionAndAnswer(string username, string password, string newPasswordQuestion, string newPasswordAnswer) { if (ValidateUser(username, password)) { var user = MembershipService.GetUser(username); user.PasswordQuestion = newPasswordQuestion; user.PasswordAnswer = newPasswordAnswer; return true; } return false; } public override bool DeleteUser(string username, bool deleteAllRelatedData) { throw new NotImplementedException(); } public override MembershipUserCollection FindUsersByEmail(string emailToMatch, int pageIndex, int pageSize, out int totalRecords) { throw new NotImplementedException(); } public override MembershipUserCollection FindUsersByName(string usernameToMatch, int pageIndex, int pageSize, out int totalRecords) { throw new NotImplementedException(); } public override MembershipUserCollection GetAllUsers(int pageIndex, int pageSize, out int totalRecords) { throw new NotImplementedException(); } public override int GetNumberOfUsersOnline() { throw new NotImplementedException(); } public override string GetPassword(string username, string answer) { throw new NotImplementedException(); } public override MembershipUser GetUser(string username, bool userIsOnline) { throw new NotImplementedException(); } public override MembershipUser GetUser(object providerUserKey, bool userIsOnline) { throw new NotImplementedException(); } public override string GetUserNameByEmail(string email) { throw new NotImplementedException(); } public override string ResetPassword(string username, string answer) { throw new NotImplementedException(); } public override bool UnlockUser(string userName) { throw new NotImplementedException(); } public override MembershipUser CreateUser(string username, string password, string email, string passwordQuestion, string passwordAnswer, bool isApproved, object providerUserKey, out MembershipCreateStatus status) { throw new NotImplementedException(); } public override void UpdateUser(MembershipUser user) { throw new NotImplementedException(); } }", "label": "ComplexConditional"}
{"text": "/// <summary> /// Base class for top-level widgets. /// </summary> /// <remarks> /// This class acts as a base for top level widget. /// It handles scheduling layout, styling and rendering as well as /// tracking the widget's <see cref=\"ClientSize\"/>. /// </remarks> public abstract class TopLevel : ContentControl, IInputRoot, ILayoutRoot, IRenderRoot, ICloseable, IStyleRoot, IWeakSubscriber<ResourcesChangedEventArgs> { /// <summary> /// Defines the <see cref=\"ClientSize\"/> property. /// </summary> public static readonly DirectProperty<TopLevel, Size> ClientSizeProperty = AvaloniaProperty.RegisterDirect<TopLevel, Size>(nameof(ClientSize), o => o.ClientSize); /// <summary> /// Defines the <see cref=\"IInputRoot.PointerOverElement\"/> property. /// </summary> public static readonly StyledProperty<IInputElement> PointerOverElementProperty = AvaloniaProperty.Register<TopLevel, IInputElement>(nameof(IInputRoot.PointerOverElement)); private readonly IInputManager _inputManager; private readonly IAccessKeyHandler _accessKeyHandler; private readonly IKeyboardNavigationHandler _keyboardNavigationHandler; private readonly IPlatformRenderInterface _renderInterface; private Size _clientSize; private ILayoutManager _layoutManager; /// <summary> /// Initializes static members of the <see cref=\"TopLevel\"/> class. /// </summary> static TopLevel() { AffectsMeasure<TopLevel>(ClientSizeProperty); } /// <summary> /// Initializes a new instance of the <see cref=\"TopLevel\"/> class. /// </summary> /// <param name=\"impl\">The platform-specific window implementation.</param> public TopLevel(ITopLevelImpl impl) : this(impl, AvaloniaLocator.Current) { } /// <summary> /// Initializes a new instance of the <see cref=\"TopLevel\"/> class. /// </summary> /// <param name=\"impl\">The platform-specific window implementation.</param> /// <param name=\"dependencyResolver\"> /// The dependency resolver to use. If null the default dependency resolver will be used. /// </param> public TopLevel(ITopLevelImpl impl, IAvaloniaDependencyResolver dependencyResolver) { if (impl == null) { throw new InvalidOperationException( \"Could not create window implementation: maybe no windowing subsystem was initialized?\"); } PlatformImpl = impl; dependencyResolver = dependencyResolver ?? AvaloniaLocator.Current; var styler = TryGetService<IStyler>(dependencyResolver); _accessKeyHandler = TryGetService<IAccessKeyHandler>(dependencyResolver); _inputManager = TryGetService<IInputManager>(dependencyResolver); _keyboardNavigationHandler = TryGetService<IKeyboardNavigationHandler>(dependencyResolver); _renderInterface = TryGetService<IPlatformRenderInterface>(dependencyResolver); Renderer = impl.CreateRenderer(this); if (Renderer != null) { Renderer.SceneInvalidated += SceneInvalidated; } impl.SetInputRoot(this); impl.Closed = HandleClosed; impl.Input = HandleInput; impl.Paint = HandlePaint; impl.Resized = HandleResized; impl.ScalingChanged = HandleScalingChanged; _keyboardNavigationHandler?.SetOwner(this); _accessKeyHandler?.SetOwner(this); styler?.ApplyStyles(this); ClientSize = impl.ClientSize; this.GetObservable(PointerOverElementProperty) .Select( x => (x as InputElement)?.GetObservable(CursorProperty) ?? Observable.Empty<Cursor>()) .Switch().Subscribe(cursor => PlatformImpl?.SetCursor(cursor?.PlatformCursor)); if (((IStyleHost)this).StylingParent is IResourceProvider applicationResources) { WeakSubscriptionManager.Subscribe( applicationResources, nameof(IResourceProvider.ResourcesChanged), this); } } /// <summary> /// Fired when the window is opened. /// </summary> public event EventHandler Opened; /// <summary> /// Fired when the window is closed. /// </summary> public event EventHandler Closed; /// <summary> /// Gets or sets the client size of the window. /// </summary> public Size ClientSize { get { return _clientSize; } protected set { SetAndRaise(ClientSizeProperty, ref _clientSize, value); } } public ILayoutManager LayoutManager { get { if (_layoutManager == null) _layoutManager = CreateLayoutManager(); return _layoutManager; } } /// <summary> /// Gets the platform-specific window implementation. /// </summary> [CanBeNull] public ITopLevelImpl PlatformImpl { get; private set; } /// <summary> /// Gets the renderer for the window. /// </summary> public IRenderer Renderer { get; private set; } /// <summary> /// Gets the access key handler for the window. /// </summary> IAccessKeyHandler IInputRoot.AccessKeyHandler => _accessKeyHandler; /// <summary> /// Gets or sets the keyboard navigation handler for the window. /// </summary> IKeyboardNavigationHandler IInputRoot.KeyboardNavigationHandler => _keyboardNavigationHandler; /// <summary> /// Gets or sets the input element that the pointer is currently over. /// </summary> IInputElement IInputRoot.PointerOverElement { get { return GetValue(PointerOverElementProperty); } set { SetValue(PointerOverElementProperty, value); } } /// <inheritdoc/> IMouseDevice IInputRoot.MouseDevice => PlatformImpl?.MouseDevice; void IWeakSubscriber<ResourcesChangedEventArgs>.OnEvent(object sender, ResourcesChangedEventArgs e) { ((ILogical)this).NotifyResourcesChanged(e); } /// <summary> /// Gets or sets a value indicating whether access keys are shown in the window. /// </summary> bool IInputRoot.ShowAccessKeys { get { return GetValue(AccessText.ShowAccessKeyProperty); } set { SetValue(AccessText.ShowAccessKeyProperty, value); } } /// <inheritdoc/> Size ILayoutRoot.MaxClientSize => Size.Infinity; /// <inheritdoc/> double ILayoutRoot.LayoutScaling => PlatformImpl?.Scaling ?? 1; /// <inheritdoc/> double IRenderRoot.RenderScaling => PlatformImpl?.Scaling ?? 1; IStyleHost IStyleHost.StylingParent { get { return AvaloniaLocator.Current.GetService<IGlobalStyles>(); } } IRenderTarget IRenderRoot.CreateRenderTarget() => CreateRenderTarget(); /// <inheritdoc/> protected virtual IRenderTarget CreateRenderTarget() { if(PlatformImpl == null) throw new InvalidOperationException(\"Can't create render target, PlatformImpl is null (might be already disposed)\"); return _renderInterface.CreateRenderTarget(PlatformImpl.Surfaces); } /// <inheritdoc/> void IRenderRoot.Invalidate(Rect rect) { PlatformImpl?.Invalidate(rect); } /// <inheritdoc/> Point IRenderRoot.PointToClient(PixelPoint p) { return PlatformImpl?.PointToClient(p) ?? default; } /// <inheritdoc/> PixelPoint IRenderRoot.PointToScreen(Point p) { return PlatformImpl?.PointToScreen(p) ?? default; } /// <summary> /// Creates the layout manager for this <see cref=\"TopLevel\" />. /// </summary> protected virtual ILayoutManager CreateLayoutManager() => new LayoutManager(); /// <summary> /// Handles a paint notification from <see cref=\"ITopLevelImpl.Resized\"/>. /// </summary> /// <param name=\"rect\">The dirty area.</param> protected virtual void HandlePaint(Rect rect) { Renderer?.Paint(rect); } /// <summary> /// Handles a closed notification from <see cref=\"ITopLevelImpl.Closed\"/>. /// </summary> protected virtual void HandleClosed() { (this as IInputRoot).MouseDevice?.TopLevelClosed(this); PlatformImpl = null; Closed?.Invoke(this, EventArgs.Empty); Renderer?.Dispose(); Renderer = null; } /// <summary> /// Handles a resize notification from <see cref=\"ITopLevelImpl.Resized\"/>. /// </summary> /// <param name=\"clientSize\">The new client size.</param> protected virtual void HandleResized(Size clientSize) { ClientSize = clientSize; Width = clientSize.Width; Height = clientSize.Height; LayoutManager.ExecuteLayoutPass(); Renderer?.Resized(clientSize); } /// <summary> /// Handles a window scaling change notification from /// <see cref=\"ITopLevelImpl.ScalingChanged\"/>. /// </summary> /// <param name=\"scaling\">The window scaling.</param> protected virtual void HandleScalingChanged(double scaling) { foreach (ILayoutable control in this.GetSelfAndVisualDescendants()) { control.InvalidateMeasure(); } } /// <inheritdoc/> protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e) { base.OnAttachedToVisualTree(e); throw new InvalidOperationException( $\"Control '{GetType().Name}' is a top level control and cannot be added as a child.\"); } /// <summary> /// Raises the <see cref=\"Opened\"/> event. /// </summary> /// <param name=\"e\">The event args.</param> protected virtual void OnOpened(EventArgs e) => Opened?.Invoke(this, e); /// <summary> /// Tries to get a service from an <see cref=\"IAvaloniaDependencyResolver\"/>, logging a /// warning if not found. /// </summary> /// <typeparam name=\"T\">The service type.</typeparam> /// <param name=\"resolver\">The resolver.</param> /// <returns>The service.</returns> private T TryGetService<T>(IAvaloniaDependencyResolver resolver) where T : class { var result = resolver.GetService<T>(); if (result == null) { Logger.Warning( LogArea.Control, this, \"Could not create {Service} : maybe Application.RegisterServices() wasn't called?\", typeof(T)); } return result; } /// <summary> /// Handles input from <see cref=\"ITopLevelImpl.Input\"/>. /// </summary> /// <param name=\"e\">The event args.</param> private void HandleInput(RawInputEventArgs e) { _inputManager.ProcessInput(e); } private void SceneInvalidated(object sender, SceneInvalidatedEventArgs e) { (this as IInputRoot).MouseDevice.SceneInvalidated(this, e.DirtyRect); } }", "label": "FeatureEnvy"}
