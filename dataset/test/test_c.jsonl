{"text": "public static bool NeedsToBeRun(PrintHostConfig printer)\n\t\t{\n\t\t\tPrintLevelingData levelingData = printer.Settings.Helpers.PrintLevelingData;\n\n\t\t\tvar required = printer.Settings.GetValue<bool>(SettingsKey.print_leveling_required_to_print);\n\t\t\tif (required && levelingData == null)\n\t\t\t{\n\t\t\t\t// need but don't have data\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (printer.Settings.GetValue<bool>(SettingsKey.has_hardware_leveling))\n\t\t\t{\n\t\t\t\t// If printer has hardware leveling, software leveling is disabled\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar enabled = printer.Settings.GetValue<bool>(SettingsKey.print_leveling_enabled);\n\n\t\t\t// check if leveling is turned on\n\t\t\tif (required && !enabled)\n\t\t\t{\n\t\t\t\t// need but not turned on\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (!required && !enabled)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// check that there are no duplicate points\n\t\t\tvar positionCounts = from x in levelingData.SampledPositions\n\t\t\t\t\t\t\t\t group x by x into g\n\t\t\t\t\t\t\t\t let count = g.Count()\n\t\t\t\t\t\t\t\t orderby count descending\n\t\t\t\t\t\t\t\t select new { Value = g.Key, Count = count };\n\n\t\t\tforeach (var x in positionCounts)\n\t\t\t{\n\t\t\t\tif (x.Count > 1)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// check that the solution last measured is the currently selected solution\n\t\t\tif (printer.Settings.GetValue<LevelingSystem>(SettingsKey.print_leveling_solution) != levelingData.LevelingSystem)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\t// check that the bed temperature at probe time was close enough to the current print bed temp\n\t\t\tdouble requiredLevelingTemp = printer.Settings.GetValue<bool>(SettingsKey.has_heated_bed) ?\n\t\t\t\tprinter.Settings.GetValue<double>(SettingsKey.bed_temperature)\n\t\t\t\t: 0;\n\n\t\t\t// check that the number of points sampled is correct for the solution\n\t\t\tswitch (levelingData.LevelingSystem)\n\t\t\t{\n\t\t\t\tcase LevelingSystem.Probe3Points:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != 3) // different criteria for what is not initialized\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LevelingSystem.Probe7PointRadial:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != 7) // different criteria for what is not initialized\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LevelingSystem.Probe13PointRadial:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != 13) // different criteria for what is not initialized\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LevelingSystem.Probe100PointRadial:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != 100) // different criteria for what is not initialized\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LevelingSystem.Probe3x3Mesh:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != 9) // different criteria for what is not initialized\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LevelingSystem.Probe5x5Mesh:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != 25) // different criteria for what is not initialized\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LevelingSystem.Probe10x10Mesh:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != 100) // different criteria for what is not initialized\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase LevelingSystem.ProbeCustom:\n\t\t\t\t\tif (levelingData.SampledPositions.Count != LevelWizardCustom.ParseLevelingSamplePoints(printer).Count)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new NotImplementedException();\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}", "label": "ComplexMethod"}
{"text": "private static float ComboDamage(Obj_AI_Base enemy)\n        {\n            var damage = 0d;\n            if (_igniteSlot != SpellSlot.Unknown &&\n                Player.Spellbook.CanUseSpell(_igniteSlot) == SpellState.Ready)\n                damage += ObjectManager.Player.GetSummonerSpellDamage(enemy, Damage.SummonerSpell.Ignite);\n            if (Items.HasItem(3077) && Items.CanUseItem(3077))\n                damage += Player.GetItemDamage(enemy, Damage.DamageItems.Tiamat);\n            if (Items.HasItem(3074) && Items.CanUseItem(3074))\n                damage += Player.GetItemDamage(enemy, Damage.DamageItems.Hydra);\n            if (Items.HasItem(3153) && Items.CanUseItem(3153))\n                damage += Player.GetItemDamage(enemy, Damage.DamageItems.Botrk);\n            if (Items.HasItem(3144) && Items.CanUseItem(3144))\n                damage += Player.GetItemDamage(enemy, Damage.DamageItems.Bilgewater);\n            if (Q.IsReady())\n                damage += Player.GetSpellDamage(enemy, SpellSlot.Q)*2*1.2;\n            if (E.IsReady())\n                damage += Player.GetSpellDamage(enemy, SpellSlot.E);\n            if (R.IsReady())\n                damage += Player.GetSpellDamage(enemy, SpellSlot.R);\n\n            damage += Player.GetAutoAttackDamage(enemy, true)*1.1;\n            damage += Player.GetAutoAttackDamage(enemy, true);\n            return (float) damage;\n        }", "label": "ComplexMethod"}
{"text": "static void Main(string[] args)\n        {\n            try\n            {\n                // Create a message actionClient to receive events on\n                ActionClient = new AriClient(new StasisEndpoint(\"127.0.0.1\", 8088, \"dev\", \"test\"), AppName);\n\n                ActionClient.OnStasisStartEvent += c_OnStasisStartEvent;\n                ActionClient.OnStasisEndEvent += c_OnStasisEndEvent;\n\n                ActionClient.Connect();\n\n                // Create simple bridge\n                SimpleBridge = ActionClient.Bridges.Create(\"mixing\", Guid.NewGuid().ToString(), AppName);\n\n                // subscribe to bridge events\n                ActionClient.Applications.Subscribe(AppName, \"bridge:\" + SimpleBridge.Id);\n\n                // start MOH on bridge\n                ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\");\n\n                var done = false;\n                while (!done)\n                {\n                    var lastKey = Console.ReadKey();\n                    switch(lastKey.KeyChar.ToString())\n                    {\n                        case \"*\":\n                            done = true;\n                            break;\n                        case \"1\":\n                            ActionClient.Bridges.StopMoh(SimpleBridge.Id);\n                            break;\n                        case \"2\":\n                            ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\");\n                            break;\n                        case \"3\":\n                            // Mute all channels on bridge\n                            var bridgeMute = ActionClient.Bridges.Get(SimpleBridge.Id);\n                            foreach (var chan in bridgeMute.Channels)\n                                ActionClient.Channels.Mute(chan, \"in\");\n                            break;\n                        case \"4\":\n                            // Unmute all channels on bridge\n                            var bridgeUnmute = ActionClient.Bridges.Get(SimpleBridge.Id);\n                            foreach (var chan in bridgeUnmute.Channels)\n                                ActionClient.Channels.Unmute(chan, \"in\");\n                            break;\n                    }\n                }\n\n                ActionClient.Bridges.Destroy(SimpleBridge.Id);\n                ActionClient.Disconnect();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.ToString());\n                Console.ReadKey();\n            }\n        }", "label": "ComplexMethod"}
{"text": "private void BuildPreprocessorStateChangeMap()\n        {\n            InternalSyntax.DirectiveStack currentState = InternalSyntax.DirectiveStack.Empty;\n            var positions = ArrayBuilder<int>.GetInstance();\n            var states = ArrayBuilder<InternalSyntax.DirectiveStack>.GetInstance();\n\n            foreach (DirectiveTriviaSyntax directive in this.GetRoot().GetDirectives(d =>\n                                                                        {\n                                                                            switch (d.Kind())\n                                                                            {\n                                                                                case SyntaxKind.IfDirectiveTrivia:\n                                                                                case SyntaxKind.ElifDirectiveTrivia:\n                                                                                case SyntaxKind.ElseDirectiveTrivia:\n                                                                                case SyntaxKind.EndIfDirectiveTrivia:\n                                                                                case SyntaxKind.DefineDirectiveTrivia:\n                                                                                case SyntaxKind.UndefDirectiveTrivia:\n                                                                                    return true;\n                                                                                default:\n                                                                                    return false;\n                                                                            }\n                                                                        }))\n            {\n                currentState = directive.ApplyDirectives(currentState);\n\n                switch (directive.Kind())\n                {\n                    case SyntaxKind.IfDirectiveTrivia:\n                        // #if directive doesn't affect the set of defined/undefined symbols\n                        break;\n\n                    case SyntaxKind.ElifDirectiveTrivia:\n                        states.Add(currentState);\n                        positions.Add(((ElifDirectiveTriviaSyntax)directive).ElifKeyword.SpanStart);\n                        break;\n\n                    case SyntaxKind.ElseDirectiveTrivia:\n                        states.Add(currentState);\n                        positions.Add(((ElseDirectiveTriviaSyntax)directive).ElseKeyword.SpanStart);\n                        break;\n\n                    case SyntaxKind.EndIfDirectiveTrivia:\n                        states.Add(currentState);\n                        positions.Add(((EndIfDirectiveTriviaSyntax)directive).EndIfKeyword.SpanStart);\n                        break;\n\n                    case SyntaxKind.DefineDirectiveTrivia:\n                        states.Add(currentState);\n                        positions.Add(((DefineDirectiveTriviaSyntax)directive).Name.SpanStart);\n                        break;\n\n                    case SyntaxKind.UndefDirectiveTrivia:\n                        states.Add(currentState);\n                        positions.Add(((UndefDirectiveTriviaSyntax)directive).Name.SpanStart);\n                        break;\n\n                    default:\n                        throw ExceptionUtilities.Unreachable;\n                }\n            }\n\n#if DEBUG\n            int currentPos = -1;\n            foreach (int pos in positions)\n            {\n                Debug.Assert(currentPos < pos);\n                currentPos = pos;\n            }\n#endif\n\n            ImmutableInterlocked.InterlockedInitialize(ref _preprocessorStates, states.ToImmutableAndFree());\n            ImmutableInterlocked.InterlockedInitialize(ref _preprocessorStateChangePositions, positions.ToImmutableAndFree());\n        }", "label": "ComplexMethod"}
{"text": "/// <summary>\n        /// Converts the value of this instance to c# code.\n        /// </summary>\n        /// <param name=\"value\">The instance.</param>\n        /// <returns>C# code.</returns>\n        public static string ToCode(this string value)\n        {\n            value = value.Replace(\"\\\"\", \"\\\\\\\"\");\n            value = value.Replace(\"\\r\\n\", \"\\\\n\");\n            value = value.Replace(\"\\n\", \"\\\\n\");\n            value = value.Replace(\"\\t\", \"\\\\t\");\n            return \"\\\"\" + value + \"\\\"\";\n        }/// <summary>\n        /// Converts the value of this instance to c# code.\n        /// </summary>\n        /// <param name=\"value\">The value.</param>\n        /// <returns>C# code.</returns>\n        public static string ToCode(this bool value)\n        {\n            return value.ToString().ToLower();\n        }/// <summary>\n        /// Converts the value of this instance to c# code.\n        /// </summary>\n        /// <param name=\"value\">The instance.</param>\n        /// <returns>C# code.</returns>\n        public static string ToCode(this int value)\n        {\n            return value.ToString(CultureInfo.InvariantCulture);\n        }/// <summary>\n        /// Converts the value of this instance to c# code.\n        /// </summary>\n        /// <param name=\"value\">The instance.</param>\n        /// <returns>C# code.</returns>\n        public static string ToCode(this Enum value)\n        {\n            return string.Format(\"{0}.{1}\", value.GetType().Name, value);\n        }/// <summary>\n        /// Converts the value of this instance to c# code.\n        /// </summary>\n        /// <param name=\"value\">The instance.</param>\n        /// <returns>C# code.</returns>\n        public static string ToCode(this double value)\n        {\n            if (double.IsNaN(value))\n            {\n                return \"double.NaN\";\n            }\n\n            if (double.IsPositiveInfinity(value))\n            {\n                return \"double.PositiveInfinity\";\n            }\n\n            if (double.IsNegativeInfinity(value))\n            {\n                return \"double.NegativeInfinity\";\n            }\n\n            if (value.Equals(double.MinValue))\n            {\n                return \"double.MinValue\";\n            }\n\n            if (value.Equals(double.MaxValue))\n            {\n                return \"double.MaxValue\";\n            }\n\n            return value.ToString(CultureInfo.InvariantCulture);\n        }/// <summary>\n        /// Converts the value of this instance to c# code.\n        /// </summary>\n        /// <param name=\"value\">The instance.</param>\n        /// <returns>C# code.</returns>\n        public static string ToCode(this object value)\n        {\n            if (value == null)\n            {\n                return \"null\";\n            }\n\n            if (value is int)\n            {\n                return ((int)value).ToCode();\n            }\n\n            if (value is double)\n            {\n                return ((double)value).ToCode();\n            }\n\n            if (value is string)\n            {\n                return ((string)value).ToCode();\n            }\n\n            if (value is bool)\n            {\n                return ((bool)value).ToCode();\n            }\n\n            if (value is Enum)\n            {\n                return ((Enum)value).ToCode();\n            }\n\n            if (value is ICodeGenerating)\n            {\n                return ((ICodeGenerating)value).ToCode();\n            }\n\n            return null;\n        }", "label": "ComplexMethod"}
{"text": "private static void HandleCommaToken(SyntaxTreeAnalysisContext context, SyntaxToken token)\n        {\n            if (token.IsMissing)\n            {\n                return;\n            }\n\n            // check for a following space\n            bool missingFollowingSpace = true;\n\n            // check for things like $\"{x,5}\"\n            var shouldNotHaveFollowingSpace = token.Parent.IsKind(SyntaxKind.InterpolationAlignmentClause);\n            if (token.HasTrailingTrivia)\n            {\n                if (token.TrailingTrivia.First().IsKind(SyntaxKind.WhitespaceTrivia))\n                {\n                    missingFollowingSpace = false;\n                }\n                else if (token.TrailingTrivia.First().IsKind(SyntaxKind.EndOfLineTrivia))\n                {\n                    missingFollowingSpace = false;\n                }\n            }\n            else\n            {\n                SyntaxToken nextToken = token.GetNextToken();\n                if (nextToken.IsKind(SyntaxKind.CommaToken) || nextToken.IsKind(SyntaxKind.GreaterThanToken) || nextToken.IsKind(SyntaxKind.CloseBracketToken))\n                {\n                    // make an exception for things like typeof(Func<,>), typeof(Func<,,>), and int[,]\n                    missingFollowingSpace = false;\n                }\n            }\n\n            if (token.IsFirstInLine() || token.IsPrecededByWhitespace(context.CancellationToken))\n            {\n                // comma should{ not} be {preceded} by whitespace\n                context.ReportDiagnostic(Diagnostic.Create(Descriptor, token.GetLocation(), TokenSpacingProperties.RemovePrecedingPreserveLayout, \" not\", \"preceded\"));\n            }\n\n            if (missingFollowingSpace && !shouldNotHaveFollowingSpace)\n            {\n                // comma should{} be {followed} by whitespace\n                context.ReportDiagnostic(Diagnostic.Create(Descriptor, token.GetLocation(), TokenSpacingProperties.InsertFollowing, string.Empty, \"followed\"));\n            }\n\n            if (!missingFollowingSpace && shouldNotHaveFollowingSpace)\n            {\n                // comma should{ not} be {followed} by whitespace\n                context.ReportDiagnostic(Diagnostic.Create(Descriptor, token.GetLocation(), TokenSpacingProperties.RemoveFollowing, \" not\", \"followed\"));\n            }\n        }", "label": "ComplexMethod"}
{"text": "/// <summary>\n            /// Formats the literal with a type prefix and quotes (if the type requires it).\n            /// </summary>\n            /// <param name=\"value\">The value to format.</param>\n            /// <returns>The formatted literal, with type marker if needed.</returns>\n            private string FormatLiteralWithTypePrefix(object value)\n            {\n                Debug.Assert(value != null, \"value != null. Null values need to be handled differently in some cases.\");\n\n                var enumValue = value as ODataEnumValue;\n                if (enumValue != null)\n                {\n                    if (string.IsNullOrEmpty(enumValue.TypeName))\n                    {\n                        // TODO: [Sizhong Du] Replace with error string #647.\n                        throw new ODataException(\"Type name should not be null or empty when serializing an Enum value for URI key.\");\n                    }\n\n                    return enumValue.TypeName + \"'\" + this.FormatAndEscapeLiteral(enumValue.Value) + \"'\";\n                }\n\n                string result = this.FormatAndEscapeLiteral(value);\n\n                if (value is byte[])\n                {\n                    return ExpressionConstants.LiteralPrefixBinary + \"'\" + result + \"'\";\n                }\n\n                if (value is Geography)\n                {\n                    return ExpressionConstants.LiteralPrefixGeography + \"'\" + result + \"'\";\n                }\n\n                if (value is Geometry)\n                {\n                    return ExpressionConstants.LiteralPrefixGeometry + \"'\" + result + \"'\";\n                }\n\n                if (value is TimeSpan)\n                {\n                    return ExpressionConstants.LiteralPrefixDuration + \"'\" + result + \"'\";\n                }\n\n                if (value is string)\n                {\n                    return \"'\" + result + \"'\";\n                }\n\n                // for int32,int64,float,double, decimal, Infinity/NaN, just output them without prefix or suffix such as L/M/D/F.\n                return result;\n            }", "label": "ComplexMethod"}
{"text": "private static MethodSupport GetMathMethodSupport(SqlMethodCall mc)\n\t\t{\n\t\t\tif(mc.Method.IsStatic && mc.Method.DeclaringType == typeof(Math))\n\t\t\t{\n\t\t\t\tswitch(mc.Method.Name)\n\t\t\t\t{\n\t\t\t\t\tcase \"Abs\":\n\t\t\t\t\tcase \"Acos\":\n\t\t\t\t\tcase \"Asin\":\n\t\t\t\t\tcase \"Atan\":\n\t\t\t\t\tcase \"Ceiling\":\n\t\t\t\t\tcase \"Cos\":\n\t\t\t\t\tcase \"Cosh\":\n\t\t\t\t\tcase \"Exp\":\n\t\t\t\t\tcase \"Floor\":\n\t\t\t\t\tcase \"Log10\":\n\t\t\t\t\t\tif(mc.Arguments.Count == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MethodSupport.Method;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn MethodSupport.MethodGroup;\n\t\t\t\t\tcase \"Log\":\n\t\t\t\t\t\tif(mc.Arguments.Count == 1 || mc.Arguments.Count == 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MethodSupport.Method;\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn MethodSupport.MethodGroup;\n\t\t\t\t\tcase \"Max\":\n\t\t\t\t\tcase \"Min\":\n\t\t\t\t\tcase \"Pow\":\n\t\t\t\t\tcase \"Atan2\":\n\t\t\t\t\tcase \"BigMul\":\n\t\t\t\t\t\tif(mc.Arguments.Count == 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MethodSupport.Method;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn MethodSupport.MethodGroup;\n\t\t\t\t\tcase \"Round\":\n\t\t\t\t\t\tif(mc.Arguments[mc.Arguments.Count - 1].ClrType == typeof(MidpointRounding)\n\t\t\t\t\t\t\t&& (mc.Arguments.Count == 2 || mc.Arguments.Count == 3))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MethodSupport.Method;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn MethodSupport.MethodGroup;\n\t\t\t\t\tcase \"Sign\":\n\t\t\t\t\tcase \"Sin\":\n\t\t\t\t\tcase \"Sinh\":\n\t\t\t\t\tcase \"Sqrt\":\n\t\t\t\t\tcase \"Tan\":\n\t\t\t\t\tcase \"Tanh\":\n\t\t\t\t\tcase \"Truncate\":\n\t\t\t\t\t\tif(mc.Arguments.Count == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn MethodSupport.Method;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn MethodSupport.MethodGroup;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn MethodSupport.None;\n\t\t}", "label": "ComplexMethod"}
{"text": "private static int LZ4_compressHCCtx_64(LZ4HC_Data_Structure ctx)\n\t\t{\n\t\t\tvar src = ctx.src;\n\t\t\tvar src_p = ctx.src_base;\n\t\t\tvar src_end = ctx.src_end;\n\t\t\tvar dst_0 = ctx.dst_base;\n\t\t\tvar src_anchor = src_p;\n\t\t\tvar src_mflimit = src_end - MFLIMIT;\n\t\t\tvar dst = ctx.dst;\n\t\t\tvar dst_len = ctx.dst_len;\n\t\t\tvar dst_p = ctx.dst_base;\n\n\t\t\tvar xxx_ref = 0;\n\t\t\tvar start2 = 0;\n\t\t\tvar ref2 = 0;\n\t\t\tvar start3 = 0;\n\t\t\tvar ref3 = 0;\n\n\t\t\tsrc_p++;\n\n\t\t\t// Main Loop\n\t\t\twhile (src_p < src_mflimit)\n\t\t\t{\n\t\t\t\tvar ml = LZ4HC_InsertAndFindBestMatch_64(ctx, src_p, ref xxx_ref);\n\t\t\t\tif (ml == 0)\n\t\t\t\t{\n\t\t\t\t\tsrc_p++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// saved, in case we would skip too much\n\t\t\t\tvar start0 = src_p;\n\t\t\t\tvar ref0 = xxx_ref;\n\t\t\t\tvar ml0 = ml;\n\n\t\t\t_Search2:\n\t\t\t\tvar ml2 = src_p + ml < src_mflimit\n\t\t\t\t\t? LZ4HC_InsertAndGetWiderMatch_64(ctx, src_p + ml - 2, src_p + 1, ml, ref ref2, ref start2)\n\t\t\t\t\t: ml;\n\n\t\t\t\tif (ml2 == ml) // No better match\n\t\t\t\t{\n\t\t\t\t\tif (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (start0 < src_p)\n\t\t\t\t{\n\t\t\t\t\tif (start2 < src_p + ml0) // empirical\n\t\t\t\t\t{\n\t\t\t\t\t\tsrc_p = start0;\n\t\t\t\t\t\txxx_ref = ref0;\n\t\t\t\t\t\tml = ml0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Here, start0==ip\n\t\t\t\tif ((start2 - src_p) < 3) // First Match too small : removed\n\t\t\t\t{\n\t\t\t\t\tml = ml2;\n\t\t\t\t\tsrc_p = start2;\n\t\t\t\t\txxx_ref = ref2;\n\t\t\t\t\tgoto _Search2;\n\t\t\t\t}\n\n\t\t\t_Search3:\n\t\t\t\t// Currently we have :\n\t\t\t\t// ml2 > ml1, and\n\t\t\t\t// ip1+3 <= ip2 (usually < ip1+ml1)\n\t\t\t\tif ((start2 - src_p) < OPTIMAL_ML)\n\t\t\t\t{\n\t\t\t\t\tvar new_ml = ml;\n\t\t\t\t\tif (new_ml > OPTIMAL_ML) new_ml = OPTIMAL_ML;\n\t\t\t\t\tif (src_p + new_ml > start2 + ml2 - MINMATCH) new_ml = (start2 - src_p) + ml2 - MINMATCH;\n\t\t\t\t\tvar correction = new_ml - (start2 - src_p);\n\t\t\t\t\tif (correction > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tstart2 += correction;\n\t\t\t\t\t\tref2 += correction;\n\t\t\t\t\t\tml2 -= correction;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Now, we have start2 = ip+new_ml, with new_ml=min(ml, OPTIMAL_ML=18)\n\n\t\t\t\tvar ml3 = start2 + ml2 < src_mflimit\n\t\t\t\t\t? LZ4HC_InsertAndGetWiderMatch_64(ctx, start2 + ml2 - 3, start2, ml2, ref ref3, ref start3)\n\t\t\t\t\t: ml2;\n\n\t\t\t\tif (ml3 == ml2) // No better match : 2 sequences to encode\n\t\t\t\t{\n\t\t\t\t\t// ip & ref are known; Now for ml\n\t\t\t\t\tif (start2 < src_p + ml) ml = (start2 - src_p);\n\t\t\t\t\t// Now, encode 2 sequences\n\t\t\t\t\tif (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0;\n\t\t\t\t\tsrc_p = start2;\n\t\t\t\t\tif (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml2, ref2) != 0) return 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (start3 < src_p + ml + 3) // Not enough space for match 2 : remove it\n\t\t\t\t{\n\t\t\t\t\tif (start3 >= (src_p + ml)) // can write Seq1 immediately ==> Seq2 is removed, so Seq3 becomes Seq1\n\t\t\t\t\t{\n\t\t\t\t\t\tif (start2 < src_p + ml)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar correction = (src_p + ml - start2);\n\t\t\t\t\t\t\tstart2 += correction;\n\t\t\t\t\t\t\tref2 += correction;\n\t\t\t\t\t\t\tml2 -= correction;\n\t\t\t\t\t\t\tif (ml2 < MINMATCH)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstart2 = start3;\n\t\t\t\t\t\t\t\tref2 = ref3;\n\t\t\t\t\t\t\t\tml2 = ml3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0;\n\t\t\t\t\t\tsrc_p = start3;\n\t\t\t\t\t\txxx_ref = ref3;\n\t\t\t\t\t\tml = ml3;\n\n\t\t\t\t\t\tstart0 = start2;\n\t\t\t\t\t\tref0 = ref2;\n\t\t\t\t\t\tml0 = ml2;\n\t\t\t\t\t\tgoto _Search2;\n\t\t\t\t\t}\n\n\t\t\t\t\tstart2 = start3;\n\t\t\t\t\tref2 = ref3;\n\t\t\t\t\tml2 = ml3;\n\t\t\t\t\tgoto _Search3;\n\t\t\t\t}\n\n\t\t\t\t// OK, now we have 3 ascending matches; let's write at least the first one\n\t\t\t\t// ip & ref are known; Now for ml\n\t\t\t\tif (start2 < src_p + ml)\n\t\t\t\t{\n\t\t\t\t\tif ((start2 - src_p) < ML_MASK)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ml > OPTIMAL_ML) ml = OPTIMAL_ML;\n\t\t\t\t\t\tif (src_p + ml > start2 + ml2 - MINMATCH) ml = (start2 - src_p) + ml2 - MINMATCH;\n\t\t\t\t\t\tvar correction = ml - (start2 - src_p);\n\t\t\t\t\t\tif (correction > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstart2 += correction;\n\t\t\t\t\t\t\tref2 += correction;\n\t\t\t\t\t\t\tml2 -= correction;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tml = (start2 - src_p);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (LZ4_encodeSequence_64(ctx, ref src_p, ref dst_p, ref src_anchor, ml, xxx_ref) != 0) return 0;\n\n\t\t\t\tsrc_p = start2;\n\t\t\t\txxx_ref = ref2;\n\t\t\t\tml = ml2;\n\n\t\t\t\tstart2 = start3;\n\t\t\t\tref2 = ref3;\n\t\t\t\tml2 = ml3;\n\n\t\t\t\tgoto _Search3;\n\t\t\t}\n\n\t\t\t// Encode Last Literals\n\t\t\t{\n\t\t\t\tvar lastRun = (src_end - src_anchor);\n\t\t\t\tif ((dst_p - dst_0) + lastRun + 1 + ((lastRun + 255 - RUN_MASK) / 255) > (uint)dst_len) return 0; // Check output limit\n\t\t\t\tif (lastRun >= RUN_MASK)\n\t\t\t\t{\n\t\t\t\t\tdst[dst_p++] = (RUN_MASK << ML_BITS);\n\t\t\t\t\tlastRun -= RUN_MASK;\n\t\t\t\t\tfor (; lastRun > 254; lastRun -= 255) dst[dst_p++] = 255;\n\t\t\t\t\tdst[dst_p++] = (byte)lastRun;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdst[dst_p++] = (byte)(lastRun << ML_BITS);\n\t\t\t\t}\n\t\t\t\tBlockCopy(src, src_anchor, dst, dst_p, src_end - src_anchor);\n\t\t\t\tdst_p += src_end - src_anchor;\n\t\t\t}\n\n\t\t\t// End\n\t\t\treturn (dst_p - dst_0);\n\t\t}", "label": "ComplexMethod"}
{"text": "private static STOutput ImplSTRandomPrime(IDigest d, int length, byte[] primeSeed)\n        {\n            int dLen = d.GetDigestSize();\n\n            if (length < 33)\n            {\n                int primeGenCounter = 0;\n\n                byte[] c0 = new byte[dLen];\n                byte[] c1 = new byte[dLen];\n\n                for (;;)\n                {\n                    Hash(d, primeSeed, c0, 0);\n                    Inc(primeSeed, 1);\n\n                    Hash(d, primeSeed, c1, 0);\n                    Inc(primeSeed, 1);\n\n                    uint c = Extract32(c0) ^ Extract32(c1);\n                    c &= (uint.MaxValue >> (32 - length));\n                    c |= (1U << (length - 1)) | 1U;\n\n                    ++primeGenCounter;\n\n                    if (IsPrime32(c))\n                    {\n                        return new STOutput(BigInteger.ValueOf((long)c), primeSeed, primeGenCounter);\n                    }\n\n                    if (primeGenCounter > (4 * length))\n                    {\n                        throw new InvalidOperationException(\"Too many iterations in Shawe-Taylor Random_Prime Routine\");\n                    }\n                }\n            }\n\n            STOutput rec = ImplSTRandomPrime(d, (length + 3)/2, primeSeed);\n\n            {\n                BigInteger c0 = rec.Prime;\n                primeSeed = rec.PrimeSeed;\n                int primeGenCounter = rec.PrimeGenCounter;\n\n                int outlen = 8 * dLen;\n                int iterations = (length - 1)/outlen;\n\n                int oldCounter = primeGenCounter;\n\n                BigInteger x = HashGen(d, primeSeed, iterations + 1);\n                x = x.Mod(One.ShiftLeft(length - 1)).SetBit(length - 1);\n\n                BigInteger c0x2 = c0.ShiftLeft(1);\n                BigInteger tx2 = x.Subtract(One).Divide(c0x2).Add(One).ShiftLeft(1);\n                int dt = 0;\n\n                BigInteger c = tx2.Multiply(c0).Add(One);\n\n                /*\n                 * TODO Since the candidate primes are generated by constant steps ('c0x2'),\n                 * sieving could be used here in place of the 'HasAnySmallFactors' approach.\n                 */\n                for (;;)\n                {\n                    if (c.BitLength > length)\n                    {\n                        tx2 = One.ShiftLeft(length - 1).Subtract(One).Divide(c0x2).Add(One).ShiftLeft(1);\n                        c = tx2.Multiply(c0).Add(One);\n                    }\n\n                    ++primeGenCounter;\n\n                    /*\n                     * This is an optimization of the original algorithm, using trial division to screen out\n                     * many non-primes quickly.\n                     * \n                     * NOTE: 'primeSeed' is still incremented as if we performed the full check!\n                     */\n                    if (!ImplHasAnySmallFactors(c))\n                    {\n                        BigInteger a = HashGen(d, primeSeed, iterations + 1);\n                        a = a.Mod(c.Subtract(Three)).Add(Two);\n\n                        tx2 = tx2.Add(BigInteger.ValueOf(dt));\n                        dt = 0;\n\n                        BigInteger z = a.ModPow(tx2, c);\n\n                        if (c.Gcd(z.Subtract(One)).Equals(One) && z.ModPow(c0, c).Equals(One))\n                        {\n                            return new STOutput(c, primeSeed, primeGenCounter);\n                        }\n                    }\n                    else\n                    {\n                        Inc(primeSeed, iterations + 1);\n                    }\n\n                    if (primeGenCounter >= ((4 * length) + oldCounter))\n                    {\n                        throw new InvalidOperationException(\"Too many iterations in Shawe-Taylor Random_Prime Routine\");\n                    }\n\n                    dt += 2;\n                    c = c.Add(c0x2);\n                }\n            }\n        }", "label": "ComplexMethod"}
{"text": "public int GetMaxHitPoints()\n        {\n            var result = 0;\n\n            //this is inaccurate\n\n            if ( Body == null )\n            {\n                return 0;\n            }\n            result = Body.Hitpoints;\n            if ( Propulsion == null )\n            {\n                return result;\n            }\n            result += (Body.Hitpoints * Propulsion.HitPoints / 100.0D).ToInt();\n            if ( Turret1 == null )\n            {\n                return result;\n            }\n            result += Body.Hitpoints + Turret1.HitPoints;\n            if ( TurretCount < 2 || Turret2 == null )\n            {\n                return result;\n            }\n            if ( Turret2.TurretType != TurretType.Weapon )\n            {\n                return result;\n            }\n            result += Body.Hitpoints + Turret2.HitPoints;\n            if ( TurretCount < 3 || Turret3 == null )\n            {\n                return result;\n            }\n            if ( Turret3.TurretType != TurretType.Weapon )\n            {\n                return result;\n            }\n            result += Body.Hitpoints + Turret3.HitPoints;\n            return result;\n        }", "label": "ComplexMethod"}
{"text": "private void ComputeLocation(Coordinate p, Geometry geom)\n        {\n            if (geom is Point)\n                UpdateLocationInfo(LocateOnPoint(p, (Point) geom));\n            if (geom is LineString)\n                UpdateLocationInfo(LocateOnLineString(p, (LineString) geom));\n            else if(geom is Polygon)\n                UpdateLocationInfo(LocateInPolygon(p, (Polygon) geom));\n            else if(geom is MultiLineString)\n            {\n                var ml = (MultiLineString) geom;\n                foreach (LineString l in ml.Geometries)\n                    UpdateLocationInfo(LocateOnLineString(p, l));\n            }\n            else if(geom is MultiPolygon)\n            {\n                var mpoly = (MultiPolygon) geom;\n                foreach (Polygon poly in mpoly.Geometries)\n                    UpdateLocationInfo(LocateInPolygon(p, poly));\n            }\n            else if (geom is GeometryCollection)\n            {\n                var geomi = new GeometryCollectionEnumerator((GeometryCollection) geom);\n                while(geomi.MoveNext())\n                {\n                    var g2 = (Geometry) geomi.Current;\n                    if (g2 != geom)\n                        ComputeLocation(p, g2);\n                }\n            }\n        }", "label": "ComplexMethod"}
{"text": "public void LoadProp(string givenPath) {\n            //int count = 0;\n            if ( !File.Exists(givenPath) ) return;\n            string[] lines = File.ReadAllLines(givenPath);\n\n            foreach ( string line in lines ) {\n                if ( line != \"\" && line[0] != '#' ) {\n                    //int index = line.IndexOf('=') + 1; // not needed if we use Split('=')\n                    string key = line.Split('=')[0].Trim();\n                    string value = \"\";\n                    if ( line.IndexOf('=') >= 0 )\n                        value = line.Substring(line.IndexOf('=') + 1).Trim(); // allowing = in the values\n                    string color = \"\";\n\n                    switch ( key.ToLower() ) {\n                        case \"server-name\":\n                            if ( ValidString(value, \"![]:.,{}~-+()?_/\\\\' \") ) txtName.Text = value;\n                            else txtName.Text = \"[MCForge] Minecraft server\";\n                            break;\n                        case \"motd\":\n                            if ( ValidString(value, \"=![]&:.,{}~-+()?_/\\\\' \") ) txtMOTD.Text = value; // allow = in the motd\n                            else txtMOTD.Text = \"Welcome to my server!\";\n                            break;\n                        case \"port\":\n                            try { numPort.Text = Convert.ToInt32(value).ToString(); }\n                            catch { numPort.Text = \"25565\"; }\n                            break;\n                        case \"verify-names\":\n                            chkVerify.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"public\":\n                            chkPublic.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"world-chat\":\n                            chkWorld.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"max-players\":\n                            try {\n                                if ( Convert.ToByte(value) > 128 ) {\n                                    value = \"128\";\n                                }\n                                else if ( Convert.ToByte(value) < 1 ) {\n                                    value = \"1\";\n                                }\n                                numPlayers.Value = Convert.ToInt16(value);\n                            }\n                            catch {\n                                Server.s.Log(\"max-players invalid! setting to default.\");\n                                numPlayers.Value = 12;\n                            }\n                            numGuests.Maximum = numPlayers.Value;\n                            break;\n                        case \"max-guests\":\n                            try {\n                                if ( Convert.ToByte(value) > numPlayers.Value ) {\n                                    value = numPlayers.Value.ToString();\n                                }\n                                else if ( Convert.ToByte(value) < 0 ) {\n                                    value = \"0\";\n                                }\n                                numGuests.Minimum = 0;\n                                numGuests.Maximum = numPlayers.Value;\n                                numGuests.Value = Convert.ToInt16(value);\n                            }\n                            catch {\n                                Server.s.Log(\"max-guests invalid! setting to default.\");\n                                numGuests.Value = 10;\n                            }\n                            break;\n                        case \"max-maps\":\n                            try {\n                                if ( Convert.ToByte(value) > 100 ) {\n                                    value = \"100\";\n                                }\n                                else if ( Convert.ToByte(value) < 1 ) {\n                                    value = \"1\";\n                                }\n                                numMaps.Text = value;\n                            }\n                            catch {\n                                Server.s.Log(\"max-maps invalid! setting to default.\");\n                                numMaps.Text = \"5\";\n                            }\n                            break;\n                        case \"mcforge-protection-level\":\n                            comboBoxProtection.SelectedItem = value;\n                            break;\n                        case \"irc\":\n                            chkIRC.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"irc-server\":\n                            txtIRCServer.Text = value;\n                            break;\n                        case \"irc-port\":\n                            numIRCPort.Text = value;\n                            break;\n                        case \"irc-nick\":\n                            txtNick.Text = value;\n                            break;\n                        case \"irc-channel\":\n                            txtChannel.Text = value;\n                            break;\n                        case \"irc-opchannel\":\n                            txtOpChannel.Text = value;\n                            break;\n                        case \"irc-identify\":\n                            chkIrcId.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"irc-password\":\n                            txtIrcId.Text = value;\n                            break;\n                        case \"anti-tunnels\":\n                            ChkTunnels.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"max-depth\":\n                            numDepth.Text = value;\n                            break;\n\n                        case \"rplimit\":\n                            try { txtRP.Text = value; }\n                            catch { txtRP.Text = \"500\"; }\n                            break;\n                        case \"rplimit-norm\":\n                            try { txtNormRp.Text = value; }\n                            catch { txtNormRp.Text = \"10000\"; }\n                            break;\n\n                        case \"log-heartbeat\":\n                            chkLogBeat.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"force-cuboid\":\n                            chkForceCuboid.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"profanity-filter\":\n                            chkProfanityFilter.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"notify-on-join-leave\":\n                            chkNotifyOnJoinLeave.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"backup-time\":\n                            txtBackup.Text = Convert.ToInt32(value) > 1 ? value : \"300\";\n                            break;\n\n                        case \"backup-location\":\n                            if ( !value.Contains(\"System.Windows.Forms.TextBox, Text:\") )\n                                txtBackupLocation.Text = value;\n                            break;\n\n                        case \"physicsrestart\":\n                            chkPhysicsRest.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"deathcount\":\n                            chkDeath.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"defaultcolor\":\n                            color = c.Parse(value);\n\n                            if ( color == \"\" ) {\n                                color = c.Name(value); if ( color != \"\" ) color = value; else { Server.s.Log(\"Could not find \" + value); return; }\n                            }\n                            cmbDefaultColour.SelectedIndex = cmbDefaultColour.Items.IndexOf(c.Name(color)); break;\n\n                        case \"irc-color\":\n                            color = c.Parse(value);\n                            if ( color == \"\" ) {\n                                color = c.Name(value); if ( color != \"\" ) color = value; else { Server.s.Log(\"Could not find \" + value); return; }\n                            }\n                            cmbIRCColour.SelectedIndex = cmbIRCColour.Items.IndexOf(c.Name(color)); break;\n                        case \"default-rank\":\n                            try {\n                                if ( cmbDefaultRank.Items.IndexOf(value.ToLower()) != -1 )\n                                    cmbDefaultRank.SelectedIndex = cmbDefaultRank.Items.IndexOf(value.ToLower());\n                            }\n                            catch { cmbDefaultRank.SelectedIndex = 1; }\n                            break;\n\n                        case \"cheapmessage\":\n                            chkCheap.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"cheap-message-given\":\n                            txtCheap.Text = value;\n                            break;\n\n                        case \"rank-super\":\n                            chkrankSuper.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"custom-ban\":\n                            chkBanMessage.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"custom-ban-message\":\n                            txtBanMessage.Text = value;\n                            break;\n\n                        case \"custom-shutdown\":\n                            chkShutdown.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"custom-shutdown-message\":\n                            txtShutdown.Text = value;\n                            break;\n\n                        case \"custom-griefer-stone\":\n                            chkGrieferStone.Checked = ( value.ToLower() == \"true\" );\n                            break;\n\n                        case \"custom-griefer-stone-message\":\n                            txtGrieferStone.Text = value;\n                            break;\n\n                        case \"auto-restart\":\n                            chkRestartTime.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"restarttime\":\n                            txtRestartTime.Text = value;\n                            break;\n                        case \"afk-minutes\":\n                            try { txtafk.Text = Convert.ToInt16(value).ToString(); }\n                            catch { txtafk.Text = \"10\"; }\n                            break;\n                        case \"afk-kick\":\n                            try { txtAFKKick.Text = Convert.ToInt16(value).ToString(); }\n                            catch { txtAFKKick.Text = \"45\"; }\n                            break;\n                        case \"check-updates\":\n                            chkUpdates.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"auto-update\":\n                            autoUpdate.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"in-game-update-notify\":\n                            notifyInGameUpdate.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"update-countdown\":\n                            try { updateTimeNumeric.Value = Convert.ToDecimal(value); }\n                            catch { updateTimeNumeric.Value = 10; }\n                            break;\n                        case \"autoload\":\n                            chkAutoload.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"parse-emotes\":\n                            chkSmile.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"allow-tp-to-higher-ranks\":\n                            chkTpToHigherRanks.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"agree-to-rules-on-entry\":\n                            chkAgreeToRules.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"admins-join-silent\":\n                            chkAdminsJoinSilent.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"main-name\":\n                            txtMain.Text = value;\n                            break;\n                        case \"dollar-before-dollar\":\n                            chk17Dollar.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"money-name\":\n                            txtMoneys.Text = value;\n                            break;\n                        /*case \"mono\":\n                            chkMono.Checked = (value.ToLower() == \"true\") ? true : false;\n                            break;*/\n                        case \"restart-on-error\":\n                            chkRestart.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"repeat-messages\":\n                            chkRepeatMessages.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"host-state\":\n                            if ( value != \"\" ) txtHost.Text = value;\n                            break;\n                        case \"kick-on-hackrank\":\n                            hackrank_kick.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"hackrank-kick-time\":\n                            hackrank_kick_time.Text = value;\n                            break;\n                        case \"server-owner\":\n                            txtServerOwner.Text = value;\n                            break;\n                        case \"zombie-on-server-start\":\n                            chkZombieOnServerStart.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"limited-blocks\":\n                            chkZombieOnServerStart.Checked = (value.ToLower() == \"true\") ? true : false;\n                            break;\n                        case \"no-respawning-during-zombie\":\n                            chkNoRespawnDuringZombie.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"no-level-saving-during-zombie\":\n                            chkNoLevelSavingDuringZombie.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"no-pillaring-during-zombie\":\n                            chkNoPillaringDuringZombie.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"zombie-name-while-infected\":\n                            ZombieName.Text = value;\n                            break;\n                        case \"enable-changing-levels\":\n                            chkEnableChangingLevels.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"zombie-survival-only-server\":\n                            chkZombieOnlyServer.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"use-level-list\":\n                            chkUseLevelList.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"zombie-level-list\":\n                            if ( value != \"\" ) {\n                                string input = value.Replace(\" \", \"\").ToString();\n                                int itndex = input.IndexOf(\"#\");\n                                if ( itndex > 0 )\n                                    input = input.Substring(0, itndex);\n                                levelList.Text = input;\n                            }\n                            break;\n                        case \"guest-limit-notify\":\n                            chkGuestLimitNotify.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"ignore-ops\":\n                            chkIgnoreGlobal.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"admin-verification\":\n                            chkEnableVerification.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"usemysql\":\n                            chkUseSQL.Checked = ( value.ToLower() == \"true\" );\n                            break;\n                        case \"username\":\n                            if ( value != \"\" ) txtSQLUsername.Text = value;\n                            break;\n                        case \"password\":\n                            if ( value != \"\" ) txtSQLPassword.Text = value;\n                            break;\n                        case \"databasename\":\n                            if ( value != \"\" ) txtSQLDatabase.Text = value;\n                            break;\n                        case \"host\":\n                            try {\n                                IPAddress.Parse(value);\n                                txtSQLHost.Text = value;\n                            }\n                            catch {\n                                txtSQLHost.Text = \"127.0.0.1\";\n                            }\n                            break;\n                        case \"sqlport\":\n                            try {\n                                int.Parse(value);\n                                numMySQLPort.Text = value;\n                            }\n                            catch {\n                                numMySQLPort.Text = \"3306\";\n                            }\n                            break;\n                        case \"mute-on-spam\":\n                            chkSpamControl.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"spam-messages\":\n                            try {\n                                numSpamMessages.Value = Convert.ToInt16(value);\n                            }\n                            catch {\n                                numSpamMessages.Value = 8;\n                            }\n                            break;\n                        case \"spam-mute-time\":\n                            try {\n                                numSpamMute.Value = Convert.ToInt16(value);\n                            }\n                            catch {\n                                numSpamMute.Value = 60;\n                            }\n                            break;\n                        case \"show-empty-ranks\":\n                            chkShowEmptyRanks.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n\n                        case \"global-chat-enabled\":\n                            chkGlobalChat.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n\n                        case \"global-chat-nick\":\n                            if ( value != \"\" ) txtGlobalChatNick.Text = value;\n                            break;\n\n                        case \"global-chat-color\":\n                            color = c.Parse(value);\n                            if ( color == \"\" ) {\n                                color = c.Name(value); if ( color != \"\" ) color = value; else { Server.s.Log(\"Could not find \" + value); return; }\n                            }\n                            cmbGlobalChatColor.SelectedIndex = cmbGlobalChatColor.Items.IndexOf(c.Name(color)); break;\n\n                        case \"griefer-stone-tempban\":\n                            chkGrieferStoneBan.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n\n                        case \"griefer-stone-type\":\n                            try { cmbGrieferStoneType.SelectedIndex = cmbGrieferStoneType.Items.IndexOf(value); }\n                            catch {\n                                try { cmbGrieferStoneType.SelectedIndex = cmbGrieferStoneType.Items.IndexOf(Block.Name(Convert.ToByte(value))); }\n                                catch { Server.s.Log(\"Could not find \" + value); }\n                            }\n                            break;\n                        case \"wom-direct\":\n                            chkWomDirect.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"premium-only\":\n                            chkPrmOnly.Checked = ( value.ToLower() == \"true\" ) ? true : false;\n                            break;\n                        case \"view\":\n                            Server.reviewview = Level.PermissionFromName(value.ToLower());\n                            break;\n                        case \"enter\":\n                            Server.reviewenter = Level.PermissionFromName(value.ToLower());\n                            break;\n                        case \"leave\":\n                            Server.reviewleave = Level.PermissionFromName(value.ToLower());\n                            break;\n                        case \"cooldown\":\n                            try {\n                                Server.reviewcooldown = Convert.ToInt32(value.ToLower()) < 600 ? Convert.ToInt32(value.ToLower()) : 600;\n                            }\n                            catch {\n                                Server.reviewcooldown = 60;\n                                Server.s.Log(\"An error occurred reading the review cooldown value\");\n                            }\n                            break;\n                        case \"clear\":\n                            Server.reviewclear = Level.PermissionFromName(value.ToLower());\n                            break;\n                        case \"next\":\n                            Server.reviewnext = Level.PermissionFromName(value.ToLower());\n                            break;\n                        case \"ignoreomnibans\":\n                            chkIgnoreOmnibans.Checked = value.ToLower() == \"true\";\n                            break;\n                    }\n                }\n            }\n            //Save(givenPath);\n            //else Save(givenPath);\n        }", "label": "ComplexMethod"}
{"text": "public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 0:\n              if (field.Type == TType.Set) {\n                {\n                  Success = new THashSet<string>();\n                  TSet _set222 = iprot.ReadSetBegin();\n                  for( int _i223 = 0; _i223 < _set222.Count; ++_i223)\n                  {\n                    string _elem224 = null;\n                    _elem224 = iprot.ReadString();\n                    Success.Add(_elem224);\n                  }\n                  iprot.ReadSetEnd();\n                }\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 1:\n              if (field.Type == TType.Struct) {\n                E = new TalkException();\n                E.Read(iprot);\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }", "label": "ComplexMethod"}
{"text": "/// <summary>Renames the page. Redirection from old title to new title is\n\t\t/// automatically created.</summary>\n\t\t/// <param name=\"newTitle\">New title of this page.</param>\n\t\t/// <param name=\"reason\">Reason for renaming.</param>\n\t\tpublic void RenameTo(string newTitle, string reason)\n\t\t{\n\t\t\tRenameTo(newTitle, reason, false, false);\n\t\t}/// <summary>Renames the page. Redirection from old title to new title is\n\t\t/// automatically created.</summary>\n\t\t/// <param name=\"newTitle\">New title of this page.</param>\n\t\t/// <param name=\"reason\">Reason for renaming.</param>\n\t\t/// <param name=\"renameTalkPage\">If true, corresponding talk page will\n\t\t/// also be renamed.</param>\n\t\t/// <param name=\"renameSubPages\">If true, subpages (like User:Me/Subpage)\n\t\t/// will also be renamed.</param>\n\t\tpublic void RenameTo(string newTitle, string reason, bool renameTalkPage,\n\t\t\tbool renameSubPages)\n\t\t{\n\t\t\tif (string.IsNullOrEmpty(newTitle))\n\t\t\t\tthrow new ArgumentNullException(\"newTitle\");\n\t\t\tif (string.IsNullOrEmpty(title))\n\t\t\t\tthrow new WikiBotException(Bot.Msg(\"No title is specified for page to rename.\"));\n\n\t\t\tif (Bot.askConfirm) {\n\t\t\t\tConsole.Write(\"\\n\\n\" +\n\t\t\t\t\tBot.Msg(\"The page \\\"{0}\\\" is going to be renamed to \\\"{1}\\\".\\n\"),\n\t\t\t\t\ttitle, newTitle);\n\t\t\t\tif(!Bot.UserConfirms())\n\t\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (site.useApi) {\n\n\t\t\t\tstring token = \"\";\n\t\t\t\tif (site.tokens != null && site.tokens.ContainsKey(\"csrftoken\"))\n\t\t\t\t\ttoken = site.tokens[\"csrftoken\"];\n\t\t\t\telse {\n\t\t\t\t\tvar tokens = GetSecurityTokens(\"move\");\n\t\t\t\t\tif (tokens.ContainsKey(\"missing\"))\n\t\t\t\t\t\tthrow new WikiBotException(\n\t\t\t\t\t\t\tstring.Format(Bot.Msg(\"Page \\\"{0}\\\" doesn't exist.\"), title));\n\t\t\t\t\tif (!tokens.ContainsKey(\"movetoken\") || tokens[\"movetoken\"] == \"\")\n\t\t\t\t\t\tthrow new WikiBotException(string.Format(\n\t\t\t\t\t\t\tBot.Msg(\"Unable to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle));\n\t\t\t\t\ttoken = tokens[\"movetoken\"];\n\t\t\t\t}\n\n\t\t\t\tstring postData = string.Format(\"from={0}&to={1}&reason={2}{3}{4}&token={5}\",\n\t\t\t\t\tBot.UrlEncode(title),\n\t\t\t\t\tBot.UrlEncode(newTitle),\n\t\t\t\t\tBot.UrlEncode(reason),\n\t\t\t\t\trenameTalkPage ? \"&movetalk=1\" : \"\",\n\t\t\t\t\trenameSubPages ? \"&movesubpages=1\" : \"\",\n\t\t\t\t\tBot.UrlEncode(token));\n\t\t\t\tstring respStr = site.PostDataAndGetResult(site.apiPath + \"?action=move\" +\n\t\t\t\t\t\"&format=xml\", postData);\n\t\t\t\tif (respStr.Contains(\"<error\"))\n\t\t\t\t\tthrow new WikiBotException(string.Format(\n\t\t\t\t\t\tBot.Msg(\"Failed to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstring respStr = site.GetWebPage(site.indexPath + \"?title=Special:Movepage/\" +\n\t\t\t\t\tBot.UrlEncode(title));\n\t\t\t\tMatch m = site.regexes[\"editToken\"].Match(respStr);\n\t\t\t\tstring securityToken = string.IsNullOrEmpty(m.Groups[1].Value)\n\t\t\t\t\t? m.Groups[2].Value : m.Groups[1].Value;\n\t\t\t\tif (string.IsNullOrEmpty(securityToken)) {\n\t\t\t\t\tConsole.Error.WriteLine(\n\t\t\t\t\t\tBot.Msg(\"Unable to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (site.watchList == null) {\n\t\t\t\t\tsite.watchList = new PageList(site);\n\t\t\t\t\tsite.watchList.FillFromWatchList();\n\t\t\t\t}\n\t\t\t\twatched = site.watchList.Contains(this);\n\n\t\t\t\tstring postData = string.Format(\"wpNewTitle={0}&wpOldTitle={1}&wpEditToken={2}\" +\n\t\t\t\t\t\"&wpReason={3}{4}{5}{6}\",\n\t\t\t\t\tBot.UrlEncode(newTitle),\n\t\t\t\t\tBot.UrlEncode(title),\n\t\t\t\t\tBot.UrlEncode(securityToken),\n\t\t\t\t\tBot.UrlEncode(reason),\n\t\t\t\t\trenameTalkPage ? \"&wpMovetalk=1\" : \"\",\n\t\t\t\t\trenameSubPages ? \"&wpMovesubpages=1\" : \"\",\n\t\t\t\t\twatched ? \"&wpWatch=1\" : \"\");\n\t\t\t\trespStr = site.PostDataAndGetResult(site.indexPath +\n\t\t\t\t\t\"?title=Special:Movepage&action=submit\", postData);\n\n\t\t\t\tif (site.messages == null)\n\t\t\t\t\tsite.LoadMediawikiMessages(true);\n\t\t\t\tRegex successMsg = new Regex(\n\t\t\t\t\t\"<h1[^>]*>(<span[^>]*>)?\\\\s*\" + site.messages[\"pagemovedsub\"] + \"\\\\s*<\");\n\t\t\t\tif (!successMsg.IsMatch(respStr))\n\t\t\t\t\tthrow new WikiBotException(string.Format(\n\t\t\t\t\t\tBot.Msg(\"Failed to rename page \\\"{0}\\\" to \\\"{1}\\\".\"), title, newTitle));\n\t\t\t}\n\n\t\t\ttitle = newTitle;\n\t\t\tConsole.WriteLine(\n\t\t\t\tBot.Msg(\"Page \\\"{0}\\\" has been successfully renamed to \\\"{1}\\\".\"), title, newTitle);\n\t\t}", "label": "ComplexMethod"}
{"text": "private static void UpdateModel(CPpmd7 p)\n        {\n            CPpmd_Void_Ref successor, fSuccessor = SUCCESSOR(p.FoundState);\n            CPpmd7_Context* c;\n            uint s0, ns;\n\n            if (p.FoundState->Freq < MAX_FREQ / 4 && p.MinContext->Suffix.Value != 0)\n            {\n                c = SUFFIX(p, p.MinContext);\n\n                if (c->NumStats == 1)\n                {\n                    CPpmd_State* s = ONE_STATE(c);\n                    if (s->Freq < 32)\n                        s->Freq++;\n                }\n                else\n                {\n                    CPpmd_State* s = STATS(p, c);\n                    if (s->Symbol != p.FoundState->Symbol)\n                    {\n                        do { s++; } while (s->Symbol != p.FoundState->Symbol);\n                        if (s[0].Freq >= s[-1].Freq)\n                        {\n                            SwapStates(&s[0], &s[-1]);\n                            s--;\n                        }\n                    }\n                    if (s->Freq < MAX_FREQ - 9)\n                    {\n                        s->Freq += 2;\n                        c->SummFreq += 2;\n                    }\n                }\n            }\n\n            if (p.OrderFall == 0)\n            {\n                p.MinContext = p.MaxContext = CreateSuccessors(p, true);\n                if (p.MinContext == null)\n                {\n                    RestartModel(p);\n                    return;\n                }\n                SetSuccessor(p.FoundState, REF(p, p.MinContext));\n                return;\n            }\n\n            *p.Text++ = p.FoundState->Symbol;\n            successor = REF(p, p.Text);\n            if (p.Text >= p.UnitsStart)\n            {\n                RestartModel(p);\n                return;\n            }\n\n            if (fSuccessor.Value != 0)\n            {\n                if (fSuccessor.Value <= successor.Value)\n                {\n                    CPpmd7_Context* cs = CreateSuccessors(p, false);\n                    if (cs == null)\n                    {\n                        RestartModel(p);\n                        return;\n                    }\n                    fSuccessor = REF(p, cs);\n                }\n                if (--p.OrderFall == 0)\n                {\n                    successor = fSuccessor;\n                    p.Text -= (p.MaxContext != p.MinContext) ? 1 : 0;\n                }\n            }\n            else\n            {\n                SetSuccessor(p.FoundState, successor);\n                fSuccessor = REF(p, p.MinContext);\n            }\n\n            s0 = p.MinContext->SummFreq - (ns = p.MinContext->NumStats) - (p.FoundState->Freq - 1u);\n\n            for (c = p.MaxContext; c != p.MinContext; c = SUFFIX(p, c))\n            {\n                uint ns1;\n                uint cf, sf;\n                if ((ns1 = c->NumStats) != 1)\n                {\n                    if ((ns1 & 1) == 0)\n                    {\n                        /* Expand for one UNIT */\n                        uint oldNU = ns1 >> 1;\n                        uint i = U2I(p, oldNU);\n                        if (i != U2I(p, oldNU + 1))\n                        {\n                            void* ptr = AllocUnits(p, i + 1);\n                            void* oldPtr;\n                            if (ptr == null)\n                            {\n                                RestartModel(p);\n                                return;\n                            }\n                            oldPtr = STATS(p, c);\n                            MyMem12Cpy(ptr, oldPtr, oldNU);\n                            InsertNode(p, oldPtr, i);\n                            c->Stats = STATS_REF(p, ptr);\n                        }\n                    }\n                    c->SummFreq = (ushort)(c->SummFreq + (2 * ns1 < ns ? 1u : 0u) + 2 * ((4 * ns1 <= ns ? 1u : 0u) & (c->SummFreq <= 8 * ns1 ? 1u : 0u)));\n                }\n                else\n                {\n                    CPpmd_State* s = (CPpmd_State*)AllocUnits(p, 0);\n                    if (s == null)\n                    {\n                        RestartModel(p);\n                        return;\n                    }\n                    *s = *ONE_STATE(c);\n                    c->Stats = REF(p, s);\n                    if (s->Freq < MAX_FREQ / 4 - 1)\n                        s->Freq <<= 1;\n                    else\n                        s->Freq = MAX_FREQ - 4;\n                    c->SummFreq = (ushort)(s->Freq + p.InitEsc + (ns > 3 ? 1u : 0u));\n                }\n                cf = 2 * (uint)p.FoundState->Freq * (c->SummFreq + 6u);\n                sf = (uint)s0 + c->SummFreq;\n                if (cf < 6 * sf)\n                {\n                    cf = 1 + (cf > sf ? 1u : 0u) + (cf >= 4 * sf ? 1u : 0u);\n                    c->SummFreq += 3;\n                }\n                else\n                {\n                    cf = 4 + (cf >= 9 * sf ? 1u : 0u) + (cf >= 12 * sf ? 1u : 0u) + (cf >= 15 * sf ? 1u : 0u);\n                    c->SummFreq = (ushort)(c->SummFreq + cf);\n                }\n                {\n                    CPpmd_State* s = STATS(p, c) + ns1;\n                    SetSuccessor(s, successor);\n                    s->Symbol = p.FoundState->Symbol;\n                    s->Freq = (byte)cf;\n                    c->NumStats = (ushort)(ns1 + 1);\n                }\n            }\n            p.MaxContext = p.MinContext = CTX(p, fSuccessor);\n        }", "label": "ComplexMethod"}
{"text": "public DynValue Coroutine_Resume(DynValue[] args)\n\t\t{\n\t\t\tEnterProcessor();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tint entrypoint = 0;\n\n\t\t\t\tif (m_State != CoroutineState.NotStarted && m_State != CoroutineState.Suspended && m_State != CoroutineState.ForceSuspended)\n\t\t\t\t\tthrow ScriptRuntimeException.CannotResumeNotSuspended(m_State);\n\n\t\t\t\tif (m_State == CoroutineState.NotStarted)\n\t\t\t\t{\n\t\t\t\t\tentrypoint = PushClrToScriptStackFrame(CallStackItemFlags.ResumeEntryPoint, null, args);\n\t\t\t\t}\n\t\t\t\telse if (m_State == CoroutineState.Suspended)\n\t\t\t\t{\n\t\t\t\t\tm_ValueStack.Push(DynValue.NewTuple(args));\n\t\t\t\t\tentrypoint = m_SavedInstructionPtr;\n\t\t\t\t}\n\t\t\t\telse if (m_State == CoroutineState.ForceSuspended)\n\t\t\t\t{\n\t\t\t\t\tif (args != null && args.Length > 0)\n\t\t\t\t\t\tthrow new ArgumentException(\"When resuming a force-suspended coroutine, args must be empty.\");\n\n\t\t\t\t\tentrypoint = m_SavedInstructionPtr;\n\t\t\t\t}\n\n\t\t\t\tm_State = CoroutineState.Running;\n\t\t\t\tDynValue retVal = Processing_Loop(entrypoint);\n\n\t\t\t\tif (retVal.Type == DataType.YieldRequest)\n\t\t\t\t{\n\t\t\t\t\tif (retVal.YieldRequest.Forced)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_State = CoroutineState.ForceSuspended;\n\t\t\t\t\t\treturn retVal;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_State = CoroutineState.Suspended;\n\t\t\t\t\t\treturn DynValue.NewTuple(retVal.YieldRequest.ReturnValues);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tm_State = CoroutineState.Dead;\n\t\t\t\t\treturn retVal;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (Exception)\n\t\t\t{\n\t\t\t\t// Unhandled exception - move to dead\n\t\t\t\tm_State = CoroutineState.Dead;\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\tfinally\n\t\t\t{\n\t\t\t\tLeaveProcessor();\n\t\t\t}\n\t\t}", "label": "ComplexMethod"}
{"text": "private List<IEntity> ImportEntityGroup(IEnumerable<JNode> entityNodes, EntityType entityType, Dictionary<EntityKey, EntityKey> tempKeyMap, MergeStrategy mergeStrategy) {\n      var importedEntities = new List<IEntity>();\n      foreach (var entityNode in entityNodes) {\n        var ek = ExtractEntityKey(entityType, entityNode);\n        var entityAspectNode = entityNode.GetJNode(\"entityAspect\");\n        // var entityState = (EntityState)Enum.Parse(typeof(EntityState), entityAspectNode.Get<String>(\"entityState\"));\n        var entityState = entityAspectNode.GetEnum<EntityState>(\"entityState\");\n        IEntity targetEntity = null;\n        bool hasCollision = false;\n        // allow merge of added records with non temp keys\n        if (entityState.IsAdded() && tempKeyMap.ContainsKey(ek)) {\n          hasCollision = tempKeyMap[ek] != ek;\n        } else {\n          targetEntity = GetEntityByKey(ek);\n        }\n        if (targetEntity != null) {\n          var targetAspect = targetEntity.EntityAspect;\n          if (mergeStrategy == MergeStrategy.Disallowed) continue;\n          if (mergeStrategy == MergeStrategy.PreserveChanges && targetAspect.EntityState != EntityState.Unchanged) continue;\n          PopulateImportedEntity(targetEntity, entityNode);\n          UpdateTempFks(targetEntity, entityAspectNode, tempKeyMap);\n          if (targetAspect.EntityState != entityState) {\n            targetAspect.EntityState = entityState;\n          }\n          OnEntityChanged(targetEntity, EntityAction.MergeOnImport);\n        } else {\n          targetEntity = (IEntity)Activator.CreateInstance(entityType.ClrType);\n          targetEntity.EntityAspect.EntityType = entityType;\n          PopulateImportedEntity(targetEntity, entityNode);\n          if (hasCollision) {\n            var origEk = targetEntity.EntityAspect.EntityKey;\n            var newEk = tempKeyMap[origEk];\n            targetEntity.EntityAspect.SetDpValue(entityType.KeyProperties[0], newEk.Values[0]);\n          }\n          UpdateTempFks(targetEntity, entityAspectNode, tempKeyMap);\n          AttachImportedEntity(targetEntity, entityType, entityState);\n        }       \n\n        importedEntities.Add(targetEntity);\n      };\n      return importedEntities;\n    }", "label": "ComplexMethod"}
{"text": "private void AppendSymbolsWithName(\n                List<MergedNamespaceOrTypeDeclaration> spine, MergedNamespaceOrTypeDeclaration current,\n                Func<string, bool> predicate, SymbolFilter filter, HashSet<ISymbol> set, CancellationToken cancellationToken)\n            {\n                var includeNamespace = (filter & SymbolFilter.Namespace) == SymbolFilter.Namespace;\n                var includeType = (filter & SymbolFilter.Type) == SymbolFilter.Type;\n                var includeMember = (filter & SymbolFilter.Member) == SymbolFilter.Member;\n\n                if (current.Kind == DeclarationKind.Namespace)\n                {\n                    if (includeNamespace && predicate(current.Name))\n                    {\n                        var container = GetSpineSymbol(spine);\n                        set.Add(GetSymbol(container, current));\n                    }\n                }\n                else\n                {\n                    if (includeType && predicate(current.Name))\n                    {\n                        var container = GetSpineSymbol(spine);\n                        set.Add(GetSymbol(container, current));\n                    }\n\n                    if (includeMember)\n                    {\n                        AppendMemberSymbolsWithName(spine, current, predicate, set, cancellationToken);\n                    }\n                }\n\n                spine.Add(current);\n\n                foreach (var child in current.Children.OfType<MergedNamespaceOrTypeDeclaration>())\n                {\n                    if (includeMember || includeType)\n                    {\n                        AppendSymbolsWithName(spine, child, predicate, filter, set, cancellationToken);\n                        continue;\n                    }\n\n                    if (child.Kind == DeclarationKind.Namespace)\n                    {\n                        AppendSymbolsWithName(spine, child, predicate, filter, set, cancellationToken);\n                    }\n                }\n\n                // pop last one\n                spine.RemoveAt(spine.Count - 1);\n            }", "label": "ComplexMethod"}
{"text": "protected virtual void CompileOptions(ToolbarGump toolbar, GumpButton clicked, Point loc, MenuGumpOptions opts)\n\t\t{\n\t\t\tif (toolbar == null)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPlayerMobile user = toolbar.User;\n\n\t\t\tif (CanEdit || user.AccessLevel >= Toolbars.Access)\n\t\t\t{\n\t\t\t\tif (!toolbar.GlobalEdit)\n\t\t\t\t{\n\t\t\t\t\topts.AppendEntry(\n\t\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\t\"Load Default\",\n\t\t\t\t\t\t\tb => SuperGump.Send(\n\t\t\t\t\t\t\t\tnew ConfirmDialogGump(user, toolbar)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTitle = \"Load Default\",\n\t\t\t\t\t\t\t\t\tHtml = \"Loading the default entry will overwrite your custom entry.\\n\\nDo you want to continue?\",\n\t\t\t\t\t\t\t\t\tAcceptHandler = db =>\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tToolbarEntry def = Toolbars.DefaultEntries.GetContent(loc.X, loc.Y);\n\n\t\t\t\t\t\t\t\t\t\ttoolbar.State.SetContent(loc.X, loc.Y, def != null ? def.Clone() : null);\n\t\t\t\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\ttoolbar.HighlightHue));\n\t\t\t\t}\n\n\t\t\t\topts.AppendEntry(\n\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\"Reset\",\n\t\t\t\t\t\tb =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tReset(toolbar);\n\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttoolbar.HighlightHue));\n\t\t\t}\n\n\t\t\tif (CanDelete || user.AccessLevel >= Toolbars.Access)\n\t\t\t{\n\t\t\t\topts.AppendEntry(\n\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\"Delete\",\n\t\t\t\t\t\tb =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttoolbar.State.SetContent(loc.X, loc.Y, null);\n\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttoolbar.HighlightHue));\n\t\t\t}\n\n\t\t\tif (CanEdit || user.AccessLevel >= Toolbars.Access)\n\t\t\t{\n\t\t\t\topts.AppendEntry(\n\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\"Set Value\",\n\t\t\t\t\t\tb => SuperGump.Send(\n\t\t\t\t\t\t\tnew InputDialogGump(user, toolbar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTitle = \"Set Value\",\n\t\t\t\t\t\t\t\tHtml = \"Set the value of this entry.\",\n\t\t\t\t\t\t\t\tInputText = Value,\n\t\t\t\t\t\t\t\tCallback = (cb, text) =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tValue = text;\n\t\t\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\ttoolbar.HighlightHue));\n\n\t\t\t\topts.AppendEntry(\n\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\"Set Label\",\n\t\t\t\t\t\tb => SuperGump.Send(\n\t\t\t\t\t\t\tnew InputDialogGump(user, toolbar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTitle = \"Set Label\",\n\t\t\t\t\t\t\t\tHtml = \"Set the label of this entry.\",\n\t\t\t\t\t\t\t\tInputText = Label,\n\t\t\t\t\t\t\t\tCallback = (cb, text) =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tLabel = text;\n\t\t\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\ttoolbar.HighlightHue));\n\n\t\t\t\topts.AppendEntry(\n\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\"Set Label Color\",\n\t\t\t\t\t\tb =>\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint rrr = 255, ggg = 255, bbb = 255;\n\n\t\t\t\t\t\t\tif (LabelColor != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\trrr = LabelColor.Value.R;\n\t\t\t\t\t\t\t\tggg = LabelColor.Value.G;\n\t\t\t\t\t\t\t\tbbb = LabelColor.Value.B;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tSuperGump.Send(\n\t\t\t\t\t\t\t\tnew InputDialogGump(user, toolbar)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tTitle = \"Set Label Color\",\n\t\t\t\t\t\t\t\t\tHtml = \"Set the label color for this entry.\\nFormat 1: NamedColor (EG; Red)\\nFormat 2: RRR,GGG,BBB\",\n\t\t\t\t\t\t\t\t\tInputText = String.Format(\"{0:D3},{1:D3},{2:D3}\", rrr, ggg, bbb),\n\t\t\t\t\t\t\t\t\tCallback = (cb, text) =>\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (!String.IsNullOrWhiteSpace(text))\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (text.IndexOf(',') != -1)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar args = text.Split(',');\n\n\t\t\t\t\t\t\t\t\t\t\t\tif (args.Length >= 3)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tInt32.TryParse(args[0], out rrr);\n\t\t\t\t\t\t\t\t\t\t\t\t\tInt32.TryParse(args[1], out ggg);\n\t\t\t\t\t\t\t\t\t\t\t\t\tInt32.TryParse(args[2], out bbb);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\trrr = Math.Min(255, Math.Max(0, rrr));\n\t\t\t\t\t\t\t\t\t\t\t\t\tggg = Math.Min(255, Math.Max(0, ggg));\n\t\t\t\t\t\t\t\t\t\t\t\t\tbbb = Math.Min(255, Math.Max(0, bbb));\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tLabelColor = Color.FromArgb(rrr, ggg, bbb);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tLabelColor = Color.FromName(text);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tcatch\n\t\t\t\t\t\t\t\t\t\t\t\t{ }\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\ttoolbar.HighlightHue));\n\n\t\t\t\tif (Highlight)\n\t\t\t\t{\n\t\t\t\t\topts.Replace(\n\t\t\t\t\t\t\"Highlight\",\n\t\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\t\"Unhighlight\",\n\t\t\t\t\t\t\tb =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tHighlight = false;\n\t\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttoolbar.ErrorHue));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\topts.Replace(\n\t\t\t\t\t\t\"Unhighlight\",\n\t\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\t\"Highlight\",\n\t\t\t\t\t\t\tb =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tHighlight = true;\n\t\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\ttoolbar.HighlightHue));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (user.AccessLevel < Toolbars.Access)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\topts.AppendEntry(\n\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\"Open Props\",\n\t\t\t\t\tb => SuperGump.Send(\n\t\t\t\t\t\tnew NoticeDialogGump(user, toolbar)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTitle = \"Props Note\",\n\t\t\t\t\t\t\tHtml =\n\t\t\t\t\t\t\t\t\"Editing the properties of an entry this way requires a hard refresh.\\nExit and re-open the Toolbar when you make any changes.\",\n\t\t\t\t\t\t\tAcceptHandler = cb =>\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttoolbar.Refresh(true);\n\n\t\t\t\t\t\t\t\tPropertiesGump pg = new PropertiesGump(user, this)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tX = b.X,\n\t\t\t\t\t\t\t\t\tY = b.Y\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tuser.SendGump(pg);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}),\n\t\t\t\t\ttoolbar.HighlightHue));\n\n\t\t\tif (toolbar.GlobalEdit && toolbar.CanGlobalEdit())\n\t\t\t{\n\t\t\t\topts.AppendEntry(\n\t\t\t\t\tnew ListGumpEntry(\n\t\t\t\t\t\t\"Global Apply\",\n\t\t\t\t\t\tb => SuperGump.Send(\n\t\t\t\t\t\t\tnew ConfirmDialogGump(user, toolbar)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tTitle = \"Global Apply\",\n\t\t\t\t\t\t\t\tHtml =\n\t\t\t\t\t\t\t\t\t\"Applying this entry globally will overwrite any custom entries at the entry location on all existing toolbars.\\n\\nDo you want to continue?\",\n\t\t\t\t\t\t\t\tAcceptHandler = db =>\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tToolbarEntry def = Toolbars.DefaultEntries.GetContent(loc.X, loc.Y);\n\n\t\t\t\t\t\t\t\t\tforeach (ToolbarState tbs in Toolbars.Profiles.Values)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\ttbs.SetContent(loc.X, loc.Y, def != null ? def.Clone() : null);\n\n\t\t\t\t\t\t\t\t\t\t\tSuperGump tb = tbs.GetToolbarGump();\n\n\t\t\t\t\t\t\t\t\t\t\tif (tb != null && tb.IsOpen)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\ttb.Refresh(true);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tcatch\n\t\t\t\t\t\t\t\t\t\t{ }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\ttoolbar.HighlightHue));\n\t\t\t}\n\t\t}", "label": "ComplexMethod"}
{"text": "/// <summary>\n        /// Add pdf blobs for Display Appliance \n        /// </summary>\n        /// <exception cref=\"DocuSign.eSign.Client.ApiException\">Thrown when fails to make API call</exception>\n        /// <param name=\"accountId\">The external account number (int) or account ID Guid.</param>/// <param name=\"envelopeId\">The envelopeId Guid of the envelope being accessed.</param>\n        \n        \n        /// <returns>ApiResponse of DisplayAppliancePdf</returns>\n        public ApiResponse< DisplayAppliancePdf > CreatePdfBlobWithHttpInfo (string accountId, string envelopeId)\n        {\n            // verify the required parameter 'accountId' is set\n            if (accountId == null)\n                throw new ApiException(400, \"Missing required parameter 'accountId' when calling EnvelopesApi->CreatePdfBlob\");\n            // verify the required parameter 'envelopeId' is set\n            if (envelopeId == null)\n                throw new ApiException(400, \"Missing required parameter 'envelopeId' when calling EnvelopesApi->CreatePdfBlob\");\n\n            var localVarPath = \"/v2.1/accounts/{accountId}/envelopes/{envelopeId}/display_appliance_info/pdf_blobs\";\n            var localVarPathParams = new Dictionary<String, String>();\n            var localVarQueryParams = new Dictionary<String, String>();\n            var localVarHeaderParams = new Dictionary<String, String>(Configuration.DefaultHeader);\n            var localVarFormParams = new Dictionary<String, String>();\n            var localVarFileParams = new Dictionary<String, FileParameter>();\n            Object localVarPostBody = null;\n\n            // to determine the Content-Type header\n            String[] localVarHttpContentTypes = new String[] {\n            };\n            String localVarHttpContentType = Configuration.ApiClient.SelectHeaderContentType(localVarHttpContentTypes);\n\n            // to determine the Accept header\n            String[] localVarHttpHeaderAccepts = new String[] {\n                \"application/json\"\n            };\n            String localVarHttpHeaderAccept = Configuration.ApiClient.SelectHeaderAccept(localVarHttpHeaderAccepts);\n            if (localVarHttpHeaderAccept != null)\n                localVarHeaderParams.Add(\"Accept\", localVarHttpHeaderAccept);\n\n            // set \"format\" to json by default\n            // e.g. /pet/{petId}.{format} becomes /pet/{petId}.json\n            localVarPathParams.Add(\"format\", \"json\");\n            if (accountId != null) localVarPathParams.Add(\"accountId\", Configuration.ApiClient.ParameterToString(accountId)); // path parameter\n            if (envelopeId != null) localVarPathParams.Add(\"envelopeId\", Configuration.ApiClient.ParameterToString(envelopeId)); // path parameter\n\n\n\n\n            // make the HTTP request\n            IRestResponse localVarResponse = (IRestResponse) Configuration.ApiClient.CallApi(localVarPath,\n                Method.POST, localVarQueryParams, localVarPostBody, localVarHeaderParams, localVarFormParams, localVarFileParams,\n                localVarPathParams, localVarHttpContentType);\n\n            int localVarStatusCode = (int) localVarResponse.StatusCode;\n\n            if (ExceptionFactory != null)\n            {\n                Exception exception = ExceptionFactory(\"CreatePdfBlob\", localVarResponse);\n                if (exception != null) throw exception;\n            }\n\n            \n            // DocuSign: Handle for PDF return types\n            if (localVarResponse.ContentType != null && !localVarResponse.ContentType.ToLower().Contains(\"json\"))\n            {\n                return new ApiResponse<DisplayAppliancePdf>(localVarStatusCode, localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()), (DisplayAppliancePdf) Configuration.ApiClient.Deserialize(localVarResponse.RawBytes, typeof(DisplayAppliancePdf)));\n            }\n            else\n            {\n                return new ApiResponse<DisplayAppliancePdf>(localVarStatusCode, localVarResponse.Headers.ToDictionary(x => x.Name, x => x.Value.ToString()), (DisplayAppliancePdf) Configuration.ApiClient.Deserialize(localVarResponse, typeof(DisplayAppliancePdf)));\n            }\n            \n        }", "label": "ComplexMethod"}
{"text": "#endregion\n\n        #region Method: Decompress(string, string)\n        public override void Decompress(string infile, string outfile)\n        {\n            // make sure the output directory exists\n            string outDirectory = Path.GetDirectoryName(outfile);\n            if (!Directory.Exists(outDirectory))\n                Directory.CreateDirectory(outDirectory);\n            // open the two given files, and delegate to the format-specific code.\n            using (FileStream inStream = new FileStream(infile, FileMode.Open),\n                             outStream = new FileStream(outfile, FileMode.Create))\n            {\n                long fLength = inStream.Length;\n                // arm9.bin needs special attention\n                if (Path.GetFileName(infile) == \"arm9.bin\")\n                    fLength -= 0xC;\n                this.Decompress(inStream, fLength, outStream);\n            }\n        }#endregion\n\n        #region Decompression method\n        public override long Decompress(System.IO.Stream instream, long inLength, System.IO.Stream outstream)\n        {\n            #region Format description\n            // Overlay LZ compression is basically just LZ-0x10 compression.\n            // however the order if reading is reversed: the compression starts at the end of the file.\n            // Assuming we start reading at the end towards the beginning, the format is:\n            /*\n             * u32 extraSize; // decompressed data size = file length (including header) + this value\n             * u8 headerSize;\n             * u24 compressedLength; // can be less than file size (w/o header). If so, the rest of the file is uncompressed.\n             *                       // may also be the file size\n             * u8[headerSize-8] padding; // 0xFF-s\n             * \n             * 0x10-like-compressed data follows (without the usual 4-byte header).\n             * The only difference is that 2 should be added to the DISP value in compressed blocks\n             * to get the proper value.\n             * the u32 and u24 are read most significant byte first.\n             * if extraSize is 0, there is no headerSize, decompressedLength or padding.\n             * the data starts immediately, and is uncompressed.\n             * \n             * arm9.bin has 3 extra u32 values at the 'start' (ie: end of the file),\n             * which may be ignored. (and are ignored here) These 12 bytes also should not\n             * be included in the computation of the output size.\n             */\n            #endregion\n\n            #region First read the last 4 bytes of the stream (the 'extraSize')\n\n            // first go to the end of the stream, since we're reading from back to front\n            // read the last 4 bytes, the 'extraSize'\n            instream.Position += inLength - 4;\n\n            byte[] buffer = new byte[4];\n            try\n            {\n                instream.Read(buffer, 0, 4);\n            }\n            catch (System.IO.EndOfStreamException)\n            {\n                // since we're immediately checking the end of the stream, \n                // this is the only location where we have to check for an EOS to occur.\n                throw new StreamTooShortException();\n            }\n            uint extraSize = IOUtils.ToNDSu32(buffer, 0);\n\n            #endregion\n\n            // if the extra size is 0, there is no compressed part, and the header ends there.\n            if (extraSize == 0)\n            {\n                #region just copy the input to the output\n\n                // first go back to the start of the file. the current location is after the 'extraSize',\n                // and thus at the end of the file.\n                instream.Position -= inLength;\n                // no buffering -> slow\n                buffer = new byte[inLength - 4];\n                instream.Read(buffer, 0, (int)(inLength - 4));\n                outstream.Write(buffer, 0, (int)(inLength - 4));\n\n                // make sure the input is positioned at the end of the file\n                instream.Position += 4;\n\n                return inLength - 4;\n\n                #endregion\n            }\n            else\n            {\n                // get the size of the compression header first.\n                instream.Position -= 5;\n                int headerSize = instream.ReadByte();\n\n                // then the compressed data size.\n                instream.Position -= 4;\n                instream.Read(buffer, 0, 3);\n                int compressedSize = buffer[0] | (buffer[1] << 8) | (buffer[2] << 16);\n\n                // the compressed size sometimes is the file size.\n                if (compressedSize + headerSize >= inLength)\n                    compressedSize = (int)(inLength - headerSize);\n\n                #region copy the non-compressed data\n\n                // copy the non-compressed data first.\n                buffer = new byte[inLength - headerSize - compressedSize];\n                instream.Position -= (inLength - 5);\n                instream.Read(buffer, 0, buffer.Length);\n                outstream.Write(buffer, 0, buffer.Length);\n\n                #endregion\n\n                // buffer the compressed data, such that we don't need to keep\n                // moving the input stream position back and forth\n                buffer = new byte[compressedSize];\n                instream.Read(buffer, 0, compressedSize);\n\n                // we're filling the output from end to start, so we can't directly write the data.\n                // buffer it instead (also use this data as buffer instead of a ring-buffer for\n                // decompression)\n                byte[] outbuffer = new byte[compressedSize + headerSize + extraSize];\n\n                int currentOutSize = 0;\n                int decompressedLength = outbuffer.Length;\n                int readBytes = 0;\n                byte flags = 0, mask = 1;\n                while (currentOutSize < decompressedLength)\n                {\n                    // (throws when requested new flags byte is not available)\n                    #region Update the mask. If all flag bits have been read, get a new set.\n                    // the current mask is the mask used in the previous run. So if it masks the\n                    // last flag bit, get a new flags byte.\n                    if (mask == 1)\n                    {\n                        if (readBytes >= compressedSize)\n                            throw new NotEnoughDataException(currentOutSize, decompressedLength);\n                        flags = buffer[buffer.Length - 1 - readBytes]; readBytes++;\n                        mask = 0x80;\n                    }\n                    else\n                    {\n                        mask >>= 1;\n                    }\n                    #endregion\n\n                    // bit = 1 <=> compressed.\n                    if ((flags & mask) > 0)\n                    {\n                        // (throws when < 2 bytes are available)\n                        #region Get length and displacement('disp') values from next 2 bytes\n                        // there are < 2 bytes available when the end is at most 1 byte away\n                        if (readBytes + 1 >= inLength)\n                        {\n                            throw new NotEnoughDataException(currentOutSize, decompressedLength);\n                        }\n                        int byte1 = buffer[compressedSize - 1 - readBytes]; readBytes++;\n                        int byte2 = buffer[compressedSize - 1 - readBytes]; readBytes++;\n\n                        // the number of bytes to copy\n                        int length = byte1 >> 4;\n                        length += 3;\n\n                        // from where the bytes should be copied (relatively)\n                        int disp = ((byte1 & 0x0F) << 8) | byte2;\n                        disp += 3;\n\n                        if (disp > currentOutSize)\n                        {\n                            if (currentOutSize < 2)\n                                throw new InvalidDataException(String.Format(Main.Get_Traduction(\"S0D\"), disp.ToString(\"X\"),\n                                    currentOutSize.ToString(\"X\")));\n                            // HACK. this seems to produce valid files, but isn't the most elegant solution.\n                            // although this _could_ be the actual way to use a disp of 2 in this format,\n                            // as otherwise the minimum would be 3 (and 0 is undefined, and 1 is less useful).\n                            disp = 2;\n                        }\n                        #endregion\n\n                        int bufIdx = currentOutSize - disp;\n                        for (int i = 0; i < length; i++)\n                        {\n                            byte next = outbuffer[outbuffer.Length - 1 - bufIdx];\n                            bufIdx++;\n                            outbuffer[outbuffer.Length - 1 - currentOutSize] = next;\n                            currentOutSize++;\n                        }\n                    }\n                    else\n                    {\n                        if (readBytes >= inLength)\n                            throw new NotEnoughDataException(currentOutSize, decompressedLength);\n                        byte next = buffer[buffer.Length - 1 - readBytes]; readBytes++;\n\n                        outbuffer[outbuffer.Length - 1 - currentOutSize] = next;\n                        currentOutSize++;\n                    }\n                }\n\n                // write the decompressed data\n                outstream.Write(outbuffer, 0, outbuffer.Length);\n\n                // make sure the input is positioned at the end of the file; the stream is currently\n                // at the compression header.\n                instream.Position += headerSize;\n\n                return decompressedLength + (inLength - headerSize - compressedSize);\n            }\n        }", "label": "ComplexMethod"}
{"text": "public static Op GetPushOp(long value)\n\t\t{\n\t\t\treturn GetPushOp(Utils.BigIntegerToBytes(ooo.BigInteger.ValueOf(value)));\n\t\t}public static Op GetPushOp(byte[] data)\n\t\t{\n\t\t\tOp op = new Op();\n\t\t\top.PushData = data;\n\t\t\tif (data.Length == 0)\n\t\t\t\top.Code = OpcodeType.OP_0;\n\t\t\telse if (data.Length == 1 && (byte)1 <= data[0] && data[0] <= (byte)16)\n\t\t\t\top.Code = (OpcodeType)(data[0] + (byte)OpcodeType.OP_1 - 1);\n\t\t\telse if (data.Length == 1 && (byte)0x81 == data[0])\n\t\t\t\top.Code = OpcodeType.OP_1NEGATE;\n\t\t\telse if (0x01 <= data.Length && data.Length <= 0x4b)\n\t\t\t\top.Code = (OpcodeType)(byte)data.Length;\n\t\t\telse if (data.Length <= 0xFF)\n\t\t\t\top.Code = OpcodeType.OP_PUSHDATA1;\n#if !NETSTANDARD1X\n\t\t\telse if (data.LongLength <= 0xFFFF)\n\t\t\t\top.Code = OpcodeType.OP_PUSHDATA2;\n\t\t\telse if (data.LongLength <= 0xFFFFFFFF)\n\t\t\t\top.Code = OpcodeType.OP_PUSHDATA4;\n#else\n\t\t\telse if(data.Length <= 0xFFFF)\n\t\t\t\top.Code = OpcodeType.OP_PUSHDATA2;\n#endif\n\t\t\telse\n\t\t\t\tthrow new NotSupportedException(\"Data length should not be bigger than 0xFFFFFFFF\");\n\t\t\treturn op;\n\t\t}", "label": "ComplexMethod"}
{"text": "/// <summary>\n        /// this implements the evaluation functionality, cannot be used directly\n        /// </summary>\n        /// <param name=\"tree\">the parsetree itself</param>\n        /// <param name=\"paramlist\">optional input parameters</param>\n        /// <returns>a partial result of the evaluation</returns>\n        internal object Eval(ParseTree tree, params object[] paramlist)\n        {\n            object Value = null;\n\n            switch (Token.Type)\n            {\n                case TokenType.Start:\n                    Value = EvalStart(tree, paramlist);\n                    break;\n                case TokenType.instruction_block:\n                    Value = Evalinstruction_block(tree, paramlist);\n                    break;\n                case TokenType.instruction:\n                    Value = Evalinstruction(tree, paramlist);\n                    break;\n                case TokenType.lazyglobal_directive:\n                    Value = Evallazyglobal_directive(tree, paramlist);\n                    break;\n                case TokenType.directive:\n                    Value = Evaldirective(tree, paramlist);\n                    break;\n                case TokenType.empty_stmt:\n                    Value = Evalempty_stmt(tree, paramlist);\n                    break;\n                case TokenType.set_stmt:\n                    Value = Evalset_stmt(tree, paramlist);\n                    break;\n                case TokenType.if_stmt:\n                    Value = Evalif_stmt(tree, paramlist);\n                    break;\n                case TokenType.until_stmt:\n                    Value = Evaluntil_stmt(tree, paramlist);\n                    break;\n                case TokenType.fromloop_stmt:\n                    Value = Evalfromloop_stmt(tree, paramlist);\n                    break;\n                case TokenType.unlock_stmt:\n                    Value = Evalunlock_stmt(tree, paramlist);\n                    break;\n                case TokenType.print_stmt:\n                    Value = Evalprint_stmt(tree, paramlist);\n                    break;\n                case TokenType.on_stmt:\n                    Value = Evalon_stmt(tree, paramlist);\n                    break;\n                case TokenType.toggle_stmt:\n                    Value = Evaltoggle_stmt(tree, paramlist);\n                    break;\n                case TokenType.wait_stmt:\n                    Value = Evalwait_stmt(tree, paramlist);\n                    break;\n                case TokenType.when_stmt:\n                    Value = Evalwhen_stmt(tree, paramlist);\n                    break;\n                case TokenType.onoff_stmt:\n                    Value = Evalonoff_stmt(tree, paramlist);\n                    break;\n                case TokenType.onoff_trailer:\n                    Value = Evalonoff_trailer(tree, paramlist);\n                    break;\n                case TokenType.stage_stmt:\n                    Value = Evalstage_stmt(tree, paramlist);\n                    break;\n                case TokenType.clear_stmt:\n                    Value = Evalclear_stmt(tree, paramlist);\n                    break;\n                case TokenType.add_stmt:\n                    Value = Evaladd_stmt(tree, paramlist);\n                    break;\n                case TokenType.remove_stmt:\n                    Value = Evalremove_stmt(tree, paramlist);\n                    break;\n                case TokenType.log_stmt:\n                    Value = Evallog_stmt(tree, paramlist);\n                    break;\n                case TokenType.break_stmt:\n                    Value = Evalbreak_stmt(tree, paramlist);\n                    break;\n                case TokenType.preserve_stmt:\n                    Value = Evalpreserve_stmt(tree, paramlist);\n                    break;\n                case TokenType.declare_identifier_clause:\n                    Value = Evaldeclare_identifier_clause(tree, paramlist);\n                    break;\n                case TokenType.declare_parameter_clause:\n                    Value = Evaldeclare_parameter_clause(tree, paramlist);\n                    break;\n                case TokenType.declare_function_clause:\n                    Value = Evaldeclare_function_clause(tree, paramlist);\n                    break;\n                case TokenType.declare_lock_clause:\n                    Value = Evaldeclare_lock_clause(tree, paramlist);\n                    break;\n                case TokenType.declare_stmt:\n                    Value = Evaldeclare_stmt(tree, paramlist);\n                    break;\n                case TokenType.return_stmt:\n                    Value = Evalreturn_stmt(tree, paramlist);\n                    break;\n                case TokenType.switch_stmt:\n                    Value = Evalswitch_stmt(tree, paramlist);\n                    break;\n                case TokenType.copy_stmt:\n                    Value = Evalcopy_stmt(tree, paramlist);\n                    break;\n                case TokenType.rename_stmt:\n                    Value = Evalrename_stmt(tree, paramlist);\n                    break;\n                case TokenType.delete_stmt:\n                    Value = Evaldelete_stmt(tree, paramlist);\n                    break;\n                case TokenType.edit_stmt:\n                    Value = Evaledit_stmt(tree, paramlist);\n                    break;\n                case TokenType.run_stmt:\n                    Value = Evalrun_stmt(tree, paramlist);\n                    break;\n                case TokenType.runpath_stmt:\n                    Value = Evalrunpath_stmt(tree, paramlist);\n                    break;\n                case TokenType.runoncepath_stmt:\n                    Value = Evalrunoncepath_stmt(tree, paramlist);\n                    break;\n                case TokenType.compile_stmt:\n                    Value = Evalcompile_stmt(tree, paramlist);\n                    break;\n                case TokenType.list_stmt:\n                    Value = Evallist_stmt(tree, paramlist);\n                    break;\n                case TokenType.reboot_stmt:\n                    Value = Evalreboot_stmt(tree, paramlist);\n                    break;\n                case TokenType.shutdown_stmt:\n                    Value = Evalshutdown_stmt(tree, paramlist);\n                    break;\n                case TokenType.for_stmt:\n                    Value = Evalfor_stmt(tree, paramlist);\n                    break;\n                case TokenType.unset_stmt:\n                    Value = Evalunset_stmt(tree, paramlist);\n                    break;\n                case TokenType.arglist:\n                    Value = Evalarglist(tree, paramlist);\n                    break;\n                case TokenType.expr:\n                    Value = Evalexpr(tree, paramlist);\n                    break;\n                case TokenType.ternary_expr:\n                    Value = Evalternary_expr(tree, paramlist);\n                    break;\n                case TokenType.or_expr:\n                    Value = Evalor_expr(tree, paramlist);\n                    break;\n                case TokenType.and_expr:\n                    Value = Evaland_expr(tree, paramlist);\n                    break;\n                case TokenType.compare_expr:\n                    Value = Evalcompare_expr(tree, paramlist);\n                    break;\n                case TokenType.arith_expr:\n                    Value = Evalarith_expr(tree, paramlist);\n                    break;\n                case TokenType.multdiv_expr:\n                    Value = Evalmultdiv_expr(tree, paramlist);\n                    break;\n                case TokenType.unary_expr:\n                    Value = Evalunary_expr(tree, paramlist);\n                    break;\n                case TokenType.factor:\n                    Value = Evalfactor(tree, paramlist);\n                    break;\n                case TokenType.suffix:\n                    Value = Evalsuffix(tree, paramlist);\n                    break;\n                case TokenType.suffix_trailer:\n                    Value = Evalsuffix_trailer(tree, paramlist);\n                    break;\n                case TokenType.suffixterm:\n                    Value = Evalsuffixterm(tree, paramlist);\n                    break;\n                case TokenType.suffixterm_trailer:\n                    Value = Evalsuffixterm_trailer(tree, paramlist);\n                    break;\n                case TokenType.function_trailer:\n                    Value = Evalfunction_trailer(tree, paramlist);\n                    break;\n                case TokenType.array_trailer:\n                    Value = Evalarray_trailer(tree, paramlist);\n                    break;\n                case TokenType.atom:\n                    Value = Evalatom(tree, paramlist);\n                    break;\n                case TokenType.sci_number:\n                    Value = Evalsci_number(tree, paramlist);\n                    break;\n                case TokenType.number:\n                    Value = Evalnumber(tree, paramlist);\n                    break;\n                case TokenType.varidentifier:\n                    Value = Evalvaridentifier(tree, paramlist);\n                    break;\n                case TokenType.identifier_led_stmt:\n                    Value = Evalidentifier_led_stmt(tree, paramlist);\n                    break;\n                case TokenType.identifier_led_expr:\n                    Value = Evalidentifier_led_expr(tree, paramlist);\n                    break;\n\n                default:\n                    Value = Token.Text;\n                    break;\n            }\n            return Value;\n        }", "label": "ComplexMethod"}
{"text": "public static ushort ConvertCPE(ushort b)\n        {\n            switch (b)\n            {\n                case 50: return 44;\n                case 51: return 39;\n                case 52: return 12;\n                case 53: return 0;\n                case 54: return 10;\n                case 55: return 33;\n                case 56: return 25;\n                case 57: return 3;\n                case 58: return 29;\n                case 59: return 28;\n                case 60: return 20;\n                case 61: return 42;\n                case 62: return 49;\n                case 63: return 36;\n                case 64: return 5;\n                case 65: return 1;\n                default:\n                    return b;\n            }\n        }", "label": "ComplexMethod"}
{"text": "/// <inheritdoc/>\n        public override Size MeasureOverride(Size availableSize)\n        {\n            var scrollable = (ILogicalScrollable)Owner;\n            var visualRoot = Owner.GetVisualRoot();\n            var maxAvailableSize = (visualRoot as WindowBase)?.PlatformImpl?.MaxClientSize\n                 ?? (visualRoot as TopLevel)?.ClientSize;\n\n            // If infinity is passed as the available size and we're virtualized then we need to\n            // fill the available space, but to do that we *don't* want to materialize all our\n            // items! Take a look at the root of the tree for a MaxClientSize and use that as\n            // the available size.\n            if (VirtualizingPanel.ScrollDirection == Orientation.Vertical)\n            {\n                if (availableSize.Height == double.PositiveInfinity)\n                {\n                    if (maxAvailableSize.HasValue)\n                    {\n                        availableSize = availableSize.WithHeight(maxAvailableSize.Value.Height);\n                    }\n                }\n\n                if (scrollable.CanHorizontallyScroll)\n                {\n                    availableSize = availableSize.WithWidth(double.PositiveInfinity);\n                }\n            }\n            else\n            {\n                if (availableSize.Width == double.PositiveInfinity)\n                {\n                    if (maxAvailableSize.HasValue)\n                    {\n                        availableSize = availableSize.WithWidth(maxAvailableSize.Value.Width);\n                    }\n                }\n\n                if (scrollable.CanVerticallyScroll)\n                {\n                    availableSize = availableSize.WithHeight(double.PositiveInfinity);\n                }\n            }\n\n            Owner.Panel.Measure(availableSize);\n            return Owner.Panel.DesiredSize;\n        }", "label": "ComplexMethod"}
{"text": "public override void WriteXml(XmlWriter writer)\n        {\n            writer.WriteElementString(\"Name\", Namespace, Name.ToString());\n            writer.WriteElementString(\"Title\", Namespace, Title);\n            if (!string.IsNullOrEmpty(Abstract))\n                writer.WriteElementString(\"Abstract\", Namespace, Abstract);\n            if (_keywordListField != null && _keywordListField.Keyword.Count > 0)\n            {\n                writer.WriteStartElement(\"KeywordList\", Namespace);\n                KeywordList.WriteXml(writer);\n                writer.WriteEndElement();\n            }\n\n            writer.WriteStartElement(\"OnlineResource\", Namespace);\n            OnlineResource.WriteXml(writer);\n            writer.WriteEndElement();\n\n            if (_contactInformationField != null)\n            {\n                writer.WriteStartElement(\"ContactInformation\", Namespace);\n                _contactInformationField.WriteXml(writer);\n                writer.WriteEndElement();\n            }\n\n            if (!string.IsNullOrEmpty(Fees))\n                writer.WriteElementString(\"Fees\", Namespace, Fees);\n\n            if (!string.IsNullOrEmpty(AccessConstraints))\n                writer.WriteElementString(\"AccessConstraints\", Namespace, AccessConstraints);\n\n            if (LayerLimit.HasValue)\n                writer.WriteElementString(\"LayerLimit\", Namespace, LayerLimit.Value.ToString());\n            if (MaxWidth.HasValue)\n                writer.WriteElementString(\"MaxWidth\", Namespace, MaxWidth.Value.ToString());\n            if (MaxHeight.HasValue)\n                writer.WriteElementString(\"MaxHeight\", Namespace, MaxHeight.Value.ToString());\n        }", "label": "ComplexMethod"}
{"text": "public override bool Equals(object obj)\n\t\t{\n\t\t\tif (this == obj)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar cacheKey = obj as CacheKey;\n\t\t\tif (cacheKey == null)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!Equals(type, cacheKey.type))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!Equals(target, cacheKey.target))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (interfaces.Length != cacheKey.interfaces.Length)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfor (var i = 0; i < interfaces.Length; i++)\n\t\t\t{\n\t\t\t\tif (!Equals(interfaces[i], cacheKey.interfaces[i]))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!Equals(options, cacheKey.options))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}", "label": "ComplexMethod"}
{"text": "internal static P<uint> GetMatchesSpec1(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue, P<uint> distances, uint maxLen)\n            {\n                P<uint> ptr0 = son + (_cyclicBufferPos << 1) + 1;\n                P<uint> ptr1 = son + (_cyclicBufferPos << 1);\n                uint len0 = 0;\n                uint len1 = 0;\n\n                for (;;)\n                {\n                    uint delta = pos - curMatch;\n                    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n                    {\n                        ptr0[0] = ptr1[0] = CMatchFinder.kEmptyHashValue;\n                        return distances;\n                    }\n\n                    P<uint> pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);\n                    P<byte> pb = cur - delta;\n                    uint len = (len0 < len1 ? len0 : len1);\n\n                    if (pb[len] == cur[len])\n                    {\n                        if (++len != lenLimit && pb[len] == cur[len])\n                            while (++len != lenLimit)\n                                if (pb[len] != cur[len])\n                                    break;\n\n                        if (maxLen < len)\n                        {\n                            distances[0] = maxLen = len;\n                            distances++;\n                            distances[0] = delta - 1;\n                            distances++;\n\n                            if (len == lenLimit)\n                            {\n                                ptr1[0] = pair[0];\n                                ptr0[0] = pair[1];\n                                return distances;\n                            }\n                        }\n                    }\n\n                    if (pb[len] < cur[len])\n                    {\n                        ptr1[0] = curMatch;\n                        ptr1 = pair + 1;\n                        curMatch = ptr1[0];\n                        len1 = len;\n                    }\n                    else\n                    {\n                        ptr0[0] = curMatch;\n                        ptr0 = pair;\n                        curMatch = ptr0[0];\n                        len0 = len;\n                    }\n                }\n            }", "label": "ComplexMethod"}
{"text": "private void BreakAllInvalidJoints()\n        {\n            GameEvents.onVesselWasModified.Remove(OnVesselWasModified);\n\n            foreach (ConfigurableJoint j in joints)\n                GameObject.Destroy(j);\n\n            joints.Clear();\n\n            var vessels = new List<Vessel>();\n\n            foreach (Part n in neighbours)\n            {\n                if (n.vessel == null || vessels.Contains(n.vessel))\n                    continue;\n\n                vessels.Add(n.vessel);\n\n                foreach (Part p in n.vessel.Parts)\n                {\n                    if (p.Modules.Contains<LaunchClamp>())\n                        continue;\n\n\n                    ConfigurableJoint[] possibleConnections = p.GetComponents<ConfigurableJoint>();\n\n                    if (possibleConnections == null)\n                        continue;\n\n                    foreach (ConfigurableJoint j in possibleConnections)\n                    {\n                        if (j.connectedBody == null)\n                        {\n                            GameObject.Destroy(j);\n                            continue;\n                        }\n                        Part cp = j.connectedBody.GetComponent<Part>();\n                        if (cp != null && cp.vessel != p.vessel)\n                            GameObject.Destroy(j);\n                    }\n                }\n            }\n            neighbours.Clear();\n        }", "label": "ComplexMethod"}
{"text": "private static void Provider_Executing(object sender, ExecutingEventArgs args)\n        {\n            if (!(args.CommandName == \"CommitTransaction\" || args.CommandName == \"FlushTransaction\"))\n                return;\n\n            var provider = sender as PageDataProvider;\n\n            var dirtyItems = provider.GetDirtyItems();\n            if (dirtyItems.Count == 0)\n                return;\n\n            var createdPageTemplates = provider.GetExecutionStateData(CreatedPageTemplatesCategoryIds) as HashSet<string>;\n            if (createdPageTemplates == null)\n                createdPageTemplates = new HashSet<string>();\n\n            foreach (var item in dirtyItems)\n            {\n                SecurityConstants.TransactionActionType itemStatus = provider.GetDirtyItemStatus(item);\n                var pageTemplate = item as PageTemplate;\n                if (pageTemplate != null)\n                {\n                    if (itemStatus == SecurityConstants.TransactionActionType.New && pageTemplate.Framework == PageTemplateFramework.Mvc)\n                    {\n                        // the template name is formulated as Bootstrap.default\n                        var nameParts = pageTemplate.Name.Split(new char[] { '.' }, StringSplitOptions.RemoveEmptyEntries);\n                        if (nameParts.Length > 1)\n                        {\n                            var package = nameParts[0];\n\n                            // always create the template, desipite if the package is not there\n                            // in case the client first performs a sync and then deploys the files by mistake\n                            createdPageTemplates.Add(package);\n                        }\n                    }\n                }\n            }\n\n            if (createdPageTemplates.Any())\n            {\n                provider.SetExecutionStateData(CreatedPageTemplatesCategoryIds, createdPageTemplates);\n            }\n        }", "label": "ComplexMethod"}
{"text": "private static float ComboDamage(Obj_AI_Base enemy)\n        {\n            var damage = 0d;\n            if (_igniteSlot != SpellSlot.Unknown &&\n                _player.Spellbook.CanUseSpell(_igniteSlot) == SpellState.Ready)\n                damage += ObjectManager.Player.GetSummonerSpellDamage(enemy, Damage.SummonerSpell.Ignite);\n            if (Items.HasItem(3077) && Items.CanUseItem(3077))\n                damage += _player.GetItemDamage(enemy, Damage.DamageItems.Tiamat);\n            if (Items.HasItem(3074) && Items.CanUseItem(3074))\n                damage += _player.GetItemDamage(enemy, Damage.DamageItems.Hydra);\n            if (Items.HasItem(3153) && Items.CanUseItem(3153))\n                damage += _player.GetItemDamage(enemy, Damage.DamageItems.Botrk);\n            if (Items.HasItem(3144) && Items.CanUseItem(3144))\n                damage += _player.GetItemDamage(enemy, Damage.DamageItems.Bilgewater);\n            if (_q.IsReady())\n                damage += _player.GetSpellDamage(enemy, SpellSlot.Q)*1.2;\n            if (_q.IsReady())\n                damage += _player.GetSpellDamage(enemy, SpellSlot.W)*3;\n            if (_e.IsReady())\n                damage += _player.GetSpellDamage(enemy, SpellSlot.E);\n            if (_r.IsReady())\n                damage += _player.GetSpellDamage(enemy, SpellSlot.R);\n            damage += _player.GetAutoAttackDamage(enemy, true)*2;\n            return (float) damage;\n        }", "label": "ComplexMethod"}
{"text": "public void ExportHQTFFD(string path, ETLExportEnum exportType = ETLExportEnum.ETLExportSimple, bool append = false, bool omitSource = false, bool omitLegacy = false, long size = 32)\n        {\n            // The public entry point for exporting HQTFFD from the JMSML library\n            // into CSV format.  These include combinations of headquarter, task force, and feint/dummy amplifiers\n\n            // Accepts a path for the output (sans file name extension).  The output may also\n            // be appended to an existing file.\n\n            IHQTFFDExport hqTFFDExporter = null;\n            string line = \"\";\n\n            _configHelper.PointSize = (int)size;\n\n            switch (exportType)\n            {\n                case ETLExportEnum.ETLExportDomain:\n                    hqTFFDExporter = new DomainHQTFFDExport(_configHelper);\n                    break;\n\n                case ETLExportEnum.ETLExportImage:\n                    hqTFFDExporter = new ImageHQTFFDExport(_configHelper, omitSource, omitLegacy);\n                    break;\n            }\n\n            if (hqTFFDExporter != null)\n            {\n                using (var w = new StreamWriter(path + \".csv\", append))\n                {\n                    if (!append)\n                    {\n                        line = string.Format(\"{0}\", hqTFFDExporter.Headers);\n\n                        w.WriteLine(line);\n                        w.Flush();\n                    }\n\n                    foreach (LibraryHQTFDummy hqTFFD in _library.HQTFDummies)\n                    {\n                        if (hqTFFD.Graphics != null && exportType == ETLExportEnum.ETLExportImage)\n                        {\n                            foreach (LibraryHQTFDummyGraphic graphic in hqTFFD.Graphics)\n                            {\n                                line = hqTFFDExporter.Line(hqTFFD, graphic);\n\n                                if (line != \"\")\n                                {\n                                    w.WriteLine(line);\n                                    w.Flush();\n                                }\n                            }\n                        }\n                        else if (exportType == ETLExportEnum.ETLExportDomain)\n                        {\n                            if (!hqTFFD.IsExtension)\n                            {\n                                line = hqTFFDExporter.Line(hqTFFD, null);\n\n                                if (line != \"\")\n                                {\n                                    w.WriteLine(line);\n                                    w.Flush();\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }", "label": "ComplexMethod"}
{"text": "/// <summary>\n\t\t/// <p>\n\t\t/// If buffer is non null stream assumed to be partial, otherwise the length will be used\n\t\t/// to output a fixed length packet.\n\t\t/// </p>\n\t\t/// <p>\n\t\t/// The stream created can be closed off by either calling Close()\n\t\t/// on the stream or Close() on the generator. Closing the returned\n\t\t/// stream does not close off the Stream parameter <c>outStr</c>.\n\t\t/// </p>\n\t\t/// </summary>\n        private Stream Open(\n            Stream\toutStr,\n            long\tlength,\n            byte[]\tbuffer)\n        {\n\t\t\tif (cOut != null)\n\t\t\t\tthrow new InvalidOperationException(\"generator already in open state\");\n\t\t\tif (methods.Count == 0)\n\t\t\t\tthrow new InvalidOperationException(\"No encryption methods specified\");\n\t\t\tif (outStr == null)\n\t\t\t\tthrow new ArgumentNullException(\"outStr\");\n\n\t\t\tpOut = new BcpgOutputStream(outStr);\n\n\t\t\tKeyParameter key;\n\n\t\t\tif (methods.Count == 1)\n            {\n                if (methods[0] is PbeMethod)\n                {\n                    PbeMethod m = (PbeMethod)methods[0];\n\n\t\t\t\t\tkey = m.GetKey();\n                }\n                else\n                {\n                    key = PgpUtilities.MakeRandomKey(defAlgorithm, rand);\n\n\t\t\t\t\tbyte[] sessionInfo = CreateSessionInfo(defAlgorithm, key);\n                    PubMethod m = (PubMethod)methods[0];\n\n                    try\n                    {\n                        m.AddSessionInfo(sessionInfo, rand);\n                    }\n                    catch (Exception e)\n                    {\n                        throw new PgpException(\"exception encrypting session key\", e);\n                    }\n                }\n\n\t\t\t\tpOut.WritePacket((ContainedPacket)methods[0]);\n            }\n            else // multiple methods\n            {\n                key = PgpUtilities.MakeRandomKey(defAlgorithm, rand);\n\t\t\t\tbyte[] sessionInfo = CreateSessionInfo(defAlgorithm, key);\n\n\t\t\t\tfor (int i = 0; i != methods.Count; i++)\n                {\n                    EncMethod m = (EncMethod)methods[i];\n\n                    try\n                    {\n                        m.AddSessionInfo(sessionInfo, rand);\n                    }\n                    catch (Exception e)\n                    {\n                        throw new PgpException(\"exception encrypting session key\", e);\n                    }\n\n                    pOut.WritePacket(m);\n                }\n            }\n\n            string cName = PgpUtilities.GetSymmetricCipherName(defAlgorithm);\n\t\t\tif (cName == null)\n            {\n                throw new PgpException(\"null cipher specified\");\n            }\n\n\t\t\ttry\n            {\n                if (withIntegrityPacket)\n                {\n                    cName += \"/CFB/NoPadding\";\n                }\n                else\n                {\n                    cName += \"/OpenPGPCFB/NoPadding\";\n                }\n\n                c = CipherUtilities.GetCipher(cName);\n\n\t\t\t\t// TODO Confirm the IV should be all zero bytes (not inLineIv - see below)\n\t\t\t\tbyte[] iv = new byte[c.GetBlockSize()];\n                c.Init(true, new ParametersWithRandom(new ParametersWithIV(key, iv), rand));\n\n                if (buffer == null)\n                {\n                    //\n                    // we have to Add block size + 2 for the Generated IV and + 1 + 22 if integrity protected\n                    //\n                    if (withIntegrityPacket)\n                    {\n                        pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricEncryptedIntegrityProtected, length + c.GetBlockSize() + 2 + 1 + 22);\n                        pOut.WriteByte(1);        // version number\n                    }\n                    else\n                    {\n                        pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricKeyEncrypted, length + c.GetBlockSize() + 2, oldFormat);\n                    }\n                }\n                else\n                {\n                    if (withIntegrityPacket)\n                    {\n                        pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricEncryptedIntegrityProtected, buffer);\n                        pOut.WriteByte(1);        // version number\n                    }\n                    else\n                    {\n                        pOut = new BcpgOutputStream(outStr, PacketTag.SymmetricKeyEncrypted, buffer);\n                    }\n                }\n\n\t\t\t\tint blockSize = c.GetBlockSize();\n\t\t\t\tbyte[] inLineIv = new byte[blockSize + 2];\n                rand.NextBytes(inLineIv, 0, blockSize);\n\t\t\t\tArray.Copy(inLineIv, inLineIv.Length - 4, inLineIv, inLineIv.Length - 2, 2);\n\n\t\t\t\tStream myOut = cOut = new CipherStream(pOut, null, c);\n\n\t\t\t\tif (withIntegrityPacket)\n                {\n\t\t\t\t\tstring digestName = PgpUtilities.GetDigestName(HashAlgorithmTag.Sha1);\n\t\t\t\t\tIDigest digest = DigestUtilities.GetDigest(digestName);\n\t\t\t\t\tmyOut = digestOut = new DigestStream(myOut, null, digest);\n                }\n\n\t\t\t\tmyOut.Write(inLineIv, 0, inLineIv.Length);\n\n\t\t\t\treturn new WrappedGeneratorStream(this, myOut);\n            }\n            catch (Exception e)\n            {\n                throw new PgpException(\"Exception creating cipher\", e);\n            }\n        }/// <summary>\n\t\t/// <p>\n\t\t/// Return an output stream which will encrypt the data as it is written to it.\n\t\t/// </p>\n\t\t/// <p>\n\t\t/// The stream created can be closed off by either calling Close()\n\t\t/// on the stream or Close() on the generator. Closing the returned\n\t\t/// stream does not close off the Stream parameter <c>outStr</c>.\n\t\t/// </p>\n\t\t/// </summary>\n        public Stream Open(\n            Stream\toutStr,\n            long\tlength)\n        {\n            return Open(outStr, length, null);\n        }/// <summary>\n\t\t/// <p>\n\t\t/// Return an output stream which will encrypt the data as it is written to it.\n\t\t/// The stream will be written out in chunks according to the size of the passed in buffer.\n\t\t/// </p>\n\t\t/// <p>\n\t\t/// The stream created can be closed off by either calling Close()\n\t\t/// on the stream or Close() on the generator. Closing the returned\n\t\t/// stream does not close off the Stream parameter <c>outStr</c>.\n\t\t/// </p>\n\t\t/// <p>\n\t\t/// <b>Note</b>: if the buffer is not a power of 2 in length only the largest power of 2\n\t\t/// bytes worth of the buffer will be used.\n\t\t/// </p>\n\t\t/// </summary>\n        public Stream Open(\n            Stream\toutStr,\n            byte[]\tbuffer)\n        {\n            return Open(outStr, 0, buffer);\n        }", "label": "ComplexMethod"}
{"text": "// REVIEW: We can use a stack if the perf is bad for Except and MergeWith\n        public static XElement Except(this XElement source, XElement target)\n        {\n            if (target == null)\n            {\n                return source;\n            }\n\n            var attributesToRemove = from e in source.Attributes()\n                where AttributeEquals(e, target.Attribute(e.Name))\n                select e;\n            // Remove the attributes\n            foreach (var a in attributesToRemove.ToList())\n            {\n                a.Remove();\n            }\n\n            foreach (var sourceChildNode in source.Nodes().ToList())\n            {\n                var sourceChildComment = sourceChildNode as XComment;\n                if (sourceChildComment != null)\n                {\n                    var hasMatchingComment = HasComment(target, sourceChildComment);\n                    if (hasMatchingComment)\n                    {\n                        sourceChildComment.Remove();\n                    }\n                    continue;\n                }\n\n                var sourceChild = sourceChildNode as XElement;\n                if (sourceChild != null)\n                {\n                    var targetChild = FindElement(target, sourceChild);\n                    if (targetChild != null\n                        && !HasConflict(sourceChild, targetChild))\n                    {\n                        Except(sourceChild, targetChild);\n                        var hasContent = sourceChild.HasAttributes || sourceChild.HasElements;\n                        if (!hasContent)\n                        {\n                            // Remove the element if there is no content\n                            sourceChild.Remove();\n                            targetChild.Remove();\n                        }\n                    }\n                }\n            }\n            return source;\n        }", "label": "ComplexMethod"}
{"text": "public override bool DoActionCombat()\n\t\t{\n\t\t\tMobile combatant = m_Mobile.Combatant;\n\n\t\t\tif (combatant == null || combatant.Deleted || combatant.Map != m_Mobile.Map || !combatant.Alive ||\n\t\t\t\tcombatant.IsDeadBondedPet)\n\t\t\t{\n\t\t\t\tm_Mobile.DebugSay(\"My combatant is gone, so my guard is up\");\n\n\t\t\t\tAction = ActionType.Guard;\n\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (Utility.RandomDouble() < teleportChance)\n\t\t\t{\n\t\t\t\tTryToTeleport();\n\t\t\t}\n\n\t\t\tif (!m_Mobile.InRange(combatant, m_Mobile.RangePerception))\n\t\t\t{\n\t\t\t\t// They are somewhat far away, can we find something else?\n\t\t\t\tif (AcquireFocusMob(m_Mobile.RangePerception, m_Mobile.FightMode, false, false, true))\n\t\t\t\t{\n\t\t\t\t\tm_Mobile.Combatant = m_Mobile.FocusMob;\n\t\t\t\t\tm_Mobile.FocusMob = null;\n\t\t\t\t}\n\t\t\t\telse if (!m_Mobile.InRange(combatant, m_Mobile.RangePerception * 3))\n\t\t\t\t{\n\t\t\t\t\tm_Mobile.Combatant = null;\n\t\t\t\t}\n\n\t\t\t\tcombatant = m_Mobile.Combatant;\n\n\t\t\t\tif (combatant == null)\n\t\t\t\t{\n\t\t\t\t\tm_Mobile.DebugSay(\"My combatant has fled, so I am on guard\");\n\t\t\t\t\tAction = ActionType.Guard;\n\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/*if ( !m_Mobile.InLOS( combatant ) )\n            {\n            if ( AcquireFocusMob( m_Mobile.RangePerception, m_Mobile.FightMode, false, false, true ) )\n            {\n            m_Mobile.Combatant = combatant = m_Mobile.FocusMob;\n            m_Mobile.FocusMob = null;\n            }\n            }*/\n\n\t\t\tif (MoveTo(combatant, true, m_Mobile.RangeFight))\n\t\t\t{\n\t\t\t\tm_Mobile.Direction = m_Mobile.GetDirectionTo(combatant);\n\t\t\t}\n\t\t\telse if (AcquireFocusMob(m_Mobile.RangePerception, m_Mobile.FightMode, false, false, true))\n\t\t\t{\n\t\t\t\tif (m_Mobile.Debug)\n\t\t\t\t{\n\t\t\t\t\tm_Mobile.DebugSay(\"My move is blocked, so I am going to attack {0}\", m_Mobile.FocusMob.Name);\n\t\t\t\t}\n\n\t\t\t\tm_Mobile.Combatant = m_Mobile.FocusMob;\n\t\t\t\tAction = ActionType.Combat;\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (m_Mobile.GetDistanceToSqrt(combatant) > m_Mobile.RangePerception + 1)\n\t\t\t{\n\t\t\t\tif (m_Mobile.Debug)\n\t\t\t\t{\n\t\t\t\t\tm_Mobile.DebugSay(\"I cannot find {0}, so my guard is up\", combatant.Name);\n\t\t\t\t}\n\n\t\t\t\tAction = ActionType.Guard;\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (m_Mobile.Debug)\n\t\t\t\t{\n\t\t\t\t\tm_Mobile.DebugSay(\"I should be closer to {0}\", combatant.Name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!m_Mobile.Controlled && !m_Mobile.Summoned)\n\t\t\t{\n\t\t\t\tif (m_Mobile.Hits < m_Mobile.HitsMax * 20 / 100)\n\t\t\t\t{\n\t\t\t\t\t// We are low on health, should we flee?\n\t\t\t\t\tbool flee = false;\n\n\t\t\t\t\tif (m_Mobile.Hits < combatant.Hits)\n\t\t\t\t\t{\n\t\t\t\t\t\t// We are more hurt than them\n\t\t\t\t\t\tint diff = combatant.Hits - m_Mobile.Hits;\n\n\t\t\t\t\t\tflee = (Utility.Random(0, 100) < (10 + diff)); // (10 + diff)% chance to flee\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tflee = Utility.Random(0, 100) < 10; // 10% chance to flee\n\t\t\t\t\t}\n\n\t\t\t\t\tif (flee)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (m_Mobile.Debug)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_Mobile.DebugSay(\"I am going to flee from {0}\", combatant.Name);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tAction = ActionType.Flee;\n\n\t\t\t\t\t\tif (Utility.RandomDouble() < teleportChance + 0.1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tTryToTeleport();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}", "label": "ComplexMethod"}
{"text": "protected override void OnTick()\n\t\t\t{\n\t\t\t\tif (m_NextSkillTime != m_From.NextSkillTime || m_NextSpellTime != m_From.NextSpellTime ||\n\t\t\t\t\tm_NextActionTime != m_From.NextActionTime)\n\t\t\t\t{\n\t\t\t\t\tTerminate();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (m_LastMoveTime != m_From.LastMoveTime)\n\t\t\t\t{\n\t\t\t\t\tm_From.SendLocalizedMessage(503023);\n\t\t\t\t\t\t// You cannot move around while digging up treasure. You will need to start digging anew.\n\t\t\t\t\tTerminate();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tint z = (m_Chest != null) ? m_Chest.Z + m_Chest.ItemData.Height : int.MinValue;\n\t\t\t\tint height = 16;\n\n\t\t\t\tif (z > m_Location.Z)\n\t\t\t\t{\n\t\t\t\t\theight -= (z - m_Location.Z);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tz = m_Location.Z;\n\t\t\t\t}\n\n\t\t\t\tif (!m_Map.CanFit(m_Location.X, m_Location.Y, z, height, true, true, false))\n\t\t\t\t{\n\t\t\t\t\tm_From.SendLocalizedMessage(503024);\n\t\t\t\t\t\t// You stop digging because something is directly on top of the treasure chest.\n\t\t\t\t\tTerminate();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tm_Count++;\n\n\t\t\t\tm_From.RevealingAction();\n\t\t\t\tm_From.Direction = m_From.GetDirectionTo(m_Location);\n\n\t\t\t\tif (m_Count > 1 && m_Dirt1 == null)\n\t\t\t\t{\n\t\t\t\t\tm_Dirt1 = new TreasureChestDirt();\n\t\t\t\t\tm_Dirt1.MoveToWorld(m_Location, m_Map);\n\n\t\t\t\t\tm_Dirt2 = new TreasureChestDirt();\n\t\t\t\t\tm_Dirt2.MoveToWorld(new Point3D(m_Location.X, m_Location.Y - 1, m_Location.Z), m_Map);\n\t\t\t\t}\n\n\t\t\t\tif (m_Count == 5)\n\t\t\t\t{\n\t\t\t\t\tm_Dirt1.Turn1();\n\t\t\t\t}\n\t\t\t\telse if (m_Count == 10)\n\t\t\t\t{\n\t\t\t\t\tm_Dirt1.Turn2();\n\t\t\t\t\tm_Dirt2.Turn2();\n\t\t\t\t}\n\t\t\t\telse if (m_Count > 10)\n\t\t\t\t{\n\t\t\t\t\tif (m_Chest == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Chest = new TreasureMapChest(m_From, m_TreasureMap.Level, true);\n\t\t\t\t\t\tm_Chest.MoveToWorld(new Point3D(m_Location.X, m_Location.Y, m_Location.Z - 15), m_Map);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tm_Chest.Z++;\n\t\t\t\t\t}\n\n\t\t\t\t\tEffects.PlaySound(m_Chest, m_Map, 0x33B);\n\t\t\t\t}\n\n\t\t\t\tif (m_Chest != null && m_Chest.Location.Z >= m_Location.Z)\n\t\t\t\t{\n\t\t\t\t\tStop();\n\t\t\t\t\tm_From.EndAction(typeof(TreasureMap));\n\n\t\t\t\t\tm_Chest.Temporary = false;\n\t\t\t\t\tm_TreasureMap.Completed = true;\n\t\t\t\t\tm_TreasureMap.CompletedBy = m_From;\n\n\t\t\t\t\tint spawns;\n\t\t\t\t\tswitch (m_TreasureMap.Level)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tspawns = 3;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tspawns = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tspawns = 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (int i = 0; i < spawns; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t\tBaseCreature bc = Spawn(m_TreasureMap.Level, m_Chest.Location, m_Chest.Map, null, true);\n\n\t\t\t\t\t\tif (bc != null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_Chest.Guardians.Add(bc);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (m_From.Body.IsHuman && !m_From.Mounted)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_From.Animate(11, 5, 1, true, false, 0);\n\t\t\t\t\t}\n\n\t\t\t\t\tnew SoundTimer(m_From, 0x125 + (m_Count % 2)).Start();\n\t\t\t\t}\n\t\t\t}", "label": "ComplexMethod"}
{"text": "public override void Use(Player p, string message)\n        {\n\t\t\tmessage = message.ToLower ();\n            if (message == \"\") { Help(p); return; }\n            Player pl = Player.Find(message);\n            if (pl != null && !pl.hidden)\n            {\n                Player.SendMessage(p, pl.color + pl.name + Server.DefaultColor + \" is online, using /whois instead.\");\n                Command.all.Find(\"whois\").Use(p, message);\n                return;\n            }\n\n            if (message.IndexOf(\"'\") != -1) { Player.SendMessage(p, \"Cannot parse request.\"); return; }\n\n            string FoundRank = Group.findPlayer(message.ToLower());\n            if (!Load(message)) { Player.SendMessage(p, Group.Find(FoundRank).color + message + Server.DefaultColor + \" has the rank of \" + Group.Find(FoundRank).color + FoundRank); return; }\n\n            if (title == \"\" || title == null || String.IsNullOrEmpty(title))\n                Player.SendMessage(p, color + message + Server.DefaultColor + \" has :\");\n            else\n                Player.SendMessage(p, color + \"[\" + titlecolor + title + color + \"] \" + message + Server.DefaultColor + \" has :\");\n            Player.SendMessage(p, \"> > the rank of \" + Group.Find(FoundRank).color + FoundRank);\n            try\n            {\n                if (!Group.Find(\"Nobody\").commands.Contains(\"pay\") && !Group.Find(\"Nobody\").commands.Contains(\"give\") && !Group.Find(\"Nobody\").commands.Contains(\"take\")) Player.SendMessage(p, \"> > &a\" + money + Server.DefaultColor + \" \" + Server.moneys);\n            }\n            catch { }\n            Player.SendMessage(p, \"> > &cdied &a\" + overalldeaths + Server.DefaultColor + \" times\");\n            Player.SendMessage(p, \"> > &bmodified &a\" + overallblocks + \" &eblocks.\");\n            Player.SendMessage(p, \"> > was last seen on &a\" + lastlogin);\n            Player.SendMessage(p, \"> > first logged into the server on &a\" + firstlogin);\n            Player.SendMessage(p, \"> > logged in &a\" + totallogins + Server.DefaultColor + \" times, &c\" + totalkicks + Server.DefaultColor + \" of which ended in a kick.\");\n            Player.SendMessage(p, \"> > \" + Awards.awardAmount(message) + \" awards\");\n            if (Ban.Isbanned(message))\n            {\n                string[] data = Ban.Getbandata(message);\n                Player.SendMessage(p, \"> > was banned by \" + data[0] + \" for \" + data[1] + \" on \" + data[2]);\n            }\n\n            if (Server.Devs.Contains(message.ToLower()))\n            {\n                Player.SendMessage(p, Server.DefaultColor + \"> > Player is a &9Developer\");\n                if (Server.forgeProtection == ForgeProtection.Mod || Server.forgeProtection == ForgeProtection.Dev)\n                    Player.SendMessage(p, Server.DefaultColor + \"> > Player is &CPROTECTED\" + Server.DefaultColor + \" under MCForge Staff protection\");\n            }\n            else if (Server.Mods.Contains(message.ToLower()))\n            {\n                Player.SendMessage(p, Server.DefaultColor + \"> > Player is a &9MCForge Moderator\");\n                if (Server.forgeProtection == ForgeProtection.Mod)\n                    Player.SendMessage(p, Server.DefaultColor + \"> > Player is &CPROTECTED\" + Server.DefaultColor + \" under MCForge Staff protection\");\n            }\n            else if (Server.GCmods.Contains(message.ToLower()))\n                Player.SendMessage(p, Server.DefaultColor + \"> > Player is a &9Global Chat Moderator\");\n\n            if (!(p != null && (int)p.group.Permission <= CommandOtherPerms.GetPerm(this)))\n\t\t\t{\n                if (Server.useWhitelist)\n                {\n                    if (Server.whiteList.Contains(message.ToLower()))\n                    {\n                        Player.SendMessage(p, \"> > Player is &fWhitelisted\");\n                    }\n                }\n            }\n        }", "label": "ComplexMethod"}
{"text": "/// <summary>\n\t\t/// Returns an URL to entry thumbnail image, or placeholder if no image if specified.\n\t\t/// </summary>\n\t\t/// <param name=\"urlHelper\">URL helper. Cannot be null.</param>\n\t\t/// <param name=\"imageInfo\">Image information. Cannot be null.</param>\n\t\t/// <param name=\"size\">Requested image size.</param>\n\t\t/// <returns>URL to the image thumbnail (may be placeholder).</returns>\n\t\tpublic static string ImageThumb(this UrlHelper urlHelper, EntryThumbForApiContract imageInfo, ImageSize size) {\n\n\t\t\treturn imageInfo?.GetSmallestThumb(size).EmptyToNull() ?? GetUnknownImageUrl(urlHelper);\n\n\t\t}/// <summary>\n\t\t/// Returns an URL to entry thumbnail image.\n\t\t/// Currently only used for album and artist main images.\n\t\t/// \n\t\t/// Gets the URL to the static images folder on disk if possible,\n\t\t/// otherwise gets the image from the DB.\n\t\t/// </summary>\n\t\t/// <param name=\"urlHelper\">URL helper. Cannot be null.</param>\n\t\t/// <param name=\"imageInfo\">Image information. Cannot be null.</param>\n\t\t/// <param name=\"size\">Requested image size.</param>\n\t\t/// <param name=\"fullUrl\">\n\t\t/// Whether the URL should always include the hostname and application path root.\n\t\t/// If this is false (default), the URL maybe either full (such as http://vocadb.net/Album/CoverPicture/123)\n\t\t/// or relative (such as /Album/CoverPicture/123).\n\t\t/// Usually this should be set to true if the image is to be referred from another domain.\n\t\t/// </param>\n\t\t/// <returns>URL to the image thumbnail.</returns>\n\t\tpublic static string ImageThumb(this UrlHelper urlHelper, IEntryImageInformation imageInfo, ImageSize size, bool fullUrl = false) {\n\t\t\t\n\t\t\tif (imageInfo == null)\n\t\t\t\treturn null;\n\n\t\t\tvar shouldExist = ShouldExist(imageInfo);\n\t\t\tstring dynamicUrl = null;\n\n\t\t\t// Use MVC dynamic actions (instead of static file) when requesting original or an image that doesn't exist on disk.\n\t\t\tif (imageInfo.EntryType == EntryType.Album) {\n\n\t\t\t\tif (size == ImageSize.Original)\n\t\t\t\t\tdynamicUrl = urlHelper.Action(\"CoverPicture\", \"Album\", new { id = imageInfo.Id, v = imageInfo.Version });\n\t\t\t\telse if (shouldExist && !imagePersister.HasImage(imageInfo, size))\n\t\t\t\t\tdynamicUrl = urlHelper.Action(\"CoverPictureThumb\", \"Album\", new { id = imageInfo.Id, v = imageInfo.Version });\n\n\t\t\t} else if (imageInfo.EntryType == EntryType.Artist) {\n\t\t\t\t\n\t\t\t\tif (size == ImageSize.Original)\n\t\t\t\t\tdynamicUrl = urlHelper.Action(\"Picture\", \"Artist\", new { id = imageInfo.Id, v = imageInfo.Version });\n\t\t\t\telse if (shouldExist && !imagePersister.HasImage(imageInfo, size))\n\t\t\t\t\tdynamicUrl = urlHelper.Action(\"PictureThumb\", \"Artist\", new { id = imageInfo.Id, v = imageInfo.Version });\n\n\t\t\t}\n\n\t\t\tif (dynamicUrl != null) {\t\t\t\t\n\t\t\t\treturn fullUrl ? VocaUriBuilder.Absolute(dynamicUrl) : dynamicUrl;\n\t\t\t}\n\n\t\t\tif (!shouldExist) {\n\t\t\t\tvar unknown = GetUnknownImageUrl(urlHelper);\n\t\t\t\treturn fullUrl ? VocaUriBuilder.Absolute(unknown) : unknown;\n\t\t\t}\n\n\t\t\t// For all other cases use the static file\n\t\t\treturn imagePersister.GetUrlAbsolute(imageInfo, size);\n\n\t\t}", "label": "ComplexMethod"}
{"text": "public Unit GetNextTarget()\n        {\n            Unit Me = GetUnit();\n            Unit Target = null;\n\n            if (!Me.IsPlayer())\n            {\n                AggroInfo Info = GetMaxAggroHate(true);\n                if (Info == null)\n                    Info = GetMaxAggroHate(false);\n\n                if(Info != null)\n                    Target = _Owner.Region.GetObject(Info.Oid) as Unit;\n\n            }\n            else\n            {\n                Target = GetTarget(GameData.TargetTypes.TARGETTYPES_TARGET_ENEMY);\n            }\n\n            if (Target == null)\n                return null;\n\n            if (!Target.IsInWorld())\n                return null;\n\n            if (Target.IsDead)\n            {\n                if (AI.State == AiState.FIGHTING)\n                    OnTargetDie(Target);\n\n                return null;\n            }\n\n            return Target;\n        }", "label": "ComplexMethod"}
{"text": "public static VkGroup FromJson(JToken json)\n        {\n            if (json == null)\n                throw new ArgumentException(\"Json can not be null.\");\n\n            var result = new VkGroup();\n\n            result.Id = Math.Abs(json[\"id\"].Value<long>());\n            result.Name = WebUtility.HtmlDecode(json[\"name\"].Value<string>()).Trim();\n\n            if (json[\"photo_50\"] != null)\n                result.Photo = (string)json[\"photo_50\"];\n\n            if (json[\"photo_100\"] != null)\n                result.PhotoMedium = json[\"photo_100\"].Value<string>();\n\n            if (json[\"photo_200_orig\"] != null)\n                result.PhotoBig = json[\"photo_200_orig\"].Value<string>();\n\n            if (json[\"photo_200\"] != null)\n                result.PhotoBigSquare = json[\"photo_200\"].Value<string>();\n\n            if (json[\"photo_400_orig\"] != null)\n                result.PhotoLarge = json[\"photo_400_orig\"].Value<string>();\n\n            if (json[\"photo_max\"] != null)\n                result.PhotoMaxSquare = json[\"photo_max\"].Value<string>();\n\n            if (json[\"photo_max_orig\"] != null)\n                result.PhotoMax = json[\"photo_max_orig\"].Value<string>();\n\n            if (json[\"is_admin\"] != null)\n                result.IsAdmin = json[\"is_admin\"].Value<int>() == 1;\n\n            if (json[\"is_member\"] != null)\n                result.IsAdmin = json[\"is_member\"].Value<int>() == 1;\n\n            if (json[\"is_closed\"] != null)\n                result.IsClosed = json[\"is_closed\"].Value<int>() == 1;\n\n            if (json[\"type\"] != null)\n                result.Type = json[\"type\"].Value<string>();\n\n            return result;\n        }", "label": "ComplexMethod"}
{"text": "public override void Close(PdfWriter writer) {\n            CheckOutputIntentsInStamperMode(writer);\n                    if ((rgbUsed || cmykUsed || grayUsed) && pdfaOutputIntentColorSpace == null) {\n            throw new PdfAConformanceException(null, MessageLocalization.GetComposedMessage(\"if.device.rgb.cmyk.gray.used.in.file.that.file.shall.contain.pdfa.outputintent\"));\n        }\n\n            if (\"RGB \".Equals(pdfaOutputIntentColorSpace)) {\n                if (cmykUsed)\n                    throw new PdfAConformanceException(null,\n                        MessageLocalization.GetComposedMessage(\n                            \"devicecmyk.may.be.used.only.if.the.file.has.a.cmyk.pdfa.outputIntent\"));\n            } else if (\"CMYK\".Equals(pdfaOutputIntentColorSpace)) {\n                if (rgbUsed)\n                    throw new PdfAConformanceException(null,\n                        MessageLocalization.GetComposedMessage(\n                            \"devicergb.may.be.used.only.if.the.file.has.a.rgb.pdfa.outputIntent\"));\n            } else {\n                if (cmykUsed)\n                    throw new PdfAConformanceException(null,\n                        MessageLocalization.GetComposedMessage(\n                            \"devicecmyk.may.be.used.only.if.the.file.has.a.cmyk.pdfa.outputIntent\"));\n                if (rgbUsed)\n                    throw new PdfAConformanceException(null,\n                        MessageLocalization.GetComposedMessage(\n                            \"devicergb.may.be.used.only.if.the.file.has.a.rgb.pdfa.outputIntent\"));\n            }\n        }", "label": "ComplexMethod"}
{"text": "private bool ParsePostValue()\n        {\n            while (true)\n            {\n                char currentChar = _chars[_charPos];\n\n                switch (currentChar)\n                {\n                    case '\\0':\n                        if (_charsUsed == _charPos)\n                        {\n                            if (ReadData(false) == 0)\n                            {\n                                _currentState = State.Finished;\n                                return false;\n                            }\n                        }\n                        else\n                        {\n                            _charPos++;\n                        }\n                        break;\n                    case '}':\n                        _charPos++;\n                        SetToken(JsonToken.EndObject);\n                        return true;\n                    case ']':\n                        _charPos++;\n                        SetToken(JsonToken.EndArray);\n                        return true;\n                    case ')':\n                        _charPos++;\n                        SetToken(JsonToken.EndConstructor);\n                        return true;\n                    case '/':\n                        ParseComment();\n                        return true;\n                    case ',':\n                        _charPos++;\n\n                        // finished parsing\n                        SetStateBasedOnCurrent();\n                        return false;\n                    case ' ':\n                    case StringUtils.Tab:\n                        // eat\n                        _charPos++;\n                        break;\n                    case StringUtils.CarriageReturn:\n                        ProcessCarriageReturn(false);\n                        break;\n                    case StringUtils.LineFeed:\n                        ProcessLineFeed();\n                        break;\n                    default:\n                        if (char.IsWhiteSpace(currentChar))\n                        {\n                            // eat\n                            _charPos++;\n                        }\n                        else\n                        {\n                            throw JsonReaderException.Create(this, \"After parsing a value an unexpected character was encountered: {0}.\".FormatWith(CultureInfo.InvariantCulture, currentChar));\n                        }\n                        break;\n                }\n            }\n        }", "label": "ComplexMethod"}
{"text": "public virtual enHelperActivityType Process(ref Socket soUDP,\n            ref IPEndPoint remoteIpEndPoint, string sessionID, Encoding enc)\n        {\n            ProcessCommand(ref soUDP, ref remoteIpEndPoint, sessionID, enc);\n\n            // handle 555 BANNED and 598 - UNKNOWN COMMAND\n            switch (ResponseCode)\n            {\n                case 598: return enHelperActivityType.UnknownCommand_598;\n                case 555: return enHelperActivityType.Banned_555;\n            }\n\n            if (errorOccurred) return enHelperActivityType.NoSuchFile;\n\n            string sMsgType = socketResponse.Substring(0, 3);\n            switch (sMsgType)\n            {\n                case \"210\": return enHelperActivityType.FileMarkedAsDeleted;\n                case \"310\": return enHelperActivityType.FileMarkedAsDeleted;\n                case \"311\": return enHelperActivityType.FileMarkedAsDeleted;\n                case \"320\": return enHelperActivityType.NoSuchFile;\n                case \"411\": return enHelperActivityType.NoSuchFile;\n\n                case \"502\": return enHelperActivityType.LoginFailed;\n                case \"501\": return enHelperActivityType.LoginRequired;\n            }\n\n            return enHelperActivityType.FileDoesNotExist;\n        }", "label": "ComplexMethod"}
{"text": "public HouseListGump(int number, ArrayList list, BaseHouse house, bool accountOf)\n            : base(20, 30)\n        {\n            if (house.Deleted)\n                return;\n\n            m_House = house;\n\n            AddPage(0);\n\n            AddBackground(0, 0, 420, 430, 5054);\n            AddBackground(10, 10, 400, 410, 3000);\n\n            AddButton(20, 388, 4005, 4007, 0, GumpButtonType.Reply, 0);\n            AddHtmlLocalized(55, 388, 300, 20, 1011104, false, false); // Return to previous menu\n\n            AddHtmlLocalized(20, 20, 350, 20, number, false, false);\n\n            if (list != null)\n            {\n                for (int i = 0; i < list.Count; ++i)\n                {\n                    if ((i % 16) == 0)\n                    {\n                        if (i != 0)\n                        {\n                            // Next button\n                            AddButton(370, 20, 4005, 4007, 0, GumpButtonType.Page, (i / 16) + 1);\n                        }\n\n                        AddPage((i / 16) + 1);\n\n                        if (i != 0)\n                        {\n                            // Previous button\n                            AddButton(340, 20, 4014, 4016, 0, GumpButtonType.Page, i / 16);\n                        }\n                    }\n\n                    Mobile m = (Mobile)list[i];\n\n                    string name;\n\n                    if (m == null || (name = m.Name) == null || (name = name.Trim()).Length <= 0)\n                        continue;\n\n                    AddLabel(55, 55 + ((i % 16) * 20), 0, accountOf && m.Player && m.Account != null ? String.Format(\"Account of {0}\", name) : name);\n                }\n            }\n        }", "label": "ComplexMethod"}
{"text": "public void ValidateAndFillDetails()\n        {\n            if (IsNullOrEmpty(Title)) Title = $\"{FounderName}'s game\";\n            if (IsNullOrEmpty(EngineVersion) || (Mode != AutohostMode.None)) EngineVersion = server.Engine;\n            server.Downloader.GetResource(DownloadType.ENGINE, server.Engine);\n\n            switch (Mode)\n            {\n                case AutohostMode.Game1v1:\n                    MaxPlayers = 2;\n                    break;\n                case AutohostMode.Planetwars:\n                    if (MaxPlayers < 2) MaxPlayers = 16;\n                    break;\n                case AutohostMode.GameChickens:\n                    if (MaxPlayers < 2) MaxPlayers = 10;\n                    break;\n                case AutohostMode.GameFFA:\n                    if (MaxPlayers < 3) MaxPlayers = 16;\n                    break;\n                case AutohostMode.Teams:\n                    if (MaxPlayers < 4) MaxPlayers = 16;\n                    break;\n                case AutohostMode.None:\n                    if (MaxPlayers == 0) MaxPlayers = 16;\n                    break;\n            }\n            if (MaxPlayers > DynamicConfig.Instance.MaximumBattlePlayers && !IsAutohost) MaxPlayers = DynamicConfig.Instance.MaximumBattlePlayers;\n\n            HostedMod = MapPicker.FindResources(ResourceType.Mod, ModName ?? server.Game ?? GlobalConst.DefaultZkTag).FirstOrDefault();\n            HostedMap = MapName != null\n                ? MapPicker.FindResources(ResourceType.Map, MapName).FirstOrDefault()\n                : MapPicker.GetRecommendedMap(GetContext());\n\n            ModName = HostedMod?.InternalName ?? ModName ?? server.Game ?? GlobalConst.DefaultZkTag;\n            MapName = HostedMap?.InternalName ?? MapName ?? \"Small_Divide-Remake-v04\";\n\n            if (HostedMod != null)\n                try\n                {\n                    HostedModInfo = MetaDataCache.ServerGetMod(HostedMod.InternalName);\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceWarning(\"Error loading mod metadata for {0} : {1}\", HostedMod.InternalName, ex);\n                }\n        }", "label": "ComplexMethod"}
{"text": "public virtual byte[] Unwrap(\n\t\t\tbyte[]\tinBytes,\n\t\t\tint\t\tinOff,\n\t\t\tint\t\tinLen)\n\t\t{\n\t\t\tif (forWrapping)\n\t\t\t{\n\t\t\t\tthrow new InvalidOperationException(\"not set for unwrapping\");\n\t\t\t}\n\n\t\t\tint blockSize = engine.GetBlockSize();\n\n\t\t\tif (inLen < 2 * blockSize)\n\t\t\t{\n\t\t\t\tthrow new InvalidCipherTextException(\"input too short\");\n\t\t\t}\n\n\t\t\tbyte[] cekBlock = new byte[inLen];\n\t\t\tbyte[] iv = new byte[blockSize];\n\n\t\t\tArray.Copy(inBytes, inOff, cekBlock, 0, inLen);\n\t\t\tArray.Copy(inBytes, inOff, iv, 0, iv.Length);\n\n\t\t\tengine.Init(false, new ParametersWithIV(param.Parameters, iv));\n\n\t\t\tfor (int i = blockSize; i < cekBlock.Length; i += blockSize)\n\t\t\t{\n\t\t\t\tengine.ProcessBlock(cekBlock, i, cekBlock, i);    \n\t\t\t}\n\n\t\t\tArray.Copy(cekBlock, cekBlock.Length - iv.Length, iv, 0, iv.Length);\n\n\t\t\tengine.Init(false, new ParametersWithIV(param.Parameters, iv));\n\n\t\t\tengine.ProcessBlock(cekBlock, 0, cekBlock, 0);\n\n\t\t\tengine.Init(false, param);\n\n\t\t\tfor (int i = 0; i < cekBlock.Length; i += blockSize)\n\t\t\t{\n\t\t\t\tengine.ProcessBlock(cekBlock, i, cekBlock, i);\n\t\t\t}\n\n\t\t\tif ((cekBlock[0] & 0xff) > cekBlock.Length - 4)\n\t\t\t{\n\t\t\t\tthrow new InvalidCipherTextException(\"wrapped key corrupted\");\n\t\t\t}\n\n\t\t\tbyte[] key = new byte[cekBlock[0] & 0xff];\n\n\t\t\tArray.Copy(cekBlock, 4, key, 0, cekBlock[0]);\n\n\t\t\t// Note: Using constant time comparison\n\t\t\tint nonEqual = 0;\n\t\t\tfor (int i = 0; i != 3; i++)\n\t\t\t{\n\t\t\t\tbyte check = (byte)~cekBlock[1 + i];\n\t\t\t\tnonEqual |= (check ^ key[i]);\n\t\t\t}\n\n\t\t\tif (nonEqual != 0)\n\t\t\t\tthrow new InvalidCipherTextException(\"wrapped key fails checksum\");\n\n\t\t\treturn key;\n\t\t}", "label": "ComplexMethod"}
{"text": "private bool TryReadErrorDetail(out ODataErrorDetail detail)\n        {\n            Debug.Assert(\n                this.currentBufferedNode.NodeType == JsonNodeType.StartObject,\n                \"this.currentBufferedNode.NodeType == JsonNodeType.StartObject\");\n            Debug.Assert(this.parsingInStreamError, \"this.parsingInStreamError\");\n            this.AssertBuffering();\n\n            if (this.currentBufferedNode.NodeType != JsonNodeType.StartObject)\n            {\n                detail = null;\n                return false;\n            }\n\n            // {\n            ReadInternal();\n\n            detail = new ODataErrorDetail();\n\n            // we expect one of the supported properties for the value (or end-object)\n            var propertiesFoundBitmask = ODataJsonLightReaderUtils.ErrorPropertyBitMask.None;\n            while (this.currentBufferedNode.NodeType == JsonNodeType.Property)\n            {\n                var propertyName = (string)this.currentBufferedNode.Value;\n\n                switch (propertyName)\n                {\n                    case JsonConstants.ODataErrorCodeName:\n                        if (!ODataJsonLightReaderUtils.ErrorPropertyNotFound(\n                                ref propertiesFoundBitmask,\n                                ODataJsonLightReaderUtils.ErrorPropertyBitMask.Code))\n                        {\n                            return false;\n                        }\n\n                        string code;\n                        if (this.TryReadErrorStringPropertyValue(out code))\n                        {\n                            detail.ErrorCode = code;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                        break;\n\n                    case JsonConstants.ODataErrorTargetName:\n                        if (!ODataJsonLightReaderUtils.ErrorPropertyNotFound(\n                                ref propertiesFoundBitmask,\n                                ODataJsonLightReaderUtils.ErrorPropertyBitMask.Target))\n                        {\n                            return false;\n                        }\n\n                        string target;\n                        if (this.TryReadErrorStringPropertyValue(out target))\n                        {\n                            detail.Target = target;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                        break;\n\n                    case JsonConstants.ODataErrorMessageName:\n                        if (!ODataJsonLightReaderUtils.ErrorPropertyNotFound(\n                                ref propertiesFoundBitmask,\n                                ODataJsonLightReaderUtils.ErrorPropertyBitMask.MessageValue))\n                        {\n                            return false;\n                        }\n\n                        string message;\n                        if (this.TryReadErrorStringPropertyValue(out message))\n                        {\n                            detail.Message = message;\n                        }\n                        else\n                        {\n                            return false;\n                        }\n\n                        break;\n\n                    default:\n                        // if we find a non-supported property in an inner error, we skip it\n                        this.SkipValueInternal();\n                        break;\n                }\n\n                this.ReadInternal();\n            }\n\n            Debug.Assert(\n                this.currentBufferedNode.NodeType == JsonNodeType.EndObject,\n                \"this.currentBufferedNode.NodeType == JsonNodeType.EndObject\");\n\n            return true;\n        }", "label": "ComplexMethod"}
{"text": "public static string GetImagePath(ImageEntityType type, int id)\n        {\n            string path;\n\n            switch (type)\n            {\n                // 1\n                case ImageEntityType.AniDB_Cover:\n                    SVR_AniDB_Anime anime = RepoFactory.AniDB_Anime.GetByAnimeID(id);\n                    if (anime == null)\n                        return null;\n                    path = anime.PosterPath;\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n                // 4\n                case ImageEntityType.TvDB_Banner:\n                    TvDB_ImageWideBanner wideBanner = RepoFactory.TvDB_ImageWideBanner.GetByID(id);\n                    if (wideBanner == null)\n                        return null;\n                    path = wideBanner.GetFullImagePath();\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n\n                // 5\n                case ImageEntityType.TvDB_Cover:\n                    TvDB_ImagePoster poster = RepoFactory.TvDB_ImagePoster.GetByID(id);\n                    if (poster == null)\n                        return null;\n                    path = poster.GetFullImagePath();\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n\n                // 6\n                case ImageEntityType.TvDB_Episode:\n                    TvDB_Episode ep = RepoFactory.TvDB_Episode.GetByID(id);\n                    if (ep == null)\n                        return null;\n                    path = ep.GetFullImagePath();\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n\n                // 7\n                case ImageEntityType.TvDB_FanArt:\n                    TvDB_ImageFanart fanart = RepoFactory.TvDB_ImageFanart.GetByID(id);\n                    if (fanart == null)\n                        return null;\n                    path = fanart.GetFullImagePath();\n                    if (File.Exists(path))\n                        return path;\n\n                    path = string.Empty;\n                    break;\n\n                // 8\n                case ImageEntityType.MovieDB_FanArt:\n                    MovieDB_Fanart mFanart = RepoFactory.MovieDB_Fanart.GetByID(id);\n                    if (mFanart == null)\n                        return null;\n                    mFanart = RepoFactory.MovieDB_Fanart.GetByOnlineID(mFanart.URL);\n                    if (mFanart == null)\n                        return null;\n                    path = mFanart.GetFullImagePath();\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n\n                // 9\n                case ImageEntityType.MovieDB_Poster:\n                    MovieDB_Poster mPoster = RepoFactory.MovieDB_Poster.GetByID(id);\n                    if (mPoster == null)\n                        return null;\n                    mPoster = RepoFactory.MovieDB_Poster.GetByOnlineID(mPoster.URL);\n                    if (mPoster == null)\n                        return null;\n                    path = mPoster.GetFullImagePath();\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n\n                case ImageEntityType.Character:\n                    AnimeCharacter character = RepoFactory.AnimeCharacter.GetByID(id);\n                    if (character == null)\n                        return null;\n                    path = ImageUtils.GetBaseAniDBCharacterImagesPath() + Path.DirectorySeparatorChar + character.ImagePath;\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n\n                case ImageEntityType.Staff:\n                    var staff = RepoFactory.AnimeStaff.GetByID(id);\n                    if (staff == null)\n                        return null;\n                    path = ImageUtils.GetBaseAniDBCreatorImagesPath() + Path.DirectorySeparatorChar + staff.ImagePath;\n                    if (File.Exists(path))\n                    {\n                        return path;\n                    }\n                    else\n                    {\n                        path = string.Empty;\n                    }\n                    break;\n\n                default:\n                    path = string.Empty;\n                    break;\n            }\n\n            return path;\n        }", "label": "ComplexMethod"}
{"text": "private void UpdateStatusChanged(object sender, EventArgs e)\n\t\t{\n\t\t\tswitch (UpdateControlData.Instance.UpdateStatus)\n\t\t\t{\n\t\t\t\tcase UpdateControlData.UpdateStatusStates.MayBeAvailable:\n\t\t\t\t\tupdateStatusText.Text = \"New updates may be available\".Localize();\n\t\t\t\t\tcheckUpdateButton.Visible = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UpdateControlData.UpdateStatusStates.CheckingForUpdate:\n\t\t\t\t\tupdateStatusText.Text = \"Checking for updates...\".Localize();\n\t\t\t\t\t//checkUpdateLink.Visible = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UpdateControlData.UpdateStatusStates.UnableToConnectToServer:\n\t\t\t\t\tupdateStatusText.Text = \"Oops! Unable to connect to server\".Localize();\n\t\t\t\t\tdownloadButton.Visible = false;\n\t\t\t\t\tinstallButton.Visible = false;\n\t\t\t\t\tcheckUpdateButton.Visible = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UpdateControlData.UpdateStatusStates.UpdateAvailable:\n\t\t\t\t\tif (UpdateControlData.Instance.UpdateRequired)\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateStatusText.Text = requiredUpdateAvailable;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tupdateStatusText.Text = recommendedUpdateAvailable;\n\t\t\t\t\t}\n\t\t\t\t\tdownloadButton.Visible = true;\n\t\t\t\t\tinstallButton.Visible = false;\n\t\t\t\t\tcheckUpdateButton.Visible = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UpdateControlData.UpdateStatusStates.UpdateDownloading:\n\t\t\t\t\tupdateStatusText.Text = string.Format(\n\t\t\t\t\t\t\"{0} {1}%\",\n\t\t\t\t\t\t\"Downloading updates...\".Localize(),\n\t\t\t\t\t\tUpdateControlData.Instance.DownloadPercent);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UpdateControlData.UpdateStatusStates.ReadyToInstall:\n\t\t\t\t\tupdateStatusText.Text = \"New updates are ready to install\".Localize();\n\t\t\t\t\tdownloadButton.Visible = false;\n\t\t\t\t\tinstallButton.Visible = true;\n\t\t\t\t\tcheckUpdateButton.Visible = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase UpdateControlData.UpdateStatusStates.UpToDate:\n\t\t\t\t\tupdateStatusText.Text = \"Your application is up-to-date\".Localize();\n\t\t\t\t\tdownloadButton.Visible = false;\n\t\t\t\t\tinstallButton.Visible = false;\n\t\t\t\t\tcheckUpdateButton.Visible = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new NotImplementedException();\n\t\t\t}\n\t\t}", "label": "ComplexMethod"}
{"text": "private void SetClickAction()\n        {\n            switch (CursorPosition())\n            {\n                case CursPos.BottomLine:\n                    CurrentAction = ClickAction.BottomSizing;\n                    break;\n\n                case CursPos.TopLine:\n                    CurrentAction = ClickAction.TopSizing;\n                    break;\n\n                case CursPos.LeftLine:\n                    CurrentAction = ClickAction.LeftSizing;\n                    break;\n\n                case CursPos.TopLeft:\n                    CurrentAction = ClickAction.TopLeftSizing;\n                    break;\n\n                case CursPos.BottomLeft:\n                    CurrentAction = ClickAction.BottomLeftSizing;\n                    break;\n\n                case CursPos.RightLine:\n                    CurrentAction = ClickAction.RightSizing;\n                    break;\n\n                case CursPos.TopRight:\n                    CurrentAction = ClickAction.TopRightSizing;\n                    break;\n\n                case CursPos.BottomRight:\n                    CurrentAction = ClickAction.BottomRightSizing;\n                    break;\n\n                case CursPos.WithinSelectionArea:\n                    CurrentAction = ClickAction.Dragging;\n                    break;\n\n                case CursPos.OutsideSelectionArea:\n                    CurrentAction = ClickAction.Outside;\n                    break;\n            }\n        }", "label": "ComplexMethod"}
{"text": "private static void CreateRow(JsonReader reader, DataTable dt)\n        {\n            DataRow dr = dt.NewRow();\n            CheckedRead(reader);\n\n            while (reader.TokenType == JsonToken.PropertyName)\n            {\n                string columnName = (string)reader.Value;\n\n                CheckedRead(reader);\n\n                DataColumn column = dt.Columns[columnName];\n                if (column == null)\n                {\n                    Type columnType = GetColumnDataType(reader);\n                    column = new DataColumn(columnName, columnType);\n                    dt.Columns.Add(column);\n                }\n\n                if (column.DataType == typeof(DataTable))\n                {\n                    if (reader.TokenType == JsonToken.StartArray)\n                        CheckedRead(reader);\n\n                    DataTable nestedDt = new DataTable();\n\n                    while (reader.TokenType != JsonToken.EndArray)\n                    {\n                        CreateRow(reader, nestedDt);\n\n                        CheckedRead(reader);\n                    }\n\n                    dr[columnName] = nestedDt;\n                }\n                else if (column.DataType.IsArray && column.DataType != typeof(byte[]))\n                {\n                    if (reader.TokenType == JsonToken.StartArray)\n                        CheckedRead(reader);\n\n                    List<object> o = new List<object>();\n\n                    while (reader.TokenType != JsonToken.EndArray)\n                    {\n                        o.Add(reader.Value);\n                        CheckedRead(reader);\n                    }\n\n                    Array destinationArray = Array.CreateInstance(column.DataType.GetElementType(), o.Count);\n                    Array.Copy(o.ToArray(), destinationArray, o.Count);\n\n                    dr[columnName] = destinationArray;\n                }\n                else\n                {\n                    dr[columnName] = reader.Value ?? DBNull.Value;\n                }\n\n                CheckedRead(reader);\n            }\n\n            dr.EndEdit();\n            dt.Rows.Add(dr);\n        }", "label": "ComplexMethod"}
{"text": "public static void IncreaseStat(Mobile from, Stat stat, bool atrophy)\n        {\n            atrophy = atrophy || (from.RawStatTotal >= from.StatCap);\n\n            switch ( stat )\n            {\n                case Stat.Str:\n                    {\n                        if (atrophy)\n                        {\n                            if (CanLower(from, Stat.Dex) && (from.RawDex < from.RawInt || !CanLower(from, Stat.Int)))\n                                --from.RawDex;\n                            else if (CanLower(from, Stat.Int))\n                                --from.RawInt;\n                        }\n\n                        if (CanRaise(from, Stat.Str))\n                            ++from.RawStr;\n\n                        break;\n                    }\n                case Stat.Dex:\n                    {\n                        if (atrophy)\n                        {\n                            if (CanLower(from, Stat.Str) && (from.RawStr < from.RawInt || !CanLower(from, Stat.Int)))\n                                --from.RawStr;\n                            else if (CanLower(from, Stat.Int))\n                                --from.RawInt;\n                        }\n\n                        if (CanRaise(from, Stat.Dex))\n                            ++from.RawDex;\n\n                        break;\n                    }\n                case Stat.Int:\n                    {\n                        if (atrophy)\n                        {\n                            if (CanLower(from, Stat.Str) && (from.RawStr < from.RawDex || !CanLower(from, Stat.Dex)))\n                                --from.RawStr;\n                            else if (CanLower(from, Stat.Dex))\n                                --from.RawDex;\n                        }\n\n                        if (CanRaise(from, Stat.Int))\n                            ++from.RawInt;\n\n                        break;\n                    }\n            }\n        }", "label": "ComplexMethod"}
{"text": "internal static bool TryFindCommonPrefix(IEnumerable<string> collection, bool ignoreCase, char separatorChar, out string commonPrefix) {\n         Debug.Assert(collection != null);\n         commonPrefix = null;\n         var array = collection.ToArray();\n         if (array.Length == 0) {\n            return false;\n         }\n\n         // If the list contains a path null -> no common commonPrefix\n         foreach (var str in array) { \n            if (str == null || str.Length == 0) {\n               return false;\n            }\n         }\n\n         var firstStr = array[0];\n\n         //\n         //  Case where all paths are identical\n         //  or where only one path\n         //\n         bool allStringsAreIdentical = true;\n         foreach (var str in array) {\n            if (string.Compare(firstStr, str, ignoreCase) != 0) {\n               allStringsAreIdentical = false;\n               break;\n            }\n         }\n         if (allStringsAreIdentical) {\n            commonPrefix = firstStr;\n            return true;\n         }\n\n         //\n         //  Build listOfSplittedPaths\n         //\n         var listOfSplittedStrings = new List<string[]>();\n         int maxDeep = int.MaxValue;\n         foreach (var str in array) {\n            string[] strSplitted = str.Split(new[] { separatorChar });\n            if (strSplitted.Length < maxDeep) {\n               maxDeep = strSplitted.Length;\n            }\n            listOfSplittedStrings.Add(strSplitted);\n         }\n         Debug.Assert(maxDeep >= 1);\n\n         //\n         // Compute prefixSb!\n         //\n         var prefixSb = new StringBuilder();\n         for (int i = 0; i < maxDeep; i++) {\n            string current = listOfSplittedStrings[0][i];\n            foreach (string[] strSplitted in listOfSplittedStrings) {\n               if (string.Compare(strSplitted[i], current, ignoreCase) != 0) {\n                  // i==0 means that we have no common commonPrefix!!\n                  if (i == 0) { return false; }\n                  goto DONE_OK;\n               }\n            }\n            if (i > 0) {\n               prefixSb.Append(separatorChar);\n            }\n            prefixSb.Append(current);\n         }\nDONE_OK:\n         Debug.Assert(prefixSb.Length > 0);\n         commonPrefix = prefixSb.ToString();\n         return true;\n      }", "label": "ComplexMethod"}
{"text": "public void Read (TProtocol iprot)\n    {\n      TField field;\n      iprot.ReadStructBegin();\n      while (true)\n      {\n        field = iprot.ReadFieldBegin();\n        if (field.Type == TType.Stop) { \n          break;\n        }\n        switch (field.ID)\n        {\n          case 1:\n            if (field.Type == TType.Bool) {\n              HasNext = iprot.ReadBool();\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          case 4:\n            if (field.Type == TType.I64) {\n              BannerSequence = iprot.ReadI64();\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          case 5:\n            if (field.Type == TType.I32) {\n              BannerTargetType = (ProductBannerLinkType)iprot.ReadI32();\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          case 6:\n            if (field.Type == TType.String) {\n              BannerTargetPath = iprot.ReadString();\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          case 7:\n            if (field.Type == TType.List) {\n              {\n                ProductList_ = new List<Product>();\n                TList _list34 = iprot.ReadListBegin();\n                for( int _i35 = 0; _i35 < _list34.Count; ++_i35)\n                {\n                  Product _elem36 = new Product();\n                  _elem36 = new Product();\n                  _elem36.Read(iprot);\n                  ProductList_.Add(_elem36);\n                }\n                iprot.ReadListEnd();\n              }\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          case 8:\n            if (field.Type == TType.String) {\n              BannerLang = iprot.ReadString();\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          default: \n            TProtocolUtil.Skip(iprot, field.Type);\n            break;\n        }\n        iprot.ReadFieldEnd();\n      }\n      iprot.ReadStructEnd();\n    }", "label": "ComplexMethod"}
{"text": "private void ParseSubscriptionResults(byte[][] multiBytes)\n        {\n            int componentsPerMsg = IsPSubscription ? 4 : 3;\n            for (var i = 0; i < multiBytes.Length; i += componentsPerMsg)\n            {\n                var messageType = multiBytes[i];\n                var channel = multiBytes[i + 1].FromUtf8Bytes();\n                if (SubscribeWord.AreEqual(messageType)\n                    || PSubscribeWord.AreEqual(messageType))\n                {\n                    IsPSubscription = PSubscribeWord.AreEqual(messageType);\n\n                    this.SubscriptionCount = int.Parse(multiBytes[i + MsgIndex].FromUtf8Bytes());\n\n                    activeChannels.Add(channel);\n\n                    if (this.OnSubscribe != null)\n                    {\n                        this.OnSubscribe(channel);\n                    }\n                }\n                else if (UnSubscribeWord.AreEqual(messageType)\n                    || PUnSubscribeWord.AreEqual(messageType))\n                {\n                    this.SubscriptionCount = int.Parse(multiBytes[i + 2].FromUtf8Bytes());\n\n                    activeChannels.Remove(channel);\n\n                    if (this.OnUnSubscribe != null)\n                    {\n                        this.OnUnSubscribe(channel);\n                    }\n                }\n                else if (MessageWord.AreEqual(messageType))\n                {\n                    var message = multiBytes[i + MsgIndex].FromUtf8Bytes();\n\n                    if (this.OnMessage != null)\n                    {\n                        this.OnMessage(channel, message);\n                    }\n                }\n                else if (PMessageWord.AreEqual(messageType))\n                {\n                    var message = multiBytes[i + MsgIndex + 1].FromUtf8Bytes();\n                    channel = multiBytes[i + 2].FromUtf8Bytes();\n                    if (this.OnMessage != null)\n                    {\n                        this.OnMessage(channel, message);\n                    }\n                }\n                else\n                {\n                    throw new RedisException(\n                        \"Invalid state. Expected [[p]subscribe|[p]unsubscribe|message] got: \" + messageType.FromUtf8Bytes());\n                }\n            }\n        }", "label": "ComplexMethod"}
{"text": "public async Task<bool> TryToSuspectOrKill(SiloAddress silo)\n        {\n            var table = await membershipTableProvider.ReadAll();\n\n            if (log.IsEnabled(LogLevel.Debug)) log.Debug(\"-TryToSuspectOrKill: Read Membership table {0}\", table.ToString());\n\n            if (this.IsStopping)\n            {\n                this.log.LogInformation(\n                    (int)ErrorCode.MembershipFoundMyselfDead3,\n                    \"Ignoring call to TrySuspectOrKill for silo {Silo} since the local silo is dead\",\n                    silo);\n                return true;\n            }\n\n            var (localSiloEntry, _) = this.GetOrCreateLocalSiloEntry(table, this.CurrentStatus);\n            if (localSiloEntry.Status == SiloStatus.Dead)\n            {\n                var msg = string.Format(\"I should be Dead according to membership table (in TryToSuspectOrKill): entry = {0}.\", localSiloEntry.ToFullString(full: true));\n                log.Warn(ErrorCode.MembershipFoundMyselfDead3, msg);\n                KillMyselfLocally(msg);\n                return true;\n            }\n\n            if (!table.Contains(silo))\n            {\n                // this should not happen ...\n                var str = string.Format(\"-Could not find silo entry for silo {0} in the table.\", silo);\n                log.Error(ErrorCode.MembershipFailedToReadSilo, str);\n                throw new KeyNotFoundException(str);\n            }\n\n            var tuple = table.Get(silo);\n            var entry = tuple.Item1.Copy();\n            string eTag = tuple.Item2;\n            if (log.IsEnabled(LogLevel.Debug)) log.Debug(\"-TryToSuspectOrKill {siloAddress}: The current status of {siloAddress} in the table is {status}, its entry is {entry}\",\n                entry.SiloAddress, // First\n                entry.SiloAddress, // Second\n                entry.Status, \n                entry.ToFullString());\n            // check if the table already knows that this silo is dead\n            if (entry.Status == SiloStatus.Dead)\n            {\n                this.ProcessTableUpdate(table, \"TrySuspectOrKill\");\n                return true;\n            }\n\n            var allVotes = entry.SuspectTimes ?? new List<Tuple<SiloAddress, DateTime>>();\n\n            // get all valid (non-expired) votes\n            var freshVotes = entry.GetFreshVotes(DateTime.UtcNow, this.clusterMembershipOptions.DeathVoteExpirationTimeout);\n\n            if (log.IsEnabled(LogLevel.Trace)) log.Trace(\"-Current number of fresh Voters for {0} is {1}\", silo, freshVotes.Count.ToString());\n\n            if (freshVotes.Count >= this.clusterMembershipOptions.NumVotesForDeathDeclaration)\n            {\n                // this should not happen ...\n                var str = string.Format(\"-Silo {0} is suspected by {1} which is more or equal than {2}, but is not marked as dead. This is a bug!!!\",\n                    entry.SiloAddress, freshVotes.Count.ToString(), this.clusterMembershipOptions.NumVotesForDeathDeclaration.ToString());\n                log.Error(ErrorCode.Runtime_Error_100053, str);\n                KillMyselfLocally(\"Found a bug! Will stop.\");\n                return false;\n            }\n\n            // handle the corner case when the number of active silos is very small (then my only vote is enough)\n            int activeSilos = table.GetSiloStatuses(status => status == SiloStatus.Active, true, this.localSiloDetails.SiloAddress).Count;\n            // find if I have already voted\n            int myVoteIndex = freshVotes.FindIndex(voter => myAddress.Equals(voter.Item1));\n\n            // Try to kill:\n            //  if there is NumVotesForDeathDeclaration votes (including me) to kill - kill.\n            //  otherwise, if there is a majority of nodes (including me) voting to kill \u2013 kill.\n            bool declareDead = false;\n            int myAdditionalVote = myVoteIndex == -1 ? 1 : 0;\n\n            if (freshVotes.Count + myAdditionalVote >= this.clusterMembershipOptions.NumVotesForDeathDeclaration)\n                declareDead = true;\n            \n            if (freshVotes.Count + myAdditionalVote >= (activeSilos + 1) / 2)\n                declareDead = true;\n            \n            if (declareDead)\n            {\n                // kick this silo off\n                log.Info(ErrorCode.MembershipMarkingAsDead, \n                    \"-Going to mark silo {0} as DEAD in the table #1. I am the last voter: #freshVotes={1}, myVoteIndex = {2}, NumVotesForDeathDeclaration={3} , #activeSilos={4}, suspect list={5}\",\n                            entry.SiloAddress, \n                            freshVotes.Count, \n                            myVoteIndex,\n                            this.clusterMembershipOptions.NumVotesForDeathDeclaration, \n                            activeSilos, \n                            PrintSuspectList(allVotes));\n                return await DeclareDead(entry, eTag, table.Version);\n            }\n\n            // we still do not have enough votes - need to vote                             \n            // find voting place:\n            //      update my vote, if I voted previously\n            //      OR if the list is not full - just add a new vote\n            //      OR overwrite the oldest entry.\n            int indexToWrite = allVotes.FindIndex(voter => myAddress.Equals(voter.Item1));\n            if (indexToWrite == -1)\n            {\n                // My vote is not recorded. Find the most outdated vote if the list is full, and overwrite it\n                if (allVotes.Count >= this.clusterMembershipOptions.NumVotesForDeathDeclaration) // if the list is full\n                {\n                    // The list is full.\n                    DateTime minVoteTime = allVotes.Min(voter => voter.Item2); // pick the most outdated vote\n                    indexToWrite = allVotes.FindIndex(voter => voter.Item2.Equals(minVoteTime));\n                }\n            }\n\n            var prevList = allVotes.ToList(); // take a copy\n            var now = DateTime.UtcNow;\n            if (indexToWrite == -1)\n            {\n                // if did not find specific place to write (the list is not full), just add a new element to the list\n                entry.AddSuspector(myAddress, now);\n            }\n            else\n            {\n                var newEntry = new Tuple<SiloAddress, DateTime>(myAddress, now);\n                entry.SuspectTimes[indexToWrite] = newEntry;\n            }\n            log.Info(ErrorCode.MembershipVotingForKill,\n                \"-Putting my vote to mark silo {0} as DEAD #2. Previous suspect list is {1}, trying to update to {2}, eTag={3}, freshVotes is {4}\",\n                entry.SiloAddress, \n                PrintSuspectList(prevList), \n                PrintSuspectList(entry.SuspectTimes),\n                eTag,\n                PrintSuspectList(freshVotes));\n\n            // If we fail to update here we will retry later.\n            return await membershipTableProvider.UpdateRow(entry, eTag, table.Version.Next());\n\n            string PrintSuspectList(IEnumerable<Tuple<SiloAddress, DateTime>> list)\n            {\n                return Utils.EnumerableToString(list, t => string.Format(\"<{0}, {1}>\",\n                    t.Item1, LogFormatter.PrintDate(t.Item2)));\n            }\n        }", "label": "ComplexMethod"}
{"text": "private object ReadStringValue(ReadType readType)\n        {\n            EnsureBuffer();\n\n            switch (_currentState)\n            {\n                case State.PostValue:\n                    if (ParsePostValue(true))\n                    {\n                        return null;\n                    }\n                    goto case State.Start;\n                case State.Start:\n                case State.Property:\n                case State.Array:\n                case State.ArrayStart:\n                case State.Constructor:\n                case State.ConstructorStart:\n                    while (true)\n                    {\n                        char currentChar = _chars[_charPos];\n\n                        switch (currentChar)\n                        {\n                            case '\\0':\n                                if (ReadNullChar())\n                                {\n                                    SetToken(JsonToken.None, null, false);\n                                    return null;\n                                }\n                                break;\n                            case '\"':\n                            case '\\'':\n                                ParseString(currentChar, readType);\n                                return FinishReadQuotedStringValue(readType);\n                            case '-':\n                                if (EnsureChars(1, true) && _chars[_charPos + 1] == 'I')\n                                {\n                                    return ParseNumberNegativeInfinity(readType);\n                                }\n                                else\n                                {\n                                    ParseNumber(readType);\n                                    return Value;\n                                }\n                            case '.':\n                            case '0':\n                            case '1':\n                            case '2':\n                            case '3':\n                            case '4':\n                            case '5':\n                            case '6':\n                            case '7':\n                            case '8':\n                            case '9':\n                                if (readType != ReadType.ReadAsString)\n                                {\n                                    _charPos++;\n                                    throw CreateUnexpectedCharacterException(currentChar);\n                                }\n                                ParseNumber(ReadType.ReadAsString);\n                                return Value;\n                            case 't':\n                            case 'f':\n                                if (readType != ReadType.ReadAsString)\n                                {\n                                    _charPos++;\n                                    throw CreateUnexpectedCharacterException(currentChar);\n                                }\n                                string expected = currentChar == 't' ? JsonConvert.True : JsonConvert.False;\n                                if (!MatchValueWithTrailingSeparator(expected))\n                                {\n                                    throw CreateUnexpectedCharacterException(_chars[_charPos]);\n                                }\n                                SetToken(JsonToken.String, expected);\n                                return expected;\n                            case 'I':\n                                return ParseNumberPositiveInfinity(readType);\n                            case 'N':\n                                return ParseNumberNaN(readType);\n                            case 'n':\n                                HandleNull();\n                                return null;\n                            case '/':\n                                ParseComment(false);\n                                break;\n                            case ',':\n                                ProcessValueComma();\n                                break;\n                            case ']':\n                                _charPos++;\n                                if (_currentState == State.Array || _currentState == State.ArrayStart || _currentState == State.PostValue)\n                                {\n                                    SetToken(JsonToken.EndArray);\n                                    return null;\n                                }\n                                throw CreateUnexpectedCharacterException(currentChar);\n                            case StringUtils.CarriageReturn:\n                                ProcessCarriageReturn(false);\n                                break;\n                            case StringUtils.LineFeed:\n                                ProcessLineFeed();\n                                break;\n                            case ' ':\n                            case StringUtils.Tab:\n                                // eat\n                                _charPos++;\n                                break;\n                            default:\n                                _charPos++;\n\n                                if (!char.IsWhiteSpace(currentChar))\n                                {\n                                    throw CreateUnexpectedCharacterException(currentChar);\n                                }\n\n                                // eat\n                                break;\n                        }\n                    }\n                case State.Finished:\n                    ReadFinished();\n                    return null;\n                default:\n                    throw JsonReaderException.Create(this, \"Unexpected state: {0}.\".FormatWith(CultureInfo.InvariantCulture, CurrentState));\n            }\n        }", "label": "ComplexMethod"}
{"text": "/// <summary>\n        /// See <see cref=\"IByteProvider.WriteByte\" /> for more information.\n        /// </summary>\n        public void WriteByte(long index, byte value)\n        {\n            try\n            {\n                // Find the block affected.\n                long blockOffset;\n                DataBlock block = GetDataBlock(index, out blockOffset);\n\n                // If the byte is already in a memory block, modify it.\n                MemoryDataBlock memoryBlock = block as MemoryDataBlock;\n                if (memoryBlock != null)\n                {\n                    memoryBlock.Data[index - blockOffset] = value;\n                    return;\n                }\n\n                FileDataBlock fileBlock = (FileDataBlock)block;\n\n                // If the byte changing is the first byte in the block and the previous block is a memory block, extend that.\n                if (blockOffset == index && block.PreviousBlock != null)\n                {\n                    MemoryDataBlock previousMemoryBlock = block.PreviousBlock as MemoryDataBlock;\n                    if (previousMemoryBlock != null)\n                    {\n                        previousMemoryBlock.AddByteToEnd(value);\n                        fileBlock.RemoveBytesFromStart(1);\n                        if (fileBlock.Length == 0)\n                        {\n                            _dataMap.Remove(fileBlock);\n                        }\n                        return;\n                    }\n                }\n\n                // If the byte changing is the last byte in the block and the next block is a memory block, extend that.\n                if (blockOffset + fileBlock.Length - 1 == index && block.NextBlock != null)\n                {\n                    MemoryDataBlock nextMemoryBlock = block.NextBlock as MemoryDataBlock;\n                    if (nextMemoryBlock != null)\n                    {\n                        nextMemoryBlock.AddByteToStart(value);\n                        fileBlock.RemoveBytesFromEnd(1);\n                        if (fileBlock.Length == 0)\n                        {\n                            _dataMap.Remove(fileBlock);\n                        }\n                        return;\n                    }\n                }\n\n                // Split the block into a prefix and a suffix and place a memory block in-between.\n                FileDataBlock prefixBlock = null;\n                if (index > blockOffset)\n                {\n                    prefixBlock = new FileDataBlock(fileBlock.FileOffset, index - blockOffset);\n                }\n\n                FileDataBlock suffixBlock = null;\n                if (index < blockOffset + fileBlock.Length - 1)\n                {\n                    suffixBlock = new FileDataBlock(\n                        fileBlock.FileOffset + index - blockOffset + 1,\n                        fileBlock.Length - (index - blockOffset + 1));\n                }\n\n\t\t\t\tblock = _dataMap.Replace(block, new MemoryDataBlock(value));\n\n                if (prefixBlock != null)\n                {\n                    _dataMap.AddBefore(block, prefixBlock);\n                }\n\n                if (suffixBlock != null)\n                {\n                    _dataMap.AddAfter(block, suffixBlock);\n                }\n            }\n            finally\n            {\n                OnChanged(EventArgs.Empty);\n            }\n        }", "label": "ComplexMethod"}
{"text": "/// <summary>\n        /// Renders the template.\n        /// </summary>\n        /// <param name=\"template\">The template.</param>\n        /// <param name=\"additionalMergeObjects\">Any additional merge objects as a comma-delimited-list of EntityTypeId|MergeKey|EntityId</param>\n        /// <returns></returns>\n        [System.Web.Http.Route( \"api/Lava/RenderTemplate\" )]\n        [HttpPost]\n        [Authenticate, Secured]\n        public string RenderTemplate( [NakedBody] string template, [FromUri] string additionalMergeObjects = null )\n        {\n            Rock.Lava.CommonMergeFieldsOptions lavaOptions = new Lava.CommonMergeFieldsOptions();\n            lavaOptions.GetPageContext = false;\n            lavaOptions.GetPageParameters = false;\n            lavaOptions.GetCurrentPerson = true;\n            lavaOptions.GetCampuses = true;\n            lavaOptions.GetLegacyGlobalMergeFields = false;\n            var currentPerson = GetPerson();\n\n            Dictionary<string, object> mergeFields = Rock.Lava.LavaHelper.GetCommonMergeFields( null, currentPerson, lavaOptions );\n\n            if ( additionalMergeObjects != null )\n            {\n                var additionalMergeObjectList = additionalMergeObjects.Split( ',' ).Select( a => a.Split( '|' ) ).Where( a => a.Length == 3 ).Select( a => new\n                {\n                    EntityTypeId = a[0].AsInteger(),\n                    MergeKey = a[1],\n                    EntityId = a[2].AsInteger()\n                } ).ToList();\n\n                foreach ( var additionalMergeObject in additionalMergeObjectList )\n                {\n                    var entityTypeType = EntityTypeCache.Get( additionalMergeObject.EntityTypeId )?.GetEntityType();\n                    if ( entityTypeType != null )\n                    {\n                        var dbContext = Rock.Reflection.GetDbContextForEntityType( entityTypeType );\n                        var serviceInstance = Rock.Reflection.GetServiceForEntityType( entityTypeType, dbContext );\n                        if ( serviceInstance != null )\n                        {\n                            System.Reflection.MethodInfo getMethod = serviceInstance.GetType().GetMethod( \"Get\", new Type[] { typeof( int ) } );\n                            var mergeObjectEntity = getMethod.Invoke( serviceInstance, new object[] { additionalMergeObject.EntityId } ) as Rock.Data.IEntity;\n\n                            if ( mergeObjectEntity != null )\n                            {\n                                bool canView = true;\n                                if ( mergeObjectEntity is Rock.Security.ISecured )\n                                {\n                                    canView = ( mergeObjectEntity as Rock.Security.ISecured ).IsAuthorized( Rock.Security.Authorization.VIEW, currentPerson );\n                                }\n\n                                if ( canView )\n                                {\n                                    mergeFields.Add( additionalMergeObject.MergeKey, mergeObjectEntity );\n                                }\n                            }\n                        }\n                    }\n                }\n\n            }\n\n            return template.ResolveMergeFields( mergeFields, currentPerson );\n        }", "label": "ComplexMethod"}
{"text": "#endregion\n\n        #region GetProcAddress\n\n        /// <summary>\n        /// Retrieves the address of an exported function or variable from loaded module.\n        /// </summary>\n        /// <param name=\"procName\">The function or variable name.</param>\n        /// <returns>\n        /// If the function succeeds, the return value is the address of the exported function or variable.\n        /// If the function fails, the return value is IntPtr.Zero.\n        /// </returns>\n        private IntPtr GetProcAddress(string procName)\n        {\n            if (_loadedModuleHandle == IntPtr.Zero)\n                return IntPtr.Zero;\n\n            if (!_loadedFromMemory)\n            {\n                return WinBase.GetProcAddress(_loadedModuleHandle, procName);\n            }\n\n            MEMORY_MODULE* memory_module = (MEMORY_MODULE*)_loadedModuleHandle;\n\n            byte* codeBase = memory_module->codeBase;\n\n            int idx = -1;\n            uint i;\n\n            uint* nameRef;\n            ushort* ordinal;\n\n            \n            WinNT.IMAGE_DATA_DIRECTORY* directory = this.GET_HEADER_DIRECTORY(memory_module, WinNT.IMAGE_DIRECTORY_ENTRY_EXPORT);\n\n            if (directory->Size == 0)\n                // no export table found\n                return IntPtr.Zero;\n\n            WinNT.IMAGE_EXPORT_DIRECTORY* exports = (WinNT.IMAGE_EXPORT_DIRECTORY*)(codeBase + directory->VirtualAddress);\n\n            if (exports->NumberOfNames == 0 || exports->NumberOfFunctions == 0)\n                // DLL doesn't export anything\n                return IntPtr.Zero;\n\n            // search function name in list of exported names\n            nameRef = (uint*)(codeBase + exports->AddressOfNames);\n            ordinal = (ushort*)(codeBase + exports->AddressOfNameOrdinals);\n\n            for (i = 0; i < exports->NumberOfNames; i++, nameRef++, ordinal++)\n            {\n                IntPtr procNameHandle = (IntPtr)((byte*)((ulong)codeBase + *nameRef));\n                string testProcName = Marshal.PtrToStringAnsi(procNameHandle);\n\n                if (testProcName == procName)\n                {\n                    idx = *ordinal;\n                    break;\n                }\n            }\n\n            if (idx == -1)\n                // exported symbol not found\n                return IntPtr.Zero;\n\n            if ((uint)idx > exports->NumberOfFunctions)\n                // name <-> ordinal number don't match\n                return IntPtr.Zero;\n\n            // AddressOfFunctions contains the RVAs to the \"real\" functions\n            //return (IntPtr)((uint)codeBase + *(uint*)((uint)codeBase + exports->AddressOfFunctions + (idx * 4)));\n            return (IntPtr)(codeBase + *(uint*)(codeBase + exports->AddressOfFunctions + (idx * 4)));\n        }", "label": "ComplexMethod"}
{"text": "\n\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public partial class findAndAddContactsByEmail_args : TBase\n    {\n      private int _reqSeq;\n      private THashSet<string> _emails;\n\n      public int ReqSeq\n      {\n        get\n        {\n          return _reqSeq;\n        }\n        set\n        {\n          __isset.reqSeq = true;\n          this._reqSeq = value;\n        }\n      }\n\n      public THashSet<string> Emails\n      {\n        get\n        {\n          return _emails;\n        }\n        set\n        {\n          __isset.emails = true;\n          this._emails = value;\n        }\n      }\n\n\n      public Isset __isset;\n      #if !SILVERLIGHT\n      [Serializable]\n      #endif\n      public struct Isset {\n        public bool reqSeq;\n        public bool emails;\n      }\n\n      public findAndAddContactsByEmail_args() {\n      }\n\n      public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 1:\n              if (field.Type == TType.I32) {\n                ReqSeq = iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 2:\n              if (field.Type == TType.Set) {\n                {\n                  Emails = new THashSet<string>();\n                  TSet _set176 = iprot.ReadSetBegin();\n                  for( int _i177 = 0; _i177 < _set176.Count; ++_i177)\n                  {\n                    string _elem178 = null;\n                    _elem178 = iprot.ReadString();\n                    Emails.Add(_elem178);\n                  }\n                  iprot.ReadSetEnd();\n                }\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }\n\n      public void Write(TProtocol oprot) {\n        TStruct struc = new TStruct(\"findAndAddContactsByEmail_args\");\n        oprot.WriteStructBegin(struc);\n        TField field = new TField();\n        if (__isset.reqSeq) {\n          field.Name = \"reqSeq\";\n          field.Type = TType.I32;\n          field.ID = 1;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32(ReqSeq);\n          oprot.WriteFieldEnd();\n        }\n        if (Emails != null && __isset.emails) {\n          field.Name = \"emails\";\n          field.Type = TType.Set;\n          field.ID = 2;\n          oprot.WriteFieldBegin(field);\n          {\n            oprot.WriteSetBegin(new TSet(TType.String, Emails.Count));\n            foreach (string _iter179 in Emails)\n            {\n              oprot.WriteString(_iter179);\n            }\n            oprot.WriteSetEnd();\n          }\n          oprot.WriteFieldEnd();\n        }\n        oprot.WriteFieldStop();\n        oprot.WriteStructEnd();\n      }\n\n      public override string ToString() {\n        StringBuilder sb = new StringBuilder(\"findAndAddContactsByEmail_args(\");\n        sb.Append(\"ReqSeq: \");\n        sb.Append(ReqSeq);\n        sb.Append(\",Emails: \");\n        sb.Append(Emails);\n        sb.Append(\")\");\n        return sb.ToString();\n      }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "\tpublic class HandSiegeAttack : XmlAttachment\n\t{\n\t\tprivate const double DamageScaleFactor = 0.5; // multiplier of weapon min/max damage used to calculate siege damage.\n\t\tprivate const double BaseWeaponDelay = 9.0;  // base delay in seconds between attacks.  Actual delay will be reduced by weapon speed.\n\n\t\tprivate Item m_AttackTarget = null;    // target of the attack\n\t\tprivate Point3D m_currentloc;\n\t\t//private int m_currentdirection;\n\t\tprivate Map m_currentmap;\n\t\tprivate Point3D m_targetloc;\n\t\tprivate Map m_targetmap;\n\t\tprivate int m_MaxDistance = 2; // max distance away from the target allowed\n\n\t\tprivate InternalTimer m_Timer;\n\n\t\t[CommandProperty(AccessLevel.GameMaster)]\n\t\tpublic Item AttackTarget { \n\t\t\tget \n\t\t\t{ \n\t\t\t\treturn m_AttackTarget; \n\t\t\t} \n\t\t\tset \n\t\t\t{ \n\t\t\tm_AttackTarget = value; \n\n\t\t\tif (m_AttackTarget != null) \n\t\t\t{ \n\t\t\t\t// immediate attack unless already attacking\n\t\t\t\tDoTimer(TimeSpan.Zero, true); \n\t\t\t} \n\t\t} \n\t\t}\n\n\t\t[CommandProperty(AccessLevel.GameMaster)]\n\t\tpublic int MaxDistance { get { return m_MaxDistance; } set { m_MaxDistance = value; } }\n\n\t\t[CommandProperty(AccessLevel.GameMaster)]\n\t\tpublic Point3D CurrentLoc { get { return m_currentloc; } set { m_currentloc = value; } }\n\n\t\t[CommandProperty(AccessLevel.GameMaster)]\n\t\tpublic Map CurrentMap { get { return m_currentmap; } set { m_currentmap = value; } }\n\n\t\t[CommandProperty(AccessLevel.GameMaster)]\n\t\tpublic Point3D TargetLoc { get { return m_targetloc; } set { m_targetloc = value; } }\n\n\t\t[CommandProperty(AccessLevel.GameMaster)]\n\t\tpublic Map TargetMap { get { return m_targetmap; } set { m_targetmap = value; } }\n\n\t\t// These are the various ways in which the message attachment can be constructed.  \n\t\t// These can be called via the [addatt interface, via scripts, via the spawner ATTACH keyword.\n\t\t// Other overloads could be defined to handle other types of arguments\n\n\t\t// a serial constructor is REQUIRED\n\t\tpublic HandSiegeAttack(ASerial serial)\n\t\t\t: base(serial)\n\t\t{\n\t\t}\n\n\t\t[Attachable]\n\t\tpublic HandSiegeAttack()\n\t\t{\n\t\t}\n\n\t\tpublic static void SelectTarget(Mobile from, Item weapon)\n\t\t{\n\t\t\tif (from == null || weapon == null) return;\n\n\t\t\t// does this weapon have a HandSiegeAttack attachment on it already?\n\n\t\t\tHandSiegeAttack a = (HandSiegeAttack)XmlAttach.FindAttachment(weapon, typeof(HandSiegeAttack));\n\n\t\t\tif (a == null || a.Deleted)\n\t\t\t{\n\t\t\t\ta = new HandSiegeAttack();\n\t\t\t\tXmlAttach.AttachTo(weapon, a);\n\t\t\t}\n\t\t\tfrom.Target = new HandSiegeTarget(weapon, a);\n\t\t}\n\n\t\tprivate class HandSiegeTarget : Target\n\t\t{\n\t\t\tprivate Item m_weapon;\n\t\t\tprivate HandSiegeAttack m_attachment;\n\n\t\t\tpublic HandSiegeTarget(Item weapon, HandSiegeAttack attachment)\n\t\t\t\t: base(30, true, TargetFlags.None)\n\t\t\t{\n\t\t\t\tm_weapon = weapon;\n\t\t\t\tm_attachment = attachment;\n\t\t\t}\n\n\t\t\tprotected override void OnTarget(Mobile from, object targeted)\n\t\t\t{\n\t\t\t\tif (from == null || m_weapon == null || from.Map == null || m_attachment == null) return;\n\n\t\t\t\tif (targeted is StaticTarget)\n\t\t\t\t{\n\t\t\t\t\tint staticid = ((StaticTarget)targeted).ItemID;\n\t\t\t\t\tint staticx = ((StaticTarget)targeted).Location.X;\n\t\t\t\t\tint staticy = ((StaticTarget)targeted).Location.Y;\n\n\t\t\t\t\tItem multiitem = null;\n\t\t\t\t\tPoint3D tileloc = Point3D.Zero;\n\n\t\t\t\t\t// find the possible multi owner of the static tile\n\t\t\t\t\tforeach (Item item in from.Map.GetItemsInRange(((StaticTarget)targeted).Location, 50))\n\t\t\t\t\t{\n\n\t\t\t\t\t\tif (item is BaseMulti)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// search the component list for a match\n\t\t\t\t\t\t\tMultiComponentList mcl = ((BaseMulti)item).Components;\n\t\t\t\t\t\t\tbool found = false;\n\t\t\t\t\t\t\tif (mcl != null && mcl.List != null)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (int i = 0; i < mcl.List.Length; i++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tMultiTileEntry t = mcl.List[i];\n\n\t\t\t\t\t\t\t\t\tint x = t.m_OffsetX + item.X;\n\t\t\t\t\t\t\t\t\tint y = t.m_OffsetY + item.Y;\n\t\t\t\t\t\t\t\t\tint z = t.m_OffsetZ + item.Z;\n\t\t\t\t\t\t\t\t\tint itemID = t.m_ItemID & 0x3FFF;\n\n\t\t\t\t\t\t\t\t\tif (itemID == staticid && x == staticx && y == staticy)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\t\t\t\t\ttileloc = new Point3D(x, y, z);\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (found)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tmultiitem = item;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (multiitem != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t//Console.WriteLine(\"attacking {0} at {1}:{2}\", multiitem, tileloc, ((StaticTarget)targeted).Location);\n\t\t\t\t\t\t// may have to reconsider the use tileloc vs target loc\n\t\t\t\t\t\t//m_cannon.AttackTarget(from, multiitem, ((StaticTarget)targeted).Location);\n\n\t\t\t\t\t\t//m_weapon.AttackTarget(from, multiitem, multiitem.Map.GetPoint(targeted, true), m_checklos);\n\n\n\t\t\t\t\t\tm_attachment.BeginAttackTarget(from, multiitem, multiitem.Map.GetPoint(targeted, true));\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tif (targeted is AddonComponent)\n\t\t\t\t\t{\n\t\t\t\t\t\t// if the addon doesnt have an xmlsiege attachment, then attack the addon\n\t\t\t\t\t\tXmlSiege a = (XmlSiege)XmlAttach.FindAttachment(targeted, typeof(XmlSiege));\n\t\t\t\t\t\tif (a == null || a.Deleted)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_attachment.BeginAttackTarget(from, ((AddonComponent)targeted).Addon, ((Item)targeted).Location);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm_attachment.BeginAttackTarget(from, (Item)targeted, ((Item)targeted).Location);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\tif (targeted is Item)\n\t\t\t\t\t{\n\t\t\t\t\t\tm_attachment.BeginAttackTarget(from, (Item)targeted, ((Item)targeted).Location);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic void BeginAttackTarget(Mobile from, Item target, Point3D targetloc)\n\t\t{\n\t\t\tif (from == null || target == null) return;\n\n\t\t\t// check the target line of sight\n\t\t\tPoint3D adjustedloc = new Point3D(targetloc.X, targetloc.Y, targetloc.Z + target.ItemData.Height);\n\t\t\tPoint3D fromloc = new Point3D(from.Location.X, from.Location.Y, from.Location.Z + 14);\n\n\t\t\tif (!from.Map.LineOfSight(fromloc, adjustedloc))\n\t\t\t{\n\t\t\t\tfrom.SendMessage(\"Cannot see target.\");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tint distance = (int)XmlSiege.GetDistance(from.Location, targetloc);\n\n\t\t\tif (distance <= MaxDistance)\n\t\t\t{\n\t\t\t\tCurrentLoc = from.Location;\n\t\t\t\tCurrentMap = from.Map;\n\t\t\t\tTargetLoc = target.Location;\n\t\t\t\tTargetMap = target.Map;\n\n\t\t\t\tAttackTarget = target;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfrom.SendLocalizedMessage(500446); // That is too far away.\n\t\t\t}\n\n\t\t}\n\n\t\tpublic override void Serialize(GenericWriter writer)\n\t\t{\n\t\t\tbase.Serialize(writer);\n\n\t\t\twriter.Write((int)0);\n\t\t\t// version 0\n\n\t\t}\n\n\t\tpublic override void Deserialize(GenericReader reader)\n\t\t{\n\t\t\tbase.Deserialize(reader);\n\n\t\t\tint version = reader.ReadInt();\n\t\t\t// version 0\n\n\t\t}\n\n\t\tpublic override void OnAttach()\n\t\t{\n\t\t\tbase.OnAttach();\n\n\t\t\tif (!(AttachedTo is Item))\n\t\t\t{\n\t\t\t\tDelete();\n\t\t\t}\n\t\t\t\t\n\t\t}\n\n\n\t\tpublic override void OnDelete()\n\t\t{\n\t\t\tbase.OnDelete();\n\n\t\t\tif (m_Timer != null)\n\t\t\t\tm_Timer.Stop();\n\t\t}\n\n\t\tpublic void DoTimer(TimeSpan delay, bool wait)\n\t\t{\n\t\t\t// is there a timer already running?  Then let it finish\n\t\t\tif (m_Timer != null && m_Timer.Running && wait) return;\n\n\t\t\tif (m_Timer != null)\n\t\t\t\tm_Timer.Stop();\n\n\t\t\tm_Timer = new InternalTimer(this, delay);\n\t\t\tm_Timer.Start();\n\t\t}\n\n\t\t// added the duration timer that begins on spawning\n\t\tprivate class InternalTimer : Timer\n\t\t{\n\t\t\tprivate HandSiegeAttack m_attachment;\n\n\t\t\tpublic InternalTimer(HandSiegeAttack attachment, TimeSpan delay)\n\t\t\t\t: base(delay)\n\t\t\t{\n\t\t\t\tPriority = TimerPriority.TwoFiftyMS;\n\t\t\t\tm_attachment = attachment;\n\t\t\t}\n\n\t\t\tprotected override void OnTick()\n\t\t\t{\n\t\t\t\tif (m_attachment == null) return;\n\n\t\t\t\tItem weapon = m_attachment.AttachedTo as Item;\n\t\t\t\tItem target = m_attachment.AttackTarget;\n\n\t\t\t\tif (weapon == null || weapon.Deleted || target == null || target.Deleted)\n\t\t\t\t{\n\t\t\t\t\tStop();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// the weapon must be equipped\n\t\t\t\tMobile attacker = weapon.Parent as Mobile;\n\n\t\t\t\tif (attacker == null || attacker.Deleted)\n\t\t\t\t{\n\t\t\t\t\tStop();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// the attacker cannot be fighting\n\t\t\t\t\n\t\t\t\tif (attacker.Combatant != null)\n\t\t\t\t{\n\t\t\t\t\tattacker.SendMessage(\"Cannot siege while fighting.\");\n\t\t\t\t\tStop();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// get the location of the attacker\n\n\t\t\t\tPoint3D attackerloc = attacker.Location;\n\t\t\t\tMap attackermap = attacker.Map;\n\n\t\t\t\tPoint3D targetloc = target.Location;\n\t\t\t\tMap targetmap = target.Map;\n\n\t\t\t\tif (targetmap == null || targetmap == Map.Internal || attackermap == null || attackermap == Map.Internal || targetmap != attackermap)\n\t\t\t\t{\n\t\t\t\t\t// if the attacker or target has an invalid map, then stop\n\t\t\t\t\tStop();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// compare it against previous locations.  If they have moved then break off the attack\n\t\t\t\tif (attackerloc != m_attachment.CurrentLoc || attackermap != m_attachment.CurrentMap)\n\t\t\t\t{\n\t\t\t\t\tStop();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\n\t\t\t\t// attack the target\n\t\t\t\t// Animate( int action, int frameCount, int repeatCount, bool forward, bool repeat, int delay )\n\t\t\t\tint action = 26; // 1-H bash animation, 29=2-H mounted\n\n\t\t\t\t\n\n\t\t\t\t// get the layer\n\t\t\t\tswitch (weapon.Layer)\n\t\t\t\t{\n\t\t\t\t\tcase Layer.OneHanded:\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (attacker.Mount == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// unmounted animation\n\t\t\t\t\t\t\taction = 9;\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\taction = 26;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase Layer.TwoHanded:\n\t\t\t\t\t\tif (attacker.Mount == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// unmounted animation\n\t\t\t\t\t\t\taction = 12;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\taction = 29;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// attack animation\n\t\t\t\tattacker.Animate(action, 7, 1, true, false, 0);\n\n\t\t\t\tint basedamage = 1;\n\t\t\t\tdouble basedelay = BaseWeaponDelay;\n\n\t\t\t\tif (weapon is BaseWeapon)\n\t\t\t\t{\n\t\t\t\t\tBaseWeapon b = (BaseWeapon)weapon;\n\t\t\t\t\t// calculate the siege damage based on the weapon min/max damage and the overall damage scale factor\n\t\t\t\t\tbasedamage = (int)(Utility.RandomMinMax(b.MinDamage, b.MaxDamage)*DamageScaleFactor);\n\t\t\t\t\t// reduce the actual delay by the weapon speed\n\t\t\t\t\tbasedelay -= b.Speed/10;\n\t\t\t\t}\n\n\t\t\t\tif (basedelay < 1) basedelay = 1;\n\t\t\t\tif (basedamage < 1) basedamage = 1;\n\n\t\t\t\t// apply siege damage, all physical\n\t\t\t\tXmlSiege.Attack(attacker, target, basedamage, 0);\n\n\t\t\t\t// prepare for the next attack\n\t\t\t\tm_attachment.DoTimer(TimeSpan.FromSeconds(basedelay), false);\n\n\t\t\t}\n\t\t}\n\t}\n", "label": "FeatureEnvy"}
{"text": "    public class UserResolverSelector : IIdentityResolverSelector {\n        private readonly IContentManager _contentManager;\n\n        public UserResolverSelector(IContentManager contentManager) {\n            _contentManager = contentManager;\n        }\n\n        public IdentityResolverSelectorResult GetResolver(ContentIdentity contentIdentity) {\n            if (contentIdentity.Has(\"User.UserName\")) {\n                return new IdentityResolverSelectorResult {\n                    Priority = 0,\n                    Resolve = ResolveIdentity\n                };\n            }\n\n            return null;\n        }\n\n        private IEnumerable<ContentItem> ResolveIdentity(ContentIdentity identity) {\n            var identifier = identity.Get(\"User.UserName\");\n\n            if (identifier == null) {\n                return null;\n            }\n\n            var comparer = new ContentIdentity.ContentIdentityEqualityComparer();\n            return _contentManager\n                .Query<UserPart, UserPartRecord>()\n                .Where(p => p.UserName == identifier)\n                .List<ContentItem>()\n                .Where(c => comparer.Equals(identity, _contentManager.GetItemMetadata(c).Identity));\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// \n    /// </summary>\n    public class WorkflowPicker : CompositeControl, IRockControl\n    {\n        #region IRockControl implementation (Custom implementation)\n\n        /// <summary>\n        /// Gets or sets the label text.\n        /// </summary>\n        /// <value>\n        /// The label text.\n        /// </value>\n        [\n        Bindable( true ),\n        Category( \"Appearance\" ),\n        DefaultValue( \"\" ),\n        Description( \"The text for the label.\" )\n        ]\n        public string Label\n        {\n            get { return ViewState[\"Label\"] as string ?? string.Empty; }\n            set { ViewState[\"Label\"] = value; }\n        }\n\n        /// <summary>\n        /// Gets or sets the form group class.\n        /// </summary>\n        /// <value>\n        /// The form group class.\n        /// </value>\n        [\n        Bindable( true ),\n        Category( \"Appearance\" ),\n        Description( \"The CSS class to add to the form-group div.\" )\n        ]\n        public string FormGroupCssClass\n        {\n            get { return ViewState[\"FormGroupCssClass\"] as string ?? string.Empty; }\n            set { ViewState[\"FormGroupCssClass\"] = value; }\n        }\n\n        /// <summary>\n        /// Gets or sets the help text.\n        /// </summary>\n        /// <value>\n        /// The help text.\n        /// </value>\n        [\n        Bindable( true ),\n        Category( \"Appearance\" ),\n        DefaultValue( \"\" ),\n        Description( \"The help block.\" )\n        ]\n        public string Help\n        {\n            get\n            {\n                return HelpBlock != null ? HelpBlock.Text : string.Empty;\n            }\n\n            set\n            {\n                if ( HelpBlock != null )\n                {\n                    HelpBlock.Text = value;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the warning text.\n        /// </summary>\n        /// <value>\n        /// The warning text.\n        /// </value>\n        [\n        Bindable( true ),\n        Category( \"Appearance\" ),\n        DefaultValue( \"\" ),\n        Description( \"The warning block.\" )\n        ]\n        public string Warning\n        {\n            get\n            {\n                return WarningBlock != null ? WarningBlock.Text : string.Empty;\n            }\n\n            set\n            {\n                if ( WarningBlock != null )\n                {\n                    WarningBlock.Text = value;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether this <see cref=\"RockTextBox\"/> is required.\n        /// </summary>\n        /// <value>\n        ///   <c>true</c> if required; otherwise, <c>false</c>.\n        /// </value>\n        [\n        Bindable( true ),\n        Category( \"Behavior\" ),\n        DefaultValue( \"false\" ),\n        Description( \"Is the value required?\" )\n        ]\n        public bool Required\n        {\n            get \n            {\n                EnsureChildControls();\n                return _ddlWorkflow.Required; \n            }\n            set \n            {\n                EnsureChildControls();\n                _ddlWorkflow.Required = value; \n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the required error message.  If blank, the LabelName name will be used\n        /// </summary>\n        /// <value>\n        /// The required error message.\n        /// </value>\n        public string RequiredErrorMessage\n        {\n            get\n            {\n                return RequiredFieldValidator != null ? RequiredFieldValidator.ErrorMessage : string.Empty;\n            }\n\n            set\n            {\n                if ( RequiredFieldValidator != null )\n                {\n                    RequiredFieldValidator.ErrorMessage = value;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets an optional validation group to use.\n        /// </summary>\n        /// <value>\n        /// The validation group.\n        /// </value>\n        public string ValidationGroup\n        {\n            get { return ViewState[\"ValidationGroup\"] as string; }\n            set { ViewState[\"ValidationGroup\"] = value; }\n        }\n\n        /// <summary>\n        /// Gets a value indicating whether this instance is valid.\n        /// </summary>\n        /// <value>\n        ///   <c>true</c> if this instance is valid; otherwise, <c>false</c>.\n        /// </value>\n        public virtual bool IsValid\n        {\n            get\n            {\n                return !Required || RequiredFieldValidator == null || RequiredFieldValidator.IsValid;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the help block.\n        /// </summary>\n        /// <value>\n        /// The help block.\n        /// </value>\n        public HelpBlock HelpBlock { get; set; }\n\n        /// <summary>\n        /// Gets or sets the warning block.\n        /// </summary>\n        /// <value>\n        /// The warning block.\n        /// </value>\n        public WarningBlock WarningBlock { get; set; }\n\n        /// <summary>\n        /// Gets or sets the required field validator.\n        /// </summary>\n        /// <value>\n        /// The required field validator.\n        /// </value>\n        public RequiredFieldValidator RequiredFieldValidator { get; set; }\n\n        #endregion\n\n        #region Controls\n\n        private RockDropDownList _ddlWorkflowType;\n        private RockDropDownList _ddlWorkflow;\n\n        #endregion\n\n        #region Properties\n\n        /// <summary>\n        /// Gets or sets the workflow type id.\n        /// </summary>\n        /// <value>\n        /// The workflow type id.\n        /// </value>\n        public int? WorkflowTypeId\n        {\n            get\n            {\n                return ViewState[\"WorkflowTypeId\"] as int?;\n            }\n\n            set\n            {\n                ViewState[\"WorkflowTypeId\"] = value;\n                if ( value.HasValue )\n                {\n                    LoadWorkflows( value.Value );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the workflow id.\n        /// </summary>\n        /// <value>\n        /// The workflow id.\n        /// </value>\n        public int? WorkflowId\n        {\n            get\n            {\n                EnsureChildControls();\n                int workflowId = int.MinValue;\n                if ( int.TryParse( _ddlWorkflow.SelectedValue, out workflowId ) && workflowId > 0 )\n                {\n                    return workflowId;\n                }\n\n                return null;\n            }\n\n            set\n            {\n                EnsureChildControls();\n                int workflowId = value.HasValue ? value.Value : 0;\n                if ( _ddlWorkflow.SelectedValue != workflowId.ToString() )\n                {\n                    if ( !WorkflowTypeId.HasValue )\n                    {\n                        var workflow = new Rock.Model.WorkflowService( new RockContext() ).Get( workflowId );\n                        if ( workflow != null &&\n                            _ddlWorkflowType.SelectedValue != workflow.WorkflowTypeId.ToString() )\n                        {\n                            _ddlWorkflowType.SelectedValue = workflow.WorkflowTypeId.ToString();\n\n                            LoadWorkflows( workflow.WorkflowTypeId );\n                        }\n                    }\n\n                    _ddlWorkflow.SetValue( workflowId.ToString() );\n                }\n            }\n        }\n\n        #endregion\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"WorkflowPicker\"/> class.\n        /// </summary>\n        public WorkflowPicker()\n            : base()\n        {\n            HelpBlock = new HelpBlock();\n            WarningBlock = new WarningBlock();\n        }\n\n        /// <summary>\n        /// Called by the ASP.NET page framework to notify server controls that use composition-based implementation to create any child controls they contain in preparation for posting back or rendering.\n        /// </summary>\n        protected override void CreateChildControls()\n        {\n            base.CreateChildControls();\n            Controls.Clear();\n            RockControlHelper.CreateChildControls( this, Controls );\n\n            _ddlWorkflowType = new RockDropDownList();\n            _ddlWorkflowType.ID = this.ID + \"_ddlWorkflowType\";\n            _ddlWorkflowType.AutoPostBack = true;\n            _ddlWorkflowType.SelectedIndexChanged += _ddlWorkflowType_SelectedIndexChanged;\n            Controls.Add( _ddlWorkflowType );\n\n            _ddlWorkflow = new RockDropDownList();\n            _ddlWorkflow.ID = this.ID + \"_ddlWorkflow\";\n            _ddlWorkflow.Label = \"Workflow\";\n            Controls.Add( _ddlWorkflow );\n\n            LoadWorkflowTypes();\n        }\n\n        /// <summary>\n        /// Handles the SelectedIndexChanged event of the _ddlWorkflowType control.\n        /// </summary>\n        /// <param name=\"sender\">The source of the event.</param>\n        /// <param name=\"e\">The <see cref=\"EventArgs\"/> instance containing the event data.</param>\n        protected void _ddlWorkflowType_SelectedIndexChanged( object sender, EventArgs e )\n        {\n            int workflowTypeId = _ddlWorkflowType.SelectedValue.AsInteger();\n            LoadWorkflows( workflowTypeId );\n        }\n\n        /// <summary>\n        /// Outputs server control content to a provided <see cref=\"T:System.Web.UI.HtmlTextWriter\" /> object and stores tracing information about the control if tracing is enabled.\n        /// </summary>\n        /// <param name=\"writer\">The <see cref=\"T:System.Web.UI.HtmlTextWriter\" /> object that receives the control content.</param>\n        public override void RenderControl( HtmlTextWriter writer )\n        {\n            if ( this.Visible )\n            {\n                RockControlHelper.RenderControl( this, writer );\n            }\n        }\n\n        /// <summary>\n        /// Renders the base control.\n        /// </summary>\n        /// <param name=\"writer\">The writer.</param>\n        public void RenderBaseControl( HtmlTextWriter writer )\n        {\n            if ( !WorkflowTypeId.HasValue )\n            {\n                _ddlWorkflowType.RenderControl( writer );\n            }\n            _ddlWorkflow.RenderControl( writer );\n        }\n\n        /// <summary>\n        /// Loads the workflow types.\n        /// </summary>\n        private void LoadWorkflowTypes()\n        {\n            _ddlWorkflowType.Items.Clear();\n            \n            if ( !Required )\n            {\n                _ddlWorkflowType.Items.Add( new ListItem( string.Empty, Rock.Constants.None.IdValue ) );\n            }\n\n            using ( var rockContext = new RockContext() )\n            {\n                var workflowTypeService = new Rock.Model.WorkflowTypeService( rockContext );\n\n                var workflowTypes = workflowTypeService.Queryable().AsNoTracking()\n                    .Where( t => \n                        t.Category != null &&\n                        t.IsActive.HasValue &&\n                        t.IsActive.Value)\n                    .OrderBy( t => t.Category.Name)\n                    .ThenBy( t => t.Name )\n                    .Select(a => new { a.Id, CategoryName = a.Category.Name, a.Name} )\n                    .AsNoTracking()\n                    .ToList();\n                foreach ( var t in workflowTypes )\n                {\n                    _ddlWorkflowType.Items.Add( new ListItem( string.Format( \"{0}: {1}\", t.CategoryName, t.Name), t.Id.ToString().ToUpper() ) );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Loads the workflows.\n        /// </summary>\n        /// <param name=\"workflowTypeId\">The workflow type unique identifier.</param>\n        private void LoadWorkflows( int? workflowTypeId )\n        {\n            int? currentWorkflowId = this.WorkflowId;\n            _ddlWorkflow.SelectedValue = null;\n            _ddlWorkflow.Items.Clear();\n            if ( workflowTypeId.HasValue )\n            {\n                if ( !Required )\n                {\n                    _ddlWorkflow.Items.Add( new ListItem( string.Empty, Rock.Constants.None.IdValue ) );\n                }\n\n                var workflowService = new Rock.Model.WorkflowService( new RockContext() );\n                var workflows = workflowService.Queryable()\n                    .Where( w => \n                        w.WorkflowTypeId == workflowTypeId.Value &&\n                        w.ActivatedDateTime.HasValue && \n                        !w.CompletedDateTime.HasValue )\n                    .OrderBy( w => w.Name )\n                    .Select(a => new\n                    {\n                        a.Id,\n                        a.Name\n                    } )\n                    .ToList();\n\n                foreach ( var w in workflows )\n                {\n                    var workflowItem = new ListItem( w.Name, w.Id.ToString().ToUpper() );\n                    workflowItem.Selected = w.Id == currentWorkflowId;\n                    _ddlWorkflow.Items.Add( workflowItem );\n                }\n            }\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\t/**\n\t* an expanded SignerInfo block from a CMS Signed message\n\t*/\n\tpublic class SignerInformation\n\t{\n\t\tprivate static readonly CmsSignedHelper Helper = CmsSignedHelper.Instance;\n\n\t\tprivate SignerID\t\t\tsid;\n\t\tprivate SignerInfo\t\t\tinfo;\n\t\tprivate AlgorithmIdentifier\tdigestAlgorithm;\n\t\tprivate AlgorithmIdentifier\tencryptionAlgorithm;\n\t\tprivate readonly Asn1Set\tsignedAttributeSet;\n\t\tprivate readonly Asn1Set\tunsignedAttributeSet;\n\t\tprivate CmsProcessable\t\tcontent;\n\t\tprivate byte[]\t\t\t\tsignature;\n\t\tprivate DerObjectIdentifier\tcontentType;\n\t\tprivate IDigestCalculator\tdigestCalculator;\n\t\tprivate byte[]\t\t\t\tresultDigest;\n\n\t\t// Derived\n\t\tprivate Asn1.Cms.AttributeTable\tsignedAttributeTable;\n\t\tprivate Asn1.Cms.AttributeTable\tunsignedAttributeTable;\n\t\tprivate readonly bool isCounterSignature;\n\n\t\tinternal SignerInformation(\n\t\t\tSignerInfo\t\t\tinfo,\n\t\t\tDerObjectIdentifier\tcontentType,\n\t\t\tCmsProcessable\t\tcontent,\n\t\t\tIDigestCalculator\tdigestCalculator)\n\t\t{\n\t\t\tthis.info = info;\n\t\t\tthis.sid = new SignerID();\n\t\t\tthis.contentType = contentType;\n\t\t\tthis.isCounterSignature = contentType == null;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tSignerIdentifier s = info.SignerID;\n\n\t\t\t\tif (s.IsTagged)\n\t\t\t\t{\n\t\t\t\t\tAsn1OctetString octs = Asn1OctetString.GetInstance(s.ID);\n\n\t\t\t\t\tsid.SubjectKeyIdentifier = octs.GetEncoded();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tAsn1.Cms.IssuerAndSerialNumber iAnds =\n\t\t\t\t\t\tAsn1.Cms.IssuerAndSerialNumber.GetInstance(s.ID);\n\n\t\t\t\t\tsid.Issuer = iAnds.Name;\n\t\t\t\t\tsid.SerialNumber = iAnds.SerialNumber.Value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException)\n\t\t\t{\n\t\t\t\tthrow new ArgumentException(\"invalid sid in SignerInfo\");\n\t\t\t}\n\n\t\t\tthis.digestAlgorithm = info.DigestAlgorithm;\n\t\t\tthis.signedAttributeSet = info.AuthenticatedAttributes;\n\t\t\tthis.unsignedAttributeSet = info.UnauthenticatedAttributes;\n\t\t\tthis.encryptionAlgorithm = info.DigestEncryptionAlgorithm;\n\t\t\tthis.signature = info.EncryptedDigest.GetOctets();\n\n\t\t\tthis.content = content;\n\t\t\tthis.digestCalculator = digestCalculator;\n\t\t}\n\n\t\tpublic bool IsCounterSignature\n\t\t{\n\t\t\tget { return isCounterSignature; }\n\t\t}\n\n\t\tpublic DerObjectIdentifier ContentType\n\t\t{\n\t\t\tget { return contentType; }\n\t\t}\n\n\t\tpublic SignerID SignerID\n\t\t{\n\t\t\tget { return sid; }\n\t\t}\n\n\t\t/**\n\t\t* return the version number for this objects underlying SignerInfo structure.\n\t\t*/\n\t\tpublic int Version\n\t\t{\n\t\t\tget { return info.Version.Value.IntValue; }\n\t\t}\n\n\t\tpublic AlgorithmIdentifier DigestAlgorithmID\n\t\t{\n\t\t\tget { return digestAlgorithm; }\n\t\t}\n\n\t\t/**\n\t\t* return the object identifier for the signature.\n\t\t*/\n\t\tpublic string DigestAlgOid\n\t\t{\n\t\t\tget { return digestAlgorithm.ObjectID.Id; }\n\t\t}\n\n\t\t/**\n\t\t* return the signature parameters, or null if there aren't any.\n\t\t*/\n\t\tpublic Asn1Object DigestAlgParams\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tAsn1Encodable ae = digestAlgorithm.Parameters;\n\n\t\t\t\treturn ae == null ? null : ae.ToAsn1Object();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * return the content digest that was calculated during verification.\n\t\t */\n\t\tpublic byte[] GetContentDigest()\n\t\t{\n\t\t\tif (resultDigest == null)\n\t\t\t{\n\t\t\t\tthrow new InvalidOperationException(\"method can only be called after verify.\");\n\t\t\t}\n\n\t\t\treturn (byte[])resultDigest.Clone();\n\t\t}\n\n\t\tpublic AlgorithmIdentifier EncryptionAlgorithmID\n\t\t{\n\t\t\tget { return encryptionAlgorithm; }\n\t\t}\n\n\t\t/**\n\t\t* return the object identifier for the signature.\n\t\t*/\n\t\tpublic string EncryptionAlgOid\n\t\t{\n\t\t\tget { return encryptionAlgorithm.ObjectID.Id; }\n\t\t}\n\n\t\t/**\n\t\t* return the signature/encryption algorithm parameters, or null if\n\t\t* there aren't any.\n\t\t*/\n\t\tpublic Asn1Object EncryptionAlgParams\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tAsn1Encodable ae = encryptionAlgorithm.Parameters;\n\n\t\t\t\treturn ae == null ? null : ae.ToAsn1Object();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t* return a table of the signed attributes - indexed by\n\t\t* the OID of the attribute.\n\t\t*/\n\t\tpublic Asn1.Cms.AttributeTable SignedAttributes\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (signedAttributeSet != null && signedAttributeTable == null)\n\t\t\t\t{\n\t\t\t\t\tsignedAttributeTable = new Asn1.Cms.AttributeTable(signedAttributeSet);\n\t\t\t\t}\n\t\t\t\treturn signedAttributeTable;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t* return a table of the unsigned attributes indexed by\n\t\t* the OID of the attribute.\n\t\t*/\n\t\tpublic Asn1.Cms.AttributeTable UnsignedAttributes\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tif (unsignedAttributeSet != null && unsignedAttributeTable == null)\n\t\t\t\t{\n\t\t\t\t\tunsignedAttributeTable = new Asn1.Cms.AttributeTable(unsignedAttributeSet);\n\t\t\t\t}\n\t\t\t\treturn unsignedAttributeTable;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t* return the encoded signature\n\t\t*/\n\t\tpublic byte[] GetSignature()\n\t\t{\n\t\t\treturn (byte[]) signature.Clone();\n\t\t}\n\n\t\t/**\n\t\t* Return a SignerInformationStore containing the counter signatures attached to this\n\t\t* signer. If no counter signatures are present an empty store is returned.\n\t\t*/\n\t\tpublic SignerInformationStore GetCounterSignatures()\n\t\t{\n\t\t\t// TODO There are several checks implied by the RFC3852 comments that are missing\n\n\t\t\t/*\n\t\t\tThe countersignature attribute MUST be an unsigned attribute; it MUST\n\t\t\tNOT be a signed attribute, an authenticated attribute, an\n\t\t\tunauthenticated attribute, or an unprotected attribute.\n\t\t\t*/\n\t\t\tAsn1.Cms.AttributeTable unsignedAttributeTable = UnsignedAttributes;\n\t\t\tif (unsignedAttributeTable == null)\n\t\t\t{\n                return new SignerInformationStore(Platform.CreateArrayList(0));\n\t\t\t}\n\n            IList counterSignatures = Platform.CreateArrayList();\n\n\t\t\t/*\n\t\t\tThe UnsignedAttributes syntax is defined as a SET OF Attributes.  The\n\t\t\tUnsignedAttributes in a signerInfo may include multiple instances of\n\t\t\tthe countersignature attribute.\n\t\t\t*/\n\t\t\tAsn1EncodableVector allCSAttrs = unsignedAttributeTable.GetAll(CmsAttributes.CounterSignature);\n\n\t\t\tforeach (Asn1.Cms.Attribute counterSignatureAttribute in allCSAttrs)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tA countersignature attribute can have multiple attribute values.  The\n\t\t\t\tsyntax is defined as a SET OF AttributeValue, and there MUST be one\n\t\t\t\tor more instances of AttributeValue present.\n\t\t\t\t*/\n\t\t\t\tAsn1Set values = counterSignatureAttribute.AttrValues;\n\t\t\t\tif (values.Count < 1)\n\t\t\t\t{\n\t\t\t\t\t// TODO Throw an appropriate exception?\n\t\t\t\t}\n\n\t\t\t\tforeach (Asn1Encodable asn1Obj in values)\n\t\t\t\t{\n\t\t\t\t\t/*\n\t\t\t\t\tCountersignature values have the same meaning as SignerInfo values\n\t\t\t\t\tfor ordinary signatures, except that:\n\n\t\t\t\t\t   1. The signedAttributes field MUST NOT contain a content-type\n\t\t\t\t\t      attribute; there is no content type for countersignatures.\n\n\t\t\t\t\t   2. The signedAttributes field MUST contain a message-digest\n\t\t\t\t\t      attribute if it contains any other attributes.\n\n\t\t\t\t\t   3. The input to the message-digesting process is the contents\n\t\t\t\t\t      octets of the DER encoding of the signatureValue field of the\n\t\t\t\t\t      SignerInfo value with which the attribute is associated.\n\t\t\t\t\t*/\n\t\t\t\t\tSignerInfo si = SignerInfo.GetInstance(asn1Obj.ToAsn1Object());\n\n\t\t\t\t\tstring digestName = CmsSignedHelper.Instance.GetDigestAlgName(si.DigestAlgorithm.ObjectID.Id);\n\n\t\t\t\t\tcounterSignatures.Add(new SignerInformation(si, null, null, new CounterSignatureDigestCalculator(digestName, GetSignature())));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn new SignerInformationStore(counterSignatures);\n\t\t}\n\n\t\t/**\n\t\t* return the DER encoding of the signed attributes.\n\t\t* @throws IOException if an encoding error occurs.\n\t\t*/\n\t\tpublic byte[] GetEncodedSignedAttributes()\n\t\t{\n\t\t\treturn signedAttributeSet == null\n\t\t\t\t?\tnull\n\t\t\t\t:\tsignedAttributeSet.GetEncoded(Asn1Encodable.Der);\n\t\t}\n\n\t\tprivate bool DoVerify(\n\t\t\tAsymmetricKeyParameter\tkey)\n\t\t{\n\t\t\tstring digestName = Helper.GetDigestAlgName(this.DigestAlgOid);\n\t\t\tIDigest digest = Helper.GetDigestInstance(digestName);\n\n\t\t\tDerObjectIdentifier sigAlgOid = this.encryptionAlgorithm.ObjectID;\n\t\t\tAsn1Encodable sigParams = this.encryptionAlgorithm.Parameters;\n\t\t\tISigner sig;\n\n\t\t\tif (sigAlgOid.Equals(Asn1.Pkcs.PkcsObjectIdentifiers.IdRsassaPss))\n\t\t\t{\n\t\t\t\t// RFC 4056 2.2\n\t\t\t\t// When the id-RSASSA-PSS algorithm identifier is used for a signature,\n\t\t\t\t// the AlgorithmIdentifier parameters field MUST contain RSASSA-PSS-params.\n\t\t\t\tif (sigParams == null)\n\t\t\t\t\tthrow new CmsException(\"RSASSA-PSS signature must specify algorithm parameters\");\n\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\t// TODO Provide abstract configuration mechanism\n\t\t\t\t\t// (via alternate SignerUtilities.GetSigner method taking ASN.1 params)\n\n\t\t\t\t\tAsn1.Pkcs.RsassaPssParameters pss = Asn1.Pkcs.RsassaPssParameters.GetInstance(\n\t\t\t\t\t\tsigParams.ToAsn1Object());\n\n\t\t\t\t\tif (!pss.HashAlgorithm.ObjectID.Equals(this.digestAlgorithm.ObjectID))\n\t\t\t\t\t\tthrow new CmsException(\"RSASSA-PSS signature parameters specified incorrect hash algorithm\");\n\t\t\t\t\tif (!pss.MaskGenAlgorithm.ObjectID.Equals(Asn1.Pkcs.PkcsObjectIdentifiers.IdMgf1))\n\t\t\t\t\t\tthrow new CmsException(\"RSASSA-PSS signature parameters specified unknown MGF\");\n\n\t\t\t\t\tIDigest pssDigest = DigestUtilities.GetDigest(pss.HashAlgorithm.ObjectID);\n\t\t\t\t\tint saltLength = pss.SaltLength.Value.IntValue;\n\t\t\t\t\tbyte trailerField = (byte) pss.TrailerField.Value.IntValue;\n\n\t\t\t\t\t// RFC 4055 3.1\n\t\t\t\t\t// The value MUST be 1, which represents the trailer field with hexadecimal value 0xBC\n\t\t\t\t\tif (trailerField != 1)\n\t\t\t\t\t\tthrow new CmsException(\"RSASSA-PSS signature parameters must have trailerField of 1\");\n\n\t\t\t\t\tsig = new PssSigner(new RsaBlindedEngine(), pssDigest, saltLength);\n\t\t\t\t}\n\t\t\t\tcatch (Exception e)\n\t\t\t\t{\n\t\t\t\t\tthrow new CmsException(\"failed to set RSASSA-PSS signature parameters\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// TODO Probably too strong a check at the moment\n//\t\t\t\tif (sigParams != null)\n//\t\t\t\t\tthrow new CmsException(\"unrecognised signature parameters provided\");\n\n\t\t\t\tstring signatureName = digestName + \"with\" + Helper.GetEncryptionAlgName(this.EncryptionAlgOid);\n\n\t\t\t\tsig = Helper.GetSignatureInstance(signatureName);\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (digestCalculator != null)\n\t\t\t\t{\n\t\t\t\t\tresultDigest = digestCalculator.GetDigest();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (content != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontent.Write(new DigOutputStream(digest));\n\t\t\t\t\t}\n\t\t\t\t\telse if (signedAttributeSet == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO Get rid of this exception and just treat content==null as empty not missing?\n\t\t\t\t\t\tthrow new CmsException(\"data not encapsulated in signature - use detached constructor.\");\n\t\t\t\t\t}\n\n\t\t\t\t\tresultDigest = DigestUtilities.DoFinal(digest);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"can't process mime object to create signature.\", e);\n\t\t\t}\n\n\t\t\t// RFC 3852 11.1 Check the content-type attribute is correct\n\t\t\t{\n\t\t\t\tAsn1Object validContentType = GetSingleValuedSignedAttribute(\n\t\t\t\t\tCmsAttributes.ContentType, \"content-type\");\n\t\t\t\tif (validContentType == null)\n\t\t\t\t{\n\t\t\t\t\tif (!isCounterSignature && signedAttributeSet != null)\n\t\t\t\t\t\tthrow new CmsException(\"The content-type attribute type MUST be present whenever signed attributes are present in signed-data\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (isCounterSignature)\n\t\t\t\t\t\tthrow new CmsException(\"[For counter signatures,] the signedAttributes field MUST NOT contain a content-type attribute\");\n\n\t\t\t\t\tif (!(validContentType is DerObjectIdentifier))\n\t\t\t\t\t\tthrow new CmsException(\"content-type attribute value not of ASN.1 type 'OBJECT IDENTIFIER'\");\n\n\t\t\t\t\tDerObjectIdentifier signedContentType = (DerObjectIdentifier)validContentType;\n\n\t\t\t\t\tif (!signedContentType.Equals(contentType))\n\t\t\t\t\t\tthrow new CmsException(\"content-type attribute value does not match eContentType\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// RFC 3852 11.2 Check the message-digest attribute is correct\n\t\t\t{\n\t\t\t\tAsn1Object validMessageDigest = GetSingleValuedSignedAttribute(\n\t\t\t\t\tCmsAttributes.MessageDigest, \"message-digest\");\n\t\t\t\tif (validMessageDigest == null)\n\t\t\t\t{\n\t\t\t\t    if (signedAttributeSet != null)\n\t\t\t\t\t\tthrow new CmsException(\"the message-digest signed attribute type MUST be present when there are any signed attributes present\");\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!(validMessageDigest is Asn1OctetString))\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new CmsException(\"message-digest attribute value not of ASN.1 type 'OCTET STRING'\");\n\t\t\t\t\t}\n\n\t\t\t\t\tAsn1OctetString signedMessageDigest = (Asn1OctetString)validMessageDigest;\n\n\t\t\t\t\tif (!Arrays.AreEqual(resultDigest, signedMessageDigest.GetOctets()))\n\t\t\t\t\t\tthrow new CmsException(\"message-digest attribute value does not match calculated value\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// RFC 3852 11.4 Validate countersignature attribute(s)\n\t\t\t{\n            \tAsn1.Cms.AttributeTable signedAttrTable = this.SignedAttributes;\n            \tif (signedAttrTable != null\n                \t&& signedAttrTable.GetAll(CmsAttributes.CounterSignature).Count > 0)\n            \t{\n                \tthrow new CmsException(\"A countersignature attribute MUST NOT be a signed attribute\");\n            \t}\n\n            \tAsn1.Cms.AttributeTable unsignedAttrTable = this.UnsignedAttributes;\n            \tif (unsignedAttrTable != null)\n            \t{\n\t\t\t\t\tforeach (Asn1.Cms.Attribute csAttr in unsignedAttrTable.GetAll(CmsAttributes.CounterSignature))\n\t                {\n                    \tif (csAttr.AttrValues.Count < 1)\n\t                        throw new CmsException(\"A countersignature attribute MUST contain at least one AttributeValue\");\n\n\t\t\t\t\t\t// Note: We don't recursively validate the countersignature value\n    \t            }\n\t            }\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tsig.Init(false, key);\n\n\t\t\t\tif (signedAttributeSet == null)\n\t\t\t\t{\n\t\t\t\t\tif (digestCalculator != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// need to decrypt signature and check message bytes\n\t\t\t\t\t\treturn VerifyDigest(resultDigest, key, this.GetSignature());\n\t\t\t\t\t}\n\t\t\t\t\telse if (content != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t// TODO Use raw signature of the hash value instead\n\t\t\t\t\t\tcontent.Write(new SigOutputStream(sig));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbyte[] tmp = this.GetEncodedSignedAttributes();\n\t\t\t\t\tsig.BlockUpdate(tmp, 0, tmp.Length);\n\t\t\t\t}\n\n\t\t\t\treturn sig.VerifySignature(this.GetSignature());\n\t\t\t}\n\t\t\tcatch (InvalidKeyException e)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"key not appropriate to signature in message.\", e);\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"can't process mime object to create signature.\", e);\n\t\t\t}\n\t\t\tcatch (SignatureException e)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"invalid signature format in message: \" + e.Message, e);\n\t\t\t}\n\t\t}\n\n\t\tprivate bool IsNull(\n\t\t\tAsn1Encodable o)\n\t\t{\n\t\t\treturn (o is Asn1Null) || (o == null);\n\t\t}\n\n\t\tprivate DigestInfo DerDecode(\n\t\t\tbyte[] encoding)\n\t\t{\n\t\t\tif (encoding[0] != (int)(Asn1Tags.Constructed | Asn1Tags.Sequence))\n\t\t\t{\n\t\t\t\tthrow new IOException(\"not a digest info object\");\n\t\t\t}\n\n\t\t\tDigestInfo digInfo = DigestInfo.GetInstance(Asn1Object.FromByteArray(encoding));\n\n\t\t\t// length check to avoid Bleichenbacher vulnerability\n\n\t\t\tif (digInfo.GetEncoded().Length != encoding.Length)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"malformed RSA signature\");\n\t\t\t}\n\n\t\t\treturn digInfo;\n\t\t}\n\n\t\tprivate bool VerifyDigest(\n\t\t\tbyte[]\t\t\t\t\tdigest,\n\t\t\tAsymmetricKeyParameter\tkey,\n\t\t\tbyte[]\t\t\t\t\tsignature)\n\t\t{\n\t\t\tstring algorithm = Helper.GetEncryptionAlgName(this.EncryptionAlgOid);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif (algorithm.Equals(\"RSA\"))\n\t\t\t\t{\n\t\t\t\t\tIBufferedCipher c = CmsEnvelopedHelper.Instance.CreateAsymmetricCipher(\"RSA/ECB/PKCS1Padding\");\n\n\t\t\t\t\tc.Init(false, key);\n\n\t\t\t\t\tbyte[] decrypt = c.DoFinal(signature);\n\n\t\t\t\t\tDigestInfo digInfo = DerDecode(decrypt);\n\n\t\t\t\t\tif (!digInfo.AlgorithmID.ObjectID.Equals(digestAlgorithm.ObjectID))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!IsNull(digInfo.AlgorithmID.Parameters))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tbyte[] sigHash = digInfo.GetDigest();\n\n\t\t\t\t\treturn Arrays.ConstantTimeAreEqual(digest, sigHash);\n\t\t\t\t}\n\t\t\t\telse if (algorithm.Equals(\"DSA\"))\n\t\t\t\t{\n\t\t\t\t\tISigner sig = SignerUtilities.GetSigner(\"NONEwithDSA\");\n\n\t\t\t\t\tsig.Init(false, key);\n\n\t\t\t\t\tsig.BlockUpdate(digest, 0, digest.Length);\n\n\t\t\t\t\treturn sig.VerifySignature(signature);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tthrow new CmsException(\"algorithm: \" + algorithm + \" not supported in base signatures.\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (SecurityUtilityException e)\n\t\t\t{\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t\tcatch (GeneralSecurityException e)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"Exception processing signature: \" + e, e);\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"Exception decoding signature: \" + e, e);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t* verify that the given public key successfully handles and confirms the\n\t\t* signature associated with this signer.\n\t\t*/\n\t\tpublic bool Verify(\n\t\t\tAsymmetricKeyParameter pubKey)\n\t\t{\n\t\t\tif (pubKey.IsPrivate)\n\t\t\t\tthrow new ArgumentException(\"Expected public key\", \"pubKey\");\n\n\t\t\t// Optional, but still need to validate if present\n\t\t\tGetSigningTime();\n\n\t\t\treturn DoVerify(pubKey);\n\t\t}\n\n\t\t/**\n\t\t* verify that the given certificate successfully handles and confirms\n\t\t* the signature associated with this signer and, if a signingTime\n\t\t* attribute is available, that the certificate was valid at the time the\n\t\t* signature was generated.\n\t\t*/\n\t\tpublic bool Verify(\n\t\t\tX509Certificate cert)\n\t\t{\n\t\t\tAsn1.Cms.Time signingTime = GetSigningTime();\n\t\t\tif (signingTime != null)\n\t\t\t{\n\t\t\t\tcert.CheckValidity(signingTime.Date);\n\t\t\t}\n\n\t\t\treturn DoVerify(cert.GetPublicKey());\n\t\t}\n\n\t\t/**\n\t\t* Return the base ASN.1 CMS structure that this object contains.\n\t\t*\n\t\t* @return an object containing a CMS SignerInfo structure.\n\t\t*/\n\t\tpublic SignerInfo ToSignerInfo()\n\t\t{\n\t\t\treturn info;\n\t\t}\n\n\t\tprivate Asn1Object GetSingleValuedSignedAttribute(\n\t\t\tDerObjectIdentifier attrOID, string printableName)\n\t\t{\n\n\t\t\tAsn1.Cms.AttributeTable unsignedAttrTable = this.UnsignedAttributes;\n\t\t\tif (unsignedAttrTable != null\n\t\t\t\t&& unsignedAttrTable.GetAll(attrOID).Count > 0)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"The \" + printableName\n\t\t\t\t\t+ \" attribute MUST NOT be an unsigned attribute\");\n\t\t\t}\n\n\t\t\tAsn1.Cms.AttributeTable signedAttrTable = this.SignedAttributes;\n\t\t\tif (signedAttrTable == null)\n\t\t\t{\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\tAsn1EncodableVector v = signedAttrTable.GetAll(attrOID);\n\t\t\tswitch (v.Count)\n\t\t\t{\n\t\t\t\tcase 0:\n\t\t\t\t\treturn null;\n\t\t\t\tcase 1:\n\t\t\t\t\tAsn1.Cms.Attribute t = (Asn1.Cms.Attribute) v[0];\n\t\t\t\t\tAsn1Set attrValues = t.AttrValues;\n\n\t\t\t\t\tif (attrValues.Count != 1)\n\t\t\t\t\t\tthrow new CmsException(\"A \" + printableName\n\t\t\t\t\t\t\t+ \" attribute MUST have a single attribute value\");\n\n\t\t\t\t\treturn attrValues[0].ToAsn1Object();\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new CmsException(\"The SignedAttributes in a signerInfo MUST NOT include multiple instances of the \"\n\t\t\t\t\t\t+ printableName + \" attribute\");\n\t\t\t}\n\t\t}\n\n\t\tprivate Asn1.Cms.Time GetSigningTime()\n\t\t{\n\t\t\tAsn1Object validSigningTime = GetSingleValuedSignedAttribute(\n\t\t\t\tCmsAttributes.SigningTime, \"signing-time\");\n\n\t\t\tif (validSigningTime == null)\n\t\t\t\treturn null;\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn Asn1.Cms.Time.GetInstance(validSigningTime);\n\t\t\t}\n\t\t\tcatch (ArgumentException)\n\t\t\t{\n\t\t\t\tthrow new CmsException(\"signing-time attribute value not a valid 'Time' structure\");\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t* Return a signer information object with the passed in unsigned\n\t\t* attributes replacing the ones that are current associated with\n\t\t* the object passed in.\n\t\t*\n\t\t* @param signerInformation the signerInfo to be used as the basis.\n\t\t* @param unsignedAttributes the unsigned attributes to add.\n\t\t* @return a copy of the original SignerInformationObject with the changed attributes.\n\t\t*/\n\t\tpublic static SignerInformation ReplaceUnsignedAttributes(\n\t\t\tSignerInformation\t\tsignerInformation,\n\t\t\tAsn1.Cms.AttributeTable\tunsignedAttributes)\n\t\t{\n\t\t\tSignerInfo sInfo = signerInformation.info;\n\t\t\tAsn1Set unsignedAttr = null;\n\n\t\t\tif (unsignedAttributes != null)\n\t\t\t{\n\t\t\t\tunsignedAttr = new DerSet(unsignedAttributes.ToAsn1EncodableVector());\n\t\t\t}\n\n\t\t\treturn new SignerInformation(\n\t\t\t\tnew SignerInfo(\n\t\t\t\t\tsInfo.SignerID,\n\t\t\t\t\tsInfo.DigestAlgorithm,\n\t\t\t\t\tsInfo.AuthenticatedAttributes,\n\t\t\t\t\tsInfo.DigestEncryptionAlgorithm,\n\t\t\t\t\tsInfo.EncryptedDigest,\n\t\t\t\t\tunsignedAttr),\n\t\t\t\tsignerInformation.contentType,\n\t\t\t\tsignerInformation.content,\n\t\t\t\tnull);\n\t\t}\n\n\t\t/**\n\t\t * Return a signer information object with passed in SignerInformationStore representing counter\n\t\t * signatures attached as an unsigned attribute.\n\t\t *\n\t\t * @param signerInformation the signerInfo to be used as the basis.\n\t\t * @param counterSigners signer info objects carrying counter signature.\n\t\t * @return a copy of the original SignerInformationObject with the changed attributes.\n\t\t */\n\t\tpublic static SignerInformation AddCounterSigners(\n\t\t\tSignerInformation\t\tsignerInformation,\n\t\t\tSignerInformationStore\tcounterSigners)\n\t\t{\n\t\t\t// TODO Perform checks from RFC 3852 11.4\n\n\t\t\tSignerInfo sInfo = signerInformation.info;\n\t\t\tAsn1.Cms.AttributeTable unsignedAttr = signerInformation.UnsignedAttributes;\n\t\t\tAsn1EncodableVector v;\n\n\t\t\tif (unsignedAttr != null)\n\t\t\t{\n\t\t\t\tv = unsignedAttr.ToAsn1EncodableVector();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tv = new Asn1EncodableVector();\n\t\t\t}\n\n\t\t\tAsn1EncodableVector sigs = new Asn1EncodableVector();\n\n\t\t\tforeach (SignerInformation sigInf in counterSigners.GetSigners())\n\t\t\t{\n\t\t\t\tsigs.Add(sigInf.ToSignerInfo());\n\t\t\t}\n\n\t\t\tv.Add(new Asn1.Cms.Attribute(CmsAttributes.CounterSignature, new DerSet(sigs)));\n\n\t\t\treturn new SignerInformation(\n\t\t\t\tnew SignerInfo(\n\t\t\t\t\tsInfo.SignerID,\n\t\t\t\t\tsInfo.DigestAlgorithm,\n\t\t\t\t\tsInfo.AuthenticatedAttributes,\n\t\t\t\t\tsInfo.DigestEncryptionAlgorithm,\n\t\t\t\t\tsInfo.EncryptedDigest,\n\t\t\t\t\tnew DerSet(v)),\n\t\t\t\tsignerInformation.contentType,\n\t\t\t\tsignerInformation.content,\n\t\t\t\tnull);\n\t\t}\n\t}\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// The GitVersion runner.\n    /// </summary>\n    public sealed class GitVersionRunner : Tool<GitVersionSettings>\n    {\n        private readonly ICakeLog _log;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"GitVersionRunner\"/> class.\n        /// </summary>\n        /// <param name=\"fileSystem\">The file system.</param>\n        /// <param name=\"environment\">The environment.</param>\n        /// <param name=\"processRunner\">The process runner.</param>\n        /// <param name=\"tools\">The tool locator.</param>\n        /// <param name=\"log\">The log.</param>\n        public GitVersionRunner(\n            IFileSystem fileSystem,\n            ICakeEnvironment environment,\n            IProcessRunner processRunner,\n            IToolLocator tools,\n            ICakeLog log) : base(fileSystem, environment, processRunner, tools)\n        {\n            _log = log;\n        }\n\n        /// <summary>\n        /// Runs GitVersion and processes the results.\n        /// </summary>\n        /// <param name=\"settings\">The settings.</param>\n        /// <returns>A task with the GitVersion results.</returns>\n        public GitVersion Run(GitVersionSettings settings)\n        {\n            if (settings == null)\n            {\n                throw new ArgumentNullException(nameof(settings));\n            }\n\n            if (settings.OutputType != GitVersionOutput.BuildServer)\n            {\n                var jsonString = string.Empty;\n\n                Run(settings, GetArguments(settings), new ProcessSettings { RedirectStandardOutput = true },\n                process => jsonString = string.Join(\"\\n\", process.GetStandardOutput()));\n\n                var jsonSerializer = new DataContractJsonSerializer(typeof(GitVersionInternal));\n\n                using (var jsonStream = new MemoryStream(Encoding.UTF8.GetBytes(jsonString)))\n                {\n                    return (jsonSerializer.ReadObject(jsonStream) as GitVersionInternal)?.GitVersion;\n                }\n            }\n\n            Run(settings, GetArguments(settings));\n\n            return new GitVersion();\n        }\n\n        private ProcessArgumentBuilder GetArguments(GitVersionSettings settings)\n        {\n            var builder = new ProcessArgumentBuilder();\n\n            if (settings.OutputType.HasValue)\n            {\n                switch (settings.OutputType.Value)\n                {\n                    case GitVersionOutput.Json:\n                        builder.Append(\"-output\");\n                        builder.Append(\"json\");\n                        break;\n                    case GitVersionOutput.BuildServer:\n                        builder.Append(\"-output\");\n                        builder.Append(\"buildserver\");\n                        break;\n                }\n            }\n\n            if (!string.IsNullOrWhiteSpace(settings.ShowVariable))\n            {\n                builder.Append(\"-showvariable\");\n                builder.Append(settings.ShowVariable);\n            }\n\n            if (!string.IsNullOrWhiteSpace(settings.UserName))\n            {\n                builder.Append(\"-u\");\n                builder.AppendQuoted(settings.UserName);\n\n                builder.Append(\"-p\");\n                builder.AppendQuotedSecret(settings.Password);\n            }\n\n            if (settings.UpdateAssemblyInfo)\n            {\n                builder.Append(\"-updateassemblyinfo\");\n\n                if (settings.UpdateAssemblyInfoFilePath != null)\n                {\n                    builder.AppendQuoted(settings.UpdateAssemblyInfoFilePath.FullPath);\n                }\n            }\n\n            if (settings.RepositoryPath != null)\n            {\n                builder.Append(\"-targetpath\");\n                builder.AppendQuoted(settings.RepositoryPath.FullPath);\n            }\n            else if (!string.IsNullOrWhiteSpace(settings.Url))\n            {\n                builder.Append(\"-url\");\n                builder.AppendQuoted(settings.Url);\n\n                if (!string.IsNullOrWhiteSpace(settings.Branch))\n                {\n                    builder.Append(\"-b\");\n                    builder.Append(settings.Branch);\n                }\n                else\n                {\n                    _log.Warning(\"If you leave the branch name for GitVersion unset, it will fallback to the default branch for the repository.\");\n                }\n\n                if (!string.IsNullOrWhiteSpace(settings.Commit))\n                {\n                    builder.Append(\"-c\");\n                    builder.AppendQuoted(settings.Commit);\n                }\n\n                if (settings.DynamicRepositoryPath != null)\n                {\n                    builder.Append(\"-dynamicRepoLocation\");\n                    builder.AppendQuoted(settings.DynamicRepositoryPath.FullPath);\n                }\n            }\n\n            if (settings.LogFilePath != null)\n            {\n                builder.Append(\"-l\");\n                builder.AppendQuoted(settings.LogFilePath.FullPath);\n            }\n\n            if (settings.NoFetch)\n            {\n                builder.Append(\"-nofetch\");\n            }\n\n            if (settings.Verbosity.HasValue)\n            {\n                switch (settings.Verbosity.Value)\n                {\n                    case GitVersionVerbosity.None:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.None));\n                        break;\n                    case GitVersionVerbosity.Debug:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.Debug));\n                        break;\n                    case GitVersionVerbosity.Info:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.Info));\n                        break;\n                    case GitVersionVerbosity.Warn:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.Warn));\n                        break;\n                    case GitVersionVerbosity.Error:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.Error));\n                        break;\n                }\n            }\n            else\n            {\n                switch (_log.Verbosity)\n                {\n                    case Verbosity.Quiet:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.None));\n                        break;\n                    case Verbosity.Diagnostic:\n                    case Verbosity.Verbose:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.Debug));\n                        break;\n                    case Verbosity.Minimal:\n                        builder.Append(\"-verbosity\");\n                        builder.Append(nameof(GitVersionVerbosity.Error));\n                        break;\n                }\n            }\n\n            return builder;\n        }\n\n        /// <summary>\n        /// Gets the name of the tool.\n        /// </summary>\n        /// <returns>The name of the tool.</returns>\n        protected override string GetToolName()\n        {\n            return \"GitVersion\";\n        }\n\n        /// <summary>\n        /// Gets the possible names of the tool executable.\n        /// </summary>\n        /// <returns>The tool executable name.</returns>\n        protected override IEnumerable<string> GetToolExecutableNames()\n        {\n            return new[] { \"GitVersion.exe\", \"dotnet-gitversion\", \"dotnet-gitversion.exe\" };\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class TodoModule : NancyModule\n    {\n        private static readonly Logger Log = LogManager.GetCurrentClassLogger();\n        private readonly ITodoService _todoService;\n        private readonly IServiceBus _bus;\n\n        public TodoModule(IAppSettings appSettings, ITodoService todoService, IServiceBus bus)\n        {\n            _todoService = todoService;\n            _bus = bus;\n\n            Post[\"/todo\"] = _ =>\n            {\n                var slashCommand = this.Bind<SlashCommand>();\n                if (slashCommand == null ||\n                    slashCommand.command.Missing())\n                {\n                    Log.Info(\"Rejected an incoming slash command (unable to parse request body).\");\n                    return HttpStatusCode.BadRequest.WithReason(\"Unable to parse slash command.\");\n                }\n                if (!appSettings.Get(\"todo:slackSlashCommandToken\").Equals(slashCommand.token))\n                {\n                    Log.Info(\"Blocked an unauthorized slash command.\");\n                    return HttpStatusCode.Unauthorized.WithReason(\"Missing or invalid token.\");\n                }\n                if (!slashCommand.command.Equals(\"/todo\", StringComparison.InvariantCultureIgnoreCase))\n                {\n                    Log.Info(\"Rejected an incoming slash command ({0} is not handled by this module).\", slashCommand.command);\n                    return HttpStatusCode.BadRequest.WithReason(\"Unsupported slash command.\");\n                }\n\n                var responseText = HandleTodo(slashCommand);\n                if (responseText.Missing())\n                {\n                    return HttpStatusCode.OK;\n                }\n                return responseText;\n            };\n        }\n\n        private string HandleTodo(SlashCommand message)\n        {\n            var listId = message.channel_id;\n            var list = _todoService.GetItems(message.user_id, listId).ToArray();\n            var @operator = message.text.SubstringByWords(0, 1);\n            if (!@operator.Missing())\n            {\n                @operator = @operator.ToLowerInvariant();\n            }\n            switch (@operator)\n            {\n                case \"\":\n                    {\n                        // Just echo the list\n                        break;\n                    }\n                case \"show\":\n                    {\n                        _bus.Publish(new MessageToSlack\n                        {\n                            channel = listId,\n                            text = list.ToSlackString()\n                        });\n                        return null;\n                    }\n                case \"add\":\n                    {\n                        var todoText = message.text.SubstringByWords(1);\n                        if (todoText.Missing())\n                        {\n                            return null;\n                        }\n                        _todoService.AddItem(message.user_id, listId, todoText);\n                        break;\n                    }\n                case \"tick\":\n                    {\n                        var todoItemId = message.text.SubstringByWords(1, 1);\n                        if (todoItemId.Missing())\n                        {\n                            return null;\n                        }\n                        var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\";\n                        try\n                        {\n                            _todoService.TickItem(message.user_id, listId, todoItemId, force);\n                        }\n                        catch (TodoItemClaimedBySomeoneElseException ex)\n                        {\n                            return string.Format(\n                                \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\", \n                                ex.UserId,\n                                @operator,\n                                todoItemId);\n                        }\n                        break;\n                    }\n                case \"untick\":\n                    {\n                        var todoItemId = message.text.SubstringByWords(1, 1);\n                        if (todoItemId.Missing())\n                        {\n                            return null;\n                        }\n                        _todoService.UntickItem(message.user_id, listId, todoItemId);\n                        break;\n                    }\n                case \"remove\":\n                    {\n                        var todoItemId = message.text.SubstringByWords(1, 1);\n                        if (todoItemId.Missing())\n                        {\n                            return null;\n                        }\n                        var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\";\n                        try\n                        {\n                            _todoService.RemoveItem(message.user_id, listId, todoItemId, force);\n                        }\n                        catch (TodoItemClaimedBySomeoneElseException ex)\n                        {\n                            return string.Format(\n                                \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\",\n                                ex.UserId,\n                                @operator,\n                                todoItemId);\n                        }\n                        break;\n                    }\n                case \"trim\":\n                    {\n                        _todoService.ClearItems(message.user_id, listId, includeUnticked: false, force: false);\n                        break;\n                    }\n                case \"clear\":\n                    {\n                        var force = message.text.SubstringByWords(1, 1).ToLowerInvariant() == \"force\";\n                        try\n                        {\n                            _todoService.ClearItems(message.user_id, listId, includeUnticked: true, force: force);\n                        }\n                        catch (TodoItemClaimedBySomeoneElseException ex)\n                        {\n                            return string.Format(\n                                \"There are tasks claimed by other people. Use `/todo {0} force` to override.\",\n                                @operator);\n                        }\n                        break;\n                    }\n                case \"claim\":\n                {\n                    var todoItemId = message.text.SubstringByWords(1, 1);\n                    if (todoItemId.Missing())\n                    {\n                        return null;\n                    }\n                    var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\";\n                    try\n                    {\n                        _todoService.ClaimItem(message.user_id, listId, todoItemId, force);\n                    }\n                    catch (TodoItemClaimedBySomeoneElseException ex)\n                    {\n                        return string.Format(\n                            \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\",\n                            ex.UserId,\n                            @operator,\n                            todoItemId);\n                    }\n                    break;\n                }\n                case \"free\":\n                {\n                    var todoItemId = message.text.SubstringByWords(1, 1);\n                    if (todoItemId.Missing())\n                    {\n                        return null;\n                    }\n                    var force = message.text.SubstringByWords(2, 1).ToLowerInvariant() == \"force\";\n                    try\n                    {\n                        _todoService.FreeItem(message.user_id, listId, todoItemId, force);\n                    }\n                    catch (TodoItemClaimedBySomeoneElseException ex)\n                    {\n                        return string.Format(\n                            \"This task is claimed by <@{0}>. Use `/todo {1} {2} force` to override.\",\n                            ex.UserId,\n                            @operator,\n                            todoItemId);\n                    }\n                    break;\n                }\n                case \"help\":\n                    {\n                        return \"TODO\"; // TODO Return usage info\n                    }\n                default:\n                    {\n                        return \"Sorry, that is not a valid syntax for the `/todo` command. Use `/todo help` to see available operations.\";\n                    }\n            }\n            list = _todoService.GetItems(message.user_id, listId).ToArray();\n            return list.ToSlackString();\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public partial class fetchMessages_args : TBase\n    {\n      private long _localTs;\n      private int _count;\n\n      public long LocalTs\n      {\n        get\n        {\n          return _localTs;\n        }\n        set\n        {\n          __isset.localTs = true;\n          this._localTs = value;\n        }\n      }\n\n      public int Count\n      {\n        get\n        {\n          return _count;\n        }\n        set\n        {\n          __isset.count = true;\n          this._count = value;\n        }\n      }\n\n\n      public Isset __isset;\n      #if !SILVERLIGHT\n      [Serializable]\n      #endif\n      public struct Isset {\n        public bool localTs;\n        public bool count;\n      }\n\n      public fetchMessages_args() {\n      }\n\n      public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 2:\n              if (field.Type == TType.I64) {\n                LocalTs = iprot.ReadI64();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 3:\n              if (field.Type == TType.I32) {\n                Count = iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }\n\n      public void Write(TProtocol oprot) {\n        TStruct struc = new TStruct(\"fetchMessages_args\");\n        oprot.WriteStructBegin(struc);\n        TField field = new TField();\n        if (__isset.localTs) {\n          field.Name = \"localTs\";\n          field.Type = TType.I64;\n          field.ID = 2;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI64(LocalTs);\n          oprot.WriteFieldEnd();\n        }\n        if (__isset.count) {\n          field.Name = \"count\";\n          field.Type = TType.I32;\n          field.ID = 3;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32(Count);\n          oprot.WriteFieldEnd();\n        }\n        oprot.WriteFieldStop();\n        oprot.WriteStructEnd();\n      }\n\n      public override string ToString() {\n        StringBuilder sb = new StringBuilder(\"fetchMessages_args(\");\n        sb.Append(\"LocalTs: \");\n        sb.Append(LocalTs);\n        sb.Append(\",Count: \");\n        sb.Append(Count);\n        sb.Append(\")\");\n        return sb.ToString();\n      }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public partial class sendMessageIgnored_args : TBase\n    {\n      private int _seq;\n      private string _consumer;\n      private List<string> _messageIds;\n\n      public int Seq\n      {\n        get\n        {\n          return _seq;\n        }\n        set\n        {\n          __isset.seq = true;\n          this._seq = value;\n        }\n      }\n\n      public string Consumer\n      {\n        get\n        {\n          return _consumer;\n        }\n        set\n        {\n          __isset.consumer = true;\n          this._consumer = value;\n        }\n      }\n\n      public List<string> MessageIds\n      {\n        get\n        {\n          return _messageIds;\n        }\n        set\n        {\n          __isset.messageIds = true;\n          this._messageIds = value;\n        }\n      }\n\n\n      public Isset __isset;\n      #if !SILVERLIGHT\n      [Serializable]\n      #endif\n      public struct Isset {\n        public bool seq;\n        public bool consumer;\n        public bool messageIds;\n      }\n\n      public sendMessageIgnored_args() {\n      }\n\n      public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 1:\n              if (field.Type == TType.I32) {\n                Seq = iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 2:\n              if (field.Type == TType.String) {\n                Consumer = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 3:\n              if (field.Type == TType.List) {\n                {\n                  MessageIds = new List<string>();\n                  TList _list393 = iprot.ReadListBegin();\n                  for( int _i394 = 0; _i394 < _list393.Count; ++_i394)\n                  {\n                    string _elem395 = null;\n                    _elem395 = iprot.ReadString();\n                    MessageIds.Add(_elem395);\n                  }\n                  iprot.ReadListEnd();\n                }\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }\n\n      public void Write(TProtocol oprot) {\n        TStruct struc = new TStruct(\"sendMessageIgnored_args\");\n        oprot.WriteStructBegin(struc);\n        TField field = new TField();\n        if (__isset.seq) {\n          field.Name = \"seq\";\n          field.Type = TType.I32;\n          field.ID = 1;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32(Seq);\n          oprot.WriteFieldEnd();\n        }\n        if (Consumer != null && __isset.consumer) {\n          field.Name = \"consumer\";\n          field.Type = TType.String;\n          field.ID = 2;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(Consumer);\n          oprot.WriteFieldEnd();\n        }\n        if (MessageIds != null && __isset.messageIds) {\n          field.Name = \"messageIds\";\n          field.Type = TType.List;\n          field.ID = 3;\n          oprot.WriteFieldBegin(field);\n          {\n            oprot.WriteListBegin(new TList(TType.String, MessageIds.Count));\n            foreach (string _iter396 in MessageIds)\n            {\n              oprot.WriteString(_iter396);\n            }\n            oprot.WriteListEnd();\n          }\n          oprot.WriteFieldEnd();\n        }\n        oprot.WriteFieldStop();\n        oprot.WriteStructEnd();\n      }\n\n      public override string ToString() {\n        StringBuilder sb = new StringBuilder(\"sendMessageIgnored_args(\");\n        sb.Append(\"Seq: \");\n        sb.Append(Seq);\n        sb.Append(\",Consumer: \");\n        sb.Append(Consumer);\n        sb.Append(\",MessageIds: \");\n        sb.Append(MessageIds);\n        sb.Append(\")\");\n        return sb.ToString();\n      }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "    internal partial class ManagementController : IDisposable\n    {\n        private StorageManagementClient _storageManagementClient;\n        private ComputeManagementClient _computeManagementClient;\n        private PublishSettingsSubscriptionItem _publishSettingCreds;\n        private ManagementControllerParameters _parameters;\n\n        public ManagementController(ManagementControllerParameters parameters)\n        {\n            _parameters = parameters;\n\n            // To authenticate against the Microsoft Azure service management API we require management certificate\n            // load this from a publish settings file and later use it with the Service Management Libraries\n            var credential = GetSubscriptionCloudCredentials(parameters.PublishSettingsFilePath);\n\n            _storageManagementClient = CloudContext.Clients.CreateStorageManagementClient(credential);\n            _computeManagementClient = CloudContext.Clients.CreateComputeManagementClient(credential);\n\n        }\n\n        private SubscriptionCloudCredentials GetSubscriptionCloudCredentials(string publishSettingsFilePath)\n        {\n            using (var fs = File.OpenRead(publishSettingsFilePath))\n            {\n                var document = XDocument.Load(fs);\n                var subscriptions =\n                    from e in document.Descendants(\"Subscription\")\n                    select e;\n\n                if (subscriptions.Count() >= 1)\n                {\n                    // use first subscription in the publish settings file\n                    var subscription = subscriptions.First();\n\n                    _publishSettingCreds = new PublishSettingsSubscriptionItem\n                    {\n                        SubscriptionName = subscription.Attribute(\"Name\").Value,\n                        SubscriptionId = subscription.Attribute(\"Id\").Value,\n                        ManagementCertificate = subscription.Attribute(\"ManagementCertificate\").Value\n                    };\n                }\n                else\n                {\n                    Console.WriteLine(\"Invalid publishsettings file: Subscription not found.\");\n                }\n            }\n\n            return CertificateAuthenticationHelper.GetCredentials(_publishSettingCreds.SubscriptionId, _publishSettingCreds.ManagementCertificate);\n        }\n\n        internal async Task CreateStorageAccount()\n        {\n            //Create a storage account in the given region\n            await _storageManagementClient.StorageAccounts.CreateAsync(\n                new StorageAccountCreateParameters\n                {\n                    Location = _parameters.Region,\n                    Name = _parameters.StorageAccountName,\n                    AccountType = _parameters.StorageAccountType,\n                });\n        }\n\n        internal async Task<string> GetStorageAccountConnectionString()\n        {\n            //Retrieve the storage account keys\n            var keys = await _storageManagementClient.StorageAccounts.GetKeysAsync(_parameters.StorageAccountName);\n\n            string connectionString = string.Format(\n                CultureInfo.InvariantCulture,\n                \"DefaultEndpointsProtocol=https;AccountName={0};AccountKey={1}\",\n                _parameters.StorageAccountName, keys.SecondaryKey);\n\n            return connectionString;\n        }\n\n        internal async Task CreateCloudService()\n        {\n            //Create the hosted service\n            await _computeManagementClient.HostedServices.CreateAsync(new HostedServiceCreateParameters\n            {\n                Location = _parameters.Region,\n                ServiceName = _parameters.CloudServiceName\n            });\n        }\n\n        internal async Task<CloudBlockBlob> UploadDeploymentPackage()\n        {\n            //upload cloud service package and config to storage account\n            var storageConnectionString = await GetStorageAccountConnectionString();\n\n            var account = CloudStorageAccount.Parse(storageConnectionString);\n\n            var blobs = account.CreateCloudBlobClient();\n\n            var container = blobs.GetContainerReference(\"deployments\");\n\n            await container.CreateIfNotExistsAsync();\n\n            await container.SetPermissionsAsync(\n                new BlobContainerPermissions()\n                {\n                    PublicAccess = BlobContainerPublicAccessType.Container\n                });\n\n            var blob = container.GetBlockBlobReference(\n                Path.GetFileName(_parameters.ServicePackageFilePath));\n\n            await blob.UploadFromFileAsync(_parameters.ServicePackageFilePath, FileMode.Open);\n\n            return blob;\n        }\n\n        internal async Task DeployCloudService(Uri blobUri)\n        {\n            //deploy the cloud service into the provisioned slot using the uploaded *.cspkg and *.cscfg\n            await _computeManagementClient.Deployments.CreateAsync(_parameters.CloudServiceName,\n                    DeploymentSlot.Production,\n                    new DeploymentCreateParameters\n                    {\n                        Label = _parameters.CloudServiceName,\n                        Name = _parameters.CloudServiceName + \"Prod\",\n                        PackageUri = blobUri,\n                        Configuration = File.ReadAllText(_parameters.ServiceConfigurationFilePath),\n                        StartDeployment = true\n                    });\n        }\n\n        internal void TearDown()\n        {\n            //tear down everything that was created\n            _computeManagementClient.Deployments.DeleteBySlot(_parameters.CloudServiceName, DeploymentSlot.Production);\n            _computeManagementClient.HostedServices.Delete(_parameters.CloudServiceName);\n            _storageManagementClient.StorageAccounts.Delete(_parameters.StorageAccountName);\n        }\n\n        public void Dispose()\n        {\n            if (_storageManagementClient != null)\n                _storageManagementClient.Dispose();\n            if (_computeManagementClient != null)\n                _computeManagementClient.Dispose();\n        }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class QuestsInterface : BaseInterface\n    {\n        public uint Entry\n        {\n            get\n            {\n                if (_Owner == null)\n                    return 0;\n\n                if (_Owner.IsCreature())\n                    return _Owner.GetCreature().Entry;\n               \n                return 0;\n            }\n        }\n\n        #region Npc\n\n        public bool HasQuestStarter(UInt16 QuestID)\n        {\n            return WorldMgr.GetStartQuests(Entry).Find(info => info.Entry == QuestID) != null;\n        }\n\n        public bool hasQuestFinisher(UInt16 QuestID)\n        {\n            List<Quest> Quests = WorldMgr.GetFinishersQuests(Entry);\n            if(Quests != null)\n                return WorldMgr.GetFinishersQuests(Entry).Find(info => info.Entry == QuestID) != null;\n\n            return false;\n        }\n\n        public bool CreatureHasQuestToComplete(Player Plr)\n        {\n            if (Entry == 0)\n                return false;\n\n            List<Quest> Finisher = WorldMgr.GetFinishersQuests(Entry);\n            if (Finisher == null)\n                return false;\n\n            return  Finisher.Find(q => Plr.QtsInterface.CanEndQuest(q)) != null;\n        }\n\n        public bool CreatureHasQuestToAchieve(Player Plr)\n        {\n            if (Entry == 0)\n                return false;\n\n            List<Quest> Finisher = WorldMgr.GetFinishersQuests(Entry);\n            if (Finisher == null)\n                return false;\n\n            foreach (Quest Q in Finisher)\n            {\n                Character_quest CQ = Plr.QtsInterface.GetQuest(Q.Entry);\n                if (CQ != null && !CQ.Done && CQ.IsDone())\n                    return true;\n            }\n\n            return false;\n        }\n\n        public bool CreatureHasStartQuest(Player Plr)\n        {\n            if (Entry == 0)\n                return false;\n\n            List<Quest> Starter = WorldMgr.GetStartQuests(Entry);\n            if (Starter == null)\n                return false;\n\n            return Starter.Find(q => Plr.QtsInterface.CanStartQuest(q)) != null;\n        }\n\n        public void HandleInteract(Player Plr, Creature Crea, InteractMenu Menu)\n        {\n            if(Entry == 0)\n                return;\n\n            List<Quest> Starter = Crea.Spawn.Proto.StartingQuests;\n            List<Quest> Finisher = Crea.Spawn.Proto.FinishingQuests;\n            List<Quest> InProgress = Starter != null ? Starter.FindAll(info => Plr.QtsInterface.HasQuest(info.Entry) && !Plr.QtsInterface.HasDoneQuest(info.Entry)) : null;\n\n            string Text = WorldMgr.GetCreatureText(Entry);\n\n            if (Starter == null && Finisher == null && Text.Length <= 0 && InProgress == null)\n                return;\n\n            PacketOut Out = new PacketOut((byte)Opcodes.F_INTERACT_RESPONSE);\n            Out.WriteByte(0);\n            Out.WriteUInt16(_Owner.Oid);\n            Out.Fill(0, 3);\n            Out.WriteByte(0x60);\n            Out.WriteUInt32(0);\n            Out.WriteUInt16(Plr.Oid);\n\n            if (Starter != null)\n            {\n                List<Quest> Starts = Starter.FindAll(q => Plr.QtsInterface.CanStartQuest(q) );\n\n                Out.WriteByte((byte)Starts.Count);\n                foreach (Quest Q in Starts)\n                {\n                    Out.WriteByte(0);\n                    Out.WriteUInt16(Q.Entry);\n                    Out.WriteUInt16(0);\n                    Out.WritePascalString(Q.Name);\n                }\n            }\n            else\n                Out.WriteByte(0);\n\n            if (Finisher != null)\n            {\n                List<Quest> Finishs = Finisher.FindAll(q => Plr.QtsInterface.CanEndQuest(q));\n\n                Out.WriteByte((byte)Finishs.Count);\n                foreach (Quest Q in Finishs)\n                {\n                    Out.WriteByte(0);\n                    Out.WriteUInt16(Q.Entry);\n                    Out.WritePascalString(Q.Name);\n                }\n            }\n            else if (InProgress != null)\n            {\n                Out.WriteByte((byte)InProgress.Count);\n                foreach (Quest Q in InProgress)\n                {\n                    Out.WriteByte(0);\n                    Out.WriteUInt16(Q.Entry);\n                    Out.WritePascalString(Q.Name);\n                }\n            }\n            else\n                Out.WriteByte(0);\n\n            Out.WritePascalString(Text);\n            Out.WriteByte(0);\n\n            Plr.SendPacket(Out);\n        }\n\n        #endregion\n\n        #region Players\n\n        public Dictionary<ushort, Character_quest> _Quests = new Dictionary<ushort, Character_quest>();\n\n        public void Load(List<Character_quest> Quests)\n        {\n            if (Quests == null)\n                return;\n\n            foreach (Character_quest Quest in Quests)\n            {\n                Quest.Quest = WorldMgr.GetQuest(Quest.QuestID);\n                if (Quest.Quest == null)\n                    continue;\n\n                foreach (Character_Objectives Obj in Quest._Objectives)\n                    Obj.Objective = WorldMgr.GetQuestObjective(Obj.ObjectiveID);\n\n                if (!_Quests.ContainsKey(Quest.QuestID))\n                    _Quests.Add(Quest.QuestID, Quest);\n            }\n        }\n\n        public override void Save()\n        {\n            foreach (KeyValuePair<ushort, Character_quest> Kp in _Quests)\n                CharMgr.Database.SaveObject(Kp.Value);\n\n            // Lock? Threadsafe?\n            CharMgr._Chars[_Owner.GetPlayer().CharacterId].Quests = _Quests.Values.ToList<Character_quest>();\n        }\n\n        public bool HasQuest(UInt16 QuestID)\n        {\n            if (QuestID == 0)\n                return true;\n\n            return _Quests.ContainsKey(QuestID);\n        }\n\n        public bool HasFinishQuest(UInt16 QuestID)\n        {\n            if (QuestID == 0)\n                return true;\n\n            if (!HasQuest(QuestID))\n                return false;\n\n            return GetQuest(QuestID).IsDone();\n        }\n\n        public bool HasDoneQuest(UInt16 QuestID)\n        {\n            if (QuestID == 0)\n                return true;\n\n            if (!HasQuest(QuestID))\n                return false;\n\n            return GetQuest(QuestID).Done;\n        }\n\n        public Character_quest GetQuest(UInt16 QuestID)\n        {\n            Character_quest Quest;\n            _Quests.TryGetValue(QuestID, out Quest);\n            return Quest;\n        }\n\n        public bool CanStartQuest(Quest Quest)\n        {\n            if(GetPlayer() == null)\n                return false;\n\n            if (Quest == null)\n                return false;\n\n            // TODO : Fixe Starting Quests\n            if (HasQuest(Quest.Entry) || Quest.Level > (GetPlayer().Level+1) || (Quest.PrevQuest != 0 && !HasDoneQuest(Quest.PrevQuest)))\n                return false;\n\n            return true;\n        }\n\n        public bool CanEndQuest(Quest Quest)\n        {\n            if (GetPlayer() == null)\n                return false;\n\n            if (Quest == null)\n                return false;\n\n            if (!HasQuest(Quest.Entry) || !HasFinishQuest(Quest.Entry) || HasDoneQuest(Quest.Entry))\n                return false;\n\n            return true;\n        }\n\n        public bool AcceptQuest(UInt16 QuestID)\n        {\n            return AcceptQuest(WorldMgr.GetQuest(QuestID));\n        }\n\n        public bool AcceptQuest(Quest Quest)\n        {\n            if (Quest == null)\n                return false;\n\n            if (!CanStartQuest(Quest))\n                return false;\n\n            Character_quest CQuest = new Character_quest();\n            CQuest.QuestID = Quest.Entry;\n            CQuest.Done = false;\n            CQuest.CharacterId = GetPlayer().CharacterId;\n            CQuest.Quest = Quest;\n\n            foreach(Quest_Objectives QObj in Quest.Objectives)\n            {\n                Character_Objectives CObj = new Character_Objectives();\n                CObj.Quest = CQuest;\n                CObj._Count = 0;\n                CObj.Objective = QObj;\n                CObj.ObjectiveID = QObj.Guid;\n                CQuest._Objectives.Add(CObj);\n            }\n\n            CharMgr.Database.AddObject(CQuest);\n            _Quests.Add(Quest.Entry, CQuest);\n\n            SendQuestState(Quest, QuestCompletion.QUESTCOMPLETION_OFFER);\n\n            // This will make objects lootable if they contain a quest object.\n            updateObjects();\n\n            _Owner.EvtInterface.Notify(EventName.ON_ACCEPT_QUEST, _Owner, CQuest);\n            return true;\n        }\n\n        public void DeclineQuest(UInt16 QuestID)\n        {\n            Character_quest Quest = GetQuest(QuestID);\n            if (Quest == null)\n                return;\n\n            _Quests.Remove(Quest.QuestID);\n            SendQuestState(Quest.Quest, QuestCompletion.QUESTCOMPLETION_ABANDONED);\n            CharMgr.Database.DeleteObject(Quest);\n\n            // This will make objects unlootable if they were lootable because of a quest.\n            updateObjects();\n\n            // Update quest givers around\n            foreach (Object Obj in _Owner._ObjectRanged)\n            {\n                if (Obj.IsCreature())\n                    Obj.GetCreature().SendMeTo(_Owner.GetPlayer());\n            }\n\n            _Owner.EvtInterface.Notify(EventName.ON_ACCEPT_QUEST, _Owner, Quest);\n        }\n\n        public bool DoneQuest(UInt16 QuestID)\n        {\n             Character_quest Quest = GetQuest(QuestID);\n\n            if (Quest == null || !Quest.IsDone())\n                return false;\n\n            Player Plr = GetPlayer();\n\n            Dictionary<Item_Info, uint> Choices = GenerateRewards(Quest.Quest, Plr);\n\n            UInt16 FreeSlots = Plr.ItmInterface.GetTotalFreeInventorySlot();\n            if (FreeSlots < Quest.SelectedRewards.Count)\n            {\n                Plr.SendLocalizeString(\"\", Localized_text.TEXT_OVERAGE_CANT_SALVAGE);\n                return false;\n            }\n\n            foreach (Quest_Objectives Obj in Quest.Quest.Objectives)\n            {\n                if ((Objective_Type)Obj.ObjType == Objective_Type.QUEST_GET_ITEM)\n                {\n                    if (Obj.Item != null)\n                    {\n                        Plr.ItmInterface.RemoveAllItems(Obj.Item.Entry);\n                    }\n                }\n            }\n\n            byte num = 0;\n            foreach (KeyValuePair<Item_Info, uint> Kp in Choices)\n            {\n                if (Quest.SelectedRewards.Contains(num))\n                {\n                    Plr.ItmInterface.CreateItem(Kp.Key, (ushort)Kp.Value);\n                }\n                ++num;\n            }\n\n            Plr.AddXp(Quest.Quest.Xp);\n            Plr.AddMoney(Quest.Quest.Gold);\n\n            Quest.Done = true;\n            Quest.Dirty = true;\n            Quest.SelectedRewards.Clear();\n\n            SendQuestState(Quest.Quest, QuestCompletion.QUESTCOMPLETION_DONE);\n            CharMgr.Database.SaveObject(Quest);\n\n            _Owner.EvtInterface.Notify(EventName.ON_DONE_QUEST, _Owner, Quest);\n            return true;\n        }\n\n        public void FinishQuest(Quest Quest)\n        {\n            if (Quest == null)\n                return;\n\n            if (!HasFinishQuest(Quest.Entry))\n                return;\n        }\n\n        public void HandleEvent(Objective_Type Type, uint Entry, int Count, bool Group = false)\n        {\n            if (!Group && _Owner.IsPlayer() && _Owner.GetPlayer().GetGroup() != null)\n            {\n                Group Current = _Owner.GetPlayer().GetGroup();\n\n                lock (Current.Members)\n                {\n                    foreach (Player SubPlayer in Current.Members)\n                        if (SubPlayer != _Owner && SubPlayer.GetDistance(_Owner) < 150)\n                        {\n                            SubPlayer.QtsInterface.HandleEvent(Type, Entry, Count, true);\n                        }\n                }\n            }\n\n            foreach (KeyValuePair<ushort, Character_quest> QuestKp in _Quests)\n            {\n                foreach (Character_Objectives Objective in QuestKp.Value._Objectives)\n                {\n                    if (Objective.Objective.ObjType == (uint)Type && !Objective.IsDone())\n                    {\n                        bool CanAdd = false;\n                        int NewCount = Objective.Count;\n\n                        if (Type == Objective_Type.QUEST_SPEACK_TO || Type == Objective_Type.QUEST_KILL_MOB || Type == Objective_Type.QUEST_PROTECT_UNIT)\n                        {\n                            if (Objective.Objective.Creature != null && Entry == Objective.Objective.Creature.Entry)\n                            {\n                                CanAdd = true;\n                                NewCount += Count;\n                            }\n                        }\n                        else if (Type == Objective_Type.QUEST_GET_ITEM)\n                        {\n                            if (Objective.Objective.Item != null && Entry == Objective.Objective.Item.Entry)\n                            {\n                                CanAdd = true;\n                                NewCount = _Owner.GetPlayer().ItmInterface.GetItemCount(Entry);\n                            }\n                        }\n                        else if (Type == Objective_Type.QUEST_USE_GO)\n                        {\n                            if (Objective.Objective.GameObject != null && Entry == Objective.Objective.GameObject.Entry)\n                            {\n                                CanAdd = true;\n                                NewCount += Count;\n                            }\n                        }\n                        else if (Type == Objective_Type.QUEST_UNKNOWN)\n                        {\n                            if (Objective.Objective.Guid == Entry)\n                            {\n                                CanAdd = true;\n                                NewCount += Count;\n                            }\n                        }\n\n                        if (CanAdd)\n                        {\n                            Objective.Count = NewCount;\n                            QuestKp.Value.Dirty = true;\n                            SendQuestUpdate(QuestKp.Value);\n                            CharMgr.Database.SaveObject(QuestKp.Value);\n\n                            if (Objective.IsDone())\n                            {\n                                Creature Finisher;\n\n                                foreach (Object Obj in _Owner._ObjectRanged)\n                                {\n                                    if (Obj.IsCreature())\n                                    {\n                                        Finisher = Obj.GetCreature();\n                                        if (WorldMgr.HasQuestToFinish(Finisher.Entry, QuestKp.Value.Quest.Entry))\n                                            Finisher.SendMeTo(_Owner.GetPlayer());\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        public void SelectRewards(UInt16 QuestID, byte num)\n        {\n            Character_quest Quest = GetQuest(QuestID);\n            if (Quest == null || !Quest.IsDone())\n                return;\n\n            if (num > 0)\n                --num;\n\n            Log.Info(\"SelectRewards\", \"Selection de la recompence : \" + num);\n            Quest.SelectedRewards.Add(num);\n        }\n\n        #endregion\n\n        static public void BuildQuestInfo(PacketOut Out, Player Plr, Quest Q)\n        {\n            BuildQuestHeader(Out, Q, true);\n\n            BuildQuestRewards(Out, Plr, Q);\n\n            BuildObjectives(Out, Q.Objectives);\n\n            Out.WriteByte(0);\n        }\n        static public void BuildQuestHeader(PacketOut Out, Quest Q, bool Particular)\n        {\n            Out.WritePascalString(Q.Name);\n            Out.WriteUInt16((UInt16)Q.Description.Length);\n            Out.WriteStringBytes(Q.Description);\n            if (Particular)\n            {\n                Out.WriteUInt16((UInt16)Q.Particular.Length);\n                Out.WriteStringBytes(Q.Particular);\n            }\n            Out.WriteByte(1);\n            Out.WriteUInt32(Q.Gold);\n            Out.WriteUInt32(Q.Xp);\n\n        }\n\n        static public void BuildQuestInProgress(PacketOut Out, Quest Q, bool Particular)\n        {\n            Out.WritePascalString(Q.Name);\n\n            if (Q.ProgressText.Length > 0)\n            {\n                Out.WriteUInt16((UInt16)Q.ProgressText.Length);\n                Out.WriteStringBytes(Q.ProgressText);\n            }\n            else\n            {\n                Out.WriteUInt16((UInt16)Q.Particular.Length);\n                Out.WriteStringBytes(Q.Particular);\n            }\n\n            Out.WriteByte(1);\n        }\n\n        static public void BuildQuestComplete(PacketOut Out, Quest Q, bool Particular)\n        {\n            Out.WritePascalString(Q.Name);\n\n            if (Q.OnCompletionQuest.Length > 0)\n            {\n                Out.WriteUInt16((UInt16)Q.OnCompletionQuest.Length);\n                Out.WriteStringBytes(Q.OnCompletionQuest);\n            }\n            else\n            {\n                Out.WriteUInt16((UInt16)Q.Description.Length);\n                Out.WriteStringBytes(Q.Description);\n            }\n\n            if (Particular)\n            {\n                Out.WriteUInt16((UInt16)Q.Particular.Length);\n                Out.WriteStringBytes(Q.Particular);\n            }\n            Out.WriteByte(1);\n            Out.WriteUInt32(Q.Gold);\n            Out.WriteUInt32(Q.Xp);\n        }\n        static public void BuildQuestRewards(PacketOut Out, Player Plr, Quest Q)\n        {\n            Dictionary<Item_Info, uint> Choices = GenerateRewards(Q, Plr);\n\n            Out.WriteByte(Math.Min(Q.ChoiceCount,(byte)Choices.Count));\n            Out.WriteByte(0);\n            Out.WriteByte((byte)Choices.Count);\n\n            foreach (KeyValuePair<Item_Info, uint> Kp in Choices)\n                Item.BuildItem(ref Out, null, Kp.Key, 0, (ushort)Kp.Value);\n        }\n        static public void BuildQuestInteract(PacketOut Out,UInt16 QuestID, UInt16 SenderOid, UInt16 ReceiverOid)\n        {\n            Out.WriteUInt16(QuestID);\n            Out.WriteUInt16(0);\n\n            Out.WriteUInt16(SenderOid);\n            Out.WriteUInt16(0);\n\n            Out.WriteUInt16(ReceiverOid);\n        }\n\n        public void BuildQuest(UInt16 QuestID, Player Plr)\n        {\n            Quest Q = WorldMgr.GetQuest(QuestID);\n            if (Q == null)\n                return;\n\n            PacketOut Out = new PacketOut((byte)Opcodes.F_INTERACT_RESPONSE);\n            Out.WriteByte(1);\n            Out.WriteByte(1);\n\n            BuildQuestInteract(Out, Q.Entry, _Owner.Oid, Plr.Oid);\n\n            Out.WriteUInt16(0);\n\n            BuildQuestInfo(Out, Plr, Q);\n\n            Plr.SendPacket(Out);\n        }\n\n        public void BuildQuest(PacketOut Out, Quest Q)\n        {\n            Out.WriteByte(Q.ChoiceCount);\n            Out.WriteByte(0);\n        }\n\n        static public void BuildObjectives(PacketOut Out, List<Quest_Objectives> Objs)\n        {\n            Out.WriteByte((byte)Objs.Count);\n\n            foreach (Quest_Objectives Objective in Objs)\n            {\n                Out.WriteByte((byte)Objective.ObjCount);\n                Out.WritePascalString(Objective.Description);\n            }\n        }\n\n        static public void BuildObjectives(PacketOut Out, List<Character_Objectives> Objs)\n        {\n            Out.WriteByte((byte)Objs.Count);\n\n            foreach (Character_Objectives Objective in Objs)\n            {\n                Out.WriteByte((byte)Objective.Count);\n                Out.WriteByte((byte)Objective.Objective.ObjCount);\n                Out.WriteUInt16(0);\n                Out.WritePascalString(Objective.Objective.Description);\n            }\n        }\n\n        public void SendQuest(ushort QuestID)\n        {\n            Character_quest CQuest = GetQuest(QuestID);\n            SendQuest(CQuest);\n        }\n\n        public void SendQuests()\n        {\n            List<Character_quest> Quests = _Quests.Values.ToList<Character_quest>().FindAll(q => q.Done == false);\n\n            PacketOut Out = new PacketOut((byte)Opcodes.F_QUEST_LIST);\n            Out.WriteByte((byte)Quests.Count);\n            foreach (Character_quest Quest in Quests)\n            {\n                Out.WriteUInt16(Quest.QuestID);\n                Out.WriteByte(0);\n                Out.WritePascalString(Quest.Quest.Name);\n                Out.WriteByte(0);\n            }\n\n            GetPlayer().SendPacket(Out);\n        }\n\n        public void SendQuest(Character_quest CQuest)\n        {\n            if (CQuest == null)\n            {\n                Log.Error(\"QuestsInterface\", \"SendQuest CQuest == null\");\n                return;\n            }\n\n            PacketOut Packet = new PacketOut((byte)Opcodes.F_QUEST_INFO);\n            Packet.WriteUInt16(CQuest.QuestID);\n            Packet.WriteByte(0);\n            BuildQuestHeader(Packet, CQuest.Quest, true);\n\n            Dictionary<Item_Info, uint> Rewards = GenerateRewards(CQuest.Quest, GetPlayer());\n\n            Packet.WriteByte(CQuest.Quest.ChoiceCount);\n            Packet.WriteByte(0);\n            Packet.WriteByte((byte)Rewards.Count);\n\n            foreach (KeyValuePair<Item_Info, uint> Kp in Rewards)\n            {\n                Item.BuildItem(ref Packet, null, Kp.Key, 0, (ushort)Kp.Value);\n            }\n\n            Packet.WriteByte(0);\n\n            BuildObjectives(Packet, CQuest._Objectives);\n\n            Packet.WriteByte(1);\n\n            Packet.WritePascalString(CQuest.Quest.Name);\n            Packet.WritePascalString(\"Return to your giver\");\n\n            Packet.WriteUInt16(0x006A);\n            Packet.WriteUInt16(0x046D);\n            Packet.WriteUInt16(0x4D9E);\n            Packet.WriteUInt16(0xCB65);\n\n            Packet.Fill(0, 18);\n\n            GetPlayer().SendPacket(Packet);\n        }\n\n        public void SendQuestDoneInfo(Player Plr, UInt16 QuestID)\n        {\n            Character_quest Quest = Plr.QtsInterface.GetQuest(QuestID);\n\n            if (Quest == null)\n                return;\n\n            PacketOut Out = new PacketOut((byte)Opcodes.F_INTERACT_RESPONSE);\n            Out.WriteByte(3);\n            Out.WriteByte(0);\n\n            BuildQuestInteract(Out, Quest.QuestID, _Owner.Oid, Plr.Oid);\n\n            BuildQuestComplete(Out, Quest.Quest, false);\n\n            BuildQuestRewards(Out, Plr, Quest.Quest);\n\n            Plr.SendPacket(Out);\n        }\n\n        public void SendQuestInProgressInfo(Player Plr, UInt16 QuestID)\n        {\n            Character_quest Quest = Plr.QtsInterface.GetQuest(QuestID);\n\n            if (Quest == null)\n                return;\n\n            PacketOut Out = new PacketOut((byte)Opcodes.F_INTERACT_RESPONSE);\n            Out.WriteByte(2);\n            Out.WriteByte(1);\n\n            BuildQuestInteract(Out, Quest.QuestID, _Owner.Oid, Plr.Oid);\n\n            BuildQuestInProgress(Out, Quest.Quest, false);\n\n            Plr.SendPacket(Out);\n        }\n\n        public void SendQuestState(Quest Quest,QuestCompletion State)\n        {\n            PacketOut Out = new PacketOut((byte)Opcodes.F_QUEST_LIST_UPDATE);\n            Out.WriteUInt16(Quest.Entry);\n\n            if (State == QuestCompletion.QUESTCOMPLETION_ABANDONED || State == QuestCompletion.QUESTCOMPLETION_DONE)\n                Out.WriteByte(0);\n            else\n                Out.WriteByte(1);\n\n            Out.WriteByte((byte)(State == QuestCompletion.QUESTCOMPLETION_DONE ? 1 : 0));\n\n            Out.WriteUInt32(0x0000FFFF);\n            Out.WritePascalString(Quest.Name);\n            Out.WriteByte(0);\n            GetPlayer().SendPacket(Out);\n        }\n\n        public void SendQuestUpdate(Character_quest Quest)\n        {\n            if (GetPlayer() == null)\n                return;\n\n            PacketOut Out = new PacketOut((byte)Opcodes.F_QUEST_UPDATE);\n            Out.WriteUInt16(Quest.QuestID);\n            Out.WriteByte(Convert.ToByte(Quest.IsDone()));\n            Out.WriteByte((byte)Quest._Objectives.Count);\n            foreach (Character_Objectives Obj in Quest._Objectives)\n            {\n                Out.WriteByte((byte)Obj.Count);\n            }\n            Out.WriteUInt16(0);\n            GetPlayer().SendPacket(Out);\n        }\n\n        static public Dictionary<Item_Info,uint> GenerateRewards(Quest Q, Player Plr)\n        {\n            Dictionary<Item_Info,uint> Rewards = new Dictionary<Item_Info,uint>();\n\n            foreach (KeyValuePair<Item_Info, uint> Kp in Q.Rewards)\n                if (ItemsInterface.CanUse(Kp.Key, Plr, true, false, false, false, false))\n                    Rewards.Add(Kp.Key, Kp.Value);\n\n            return Rewards;\n        }\n\n        // For quests which require you to loot GameObjects this will update any objects\n        // around you and make them lootable if they have items you need for a quest.\n        // Notes: We could minimise the amount of SendMeTo's by checking if object are already\n        // flagged and unflag them or unflagged and need flagging. However it isnt possible\n        // to see if its already been flagged at the moment.\n        public void updateObjects()\n        {\n            GameObject GameObject;\n\n            foreach (Object Obj in _Owner._ObjectRanged)\n            {\n                if (Obj.IsGameObject())\n                {\n                    GameObject = Obj.GetGameObject();\n                    //Loot Loots = LootsMgr.GenerateLoot(GameObject, _Owner.GetPlayer());\n                    //if (Loots != null && Loots.IsLootable())\n                    GameObject.SendMeTo(_Owner.GetPlayer());\n                }\n            }\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class PlasmaResourceChecker : IDisposable, IResourcePresenceChecker\n    {\n        /// <summary>\n        ///     auto save cache every X seconds if dirty\n        /// </summary>\n        private const int DirtyCacheSave = 30;\n\n        private const int MaximumConcurrentTransmissions = 5;\n\n\n        /// <summary>\n        ///     How long to wait to reask server if unitsync is missing\n        /// </summary>\n        private const int UnitsyncMissingReaskQuery = 600;\n\n        /// <summary>\n        ///     how long to wait (seconds) before asking server for same resource\n        /// </summary>\n        private const int RescheduleServerQuery = 120;\n\n\n        /// <summary>\n        ///     time between work item operations in ms\n        /// </summary>\n        private const int ScannerCycleTime = 1000;\n\n        /// <summary>\n        ///     Files with different Extensions as these are ignored\n        /// </summary>\n        private static readonly string[] Extensions = { \".sd7\", \".sdz\", \".sdp\" };\n\n        /// <summary>\n        ///     Path of the file containing the serialized cache\n        /// </summary>\n        private readonly string cachePath;\n\n        /// <summary>\n        ///     looks for changes in the maps folder\n        /// </summary>\n        private readonly List<FileSystemWatcher> mapsWatchers = new List<FileSystemWatcher>();\n\n        /// <summary>\n        ///     looks for changes in the mods folder\n        /// </summary>\n        private readonly List<FileSystemWatcher> modsWatchers = new List<FileSystemWatcher>();\n\n        /// <summary>\n        ///     looks for changes in packages folder\n        /// </summary>\n        private readonly List<FileSystemWatcher> packagesWatchers = new List<FileSystemWatcher>();\n\n        private readonly IContentService service = GlobalConst.GetContentService();\n\n        /// <summary>\n        ///     queue of items to process\n        /// </summary>\n        private readonly LinkedList<WorkItem> workQueue = new LinkedList<WorkItem>();\n\n\n        private CacheFile cache = new CacheFile();\n\n        /// <summary>\n        ///     Whether the cache need to be saved\n        /// </summary>\n        private bool isCacheDirty;\n\n        private bool isDisposed;\n\n        /// <summary>\n        ///     number of work items being sent\n        /// </summary>\n        private int itemsSending;\n\n        private DateTime lastCacheSave;\n\n        /// <summary>\n        ///     unitsync is run on this thread\n        /// </summary>\n        private Thread mainThread;\n        private int workTotal;\n\n\n        public SpringPaths SpringPaths { get; private set; }\n\n\n        public bool WatchingEnabled\n        {\n            get { return mapsWatchers.First().EnableRaisingEvents; }\n            set\n            {\n                foreach (var watcher in mapsWatchers.Concat(modsWatchers).Concat(packagesWatchers)) watcher.EnableRaisingEvents = value;\n            }\n        }\n\n        public PlasmaResourceChecker(SpringPaths springPaths)\n        {\n            SpringPaths = springPaths;\n\n            foreach (var folder in springPaths.DataDirectories)\n            {\n                var modsPath = Utils.MakePath(folder, \"games\");\n                if (Directory.Exists(modsPath)) modsWatchers.Add(new FileSystemWatcher(modsPath));\n                var mapsPath = Utils.MakePath(folder, \"maps\");\n                if (Directory.Exists(mapsPath)) mapsWatchers.Add(new FileSystemWatcher(mapsPath));\n                var packagesPath = Utils.MakePath(folder, \"packages\");\n                if (Directory.Exists(packagesPath)) packagesWatchers.Add(new FileSystemWatcher(packagesPath));\n            }\n\n            SetupWatcherEvents(mapsWatchers);\n            SetupWatcherEvents(modsWatchers);\n            SetupWatcherEvents(packagesWatchers);\n\n            Directory.CreateDirectory(springPaths.Cache);\n            cachePath = Utils.MakePath(springPaths.Cache, \"ScannerCache.json\");\n            Directory.CreateDirectory(Utils.MakePath(springPaths.Cache, \"Resources\"));\n        }\n\n        public void Dispose()\n        {\n            WatchingEnabled = false;\n            isDisposed = true;\n            if (isCacheDirty) SaveCache();\n            GC.SuppressFinalize(this);\n        }\n\n\n        public bool HasResource(string name)\n        {\n            // scanner active\n            return cache.NameIndex.ContainsKey(name);\n        }\n\n\n        public int GetWorkCost()\n        {\n            lock (workQueue)\n            {\n                return workQueue.Count;\n            }\n        }\n\n        public void InitialScan()\n        {\n            CacheFile loadedCache = null;\n            if (File.Exists(cachePath))\n                try\n                {\n                    loadedCache = JsonConvert.DeserializeObject<CacheFile>(File.ReadAllText(cachePath));\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceWarning(\"Warning: problem reading scanner cache: {0}\", ex);\n                    loadedCache = null;\n                }\n\n            if (loadedCache != null) cache = loadedCache;\n\n            Rescan();\n\n            Trace.TraceInformation(\"Initial scan done\");\n        }\n\n        public event EventHandler<ResourceChangedEventArgs> LocalResourceAdded = delegate { };\n        public event EventHandler<ResourceChangedEventArgs> LocalResourceRemoved = delegate { };\n        \n        public void Rescan()\n        {\n            var foundFiles = new Dictionary<string, bool>();\n\n            InitialFolderScan(\"games\", foundFiles);\n            InitialFolderScan(\"maps\", foundFiles);\n            InitialFolderScan(\"packages\", foundFiles);\n\n            Dictionary<string, CacheItem> copy;\n            lock (cache)\n            {\n                copy = new Dictionary<string, CacheItem>(cache.ShortPathIndex);\n            }\n            foreach (var pair in copy) if (!foundFiles.ContainsKey(pair.Key)) CacheItemRemove(pair.Value);\n        }\n\n        public event EventHandler<CancelEventArgs<CacheItem>> RetryResourceCheck = delegate { };\n        // raised before attempting to reconnect to server to check for resource info\n\n        public void Start(bool watchingEnabled = true)\n        {\n            WatchingEnabled = watchingEnabled;\n            mainThread = Utils.SafeThread(MainThreadFunction);\n            mainThread.Priority = ThreadPriority.BelowNormal;\n            mainThread.Start();\n        }\n\n        // raised before attempting to upload unitsync data\n        public event EventHandler<ProgressEventArgs> WorkProgressChanged = delegate { };\n        public event EventHandler<ProgressEventArgs> WorkStarted = delegate { };\n        public event EventHandler WorkStopped = delegate { };\n\n\n        private void AddWork(string folder, string file, WorkItem.OperationType operationType, DateTime executeOn, bool toFront)\n        {\n            AddWork(new CacheItem { Folder = folder, FileName = file }, operationType, executeOn, toFront);\n        }\n\n\n        private void AddWork(CacheItem item, WorkItem.OperationType operationType, DateTime executeOn, bool toFront)\n        {\n            workTotal++;\n            lock (workQueue)\n            {\n                var work = new WorkItem(item, operationType, executeOn);\n                work.CacheItem = item;\n                if (toFront) workQueue.AddFirst(work);\n                else workQueue.AddLast(work);\n            }\n        }\n\n\n        private void CacheItemAdd(CacheItem item)\n        {\n            lock (cache)\n            {\n                cache.ShortPathIndex[item.ShortPath] = item;\n                cache.HashIndex[item.Md5] = item;\n                cache.NameIndex[item.InternalName] = item;\n                cache.FailedUnitSyncFiles.Remove(item.ShortPath);\n                LocalResourceAdded(this, new ResourceChangedEventArgs(item));\n                isCacheDirty = true;\n            }\n        }\n\n        private void CacheItemRemove(CacheItem item)\n        {\n            lock (cache)\n            {\n                cache.ShortPathIndex.Remove(item.ShortPath);\n                cache.HashIndex.Remove(item.Md5);\n                cache.NameIndex.Remove(item.InternalName);\n                LocalResourceRemoved(this, new ResourceChangedEventArgs(item));\n                isCacheDirty = true;\n            }\n        }\n\n        private string GetFullPath(WorkItem work)\n        {\n            string fullPath = null;\n            foreach (var directory in SpringPaths.DataDirectories)\n            {\n                var path = Utils.MakePath(directory, work.CacheItem.ShortPath);\n                if (File.Exists(path))\n                {\n                    fullPath = path;\n                    break;\n                }\n            }\n            return fullPath;\n        }\n\n\n        private WorkItem GetNextWorkItem()\n        {\n            var now = DateTime.Now;\n            lock (workQueue)\n            {\n                var queue = itemsSending > MaximumConcurrentTransmissions\n                    ? workQueue.Where(item => item.Operation != WorkItem.OperationType.UnitSync)\n                    : workQueue;\n                foreach (var item in queue)\n                {\n                    if (item.ExecuteOn > now) continue; // do it later\n                    workQueue.Remove(item);\n                    return item;\n                }\n            }\n            return null;\n        }\n\n        private void GetResourceData(WorkItem work)\n        {\n            ResourceData result = null;\n            try\n            {\n                result = service.GetResourceData(work.CacheItem.Md5.ToString(), work.CacheItem.InternalName);\n            }\n            catch (Exception ex)\n            {\n                var args = new CancelEventArgs<CacheItem>(work.CacheItem);\n                RetryResourceCheck.Invoke(this, args);\n                if (!args.Cancel)\n                {\n                    Trace.TraceError(\"Error getting resource data: {0}\", ex);\n                    AddWork(work.CacheItem, WorkItem.OperationType.ReAskServer, DateTime.Now.AddSeconds(RescheduleServerQuery), false);\n                    return;\n                }\n            }\n\n            if (result == null)\n            {\n                Trace.WriteLine(string.Format(\"No server resource data for {0}, asking later\", work.CacheItem.ShortPath));\n                AddWork(work.CacheItem, WorkItem.OperationType.ReAskServer, DateTime.Now.AddSeconds(UnitsyncMissingReaskQuery), false);\n                return;\n            }\n            work.CacheItem.InternalName = result.InternalName;\n            work.CacheItem.ResourceType = result.ResourceType;\n            Trace.WriteLine(string.Format(\"Adding {0}\", work.CacheItem.InternalName));\n            CacheItemAdd(work.CacheItem);\n        }\n\n        private static string GetShortPath(string folder, string file)\n        {\n            return string.Format(\"{0}/{1}\", folder, Path.GetFileName(file));\n        }\n\n        private string GetWatcherFolder(FileSystemWatcher watcher)\n        {\n            if (mapsWatchers.Contains(watcher)) return \"maps\";\n            if (modsWatchers.Contains(watcher)) return \"games\";\n            if (packagesWatchers.Contains(watcher)) return \"packages\";\n            throw new ArgumentException(\"Invalid watcher\", \"watcher\");\n        }\n\n\n        private void HandleWatcherChange(object sender, FileSystemEventArgs e)\n        {\n            if (!Extensions.Contains(Path.GetExtension(e.Name))) return;\n\n            var folder = GetWatcherFolder((FileSystemWatcher)sender);\n            var shortPath = GetShortPath(folder, e.Name);\n            CacheItem item;\n            if (e.ChangeType == WatcherChangeTypes.Deleted)\n            {\n                if (cache.ShortPathIndex.TryGetValue(shortPath, out item)) CacheItemRemove(item);\n            }\n            else\n            {\n                if (Utils.CanWrite(e.FullPath))\n                {\n                    // changed, created, renamed\n                    // remove the item if present in the cache, then process the item\n                    if (cache.ShortPathIndex.TryGetValue(shortPath, out item)) CacheItemRemove(item);\n                    AddWork(folder, e.Name, WorkItem.OperationType.Hash, DateTime.Now, true);\n                }\n            }\n        }\n\n\n        private void InitialFolderScan(string folder, Dictionary<string, bool> foundFiles)\n        {\n            var fileList = new List<string>();\n            foreach (var dd in SpringPaths.DataDirectories)\n            {\n                var path = Utils.MakePath(dd, folder);\n                if (Directory.Exists(path))\n                    try\n                    {\n                        fileList.AddRange(Directory.GetFiles(path));\n                    }\n                    catch { }\n            }\n\n            foreach (var f in fileList)\n                if (Extensions.Contains(Path.GetExtension(f)))\n                {\n                    var shortPath = GetShortPath(folder, Path.GetFileName(f));\n                    if (cache.FailedUnitSyncFiles.ContainsKey(shortPath) || foundFiles.ContainsKey(shortPath)) continue;\n                    foundFiles.Add(shortPath, true);\n                    if (!cache.ShortPathIndex.ContainsKey(shortPath)) AddWork(folder, Path.GetFileName(f), WorkItem.OperationType.Hash, DateTime.Now, false);\n                    else if (cache.ShortPathIndex[shortPath].Length != new FileInfo(f).Length)\n                    {\n                        CacheItemRemove(cache.ShortPathIndex[shortPath]);\n                        AddWork(folder, Path.GetFileName(f), WorkItem.OperationType.Hash, DateTime.Now, false);\n                    }\n                }\n        }\n\n\n        private void MainThreadFunction()\n        {\n            try\n            {\n                InitialScan();\n            }\n            catch (Exception ex)\n            {\n                Trace.TraceError(\"Error in scanner initial scan: {0}\", ex);\n            }\n\n            var isWorking = false;\n            var workDone = 0;\n            while (!isDisposed)\n                try\n                {\n                    Thread.Sleep(ScannerCycleTime);\n\n                    if (isCacheDirty && (DateTime.Now.Subtract(lastCacheSave).TotalSeconds > DirtyCacheSave))\n                    {\n                        lastCacheSave = DateTime.Now;\n                        isCacheDirty = false;\n                        SaveCache();\n                    }\n\n                    WorkItem workItem;\n                    while ((workItem = GetNextWorkItem()) != null)\n                    {\n                        if (isDisposed) return;\n\n                        if (!isWorking)\n                        {\n                            isWorking = true;\n                            workDone = 0;\n                            workTotal = GetWorkCost();\n                            WorkStarted(this, new ProgressEventArgs(workDone, workTotal, workItem.CacheItem.FileName));\n                        }\n                        else\n                        {\n                            workDone++;\n                            workTotal = Math.Max(GetWorkCost(), workTotal);\n                            WorkProgressChanged(this,\n                                new ProgressEventArgs(workDone, workTotal, string.Format(\"{0} {1}\", workItem.Operation, workItem.CacheItem.FileName)));\n                        }\n\n                        if (workItem.Operation == WorkItem.OperationType.Hash) PerformHashOperation(workItem);\n                        if (workItem.Operation == WorkItem.OperationType.ReAskServer) GetResourceData(workItem);\n                    }\n                    if (isWorking)\n                    {\n                        isWorking = false;\n                        WorkStopped(this, EventArgs.Empty);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceError(\"Exception in scanning thread: {0}\", ex);\n                }\n        }\n\n\n        private void PerformHashOperation(WorkItem work)\n        {\n            string fullPath = null;\n            try\n            {\n                fullPath = GetFullPath(work);\n                if (fullPath == null) throw new Exception(\"workitem file not found\");\n\n                using (var fs = File.OpenRead(fullPath))\n                {\n                    work.CacheItem.Md5 = Hash.HashStream(fs);\n                }\n                work.CacheItem.Length = (int)new FileInfo(fullPath).Length;\n\n                if (!cache.HashIndex.ContainsKey(work.CacheItem.Md5)) GetResourceData(work);\n            }\n            catch (Exception e)\n            {\n                Trace.WriteLine(\"Can't hash \" + work.CacheItem.ShortPath + \" (\" + e + \")\");\n            }\n        }\n\n\n        private void SaveCache()\n        {\n            lock (cache)\n            {\n                try\n                {\n                    Directory.CreateDirectory(Path.GetDirectoryName(cachePath));\n                    File.WriteAllText(cachePath, JsonConvert.SerializeObject(cache));\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceError(\"Error saving springscanner cache: {0}\", ex);\n                }\n            }\n        }\n\n        private void SetupWatcherEvents(IEnumerable<FileSystemWatcher> watchers)\n        {\n            foreach (var watcher in watchers)\n            {\n                watcher.IncludeSubdirectories = true;\n                watcher.Created += HandleWatcherChange;\n                watcher.Changed += HandleWatcherChange;\n                watcher.Deleted += HandleWatcherChange;\n                watcher.Renamed += HandleWatcherChange;\n            }\n        }\n\n        ~PlasmaResourceChecker()\n        {\n            Dispose();\n        }\n\n\n        [Serializable]\n        public class CacheItem\n        {\n            public string FileName;\n            public string Folder;\n\n            public string InternalName;\n            public int Length;\n            public Hash Md5;\n            public ResourceType ResourceType;\n\n            public string ShortPath { get { return GetShortPath(Folder, FileName); } }\n        }\n\n\n        public class ResourceChangedEventArgs : EventArgs\n        {\n            public CacheItem Item { get; protected set; }\n\n            public ResourceChangedEventArgs(CacheItem item)\n            {\n                Item = item;\n            }\n        }\n\n\n        [Serializable]\n        private class CacheFile\n        {\n            public Dictionary<string, bool> FailedUnitSyncFiles = new Dictionary<string, bool>();\n            public Dictionary<Hash, CacheItem> HashIndex = new Dictionary<Hash, CacheItem>();\n            public Dictionary<string, CacheItem> NameIndex = new Dictionary<string, CacheItem>();\n            public Dictionary<string, CacheItem> ShortPathIndex = new Dictionary<string, CacheItem>();\n            public string SpringVersion;\n        }\n\n\n        private class WorkItem\n        {\n            public enum OperationType\n            {\n                Hash,\n                ReAskServer,\n                UnitSync\n            }\n\n            public readonly OperationType Operation;\n\n\n            public CacheItem CacheItem;\n            public DateTime ExecuteOn;\n\n\n            public WorkItem(CacheItem item, OperationType operation, DateTime executeOn)\n            {\n                CacheItem = item;\n                ExecuteOn = executeOn;\n                Operation = operation;\n            }\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\tinternal sealed partial class WebCall\n\t{\n\t\t/// <summary>\n\t\t/// \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e.\n\t\t/// </summary>\n\t\t/// <param name=\"url\"> URL. </param>\n\t\t/// <param name=\"webProxy\"> \u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u043e\u043a\u0441\u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tpublic static async Task<WebCallResult> MakeCallAsync(string url, IWebProxy webProxy = null)\n\t\t{\n\t\t\tusing (var call = new WebCall(url, new Cookies(), webProxy))\n\t\t\t{\n\t\t\t\tvar response = await call._request.GetAsync(url).ConfigureAwait(false);\n\n\t\t\t\treturn await call.MakeRequestAsync(response, new Uri(url), webProxy)\n\t\t\t\t\t.ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c POST \u0437\u0430\u043f\u0440\u043e\u0441 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e.\n\t\t/// </summary>\n\t\t/// <param name=\"url\"> URL. </param>\n\t\t/// <param name=\"parameters\"> \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430. </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tpublic static async Task<WebCallResult> PostCallAsync(string url, IEnumerable<KeyValuePair<string, string>> parameters,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tIWebProxy webProxy)\n\t\t{\n\t\t\tusing (var call = new WebCall(url, new Cookies(), webProxy))\n\t\t\t{\n\t\t\t\tvar request = await call._request\n\t\t\t\t\t.PostAsync(url, new FormUrlEncodedContent(parameters))\n\t\t\t\t\t.ConfigureAwait(false);\n\n\t\t\t\treturn await call.MakeRequestAsync(request, new Uri(url), webProxy)\n\t\t\t\t\t.ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Post \u0437\u0430\u043f\u0440\u043e\u0441 \u0438\u0437 \u0444\u043e\u0440\u043c\u044b \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e.\n\t\t/// </summary>\n\t\t/// <param name=\"form\"> \u0424\u043e\u0440\u043c\u0430. </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tpublic static async Task<WebCallResult> PostAsync(WebForm form, IWebProxy webProxy)\n\t\t{\n\t\t\tusing (var call = new WebCall(form.ActionUrl, form.Cookies, webProxy, false))\n\t\t\t{\n\t\t\t\tSpecifyHeadersForFormRequest(form, call);\n\n\t\t\t\tvar request = await call._request.PostAsync(form.ActionUrl,\n\t\t\t\t\t\tnew FormUrlEncodedContent(form.GetFormFields()))\n\t\t\t\t\t.ConfigureAwait(false);\n\n\t\t\t\treturn await call.MakeRequestAsync(request, new Uri(form.ActionUrl), webProxy)\n\t\t\t\t\t.ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u0430\u044f \u043f\u0435\u0440\u0435\u0430\u0434\u0440\u0435\u0441\u0430\u0446\u0438\u044f.\n\t\t/// </summary>\n\t\t/// <param name=\"url\"> URL. </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tprivate async Task<WebCallResult> RedirectToAsync(string url, IWebProxy webProxy = null)\n\t\t{\n\t\t\tusing (var call = new WebCall(url, _result.Cookies, webProxy))\n\t\t\t{\n\t\t\t\tvar headers = call._request.DefaultRequestHeaders;\n\t\t\t\theaders.Add(\"Method\", \"GET\");\n\t\t\t\theaders.Add(\"ContentType\", \"text/html\");\n\n\t\t\t\tvar response = await call._request.GetAsync(url).ConfigureAwait(false);\n\n\t\t\t\treturn await call.MakeRequestAsync(response, new Uri(url), webProxy)\n\t\t\t\t\t.ConfigureAwait(false);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441 \u0430\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e.\n\t\t/// </summary>\n\t\t/// <param name=\"uri\"> Uri \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u0443\u043a\u0438 </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <param name=\"response\"> \u041e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\t/// <exception cref=\"VkApiException\"> Response is null. </exception>\n\t\tprivate async Task<WebCallResult> MakeRequestAsync(HttpResponseMessage response, Uri uri, IWebProxy webProxy)\n\t\t{\n\t\t\tusing (var stream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))\n\t\t\t{\n\t\t\t\tif (stream == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new VkApiException(\"Response is null.\");\n\t\t\t\t}\n\n\t\t\t\tvar encoding = Encoding.UTF8;\n\t\t\t\t_result.SaveResponse(response.RequestMessage.RequestUri, stream, encoding);\n\n\t\t\t\tvar cookies = _result.Cookies.Container;\n\n\t\t\t\t_result.SaveCookies(cookies.GetCookies(uri));\n\n\t\t\t\tif (IsAbsoluteUrl(response.Headers.Location?.ToString()))\n\t\t\t\t{\n\t\t\t\t\treturn response.StatusCode == HttpStatusCode.Redirect\n\t\t\t\t\t\t? await RedirectToAsync(response.Headers.Location.AbsoluteUri, webProxy).ConfigureAwait(false)\n\t\t\t\t\t\t: _result;\n\t\t\t\t}\n\n\t\t\t\treturn response.StatusCode == HttpStatusCode.Redirect\n\t\t\t\t\t? await RedirectToAsync(Url.Combine(_result.RequestUrl.GetLeftPart(UriPartial.Authority), response.Headers.Location.OriginalString), webProxy)\n\t\t\t\t\t\t.ConfigureAwait(false)\n\t\t\t\t\t: _result;\n\t\t\t}\n\t\t}\n\n\t\tprivate bool IsAbsoluteUrl(string url)\n\t\t{\n\t\t\tif (string.IsNullOrWhiteSpace(url))\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn Uri.TryCreate(url, UriKind.Absolute, out _);\n\t\t}\n\n\t\tprivate string GetDomain(Uri uri)\n\t\t{\n\t\t\treturn uri.GetLeftPart(UriPartial.Authority);\n\t\t}\n\t}\n\t/// <inheritdoc />\n\t/// <summary>\n\t/// WebCall\n\t/// </summary>\n\tinternal sealed partial class WebCall : IDisposable\n\t{\n\t#if DEBUG_HTTP\n\t\tconst string HTTP_LOG_PATH = \"debug_http.log\";\n\t\tconst bool WRITE_TO_FILE = false; // \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0437\u0430\u043f\u0438\u0441\u044c \u043b\u043e\u0433\u043e\u0432 \u0432 \u0444\u0430\u0439\u043b \u043e\u0442\u043a\u043b\u044e\u0447\u0435\u043d\u0430\n\n\t\tstatic internal void LogWebCallRequestInfo(string method, string url, IEnumerable<KeyValuePair<string, string>> parameters, IWebProxy webProxy)\n\t\t{\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.AppendLine($\"{method} {url} [PROXY: {(webProxy != null)}]\");\n\t\t\tif (parameters != null)\n\t\t\t{\n\t\t\t\tforeach (var p in parameters) {\n\t\t\t\t\tsb.AppendLine($\"{p.Key}: {p.Value}\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tsb.AppendLine();\n\t\t\tConsole.WriteLine($\"{nameof(VkApi)} [{nameof(WebCall)}]: \" + sb.ToString());\n\t\t\tif (WRITE_TO_FILE) {\n\t\t\t\tFile.AppendAllText(HTTP_LOG_PATH, $\"{DateTime.Now}: \" + sb.ToString(), Encoding.UTF8);\n\t\t\t}\n\t\t}\n\n\t\tstatic internal void LogWebCallResultDebugInfo(string method, string url, HttpResponseMessage response, WebCallResult res, long executionTimeMS)\n\t\t{\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tsb.AppendLine($\"{method} {url} - {(int)response.StatusCode} {response.ReasonPhrase} in {executionTimeMS} msec.\");\n\t\t\tforeach (var header in response.Content.Headers)\n\t\t\t\tsb.AppendLine($\"{header.Key}: {string.Join(\"; \", header.Value)}\");\n\t\t\tsb.AppendLine(res.Response);\n\t\t\tsb.AppendLine();\n\t\t\tConsole.WriteLine($\"{nameof(VkApi)} [{nameof(WebCall)}]: \" + sb.ToString());\n\t\t\tif (WRITE_TO_FILE)\n\t\t\t\tFile.AppendAllText(HTTP_LOG_PATH, $\"{DateTime.Now}: \" + sb.ToString(), Encoding.UTF8);\n\t\t}\n\n\t#endif\n\n\t\t/// <summary>\n\t\t/// \u041f\u043e\u043b\u0443\u0447\u0438\u0442\u044c HTTP \u0437\u0430\u043f\u0440\u043e\u0441.\n\t\t/// </summary>\n\t\tprivate readonly HttpClient _request;\n\n\t\t/// <summary>\n\t\t/// \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442.\n\t\t/// </summary>\n\t\tprivate readonly WebCallResult _result;\n\n\t\t/// <summary>\n\t\t/// WebCall.\n\t\t/// </summary>\n\t\t/// <param name=\"url\"> URL. </param>\n\t\t/// <param name=\"cookies\"> Cookies. </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <param name=\"allowAutoRedirect\"> \u0420\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044c \u0430\u0432\u0442\u043e \u0440\u0435\u0434\u0438\u0440\u0440\u0435\u043a\u0442 </param>\n\t\tprivate WebCall(string url, Cookies cookies, IWebProxy webProxy = null, bool allowAutoRedirect = true)\n\t\t{\n\t\t\tvar baseAddress = new Uri(url);\n\n\t\t\tvar handler = new HttpClientHandler\n\t\t\t{\n\t\t\t\tCookieContainer = cookies.Container,\n\t\t\t\tUseCookies = true,\n\t\t\t\tProxy = webProxy,\n\t\t\t\tAllowAutoRedirect = allowAutoRedirect\n\t\t\t};\n\n\t\t\t_request = new HttpClient(handler)\n\t\t\t{\n\t\t\t\tBaseAddress = baseAddress,\n\t\t\t\tDefaultRequestHeaders =\n\t\t\t\t{\n\t\t\t\t\tAccept =\n\t\t\t\t\t{\n\t\t\t\t\t\tMediaTypeWithQualityHeaderValue.Parse(\"text/html\")\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t_result = new WebCallResult(url, cookies);\n\t\t}\n\n\t#region Implementation of IDisposable\n\n\t\t/// <summary>\n\t\t/// </summary>\n\t\tpublic void Dispose()\n\t\t{\n\t\t\t_request?.Dispose();\n\t\t}\n\n\t#endregion\n\n\t\t/// <summary>\n\t\t/// \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441.\n\t\t/// </summary>\n\t\t/// <param name=\"url\"> URL. </param>\n\t\t/// <param name=\"webProxy\"> \u0414\u0430\u043d\u043d\u044b\u0435 \u043f\u0440\u043e\u043a\u0441\u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u0430. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tpublic static WebCallResult MakeCall(string url, IWebProxy webProxy = null)\n\t\t{\n\t\t#if DEBUG_HTTP\n\t\t\tLogWebCallRequestInfo(\"GET\", url, null, webProxy);\n\t\t\tvar watch = System.Diagnostics.Stopwatch.StartNew();\n\t\t#endif\n\n\t\t\tusing (var call = new WebCall(url, new Cookies(), webProxy))\n\t\t\t{\n\t\t\t\tvar response = call._request.GetAsync(url).Result;\n\t\t\t\tvar res = call.MakeRequest(response, new Uri(url), webProxy);\n\n\t\t\t#if DEBUG_HTTP\n\t\t\t\twatch.Stop();\n\t\t\t\tLogWebCallResultDebugInfo(\"GET\", url, response, res, watch.ElapsedMilliseconds);\n\t\t\t#endif\n\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c POST \u0437\u0430\u043f\u0440\u043e\u0441.\n\t\t/// </summary>\n\t\t/// <param name=\"url\"> URL. </param>\n\t\t/// <param name=\"parameters\"> \u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b \u0437\u0430\u043f\u0440\u043e\u0441\u0430. </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tpublic static WebCallResult PostCall(string url, IEnumerable<KeyValuePair<string, string>> parameters, IWebProxy webProxy)\n\t\t{\n\t\t#if DEBUG_HTTP\n\t\t\tLogWebCallRequestInfo(\"POST\", url, parameters, webProxy);\n\t\t\tvar watch = System.Diagnostics.Stopwatch.StartNew();\n\t\t#endif\n\n\t\t\tusing (var call = new WebCall(url, new Cookies(), webProxy))\n\t\t\t{\n\t\t\t\tvar response = call._request\n\t\t\t\t\t.PostAsync(url, new FormUrlEncodedContent(parameters))\n\t\t\t\t\t.Result;\n\n\t\t\t\tvar res = call.MakeRequest(response, new Uri(url), webProxy);\n\n\t\t\t#if DEBUG_HTTP\n\t\t\t\twatch.Stop();\n\t\t\t\tLogWebCallResultDebugInfo(\"POST\", url, response, res, watch.ElapsedMilliseconds);\n\t\t\t#endif\n\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Post \u0437\u0430\u043f\u0440\u043e\u0441 \u0438\u0437 \u0444\u043e\u0440\u043c\u044b.\n\t\t/// </summary>\n\t\t/// <param name=\"form\"> \u0424\u043e\u0440\u043c\u0430. </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tpublic static WebCallResult Post(WebForm form, IWebProxy webProxy)\n\t\t{\n\t\t#if DEBUG_HTTP\n\t\t\tLogWebCallRequestInfo(\"POST\", form.ActionUrl, form.GetFormFields(), webProxy);\n\t\t\tvar watch = System.Diagnostics.Stopwatch.StartNew();\n\t\t#endif\n\n\t\t\tusing (var call = new WebCall(form.ActionUrl, form.Cookies, webProxy, false))\n\t\t\t{\n\t\t\t\tSpecifyHeadersForFormRequest(form, call);\n\n\t\t\t\tvar response = call._request\n\t\t\t\t\t.PostAsync(form.ActionUrl, new FormUrlEncodedContent(form.GetFormFields()))\n\t\t\t\t\t.Result;\n\n\t\t\t\tvar res = call.MakeRequest(response, new Uri(form.ActionUrl), webProxy);\n\n\t\t\t#if DEBUG_HTTP\n\t\t\t\twatch.Stop();\n\t\t\t\tLogWebCallResultDebugInfo(\"POST\", form.ActionUrl, response, res, watch.ElapsedMilliseconds);\n\t\t\t#endif\n\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// \u041f\u0435\u0440\u0435 \u0430\u0434\u0440\u0435\u0441\u0430\u0446\u0438\u044f.\n\t\t/// </summary>\n\t\t/// <param name=\"url\"> URL. </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\tprivate WebCallResult RedirectTo(string url, IWebProxy webProxy = null)\n\t\t{\n\t\t#if DEBUG_HTTP\n\t\t\tLogWebCallRequestInfo(\"REDIRECT GET\", url, null, webProxy);\n\t\t\tvar watch = System.Diagnostics.Stopwatch.StartNew();\n\t\t#endif\n\n\t\t\tusing (var call = new WebCall(url, _result.Cookies, webProxy))\n\t\t\t{\n\t\t\t\tvar headers = call._request.DefaultRequestHeaders;\n\t\t\t\theaders.Add(\"Method\", \"GET\");\n\t\t\t\theaders.Add(\"ContentType\", \"text/html\");\n\n\t\t\t\tvar response = call._request.GetAsync(url).Result;\n\t\t\t\tvar res = call.MakeRequest(response, new Uri(url), webProxy);\n\n\t\t\t#if DEBUG_HTTP\n\t\t\t\twatch.Stop();\n\t\t\t\tLogWebCallResultDebugInfo(\"REDIRECT GET\", url, response, res, watch.ElapsedMilliseconds);\n\t\t\t#endif\n\n\t\t\t\treturn res;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// \u0412\u044b\u043f\u043e\u043b\u043d\u0438\u0442\u044c \u0437\u0430\u043f\u0440\u043e\u0441.\n\t\t/// </summary>\n\t\t/// <param name=\"uri\"> Uri \u0438\u0437 \u043a\u043e\u0442\u043e\u0440\u043e\u0433\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u0443\u043a\u0438 </param>\n\t\t/// <param name=\"webProxy\"> \u0425\u043e\u0441\u0442. </param>\n\t\t/// <param name=\"response\"> \u041e\u0442\u0432\u0435\u0442 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 </param>\n\t\t/// <returns> \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 </returns>\n\t\t/// <exception cref=\"VkApiException\"> Response is null. </exception>\n\t\tprivate WebCallResult MakeRequest(HttpResponseMessage response, Uri uri, IWebProxy webProxy)\n\t\t{\n\t\t\tusing (var stream = response.Content.ReadAsStreamAsync().Result)\n\t\t\t{\n\t\t\t\tif (stream == null)\n\t\t\t\t{\n\t\t\t\t\tthrow new VkApiException(\"Response is null.\");\n\t\t\t\t}\n\n\t\t\t\tvar encoding = Encoding.UTF8;\n\t\t\t\t_result.SaveResponse(response.RequestMessage.RequestUri, stream, encoding);\n\n\t\t\t\tvar cookies = _result.Cookies.Container;\n\n\t\t\t\t_result.SaveCookies(cookies.GetCookies(uri));\n\n\t\t\t\treturn response.StatusCode == HttpStatusCode.Redirect\n\t\t\t\t\t? RedirectTo(response.Headers.Location.AbsoluteUri, webProxy)\n\t\t\t\t\t: _result;\n\t\t\t}\n\t\t}\n\n\t\tprivate static void SpecifyHeadersForFormRequest(WebForm form, WebCall call)\n\t\t{\n\t\t\tvar formRequest = form.GetRequest();\n\n\t\t\tvar headers = call._request.DefaultRequestHeaders;\n\t\t\theaders.Add(\"Method\", \"POST\");\n\t\t\theaders.Add(\"ContentType\", \"application/x-www-form-urlencoded\");\n\n\t\t\theaders.Add(\"ContentLength\", formRequest.Length.ToString());\n\t\t\theaders.Referrer = new Uri(form.OriginalUrl);\n\t\t}\n\t}\n", "label": "FeatureEnvy"}
{"text": "    public class PkceTests : IdentityServerHostTest\n    {\n        const string Category = \"Conformance.PKCE\";\n\n        Client client;\n        string client_id = \"codewithproofkey_client\";\n        string redirect_uri = \"https://code_client/callback\";\n        string code_verifier = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\";\n        string client_secret = \"secret\";\n        string response_type = \"code\";\n\n        protected override void PreInit()\n        {\n            host.Scopes.Add(StandardScopes.OpenId);\n            host.Clients.Add(client = new Client\n            {\n                Enabled = true,\n                ClientId = client_id,\n                ClientSecrets = new List<Secret>\n                {\n                    new Secret(client_secret.Sha256())\n                },\n\n                Flow = Flows.AuthorizationCodeWithProofKey,\n                AllowAccessToAllScopes = true,\n\n                RequireConsent = false,\n                RedirectUris = new List<string>\n                {\n                    redirect_uri\n                }\n            });\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public void Client_can_use_plain_code_challenge_method()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var code_challenge = code_verifier;\n            var codeQuery = host.RequestAuthorizationCode(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                nonce,\n                code_challenge,\n                Constants.CodeChallengeMethods.Plain);\n\n            var code = codeQuery[\"code\"];\n\n            host.NewRequest();\n            host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret);\n\n            var result = host.PostForm(host.GetTokenUrl(),\n                new\n                {\n                    grant_type = \"authorization_code\",\n                    code,\n                    redirect_uri,\n                    code_verifier\n                }\n            );\n\n            result.StatusCode.Should().Be(HttpStatusCode.OK);\n\n            var data = result.ReadJsonObject();\n            data[\"token_type\"].Should().NotBeNull();\n            data[\"token_type\"].ToString().Should().Be(\"Bearer\");\n            data[\"access_token\"].Should().NotBeNull();\n            data[\"expires_in\"].Should().NotBeNull();\n            data[\"id_token\"].Should().NotBeNull();\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public void Client_can_use_sha256_code_challenge_method()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var code_challenge = Sha256OfCodeVerifier(code_verifier);\n            var codeQuery = host.RequestAuthorizationCode(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                nonce,\n                code_challenge,\n                Constants.CodeChallengeMethods.SHA_256);\n\n            var code = codeQuery[\"code\"];\n\n            host.NewRequest();\n            host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret);\n\n            var result = host.PostForm(host.GetTokenUrl(),\n                new\n                {\n                    grant_type = \"authorization_code\",\n                    code,\n                    redirect_uri,\n                    code_verifier\n                }\n            );\n\n            result.StatusCode.Should().Be(HttpStatusCode.OK);\n\n            var data = result.ReadJsonObject();\n            data[\"token_type\"].Should().NotBeNull();\n            data[\"token_type\"].ToString().Should().Be(\"Bearer\");\n            data[\"access_token\"].Should().NotBeNull();\n            data[\"expires_in\"].Should().NotBeNull();\n            data[\"id_token\"].Should().NotBeNull();\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public async Task Authorize_request_needs_code_challenge()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var authorizeUrl = host.GetAuthorizeUrl(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                response_type,\n                Guid.NewGuid().ToString(),\n                Guid.NewGuid().ToString());\n\n            var result = await host.Client.GetAsync(authorizeUrl);\n            result.StatusCode.Should().Be(HttpStatusCode.Found);\n\n            var query = result.Headers.Location.ParseHashFragment();\n            query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest);\n            query[\"error_description\"].Should().Be(\"code challenge required\");\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public async Task Authorize_request_code_challenge_cannot_be_too_short()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var authorizeUrl = host.GetAuthorizeUrl(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                response_type,\n                Guid.NewGuid().ToString(),\n                Guid.NewGuid().ToString(),\n                \"a\");\n\n            var result = await host.Client.GetAsync(authorizeUrl);\n            result.StatusCode.Should().Be(HttpStatusCode.Found);\n\n            var query = result.Headers.Location.ParseHashFragment();\n            query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest);\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public async Task Authorize_request_code_challenge_cannot_be_too_long()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var authorizeUrl = host.GetAuthorizeUrl(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                response_type,\n                Guid.NewGuid().ToString(),\n                Guid.NewGuid().ToString(),\n                new string('a', host.Options.InputLengthRestrictions.CodeChallengeMaxLength + 1));\n\n            var result = await host.Client.GetAsync(authorizeUrl);\n            result.StatusCode.Should().Be(HttpStatusCode.Found);\n\n            var query = result.Headers.Location.ParseHashFragment();\n            query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest);\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public async Task Authorize_request_needs_supported_code_challenge_method()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var code_challenge = code_verifier;\n            var authorizeUrl = host.GetAuthorizeUrl(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                response_type,\n                Guid.NewGuid().ToString(),\n                Guid.NewGuid().ToString(),\n                code_challenge,\n                \"unknown_code_challenge_method\");\n\n            var result = await host.Client.GetAsync(authorizeUrl);\n            result.StatusCode.Should().Be(HttpStatusCode.Found);\n\n            var query = result.Headers.Location.ParseHashFragment();\n            query[\"error\"].Should().Be(Constants.AuthorizeErrors.InvalidRequest);\n            query[\"error_description\"].Should().Be(\"transform algorithm not supported\");\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public void Token_request_needs_code_verifier()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var code_challenge = code_verifier;\n            var codeQuery = host.RequestAuthorizationCode(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                nonce,\n                code_challenge,\n                Constants.CodeChallengeMethods.Plain);\n\n            var code = codeQuery[\"code\"];\n\n            host.NewRequest();\n            host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret);\n\n            var result = host.PostForm(host.GetTokenUrl(),\n                new\n                {\n                    grant_type = \"authorization_code\",\n                    code,\n                    redirect_uri\n                }\n            );\n\n            result.StatusCode.Should().Be(HttpStatusCode.BadRequest);\n\n            var data = result.ReadJsonObject();\n            data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant);\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public void Token_request_code_verifier_cannot_be_too_short()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var code_challenge = code_verifier;\n            var codeQuery = host.RequestAuthorizationCode(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                nonce,\n                code_challenge,\n                Constants.CodeChallengeMethods.Plain);\n\n            var code = codeQuery[\"code\"];\n\n            host.NewRequest();\n            host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret);\n\n            var result = host.PostForm(host.GetTokenUrl(),\n                new\n                {\n                    grant_type = \"authorization_code\",\n                    code,\n                    redirect_uri,\n                    code_verifier = \"a\"\n                }\n            );\n\n            result.StatusCode.Should().Be(HttpStatusCode.BadRequest);\n\n            var data = result.ReadJsonObject();\n            data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant);\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public void Token_request_code_verifier_cannot_be_too_long()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var code_challenge = code_verifier;\n            var codeQuery = host.RequestAuthorizationCode(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                nonce,\n                code_challenge,\n                Constants.CodeChallengeMethods.Plain);\n\n            var code = codeQuery[\"code\"];\n\n            host.NewRequest();\n            host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret);\n\n            var result = host.PostForm(host.GetTokenUrl(),\n                new\n                {\n                    grant_type = \"authorization_code\",\n                    code,\n                    redirect_uri,\n                    code_verifier = new string('a', host.Options.InputLengthRestrictions.CodeVerifierMaxLength + 1)\n                }\n            );\n\n            result.StatusCode.Should().Be(HttpStatusCode.BadRequest);\n\n            var data = result.ReadJsonObject();\n            data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant);\n        }\n\n        [Fact]\n        [Trait(\"Category\", Category)]\n        public void Token_request_code_verifier_must_match_with_code_chalenge()\n        {\n            host.Login();\n\n            var nonce = Guid.NewGuid().ToString();\n            var code_challenge = code_verifier;\n            var codeQuery = host.RequestAuthorizationCode(\n                client_id,\n                redirect_uri,\n                Constants.StandardScopes.OpenId,\n                nonce,\n                code_challenge,\n                Constants.CodeChallengeMethods.Plain);\n\n            var code = codeQuery[\"code\"];\n\n            host.NewRequest();\n            host.Client.DefaultRequestHeaders.Authorization = new BasicAuthenticationHeaderValue(client_id, client_secret);\n\n            var result = host.PostForm(host.GetTokenUrl(),\n                new\n                {\n                    grant_type = \"authorization_code\",\n                    code,\n                    redirect_uri,\n                    code_verifier = \"mismatched_code_verifier\"\n                }\n            );\n\n            result.StatusCode.Should().Be(HttpStatusCode.BadRequest);\n\n            var data = result.ReadJsonObject();\n            data[\"error\"].ToString().Should().Be(Constants.TokenErrors.InvalidGrant);\n        }\n\n        private static string Sha256OfCodeVerifier(string codeVerifier)\n        {\n            var codeVerifierBytes = Encoding.ASCII.GetBytes(codeVerifier);\n            var hashedBytes = codeVerifierBytes.Sha256();\n            var transformedCodeVerifier = Base64Url.Encode(hashedBytes);\n\n            return transformedCodeVerifier;\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Simple string input UI for initiating string-based searches. Users of the class match against\n    /// the inputted string via the Matches() method.</summary>\n    public class StringSearchInputUI : ToolStrip\n    {\n        /// <summary>\n        /// Constructor</summary>\n        public StringSearchInputUI()\n        {\n            m_patternTextRegex = string.Empty;\n\n            Visible = true;\n            GripStyle = ToolStripGripStyle.Hidden;\n            RenderMode = ToolStripRenderMode.System;\n\n            ToolStripDropDownButton dropDownButton = new ToolStripDropDownButton();\n            dropDownButton.DisplayStyle = ToolStripItemDisplayStyle.Image;\n            dropDownButton.Image = ResourceUtil.GetImage16(Resources.SearchImage);\n            dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;\n            dropDownButton.Name = \"SearchButton\";\n            dropDownButton.Size = new System.Drawing.Size(29, 22);\n            dropDownButton.Text = \"Search\".Localize(\"'Search' is a verb\");\n\n            ToolStripButton clearSearchButton = new ToolStripButton();\n            clearSearchButton.DisplayStyle = ToolStripItemDisplayStyle.Image;\n            clearSearchButton.Image = ResourceUtil.GetImage16(Resources.DeleteImage);\n            dropDownButton.ImageTransparentColor = System.Drawing.Color.Magenta;\n            clearSearchButton.Name = \"ClearSearchButton\";\n            clearSearchButton.Size = new System.Drawing.Size(29, 22);\n            clearSearchButton.Text = \"Clear Search\".Localize(\"'Clear' is a verb\");\n            clearSearchButton.Click += clearSearchButton_Click;\n\n            m_patternTextBox = new ToolStripAutoFitTextBox();\n            m_patternTextBox.KeyUp += patternTextBox_KeyUp;\n            m_patternTextBox.TextChanged += patternTextBox_TextChanged;\n            m_patternTextBox.TextBox.PreviewKeyDown += textBox_PreviewKeyDown;\n            m_patternTextBox.MaximumWidth = 1080;\n\n            Items.AddRange(new ToolStripItem[] { \n                    dropDownButton, \n                    m_patternTextBox,\n                    clearSearchButton\n                    });\n        }\n\n        /// <summary>\n        /// Event that is raised after text control is updated</summary>\n        public event EventHandler Updated;\n\n        /// <summary>\n        /// Gets whether or not the textbox contains any input</summary>\n        /// <returns>True if any sort of string is in the textbox</returns>\n        public bool IsNullOrEmpty()\n        {\n            return m_textBoxEmpty;\n        }\n\n        /// <summary>\n        /// Returns whether the specified string matches the pattern string in the text box</summary>\n        /// <param name=\"inputString\">The string to test for match</param>\n        /// <returns>True iff the text box pattern string matches with inputString</returns>\n        public bool Matches(string inputString)\n        {\n            return Regex.Match(inputString, m_patternTextRegex, RegexOptions.IgnoreCase).Success;\n        }\n\n        /// <summary>\n        ///  Gets the search pattern</summary>\n        public string SearchPattern\n        {\n            get { return m_patternTextBox.Text; }\n        }\n\n        /// <summary>\n        /// Clears search results</summary>\n        public void ClearSearch()\n        {\n            m_patternTextBox.Text = string.Empty;\n            m_patternTextRegex = string.Empty;\n            Updated.Raise(this, EventArgs.Empty);\n        }\n\n\n\n        /// <summary>\n        /// Callback that performs custom actions when the 'clear' button has been pressed</summary>\n        /// <param name=\"sender\">The sender of the event</param>\n        /// <param name=\"e\">Arguments related to the event</param>\n        private void clearSearchButton_Click(object sender, System.EventArgs e)\n        {\n            ClearSearch();\n        }\n\n        /// <summary>\n        /// Callback that performs custom actions when any keypress is completed in the text box</summary>\n        /// <param name=\"sender\">The sender of the event</param>\n        /// <param name=\"e\">Arguments related to the event</param>\n        private void patternTextBox_KeyUp(object sender, KeyEventArgs e)\n        {\n            m_patternTextRegex = string.Empty;\n\n            if (!string.IsNullOrEmpty(m_patternTextBox.Text))\n            {\n                bool patternValid = true;\n                m_patternTextRegex = m_patternTextBox.Text.Replace(\"*\", \"[\\\\w\\\\s]+\");\n\n                // test that the regex pattern is valid by running a match, and checking for an exception\n                try\n                {\n                    Regex.Match(String.Empty, m_patternTextRegex);\n                }\n                catch (ArgumentException)\n                {\n                    patternValid = false;\n                }\n                m_patternTextRegex = (patternValid) ? m_patternTextRegex : Regex.Escape(m_patternTextBox.Text);\n            }\n\n            Updated.Raise(this, EventArgs.Empty);\n        }\n\n        /// <summary>\n        /// Callback that performs custom actions after any text changed in the text box</summary>\n        /// <param name=\"sender\">The sender of the event</param>\n        /// <param name=\"e\">Arguments related to the event</param>\n        void patternTextBox_TextChanged(object sender, EventArgs e)\n        {\n            m_textBoxEmpty = string.IsNullOrEmpty(m_patternTextBox.Text);\n        }\n\n        /// <summary>\n        /// Callback that performs custom actions after the preview key is pressed</summary>\n        /// <param name=\"sender\">The sender of the event</param>\n        /// <param name=\"e\">Arguments related to the event</param>\n        void textBox_PreviewKeyDown(object sender, PreviewKeyDownEventArgs e)\n        {\n            if (e.KeyData == Keys.Escape)\n                clearSearchButton_Click(sender, e);\n        }\n\n        private readonly ToolStripAutoFitTextBox m_patternTextBox;\n        private string m_patternTextRegex;\n        private bool m_textBoxEmpty=true;\n    }\n", "label": "FeatureEnvy"}
{"text": "        internal class Fat\n        {\n            private readonly FatFileSystem mFileSystem;\n\n            private readonly ulong mFatSector;\n\n            /// <summary>\n            /// Initializes a new instance of the <see cref=\"Fat\"/> class.\n            /// </summary>\n            /// <param name=\"aFileSystem\">The file system.</param>\n            /// <param name=\"aFatSector\">The first sector of the FAT table.</param>\n            public Fat(FatFileSystem aFileSystem, ulong aFatSector)\n            {\n                if (aFileSystem == null)\n                {\n                    throw new ArgumentNullException(nameof(aFileSystem));\n                }\n\n                mFileSystem = aFileSystem;\n                mFatSector = aFatSector;\n            }\n\n            /// <summary>\n            /// Gets the size of a FAT entry in bytes.\n            /// </summary>\n            /// <returns>The size of a FAT entry in bytes.</returns>\n            /// <exception cref=\"NotSupportedException\">Can not get the FAT entry size for an unknown FAT type.</exception>\n            private uint GetFatEntrySizeInBytes()\n            {\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat32:\n                        return 4;\n\n                    case FatTypeEnum.Fat16:\n                        return 2;\n\n                    case FatTypeEnum.Fat12:\n                        // TODO:\n                        break;\n                }\n\n                throw new NotSupportedException(\"Can not get the FAT entry size for an unknown FAT type.\");\n            }\n\n            /// <summary>\n            /// Gets the FAT chain.\n            /// </summary>\n            /// <param name=\"aFirstEntry\">The first entry.</param>\n            /// <param name=\"aDataSize\">Size of a data to be stored in bytes.</param>\n            /// <returns>An array of cluster numbers for the FAT chain.</returns>\n            /// <exception cref=\"ArgumentOutOfRangeException\"></exception>\n            public uint[] GetFatChain(uint aFirstEntry, long aDataSize = 0)\n            {\n                Global.mFileSystemDebugger.SendInternal(\"-- Fat.GetFatChain --\");\n                Global.mFileSystemDebugger.SendInternal(\"aFirstEntry =\");\n                Global.mFileSystemDebugger.SendInternal(aFirstEntry);\n                Global.mFileSystemDebugger.SendInternal(\"aDataSize =\");\n                Global.mFileSystemDebugger.SendInternal(aDataSize);\n\n                var xReturn = new uint[0];\n                uint xCurrentEntry = aFirstEntry;\n                uint xValue;\n\n                long xEntriesRequired = aDataSize / mFileSystem.BytesPerCluster;\n                if (aDataSize % mFileSystem.BytesPerCluster != 0)\n                {\n                    xEntriesRequired++;\n                }\n\n                GetFatEntry(xCurrentEntry, out xValue);\n                Array.Resize(ref xReturn, xReturn.Length + 1);\n                xReturn[xReturn.Length - 1] = xCurrentEntry;\n\n                Global.mFileSystemDebugger.SendInternal(\"xEntriesRequired =\");\n                Global.mFileSystemDebugger.SendInternal(xEntriesRequired);\n                Global.mFileSystemDebugger.SendInternal(\"xCurrentEntry =\");\n                Global.mFileSystemDebugger.SendInternal(xCurrentEntry);\n                Global.mFileSystemDebugger.SendInternal(\"xReturn.Length =\");\n                Global.mFileSystemDebugger.SendInternal(xReturn.Length);\n\n                if (xEntriesRequired > 0)\n                {\n                    while (!FatEntryIsEof(xValue))\n                    {\n                        xCurrentEntry = xValue;\n                        GetFatEntry(xCurrentEntry, out xValue);\n                        Array.Resize(ref xReturn, xReturn.Length + 1);\n                        xReturn[xReturn.Length - 1] = xCurrentEntry;\n                        Global.mFileSystemDebugger.SendInternal(\"xCurrentEntry =\");\n                        Global.mFileSystemDebugger.SendInternal(xCurrentEntry);\n                        Global.mFileSystemDebugger.SendInternal(\"xReturn.Length =\");\n                        Global.mFileSystemDebugger.SendInternal(xReturn.Length);\n                    }\n\n                    if (xEntriesRequired > xReturn.Length)\n                    {\n                        long xNewClusters = xEntriesRequired - xReturn.Length;\n                        for (int i = 0; i < xNewClusters; i++)\n                        {\n                            xCurrentEntry = GetNextUnallocatedFatEntry();\n                            uint xLastFatEntry = xReturn[xReturn.Length - 1];\n                            SetFatEntry(xLastFatEntry, xCurrentEntry);\n                            SetFatEntry(xCurrentEntry, FatEntryEofValue());\n                            Array.Resize(ref xReturn, xReturn.Length + 1);\n                            xReturn[xReturn.Length - 1] = xCurrentEntry;\n                        }\n                    }\n                }\n\n                string xChain = \"\";\n                for (int i = 0; i < xReturn.Length; i++)\n                {\n                    xChain += xReturn[i];\n                    if (i > 0 || i < xReturn.Length - 1)\n                    {\n                        xChain += \"->\";\n                    }\n                }\n                Global.mFileSystemDebugger.SendInternal(\"Fat xChain:\");\n                Global.mFileSystemDebugger.SendInternal(xChain);\n\n                SetFatEntry(xCurrentEntry, FatEntryEofValue());\n\n                return xReturn;\n            }\n\n            /// <summary>\n            /// Gets the next unallocated FAT entry.\n            /// </summary>\n            /// <returns>The index of the next unallocated FAT entry.</returns>\n            /// <exception cref=\"Exception\">Failed to find an unallocated FAT entry.</exception>\n            public uint GetNextUnallocatedFatEntry()\n            {\n                Global.mFileSystemDebugger.SendInternal(\"-- Fat.GetNextUnallocatedFatEntry --\");\n\n                uint xTotalEntries = mFileSystem.FatSectorCount * mFileSystem.BytesPerSector / GetFatEntrySizeInBytes();\n                for (uint i = mFileSystem.RootCluster; i < xTotalEntries; i++)\n                {\n                    GetFatEntry(i, out uint xEntryValue);\n                    if (FatEntryIsFree(xEntryValue))\n                    {\n                        Global.mFileSystemDebugger.SendInternal(\"i =\");\n                        Global.mFileSystemDebugger.SendInternal(i);\n                        return i;\n                    }\n                }\n\n                throw new Exception(\"Failed to find an unallocated FAT entry.\");\n            }\n\n            /// <summary>\n            /// Clears a FAT entry.\n            /// </summary>\n            /// <param name=\"aEntryNumber\">The entry number.</param>\n            public void ClearFatEntry(ulong aEntryNumber)\n            {\n                SetFatEntry(aEntryNumber, 0);\n            }\n\n            private void SetFatEntry(byte[] aData, ulong aEntryNumber, ulong aValue)\n            {\n                uint xEntrySize = GetFatEntrySizeInBytes();\n                ulong xEntryOffset = aEntryNumber * xEntrySize;\n\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat12:\n                        aData.SetUInt16(xEntryOffset, (ushort)aValue);\n                        break;\n                    case FatTypeEnum.Fat16:\n                        aData.SetUInt16(xEntryOffset, (ushort)aValue);\n                        break;\n                    case FatTypeEnum.Fat32:\n                        aData.SetUInt32(xEntryOffset, (uint)aValue);\n                        break;\n                    default:\n                        throw new NotSupportedException(\"Unknown FAT type.\");\n                }\n            }\n\n            private void GetFatEntry(byte[] aData, uint aEntryNumber, out uint aValue)\n            {\n                uint xEntrySize = GetFatEntrySizeInBytes();\n                ulong xEntryOffset = aEntryNumber * xEntrySize;\n\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat12:\n                        // We now access the FAT entry as a WORD just as we do for FAT16, but if the cluster number is\n                        // EVEN, we only want the low 12-bits of the 16-bits we fetch. If the cluster number is ODD\n                        // we want the high 12-bits of the 16-bits we fetch.\n                        uint xResult = BitConverter.ToUInt16(aData, (int)xEntryOffset);\n                        if ((aEntryNumber & 0x01) == 0)\n                        {\n                            aValue = xResult & 0x0FFF; // Even\n                        }\n                        else\n                        {\n                            aValue = xResult >> 4; // Odd\n                        }\n                        break;\n                    case FatTypeEnum.Fat16:\n                        aValue = BitConverter.ToUInt16(aData, (int)xEntryOffset);\n                        break;\n                    case FatTypeEnum.Fat32:\n                        aValue = BitConverter.ToUInt32(aData, (int)xEntryOffset) & 0x0FFFFFFF;\n                        break;\n                    default:\n                        throw new NotSupportedException(\"Unknown FAT type.\");\n                }\n            }\n\n            public void ClearAllFat()\n            {\n                //byte[] xFatTable = new byte[4096]; // TODO find where '4096' is defined\n                byte[] xFatTable = mFileSystem.NewBlockArray();\n                //var xFatTableSize = mFileSystem.FatSectorCount * mFileSystem.BytesPerSector / GetFatEntrySizeInBytes();\n\n                Global.mFileSystemDebugger.SendInternal($\"FatSector is {mFatSector}\");\n                Global.mFileSystemDebugger.SendInternal($\"RootCluster is {mFileSystem.RootCluster}\");\n                Global.mFileSystemDebugger.SendInternal(\"Clearing all Fat Table\");\n\n                byte[] xFatTableFistSector;\n                ReadFatSector(0, out xFatTableFistSector);\n\n                /* Change 3rd entry (RootDirectory) to be EOC */\n                SetFatEntry(xFatTableFistSector, 2, FatEntryEofValue());\n\n                /* Copy first three elements on xFatTable */\n                Array.Copy(xFatTableFistSector, xFatTable, 12);\n\n                Global.mFileSystemDebugger.SendInternal($\"Clearing First sector...\");\n                /* The rest of 'xFatTable' should be all 0s as new does this internally */\n                WriteFatSector(0, xFatTable);\n                Global.mFileSystemDebugger.SendInternal($\"First sector cleared\");\n\n                /* Restore the Array will all 0s as it is this we have to write in the other sectors */\n                //Array.Clear(xFatTable, 0, 12);\n\n                /* Array.Clear() not work: stack overflow! */\n                for (int i = 0; i < 11; i++)\n                {\n                    xFatTable[i] = 0;\n                }\n\n                for (ulong sector = 1; sector < mFileSystem.FatSectorCount; sector++)\n                {\n                    if (sector % 100 == 0)\n                    {\n                        Global.mFileSystemDebugger.SendInternal($\"Clearing sector {sector}\");\n                    }\n                    WriteFatSector(sector, xFatTable);\n                }\n            }\n\n            private void ReadFatSector(ulong aSector, out byte[] aData)\n            {\n                aData = mFileSystem.NewBlockArray();\n                ulong xSector = mFatSector + aSector;\n                Global.mFileSystemDebugger.SendInternal(\"xSector  =\");\n                Global.mFileSystemDebugger.SendInternal(xSector);\n                mFileSystem.Device.ReadBlock(xSector, mFileSystem.SectorsPerCluster, ref aData);\n            }\n\n            private void WriteFatSector(ulong aSector, byte[] aData)\n            {\n                if (aData == null)\n                {\n                    throw new ArgumentNullException(nameof(aData));\n                }\n\n                var xSector = mFatSector + aSector;\n                mFileSystem.Device.WriteBlock(xSector, mFileSystem.SectorsPerCluster, ref aData);\n            }\n\n            /// <summary>\n            /// Gets a FAT entry.\n            /// </summary>\n            /// <param name=\"aEntryNumber\">The entry number.</param>\n            /// <param name=\"aValue\">The entry value.</param>\n            internal void GetFatEntry(uint aEntryNumber, out uint aValue)\n            {\n                Global.mFileSystemDebugger.SendInternal(\"-- Fat.GetFatEntry --\");\n                Global.mFileSystemDebugger.SendInternal(\"aEntryNumber =\");\n                Global.mFileSystemDebugger.SendInternal(aEntryNumber);\n\n                uint xEntrySize = GetFatEntrySizeInBytes();\n                ulong xEntryOffset = aEntryNumber * xEntrySize;\n                Global.mFileSystemDebugger.SendInternal(\"xEntrySize =\");\n                Global.mFileSystemDebugger.SendInternal(xEntrySize);\n                Global.mFileSystemDebugger.SendInternal(\"xEntryOffset =\");\n                Global.mFileSystemDebugger.SendInternal(xEntryOffset);\n\n                ulong xSector = xEntryOffset / mFileSystem.BytesPerSector;\n                Global.mFileSystemDebugger.SendInternal(\"xSector =\");\n                Global.mFileSystemDebugger.SendInternal(xSector);\n\n                ReadFatSector(xSector, out byte[] xData);\n\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat12:\n                        // We now access the FAT entry as a WORD just as we do for FAT16, but if the cluster number is\n                        // EVEN, we only want the low 12-bits of the 16-bits we fetch. If the cluster number is ODD\n                        // we want the high 12-bits of the 16-bits we fetch.\n                        uint xResult = BitConverter.ToUInt16(xData, (int)xEntryOffset);\n                        if ((aEntryNumber & 0x01) == 0)\n                        {\n                            aValue = xResult & 0x0FFF; // Even\n                        }\n                        else\n                        {\n                            aValue = xResult >> 4; // Odd\n                        }\n                        break;\n\n                    case FatTypeEnum.Fat16:\n                        aValue = BitConverter.ToUInt16(xData, (int)xEntryOffset);\n                        break;\n\n                    case FatTypeEnum.Fat32:\n                        aValue = BitConverter.ToUInt32(xData, (int)xEntryOffset) & 0x0FFFFFFF;\n                        break;\n\n                    default:\n                        throw new NotSupportedException(\"Unknown FAT type.\");\n                }\n                Global.mFileSystemDebugger.SendInternal(\"aValue =\");\n                Global.mFileSystemDebugger.SendInternal(aValue);\n            }\n\n            /// <summary>\n            /// Sets a FAT entry.\n            /// </summary>\n            /// <param name=\"aEntryNumber\">The entry number.</param>\n            /// <param name=\"aValue\">The value.</param>\n            internal void SetFatEntry(ulong aEntryNumber, ulong aValue)\n            {\n                Global.mFileSystemDebugger.SendInternal(\"--- Fat.SetFatEntry ---\");\n                Global.mFileSystemDebugger.SendInternal(\"aEntryNumber =\");\n                Global.mFileSystemDebugger.SendInternal(aEntryNumber);\n\n                uint xEntrySize = GetFatEntrySizeInBytes();\n                ulong xEntryOffset = aEntryNumber * xEntrySize;\n\n                ulong xSector = xEntryOffset / mFileSystem.BytesPerSector;\n                ulong xSectorOffset = (xSector * mFileSystem.BytesPerSector) - xEntryOffset;\n\n                byte[] xData;\n                ReadFatSector(xSector, out xData);\n\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat12:\n                        xData.SetUInt16(xEntryOffset, (ushort)aValue);\n                        break;\n\n                    case FatTypeEnum.Fat16:\n                        xData.SetUInt16(xEntryOffset, (ushort)aValue);\n                        break;\n\n                    case FatTypeEnum.Fat32:\n                        xData.SetUInt32(xEntryOffset, (uint)aValue);\n                        break;\n\n                    default:\n                        throw new NotSupportedException(\"Unknown FAT type.\");\n                }\n\n                WriteFatSector(xSector, xData);\n            }\n\n            internal bool FatEntryIsFree(uint aValue)\n            {\n                return aValue == 0;\n            }\n\n            internal bool FatEntryIsEof(uint aValue)\n            {\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat12:\n                        return (aValue & 0x0FFF) >= 0x0FF8;\n                    case FatTypeEnum.Fat16:\n                        return (aValue & 0xFFFF) >= 0xFFF8;\n                    case FatTypeEnum.Fat32:\n                        return (aValue & 0x0FFFFFF8) >= 0x0FFFFFF8;\n                    default:\n                        throw new ArgumentException(\"Unknown FAT type\");\n                }\n            }\n\n            internal bool FatEntryIsBad(uint aValue)\n            {\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat12:\n                        return (aValue & 0x0FFF) == 0x0FF7;\n                    case FatTypeEnum.Fat16:\n                        return (aValue & 0xFFFF) == 0xFFF7;\n                    case FatTypeEnum.Fat32:\n                        return (aValue & 0x0FFFFFF8) == 0x0FFFFFF7;\n                    default:\n                        throw new ArgumentException(\"Unknown FAT type\");\n                }\n            }\n\n            /// <summary>\n            /// The the EOF value for a specific FAT type.\n            /// </summary>\n            /// <returns>The EOF value.</returns>\n            /// <exception cref=\"Exception\">Unknown file system type.</exception>\n            internal ulong FatEntryEofValue()\n            {\n                switch (mFileSystem.mFatType)\n                {\n                    case FatTypeEnum.Fat12:\n                        return 0x0FFF;\n\n                    case FatTypeEnum.Fat16:\n                        return 0xFFFF;\n\n                    case FatTypeEnum.Fat32:\n                        return 0x0FFFFFFF;\n\n                    default:\n                        throw new Exception(\"Unknown file system type.\");\n                }\n            }\n        }\n", "label": "FeatureEnvy"}
{"text": "    public partial class MatchMaker\n    {\n        public const int TimerSeconds = 25;\n        private const int MapModChangePauseSeconds = 30;\n\n        private int BanSecondsIncrease => DynamicConfig.Instance.MmBanSecondsIncrease;\n        private int BanSecondsMax => DynamicConfig.Instance.MmBanSecondsMax;\n        private int BanReset => DynamicConfig.Instance.MmBanReset;\n\n\n        private struct QueueConfig\n        {\n            public string Name, Description;\n            public Func<Resource, bool> MapSelector;\n            public int MaxPartySize, MaxSize, MinSize;\n            public double EloCutOffExponent;\n            public AutohostMode Mode;\n        }\n\n        public class BanInfo\n        {\n            public DateTime BannedTime;\n            public int BanCounter;\n            public int BanSeconds;\n        }\n\n        private ConcurrentDictionary<string, DateTime> lastTimePlayerDeniedMatch = new ConcurrentDictionary<string, DateTime>(); //used to check if player can be annoyed with MM suggestions or if he's clearly desinterested\n\n        private ConcurrentDictionary<string, BanInfo> bannedPlayers = new ConcurrentDictionary<string, BanInfo>();\n        private Dictionary<string, int> ingameCounts = new Dictionary<string, int>();\n\n        private List<ProposedBattle> invitationBattles = new List<ProposedBattle>();\n        private ConcurrentDictionary<string, PlayerEntry> players = new ConcurrentDictionary<string, PlayerEntry>();\n        public List<MatchMakerSetup.Queue> PossibleQueues { get; private set; } = new List<MatchMakerSetup.Queue>();\n        private List<QueueConfig> queueConfigs = new List<QueueConfig>();\n\n        private Dictionary<string, int> queuesCounts = new Dictionary<string, int>();\n\n        private ZkLobbyServer server;\n\n\n        private object tickLock = new object();\n        private Timer timer;\n        private int totalQueued;\n        private DateTime lastQueueUpdate = DateTime.Now;\n\n        public MatchMaker(ZkLobbyServer server)\n        {\n            this.server = server;\n\n            Func<Resource, bool> IsTeamsMap = x => (x.MapSupportLevel >= MapSupportLevel.MatchMaker) && (x.MapIsTeams != false) && (x.TypeID == ResourceType.Map) && x.MapIsSpecial != true;\n            Func<Resource, bool> IsCoopMap = x => (x.MapSupportLevel >= MapSupportLevel.MatchMaker) && (x.TypeID == ResourceType.Map) && x.MapIsSpecial != true;\n            Func<Resource, bool> Is1v1Map = x => (x.MapSupportLevel >= MapSupportLevel.MatchMaker) && (x.TypeID == ResourceType.Map) && x.MapIs1v1 == true && x.MapIsSpecial != true;\n\n            queueConfigs.Add(new QueueConfig()\n            {\n                Name = \"Teams\",\n                Description = \"Play 2v2 to 4v4 with players of similar skill.\",\n                MinSize = 4,\n                MaxSize = 8,\n                MaxPartySize = 4,\n                EloCutOffExponent = 0.96,\n                Mode = AutohostMode.Teams,\n                MapSelector = IsTeamsMap,\n            });\n\n            queueConfigs.Add(new QueueConfig()\n            {\n                Name = \"Coop\",\n                Description = \"Play together, against AI or chickens\",\n                MinSize = 2,\n                MaxSize = 5,\n                MaxPartySize = 5,\n                EloCutOffExponent = 0,\n                Mode = AutohostMode.GameChickens,\n                MapSelector = IsCoopMap,\n            });\n\n            queueConfigs.Add(new QueueConfig()\n            {\n                Name = \"1v1\",\n                Description = \"1v1 with opponent of similar skill\",\n                MinSize = 2,\n                MaxSize = 2,\n                EloCutOffExponent = 0.97,\n                MaxPartySize = 1,\n                Mode = AutohostMode.Game1v1,\n                MapSelector = Is1v1Map,\n            });\n\n            UpdateQueues();\n\n            timer = new Timer(TimerSeconds * 1000);\n            timer.AutoReset = true;\n            timer.Elapsed += TimerTick;\n            timer.Start();\n\n            queuesCounts = CountQueuedPeople(players.Values);\n            ingameCounts = CountIngamePeople();\n        }\n\n        private void UpdateQueues()\n        {\n            lastQueueUpdate = DateTime.Now;\n            using (var db = new ZkDataContext())\n            {\n                var oldQueues = PossibleQueues;\n                PossibleQueues = queueConfigs.Select(x =>\n                {\n                    MatchMakerSetup.Queue queue = new MatchMakerSetup.Queue();\n                    if (oldQueues.Exists(y => y.Name == x.Name))\n                    {\n                        queue = oldQueues.Find(y => y.Name == x.Name);\n                    }\n                    var oldmaps = queue.Maps;\n                    queue.Name = x.Name;\n                    queue.Description = x.Description;\n                    queue.MinSize = x.MinSize;\n                    queue.MaxSize = x.MaxSize;\n                    queue.MaxPartySize = x.MaxPartySize;\n                    queue.EloCutOffExponent = x.EloCutOffExponent;\n                    queue.Game = server.Game;\n                    queue.Mode = x.Mode;\n                    queue.Maps =\n                        db.Resources\n                            .Where(x.MapSelector)\n                            .Select(y => y.InternalName)\n                            .ToList();\n                    queue.SafeMaps = queue.Maps.Where(y => oldmaps.Contains(y)).ToList();\n                    return queue;\n                }).ToList();\n            }\n        }\n\n\n        public async Task AreYouReadyResponse(ConnectedUser user, AreYouReadyResponse response)\n        {\n            PlayerEntry entry;\n            if (players.TryGetValue(user.Name, out entry))\n                if (entry.InvitedToPlay)\n                {\n                    if (response.Ready)\n                    {\n                        entry.LastReadyResponse = true;\n                        if (entry.QuickPlay)\n                        {\n                            await server.UserLogSay($\"{user.Name} accepted his quickplay MM invitation\");\n                        }\n                        else\n                        {\n                            await server.UserLogSay($\"{user.Name} accepted his pop-up MM invitation\");\n                        }\n                    }\n                    else\n                    {\n                        if (entry.QuickPlay)\n                        {\n                            await server.UserLogSay($\"{user.Name} rejected his quickplay MM invitation\");\n                            entry.InvitedToPlay = false; //don't ban quickplayers\n                        }\n                        else\n                        {\n                            await server.UserLogSay($\"{user.Name} rejected his pop-up MM invitation\");\n                        }\n                        lastTimePlayerDeniedMatch[entry.Name] = DateTime.UtcNow; //store that this player is probably not interested in suggestive MM games\n                        entry.LastReadyResponse = false;\n                        await RemoveUser(user.Name, true);\n                    }\n\n                    var invitedPeople = players.Values.Where(x => x?.InvitedToPlay == true).ToList();\n\n                    if (invitedPeople.Count <= 1)\n                    {\n                        await server.UserLogSay($\"Aborting MM invitations because only {invitedPeople.Count} invitations outstanding.\");\n                        foreach (var p in invitedPeople) p.LastReadyResponse = true;\n                        // if we are doing tick because too few people, make sure we count remaining people as readied to not ban them \n                        OnTick();\n                    }\n                    else if (invitedPeople.All(x => x.LastReadyResponse)) OnTick();\n                    else\n                    {\n                        var readyCounts = CountQueuedPeople(invitedPeople.Where(x => x.LastReadyResponse));\n\n                        var proposedBattles = ProposeBattles(invitedPeople.Where(x => x.LastReadyResponse), false);\n\n                        await Task.WhenAll(invitedPeople.Select(async (p) =>\n                        {\n                            var invitedBattle = invitationBattles?.FirstOrDefault(x => x.Players.Contains(p));\n                            await server.SendToUser(p.Name,\n                                new AreYouReadyUpdate()\n                                {\n                                    QueueReadyCounts = readyCounts,\n                                    ReadyAccepted = p.LastReadyResponse == true,\n                                    LikelyToPlay = proposedBattles.Any(y => y.Players.Contains(p)),\n                                    YourBattleSize = invitedBattle?.Size,\n                                    YourBattleReady = invitedPeople.Count(x => x.LastReadyResponse && (invitedBattle?.Players.Contains(x) == true))\n                                });\n                        }));\n                    }\n                }\n\n        }\n\n        public int GetTotalWaiting() => totalQueued;\n\n\n        public async Task OnLoginAccepted(ConnectedUser conus)\n        {\n            await conus.SendCommand(new MatchMakerSetup() { PossibleQueues = PossibleQueues });\n            await UpdatePlayerStatus(conus.Name);\n        }\n\n        public async Task OnServerGameChanged(string game)\n        {\n            UpdateQueues();\n            await server.Broadcast(new MatchMakerSetup() { PossibleQueues = PossibleQueues });\n        }\n\n        public async Task OnServerMapsChanged()\n        {\n            UpdateQueues();\n            await server.Broadcast(new MatchMakerSetup() { PossibleQueues = PossibleQueues });\n        }\n\n        public async Task QueueRequest(ConnectedUser user, MatchMakerQueueRequest cmd)\n        {\n            var banTime = BannedSeconds(user.Name);\n            if (banTime != null)\n            {\n                await UpdatePlayerStatus(user.Name);\n                await user.Respond($\"Please rest and wait for {banTime}s because you refused previous match\");\n                return;\n            }\n\n            //assure people don't rejoin (possibly accidentally) directly after starting a game\n            if (server.Battles.Values.Any(x => x.IsInGame && DateTime.UtcNow.Subtract(x.RunningSince ?? DateTime.UtcNow).TotalMinutes < DynamicConfig.Instance.MmMinimumMinutesBetweenGames && x.spring.LobbyStartContext.Players.Count(p => !p.IsSpectator) > 1 && x.spring.LobbyStartContext.Players.Any(p => !p.IsSpectator && p.Name == user.Name)))\n            {\n                await UpdatePlayerStatus(user.Name);\n                await user.Respond($\"You have recently started a match. Please play for at least {DynamicConfig.Instance.MmMinimumMinutesBetweenGames} minutes before starting another match\");\n                return;\n            }\n\n            DateTime player;\n            lastTimePlayerDeniedMatch.TryRemove(user.Name, out player); //this player might be interested in suggestive MM games after all\n\n            var wantedQueueNames = cmd.Queues?.ToList() ?? new List<string>();\n            var wantedQueues = PossibleQueues.Where(x => wantedQueueNames.Contains(x.Name)).ToList();\n            \n            await AddOrUpdateUser(user, wantedQueues);\n        }\n\n        public List<ConnectedUser> GetEligibleQuickJoinPlayers(List<ConnectedUser> users)\n        {\n            DateTime lastDenied;\n            return users.Where(x => !(lastTimePlayerDeniedMatch.TryGetValue(x.Name, out lastDenied) && DateTime.UtcNow.Subtract(lastDenied).TotalMinutes < DynamicConfig.Instance.MmMinimumMinutesBetweenSuggestions)).ToList(); \n        }\n\n        public async Task MassJoin(List<ConnectedUser> users, List<MatchMakerSetup.Queue> wantedQueues)\n        {\n            //don't join people that are probably not interested\n            users = GetEligibleQuickJoinPlayers(users);\n\n            for (int i = 0; i < users.Count; i++) {\n                //join all users without running tick\n                await AddOrUpdateUser(users[i], wantedQueues, true); \n\n                //set width for every user to maximum to speed up MM\n                PlayerEntry entry;\n                if (players.TryGetValue(users[i].Name, out entry)) entry.SetQuickPlay();\n            }\n            await server.UserLogSay($\"{users.Count} players have been added to the {wantedQueues.Select(q => q.Name).StringJoin()} queue via Quickplay: {users.Select(q => q.Name).StringJoin()}.\");\n\n            // if nobody is invited, we can do tick now to speed up things\n            if (invitationBattles?.Any() != true) OnTick();\n            else await UpdateAllPlayerStatuses(); // else we just send statuses\n        }\n\n        /// <summary>\n        /// Removes user (and his party) from MM queues, doesnt broadcast changes\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <returns></returns>\n        public async Task RemoveUser(string name, bool broadcastChanges)\n        {\n            var party = server.PartyManager.GetParty(name);\n            var anyRemoved = false;\n\n            if (party != null)\n            {\n                foreach (var n in party.UserNames) if (await RemoveSingleUser(n)) anyRemoved = true;\n            }\n            else\n            {\n                anyRemoved = await RemoveSingleUser(name);\n            }\n            if (broadcastChanges && anyRemoved) await UpdateAllPlayerStatuses();\n        }\n\n        public async Task UpdateAllPlayerStatuses()\n        {\n            ingameCounts = CountIngamePeople();\n            queuesCounts = CountQueuedPeople(players.Values);\n\n            await Task.WhenAll(server.ConnectedUsers.Keys.Where(x => x != null).Select(UpdatePlayerStatus));\n        }\n\n        private async Task AddOrUpdateUser(ConnectedUser user, List<MatchMakerSetup.Queue> wantedQueues, bool massJoin = false)\n        {\n            // already invited ignore requests\n            PlayerEntry entry;\n            if (players.TryGetValue(user.Name, out entry) && entry.InvitedToPlay)\n            {\n                await UpdatePlayerStatus(user.Name);\n                return;\n            }\n\n\n            var party = server.PartyManager.GetParty(user.Name);\n            if (party != null) wantedQueues = wantedQueues.Where(x => x.MaxSize / 2 >= party.UserNames.Count).ToList(); // if is in party keep only queues where party fits\n\n            if (wantedQueues.Count == 0) // delete\n            {\n                if (entry?.QueueTypes?.Count > 0 && entry?.QuickPlay == false) await server.UserLogSay($\"{user.Name} has left the matchmaker.\");\n\n                await RemoveUser(user.Name, true);\n\n                return;\n            }\n\n            if (party != null)\n                foreach (var p in party.UserNames)\n                {\n                    var conUs = server.ConnectedUsers.Get(p);\n                    if (conUs != null)\n                        players.AddOrUpdate(p,\n                            (str) => new PlayerEntry(conUs.User, wantedQueues, party),\n                            (str, usr) =>\n                            {\n                                usr.UpdateTypes(wantedQueues);\n                                usr.Party = party;\n                                return usr;\n                            });\n                }\n            else\n                players.AddOrUpdate(user.Name,\n                    (str) => new PlayerEntry(user.User, wantedQueues, null),\n                    (str, usr) =>\n                    {\n                        usr.UpdateTypes(wantedQueues);\n                        usr.Party = null;\n                        return usr;\n                    });\n\n\n            //if many people are joined simultaneously, wait until join is completed before sending updates or trying to create battles.\n            if (massJoin) return;\n\n            await server.UserLogSay($\"{user.Name} has joined the following queues: {wantedQueues.Select(q => q.Name).StringJoin()}.\");\n\n            // if nobody is invited, we can do tick now to speed up things\n            if (invitationBattles?.Any() != true) OnTick();\n            else await UpdateAllPlayerStatuses(); // else we just send statuses\n        }\n\n\n        private int? BannedSeconds(string name)\n        {\n            BanInfo banEntry;\n            if (bannedPlayers.TryGetValue(name, out banEntry) && (DateTime.UtcNow.Subtract(banEntry.BannedTime).TotalSeconds < banEntry.BanSeconds)) return (int)(banEntry.BanSeconds - DateTime.UtcNow.Subtract(banEntry.BannedTime).TotalSeconds);\n\n            // remove old\n            if (banEntry != null && DateTime.UtcNow.Subtract(banEntry.BannedTime).TotalSeconds > BanReset) bannedPlayers.TryRemove(name, out banEntry);\n\n            return null;\n        }\n\n        private Dictionary<string, int> CountIngamePeople()\n        {\n            var ncounts = PossibleQueues.ToDictionary(x => x.Name, x => 0);\n            foreach (var bat in server.Battles.Values.OfType<MatchMakerBattle>().Where(x => (x != null) && x.IsMatchMakerBattle && x.IsInGame))\n            {\n                var plrs = bat.spring?.Context?.LobbyStartContext?.Players.Count(x => !x.IsSpectator) ?? 0;\n                if (plrs > 0)\n                {\n                    var type = bat.Prototype?.QueueType;\n                    if (type != null) ncounts[type.Name] += plrs;\n                }\n            }\n            return ncounts;\n        }\n\n        private Dictionary<string, int> CountQueuedPeople(IEnumerable<PlayerEntry> sumPlayers)\n        {\n            int total = 0;\n            var ncounts = PossibleQueues.ToDictionary(x => x.Name, x => 0);\n            foreach (var plr in sumPlayers.Where(x => x != null))\n            {\n                total++;\n                foreach (var jq in plr.QueueTypes) ncounts[jq.Name]++;\n            }\n            totalQueued = total; // ugly to both return and set class property, refactor for nicer\n            return ncounts;\n        }\n\n        public Dictionary<string, int> GetQueueCounts() => queuesCounts;\n        \n\n        private void OnTick()\n        {\n            lock (tickLock)\n            {\n                try\n                {\n                    timer.Stop();\n                    var realBattles = ResolveToRealBattles();\n\n                    UpdateAllPlayerStatuses();\n\n                    foreach (var bat in realBattles) StartBattle(bat);\n\n                    ResetAndSendMmInvitations();\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceError(\"MatchMaker tick error: {0}\", ex);\n                }\n                finally\n                {\n                    timer.Start();\n                }\n            }\n        }\n\n        private static List<ProposedBattle> ProposeBattles(IEnumerable<PlayerEntry> users, bool ignoreSizeLimit)\n        {\n            var proposedBattles = new List<ProposedBattle>();\n\n            var usersByWaitTime = users.OrderBy(x => x.JoinedTime).ToList();\n            var remainingPlayers = usersByWaitTime.ToList();\n\n            foreach (var user in usersByWaitTime)\n                if (remainingPlayers.Contains(user)) // consider only those not yet assigned\n                {\n                    var battle = TryToMakeBattle(user, remainingPlayers, ignoreSizeLimit);\n                    if (battle != null)\n                    {\n                        proposedBattles.Add(battle);\n                        remainingPlayers.RemoveAll(x => battle.Players.Contains(x));\n                    }\n                }\n\n            return proposedBattles;\n        }\n\n        public void BanPlayer(string name)\n        {\n\n            var banEntry = bannedPlayers.GetOrAdd(name, (n) => new BanInfo());\n            banEntry.BannedTime = DateTime.UtcNow;\n            banEntry.BanCounter++;\n            banEntry.BanSeconds = Math.Min(BanSecondsMax, BanSecondsIncrease * banEntry.BanCounter);\n\n            server.UserLogSay($\"{name} has been banned for {banEntry.BanSeconds} seconds.\");\n        }\n\n\n        private async Task<bool> RemoveSingleUser(string name)\n        {\n            PlayerEntry entry;\n            if (players.TryRemove(name, out entry))\n            {\n                if (entry.InvitedToPlay)\n                {\n                    // was invited but he is gone now (whatever reason), ban!\n                    BanPlayer(name);\n                }\n\n\n                ConnectedUser conUser;\n                if (server.ConnectedUsers.TryGetValue(name, out conUser) && (conUser != null)) if (entry?.InvitedToPlay == true) await conUser.SendCommand(new AreYouReadyResult() { AreYouBanned = true, IsBattleStarting = false, });\n                return true;\n            }\n            return false;\n        }\n\n\n        private void ResetAndSendMmInvitations()\n        {\n            // generate next battles and send inviatation\n            invitationBattles = ProposeBattles(players.Values.Where(x => x != null), false);\n            var toInvite = invitationBattles.SelectMany(x => x.Players).ToHashSet();\n            foreach (var usr in players.Values.Where(x => x != null))\n                if (toInvite.Contains(usr) || usr.QuickPlay) //invite all quickplay players, there will be lots of declines so don't care about making battles yet\n                {\n                    usr.InvitedToPlay = true;\n                    usr.LastReadyResponse = false;\n                }\n                else\n                {\n                    usr.InvitedToPlay = false;\n                    usr.LastReadyResponse = false;\n                }\n\n            var normalInvites = toInvite.Where(p => !p.QuickPlay).Select(p => p.Name).ToList();\n            var quickPlayInvites = players.Values.Where(x => x != null && x.QuickPlay).Select(x => x.Name).ToList();\n            //send out invites to players in battles\n            server.Broadcast(normalInvites,\n                new AreYouReady() {\n                    SecondsRemaining = TimerSeconds,\n                    MinimumWinChance = -1,\n                    QuickPlay = false\n                });\n            //send out invites to all QuickPlayers\n            server.Broadcast(quickPlayInvites,\n                new AreYouReady()\n                {\n                    SecondsRemaining = TimerSeconds,\n                    MinimumWinChance = DynamicConfig.Instance.MmTeamsMinimumWinChance,\n                    QuickPlay = true\n                });\n\n            if (toInvite.Count > 0)\n            {\n                server.UserLogSay($\"{normalInvites.Count} players have been sent pop-up MM invites: {normalInvites.StringJoin()}.\");\n                server.UserLogSay($\"{quickPlayInvites.Count} players have been sent quickplay MM invites: {quickPlayInvites.StringJoin()}.\");\n            }\n        }\n\n        private List<ProposedBattle> ResolveToRealBattles()\n        {\n            var lastMatchedUsers = players.Values.Where(x => x?.InvitedToPlay == true).ToList();\n            var nonAccepts = lastMatchedUsers.Where(x => !x.LastReadyResponse).ToList();\n            // force leave those not ready\n            foreach (var pl in nonAccepts)\n            {\n                pl.InvitedToPlay = !pl.QuickPlay; //don't ban quickplay users\n                RemoveUser(pl.Name, false);\n            }\n\n            var readyUsers = lastMatchedUsers.Where(x => x.LastReadyResponse).ToList();\n            var realBattles = ProposeBattles(readyUsers, true);\n\n            var readyAndStarting = readyUsers.Where(x => realBattles.Any(y => y.Players.Contains(x))).ToList();\n            var readyAndFailed = readyUsers.Where(x => !realBattles.Any(y => y.Players.Contains(x))).ToList();\n\n            server.Broadcast(readyAndFailed.Select(x => x.Name), new AreYouReadyResult() { IsBattleStarting = false });\n\n            server.Broadcast(readyAndStarting.Select(x => x.Name), new AreYouReadyResult() { IsBattleStarting = true });\n\n            foreach (var usr in readyAndStarting)\n            {\n                PlayerEntry entry;\n                players.TryRemove(usr.Name, out entry);\n            }\n\n            foreach (var usr in readyAndFailed.Where(x => x.QuickPlay)) //quickplay didn't find a game in one tick, resign\n            {\n                usr.InvitedToPlay = false; //don't ban\n                RemoveUser(usr.Name, false); //properly remove in case some party members don't use quickplay\n            }\n            if (lastMatchedUsers.Count > 0)\n            {\n                server.UserLogSay($\"{nonAccepts.Where(x => !x.QuickPlay).Count()} players have ignored their pop-up MM invites: {nonAccepts.Where(x => !x.QuickPlay).Select(x => x.Name).StringJoin()}.\");\n                server.UserLogSay($\"{nonAccepts.Where(x => x.QuickPlay).Count()} players have ignored their quickplay MM invites: {nonAccepts.Where(x => x.QuickPlay).Select(x => x.Name).StringJoin()}.\");\n                server.UserLogSay($\"{readyAndFailed.Where(x => !x.QuickPlay).Count()} players have accepted their pop-up MM invites with no match: {readyAndFailed.Where(x => !x.QuickPlay).Select(x => x.Name).StringJoin()}.\");\n                server.UserLogSay($\"{readyAndFailed.Where(x => x.QuickPlay).Count()} players have accepted their quickplay MM invites with no match: {readyAndFailed.Where(x => x.QuickPlay).Select(x => x.Name).StringJoin()}.\");\n            }\n\n            return realBattles;\n        }\n\n        private string PickMap(MatchMakerSetup.Queue queue)\n        {\n            Random r = new Random();\n            List<string> candidates;\n            if (DateTime.Now.Subtract(lastQueueUpdate).TotalSeconds > MapModChangePauseSeconds)\n            {\n                candidates = queue.Maps;\n            }\n            else\n            {\n                candidates = queue.SafeMaps;\n            }\n            return candidates.Count == 0 ? \"\" : candidates[r.Next(candidates.Count)];\n        }\n\n        private async Task StartBattle(ProposedBattle bat)\n        {\n            await server.UserLogSay($\"Match starting with players: {bat.Players.Select(x => x.Name).StringJoin()}.\");\n            var battle = new MatchMakerBattle(server, bat, PickMap(bat.QueueType));\n            await server.AddBattle(battle);\n\n            // also join in lobby\n            foreach (var usr in bat.Players) await server.ForceJoinBattle(usr.Name, battle);\n\n            if (!await battle.StartGame()) await server.RemoveBattle(battle);\n        }\n\n\n        private void TimerTick(object sender, ElapsedEventArgs elapsedEventArgs)\n        {\n            OnTick();\n        }\n\n\n        private static ProposedBattle TryToMakeBattle(PlayerEntry player, IList<PlayerEntry> otherPlayers, bool ignoreSizeLimit)\n        {\n            var allPlayers = new List<PlayerEntry>();\n            allPlayers.AddRange(otherPlayers);\n            allPlayers.Add(player);\n\n            var playersByElo =\n                otherPlayers.Where(x => x != player)\n                    .OrderBy(x => Math.Abs(x.LobbyUser.EffectiveMmElo - player.LobbyUser.EffectiveMmElo))\n                    .ThenBy(x => x.JoinedTime)\n                    .ToList();\n\n            var testedBattles = player.GenerateWantedBattles(allPlayers, ignoreSizeLimit);\n\n            foreach (var other in playersByElo)\n                foreach (var bat in testedBattles)\n                {\n                    if (bat.CanBeAdded(other, allPlayers, ignoreSizeLimit)) bat.AddPlayer(other, allPlayers);\n                    if (bat.Players.Count == bat.Size && bat.VerifyBalance(DynamicConfig.Instance.MmTeamsMinimumWinChance)) return bat;\n                }\n            return null;\n        }\n\n\n        private async Task UpdatePlayerStatus(string name)\n        {\n            ConnectedUser conus;\n            if (server.ConnectedUsers.TryGetValue(name, out conus))\n            {\n                PlayerEntry entry;\n                players.TryGetValue(name, out entry);\n                var ret = new MatchMakerStatus()\n                {\n                    QueueCounts = queuesCounts,\n                    IngameCounts = ingameCounts,\n                    JoinedQueues = entry?.QueueTypes.Select(x => x.Name).ToList(),\n                    CurrentEloWidth = entry?.EloWidth,\n                    JoinedTime = entry?.JoinedTime,\n                    BannedSeconds = BannedSeconds(name),\n                    UserCount = server.ConnectedUsers.Count,\n                    UserCountDiscord = server.GetDiscordUserCount()\n                };\n\n\n                // check for instant battle start - only non partied people\n                if ((invitationBattles?.Any() != true) && (players.Count > 0) && (server.PartyManager.GetParty(name) == null))\n                // nobody invited atm and some in queue\n                {\n                    ret.InstantStartQueues = new List<string>();\n                    // iterate each queue to check all possible instant starts\n                    foreach (var queue in PossibleQueues)\n                    {\n                        // get all currently queued players except for self\n                        var testPlayers = players.Values.Where(x => (x != null) && (x.Name != name)).ToList();\n                        var testSelf = new PlayerEntry(conus.User, new List<MatchMakerSetup.Queue> { queue }, null);\n                        testPlayers.Add(testSelf);\n                        var testBattles = ProposeBattles(testPlayers, false);\n                        ret.InstantStartQueues.AddRange(testBattles.Where(x => x.Players.Contains(testSelf)).Select(x => x.QueueType.Name).Distinct().ToList());\n                    }\n                }\n\n                await conus.SendCommand(ret);\n            }\n        }\n    }\n    public partial class MatchMaker\n    {\n        public class PlayerEntry\n        {\n            public bool InvitedToPlay;\n            public bool LastReadyResponse;\n\n            public int EloWidth => (int)(DynamicConfig.Instance.MmStartingWidth + WaitRatio * DynamicConfig.Instance.MmWidthGrowth);\n            public int MinConsideredElo => LobbyUser.EffectiveMmElo;\n            public int MaxConsideredElo => (int)(LobbyUser.EffectiveMmElo + (Math.Max(1500, LobbyUser.RawMmElo) - LobbyUser.EffectiveMmElo) * WaitRatio);\n\n            public double WaitRatio => Math.Max(0, Math.Min(1.0, DateTime.UtcNow.Subtract(JoinedTime).TotalSeconds / DynamicConfig.Instance.MmWidthGrowthTime));\n            public double SizeWaitRatio => Math.Max(0, Math.Min(1.0, DateTime.UtcNow.Subtract(JoinedTime).TotalSeconds / DynamicConfig.Instance.MmSizeGrowthTime));\n\n            public DateTime JoinedTime { get; private set; } = DateTime.UtcNow;\n            public User LobbyUser { get; private set; }\n            public string Name => LobbyUser.Name;\n            public List<MatchMakerSetup.Queue> QueueTypes { get; private set; }\n            public PartyManager.Party Party { get; set; }\n            public bool QuickPlay { get; private set; } = false;\n\n\n            public PlayerEntry(User user, List<MatchMakerSetup.Queue> queueTypes, PartyManager.Party party)\n            {\n                Party = party;\n                QueueTypes = queueTypes;\n                LobbyUser = user;\n            }\n\n            //override elo width growth to find matches instantly\n            //then remove user from queue if no match was found\n            public void SetQuickPlay()\n            {\n                JoinedTime = DateTime.UtcNow.AddHours(-1);\n                QuickPlay = true;\n            }\n\n            public List<ProposedBattle> GenerateWantedBattles(List<PlayerEntry> allPlayers, bool ignoreSizeLimit)\n            {\n                var ret = new List<ProposedBattle>();\n                foreach (var qt in QueueTypes)\n                {\n                    // variable game size, allow smaller games the longer the wait of longest waiting player\n                    var qtMaxWait = qt.MaxSize > qt.MinSize ? allPlayers.Where(x => x.QueueTypes.Contains(qt)).Max(x => x.SizeWaitRatio) : 0; \n\n                    for (var i = qt.MaxSize; i >= (ignoreSizeLimit ? qt.MinSize : qt.MaxSize - (qt.MaxSize - qt.MinSize) * qtMaxWait); i--)\n                        if (qt.Mode == AutohostMode.GameChickens || i % 2 == 0)\n                        {\n                            if (Party == null || (qt.Mode == AutohostMode.GameChickens && Party.UserNames.Count<=i) || Party.UserNames.Count == i / 2)\n                                ret.Add(new ProposedBattle(i, this, qt, qt.EloCutOffExponent, allPlayers));\n                        }\n                }\n                return ret;\n            }\n\n            public void UpdateTypes(List<MatchMakerSetup.Queue> queueTypes)\n            {\n                QueueTypes = queueTypes;\n            }\n        }\n    }\n    public partial class MatchMaker\n    {\n        public class ProposedBattle\n        {\n            private double eloCutOffExponent;\n            private PlayerEntry owner;\n            public List<PlayerEntry> Players = new List<PlayerEntry>();\n\n            private double widthMultiplier;\n            private bool hasParty;\n            public int MaxElo { get; private set; } = int.MinValue;\n            public int MinElo { get; private set; } = int.MaxValue;\n            public MatchMakerSetup.Queue QueueType { get; private set; }\n            public int Size { get; private set; }\n\n            public ProposedBattle(int size,\n                PlayerEntry initialPlayer,\n                MatchMakerSetup.Queue queue,\n                double eloCutOffExponent,\n                List<PlayerEntry> allPlayers)\n            {\n                Size = size;\n                owner = initialPlayer;\n                QueueType = queue;\n                this.eloCutOffExponent = eloCutOffExponent;\n                widthMultiplier = Math.Max(1.0, 1.0 + (Size - 4) * 0.1);\n                AddPlayer(initialPlayer, allPlayers);\n            }\n\n            public void AddPlayer(PlayerEntry player, List<PlayerEntry> allPlayers)\n            {\n                //Trace.TraceError(\"MM: proposed battle {0} adding {1}\", string.Join(\", \", Players.Select(x=>x.Name)), player.Name);\n                //var minEloOrg = MinElo;\n                //var maxEloOrg = MaxElo;\n                if (player.Party != null)\n                {\n                    foreach (var p in allPlayers.Where(x => x.Party == player.Party))\n                        if (!Players.Contains(p))\n                        {\n                            Players.Add(p);\n                        }\n                    MinElo = Math.Min(MinElo, GetPartyMaxElo(player.Party, allPlayers));\n                    MaxElo = Math.Max(MaxElo, GetPartyMinElo(player.Party, allPlayers));\n\n                    hasParty = true;\n                    //Trace.TraceError(\"MM: added party {6} MinElo: {0}->{1} ({4}),  MaxElo: {2}->{3} ({5})\", minEloOrg, MinElo, maxEloOrg, MaxElo, GetPartyMaxElo(player.Party, allPlayers), GetPartyMinElo(player.Party, allPlayers), player.Name);\n\n                }\n                else\n                {\n                    if (!Players.Contains(player))\n                    {\n                        Players.Add(player);\n                        MinElo = Math.Min(MinElo, GetPlayerMaxElo(player));\n                        MaxElo = Math.Max(MaxElo, GetPlayerMinElo(player));\n\n                        //Trace.TraceError(\"MM: added player {6} MinElo: {0}->{1} ({4}),  MaxElo: {2}->{3} ({5})\", minEloOrg, MinElo, maxEloOrg, MaxElo, GetPlayerMaxElo(player), GetPlayerMinElo(player), player.Name);\n                    }\n                }\n\n            }\n\n            public bool VerifyBalance(double minimumWinChance)\n            {\n                try\n                {\n                    if (minimumWinChance <= 0.01) return true;\n\n                    if (QueueType.Mode != AutohostMode.Teams) return true;\n\n                    var players = Players.Select(x => x.LobbyUser).Select(x => new PlayerItem(x.AccountID, x.EffectiveMmElo, x.Clan, x.PartyID)).ToList();\n                    return Balance(ZeroKWeb.SpringieInterface.Balancer.BalanceMode.Party, players).LowestWinChance > minimumWinChance;\n                }\n                catch (Exception ex)\n                {\n                    Trace.TraceError(\"MatchMaker error checking balance: \\n{0}\", ex);\n                    return true;\n                }\n            }\n\n            public bool CanBeAdded(PlayerEntry other, List<PlayerEntry> allPlayers, bool ignoreSizeLimit)\n            {\n                //Trace.TraceError(\"MM: proposed battle {0} checking {1}\", string.Join(\", \", Players.Select(x => x.Name)), other.Name);\n\n                if (Players.Contains(other))\n                {\n                    //Trace.TraceError(\"MM: cannot add {0}, already added\", other.Name);\n                    return false;\n                }\n                if (owner.Party !=null && other.Party == owner.Party) return true; // always accept same party\n\n                if (!other.GenerateWantedBattles(allPlayers, ignoreSizeLimit).Any(y => (y.Size == Size) && (y.QueueType == QueueType)))\n                {\n                    //Trace.TraceError(\"MM: cannot add {0}, does not want same game type\", other.Name);\n                    return false;\n                }\n\n                var width = owner.EloWidth * widthMultiplier;\n                if (hasParty)\n                    width = width * DynamicConfig.Instance.MmWidthReductionForParties;\n\n                if (other.Party != null)\n                {\n                    if (!hasParty)\n                        width = width * DynamicConfig.Instance.MmWidthReductionForParties;\n\n                    if (!VerifyPartySizeFits(other.Party))\n                    {\n                        //Trace.TraceError(\"MM: cannot add party {0}, party size does not fit\", other.Name);\n                        return false;\n                    }\n\n                    if ((GetPartyMinElo(other.Party, allPlayers) - MinElo > width) || (MaxElo - GetPartyMaxElo(other.Party, allPlayers) > width))\n                    {\n                        //Trace.TraceError(\"MM: cannot add party {0}, {1} - {2} > {3} || {4} - {5} > {3}\", other.Name, GetPartyMinElo(other.Party, allPlayers), MinElo, width, MaxElo, GetPartyMaxElo(other.Party, allPlayers));\n                        return false;\n                    }\n                }\n                else if ((GetPlayerMinElo(other) - MinElo > width) || (MaxElo - GetPlayerMaxElo(other) > width))\n                {\n                    //Trace.TraceError(\"MM: cannot add {0}, {1} - {2} > {3} || {4} - {5} > {3}\", other.Name, GetPlayerMinElo(other), MinElo, width, MaxElo, GetPlayerMaxElo(other));\n                    return false;\n                }\n\n                return true;\n            }\n\n            private double CutOffFunc(double input)\n            {\n                if (input >= 1500) return Math.Round(1500.0 + Math.Pow(input - 1500.0, eloCutOffExponent));\n                else return 1500.0 - Math.Pow(1500.0 - input, eloCutOffExponent);\n            }\n\n            private int GetPlayerMaxElo(PlayerEntry entry)\n            {\n                return (int)Math.Round(CutOffFunc(entry.MaxConsideredElo));\n            }\n\n            private int GetPartyMaxElo(PartyManager.Party party, List<PlayerEntry> players)\n            {\n                return (int)Math.Round(players.Where(x => x.Party == party).Select(GetPlayerMaxElo).Average());\n            }\n\n            private int GetPartyMinElo(PartyManager.Party party, List<PlayerEntry> players)\n            {\n                return (int)Math.Round(players.Where(x => x.Party == party).Select(GetPlayerMinElo).Average());\n            }\n\n\n            private int GetPlayerMinElo(PlayerEntry entry)\n            {\n                return (int)Math.Round(CutOffFunc(entry.MinConsideredElo));\n            }\n\n            private bool VerifyPartySizeFits(PartyManager.Party party)\n            {\n                if (party.UserNames.Count + Players.Count > Size) return false;\n\n                if (QueueType.Mode != AutohostMode.GameChickens)\n                {\n\n                    var existingPartySizes =\n                        Players.Where(x => x.Party != null)\n                            .GroupBy(x => x.Party)\n                            .Select(x => x.Key.UserNames.Count)\n                            .OrderByDescending(x => x)\n                            .ToList();\n                    var maxTeamSize = Size/2;\n                    var t1 = 0;\n                    var t2 = 0;\n                    foreach (var psize in existingPartySizes)\n                        if (t1 + psize <= maxTeamSize) t1 += psize;\n                        else if (t2 + psize <= maxTeamSize) t2 += psize;\n\n                    if ((party.UserNames.Count + t1 > maxTeamSize) && (party.UserNames.Count + t2 > maxTeamSize)) return false; // cannot fit new party to still balance\n                }\n\n                return true;\n            }\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class OrderAndPositionViewModel : BindableBase\n    {\n        private OrderTable _ordertable = new OrderTable();\n        private PositionTable _positiontable = new PositionTable();\n        private FillTable _filltable = new FillTable();\n        //private ResultTable _resulttable = new ResultTable();\n        System.Data.DataTable _resultstable = new System.Data.DataTable(\"ResultsTable\");\n\n        private EventAggregator _eventaggregator;\n        private readonly ILoggerFacade _logger;\n        private ConfigManager _configmanager;\n\n        PositionTracker _positiontracker;\n        OrderTracker _ordertracker;\n        List<Trade> _tradelist = new List<Trade>();\n        PerformanceEvaluator _performevaluator;\n\n        public OrderAndPositionViewModel()\n        {\n            _eventaggregator = ServiceLocator.Current.GetInstance<EventAggregator>();\n            _logger = ServiceLocator.Current.GetInstance<ILoggerFacade>();\n            _configmanager = ServiceLocator.Current.GetInstance<IConfigManager>() as ConfigManager;\n\n            _ordertracker = new OrderTracker(_configmanager.DailyOrderCapacity);\n            _ordertracker.SendDebugEvent += OnDebug;\n            _positiontracker = new PositionTracker(_configmanager.DailyOrderCapacity);\n\n            _eventaggregator.GetEvent<InitialPositionEvent>().Subscribe(ClientGotInitialPosition);\n            //_eventaggregator.GetEvent<SendOrderEvent>().Subscribe(ClientGotOrder);\n            _eventaggregator.GetEvent<OrderConfirmationEvent>().Subscribe(ClientGotOrder);\n            _eventaggregator.GetEvent<OrderCancelConfirmationEvent>().Subscribe(ClientGotOrderCancelConfirmation);\n            _eventaggregator.GetEvent<OrderFillEvent>().Subscribe(ClientGotOrderFilled);\n            _eventaggregator.GetEvent<GenerateReportEvent>().Subscribe(GeneratePerformanceReport);\n\n            _resultstable.Columns.Add(\"Statistics\");\n            _resultstable.Columns.Add(\"Result\");\n        }\n\n        private void ClientGotInitialPosition(Position obj)\n        {\n            System.Windows.Application.Current.Dispatcher.Invoke(() =>\n            {\n                if (_positiontracker.IsTracked(obj.FullSymbol))\n                {\n                    int pos = PositionTable.Select(row => row.Symbol).ToList().IndexOf(obj.FullSymbol); // should exist\n                    PositionTable[pos].AvgPrice = obj.AvgPrice;\n                    PositionTable[pos].Size = obj.Size;\n                    PositionTable[pos].ClosePL = obj.ClosedPL;\n                    PositionTable[pos].OpenPL = obj.OpenPL;\n                }\n                else\n                {\n                    int count = PositionTable.Count;\n                    // ?? A first chance exception system notsupportedexception presentationframework dll ??\n                    PositionTable.Add(new PositionEntry(count, obj.FullSymbol, obj.AvgPrice, obj.Size, obj.ClosedPL, obj.OpenPL));\n                }\n            });\n\n            _positiontracker.Adjust(obj);\n        }\n\n        private void ClientGotOrder(Order o)\n        {\n            int pos = OrderTable.Select(row => row.OrderId).ToList().IndexOf(o.Id);\n\n            System.Windows.Application.Current.Dispatcher.Invoke(() =>\n            {\n                if (pos == -1)      // not found\n                {\n                    OnDebug(\"Order id \" + o.Id.ToString() + \" is not found in order table; possibly new order.\");\n                    // it must be previous open order, or placed by tws\n                    // add to _ordertracker\n                    _ordertracker.GotOrder(o);\n                    // update status\n                    OrderTable.Add(new OrderEntry(o.Id, o.Account, o.FullSymbol, o.OrderType, o.Price, o.OrderSize, o.OrderTime, EnumDescConverter.GetEnumDescription(o.OrderStatus)));\n                }\n                else\n                {\n                    OrderTable[pos].Status = EnumDescConverter.GetEnumDescription(o.OrderStatus);\n                }\n            });\n        }\n\n        private void ClientGotOrderCancelConfirmation(long oid)\n        {\n            int pos = OrderTable.Select(row => row.OrderId).ToList().IndexOf(oid);\n\n            System.Windows.Application.Current.Dispatcher.Invoke(() =>\n            {\n                if (pos == -1)\n                {\n                    OnDebug(\"Order id \" + oid.ToString() + \" is not found in order table; possibly new order.\");\n                }\n                else\n                {\n                    // order table\n                    _ordertracker.GotCancel(oid);\n                    OrderStatus status = OrderStatus.Canceled;\n                    OrderTable[pos].Status = EnumDescConverter.GetEnumDescription(status);\n                }  \n            });\n        }\n\n        private void ClientGotOrderFilled(Trade k)\n        {\n            _tradelist.Add(k);\n\n            System.Windows.Application.Current.Dispatcher.Invoke(() =>\n            {\n                // order table\n                int pos = OrderTable.Select(row => row.OrderId).ToList().IndexOf(k.Id);\n                if (pos == -1)\n                {\n                    OnDebug(\"Order id \" + k.Id.ToString() + \" is not found in order table; possibly new order.\");\n                }\n                else\n                {\n                    _ordertracker.GotFill(k);\n\n                    if (_ordertracker[k.Id] == 0)\n                    {\n                        OrderStatus status = OrderStatus.Filled;\n                        OrderTable[pos].Status = EnumDescConverter.GetEnumDescription(status);\n                    }\n                    else\n                    {\n                        OrderStatus status = OrderStatus.PartiallyFilled;\n                        _ordertable[pos].Status = EnumDescConverter.GetEnumDescription(status);\n                    }\n                }\n\n                // position table only handles one account\n                // but it is guarantteed by order id\n                _positiontracker.Adjust(k);\n                pos = PositionTable.Select(row => row.Symbol).ToList().IndexOf(k.FullSymbol);\n                if (pos == -1)\n                {\n                    // add new position\n                    int count = PositionTable.Count;\n\n                    PositionTable.Add(new PositionEntry(count, k.FullSymbol, _positiontracker[k.FullSymbol].AvgPrice, _positiontracker[k.FullSymbol].Size,\n                        _positiontracker[k.FullSymbol].ClosedPL, _positiontracker[k.FullSymbol].OpenPL));\n                }\n                else\n                {\n                    // adjust position\n                    PositionTable[pos].AvgPrice = _positiontracker[k.FullSymbol].AvgPrice;\n                    PositionTable[pos].Size = _positiontracker[k.FullSymbol].Size;\n                    PositionTable[pos].ClosePL = _positiontracker[k.FullSymbol].ClosedPL;\n                    PositionTable[pos].OpenPL = _positiontracker[k.FullSymbol].OpenPL;\n                }\n\n                FillTable.Add(new FillEntry(k.Id, k.TradeTime, k.FullSymbol, k.TradeSize, k.TradePrice));\n            });\n        }\n\n        private void GeneratePerformanceReport(int time)\n        {\n            _performevaluator = new PerformanceEvaluator();\n            //_performevaluator.InitializePositions();\n            _performevaluator.GenerateReports(_tradelist);\n\n            System.Windows.Application.Current.Dispatcher.Invoke(() =>\n            {\n                _performevaluator.FillGrid(_resultstable);\n                TabControlSelectedIndex = 3;\n            });\n        }\n\n        int _selectedOrderIndex = -1;\n        public int SelectedOrderIndex\n        {\n            get { return _selectedOrderIndex; }\n            set\n            {\n                if (value == _selectedOrderIndex)\n                    return;\n\n                // index changed\n                _selectedOrderIndex = value;\n                _eventaggregator.GetEvent<OrderGridSelectionChangedEvent>().Publish(_ordertable[_selectedOrderIndex].OrderId);\n            }\n        }\n\n        int _tabcontrolselectedindex = 0;\n        public int TabControlSelectedIndex\n        {\n            get { return _tabcontrolselectedindex; }\n            set { SetProperty(ref _tabcontrolselectedindex, value); }\n        }\n\n        private void OnDebug(string msg)\n        {\n            _logger.Log(msg, Category.Info, Priority.None);\n        }\n\n        public OrderTable OrderTable\n        {\n            get { return this._ordertable; }\n            set { SetProperty(ref this._ordertable, value); }\n        }\n\n        public FillTable FillTable\n        {\n            get { return this._filltable; }\n            set { SetProperty(ref this._filltable, value); }\n        }\n\n        public PositionTable PositionTable\n        {\n            get { return this._positiontable; }\n            set { SetProperty(ref this._positiontable, value); }\n        }\n\n        public System.Data.DataTable ResultTable { get { return _resultstable; } }\n    }\n", "label": "FeatureEnvy"}
{"text": "    internal class PdfPrintDocument : PrintDocument\n    {\n        private readonly IPdfDocument _document;\n        private readonly PdfPrintSettings _settings;\n        private int _currentPage;\n\n        public event QueryPageSettingsEventHandler BeforeQueryPageSettings;\n\n        protected virtual void OnBeforeQueryPageSettings(QueryPageSettingsEventArgs e)\n        {\n            var ev = BeforeQueryPageSettings;\n            if (ev != null)\n                ev(this, e);\n        }\n\n        public event PrintPageEventHandler BeforePrintPage;\n\n        protected virtual void OnBeforePrintPage(PrintPageEventArgs e)\n        {\n            var ev = BeforePrintPage;\n            if (ev != null)\n                ev(this, e);\n        }\n\n        public PdfPrintDocument(IPdfDocument document, PdfPrintSettings settings)\n        {\n            if (document == null)\n                throw new ArgumentNullException(\"document\");\n\n            _document = document;\n            _settings = settings;\n        }\n\n        protected override void OnBeginPrint(PrintEventArgs e)\n        {\n            _currentPage = PrinterSettings.FromPage == 0 ? 0 : PrinterSettings.FromPage - 1;\n\n            base.OnBeginPrint(e);\n        }\n\n        protected override void OnQueryPageSettings(QueryPageSettingsEventArgs e)\n        {\n            OnBeforeQueryPageSettings(e);\n\n            // Some printers misreport landscape. The below check verifies\n            // whether the page rotation matches the landscape setting.\n            bool inverseLandscape = e.PageSettings.Bounds.Width > e.PageSettings.Bounds.Height != e.PageSettings.Landscape;\n\n            if (_settings.MultiplePages == null && _currentPage < _document.PageCount)\n            {\n                bool landscape = GetOrientation(_document.PageSizes[_currentPage]) == Orientation.Landscape;\n\n                if (inverseLandscape)\n                    landscape = !landscape;\n\n                e.PageSettings.Landscape = landscape;\n            }\n\n            base.OnQueryPageSettings(e);\n        }\n\n        protected override void OnPrintPage(PrintPageEventArgs e)\n        {\n            OnBeforePrintPage(e);\n\n            if (_settings.MultiplePages != null)\n                PrintMultiplePages(e);\n            else\n                PrintSinglePage(e);\n\n            base.OnPrintPage(e);\n        }\n\n        private void PrintMultiplePages(PrintPageEventArgs e)\n        {\n            var settings = _settings.MultiplePages;\n\n            int pagesPerPage = settings.Horizontal * settings.Vertical;\n            int pageCount = (_document.PageCount - 1) / pagesPerPage + 1;\n\n            if (_currentPage < pageCount)\n            {\n                double width = e.PageBounds.Width - e.PageSettings.HardMarginX * 2;\n                double height = e.PageBounds.Height - e.PageSettings.HardMarginY * 2;\n\n                double widthPerPage = (width - (settings.Horizontal - 1) * settings.Margin) / settings.Horizontal;\n                double heightPerPage = (height - (settings.Vertical - 1) * settings.Margin) / settings.Vertical;\n\n                for (int horizontal = 0; horizontal < settings.Horizontal; horizontal++)\n                {\n                    for (int vertical = 0; vertical < settings.Vertical; vertical++)\n                    {\n                        int page = _currentPage * pagesPerPage;\n                        if (settings.Orientation == System.Windows.Forms.Orientation.Horizontal)\n                            page += vertical * settings.Vertical + horizontal;\n                        else\n                            page += horizontal * settings.Horizontal + vertical;\n\n                        if (page >= _document.PageCount)\n                            continue;\n\n                        double pageLeft = (widthPerPage + settings.Margin) * horizontal;\n                        double pageTop = (heightPerPage + settings.Margin) * vertical;\n\n                        RenderPage(e, page, pageLeft, pageTop, widthPerPage, heightPerPage);\n                    }\n                }\n\n                _currentPage++;\n            }\n\n            if (PrinterSettings.ToPage > 0)\n                pageCount = Math.Min(PrinterSettings.ToPage, pageCount);\n\n            e.HasMorePages = _currentPage < pageCount;\n        }\n\n        private void PrintSinglePage(PrintPageEventArgs e)\n        {\n            if (_currentPage < _document.PageCount)\n            {\n                var pageOrientation = GetOrientation(_document.PageSizes[_currentPage]);\n                var printOrientation = GetOrientation(e.PageBounds.Size);\n\n                e.PageSettings.Landscape = pageOrientation == Orientation.Landscape;\n\n                double left;\n                double top;\n                double width;\n                double height;\n\n                if (_settings.Mode == PdfPrintMode.ShrinkToMargin)\n                {\n                    left = 0;\n                    top = 0;\n                    width = e.PageBounds.Width - e.PageSettings.HardMarginX * 2;\n                    height = e.PageBounds.Height - e.PageSettings.HardMarginY * 2;\n                }\n                else\n                {\n                    left = -e.PageSettings.HardMarginX;\n                    top = -e.PageSettings.HardMarginY;\n                    width = e.PageBounds.Width;\n                    height = e.PageBounds.Height;\n                }\n\n                if (pageOrientation != printOrientation)\n                {\n                    Swap(ref height, ref width);\n                    Swap(ref left, ref top);\n                }\n\n                RenderPage(e, _currentPage, left, top, width, height);\n                _currentPage++;\n            }\n\n            int pageCount = PrinterSettings.ToPage == 0\n                ? _document.PageCount\n                : Math.Min(PrinterSettings.ToPage, _document.PageCount);\n\n            e.HasMorePages = _currentPage < pageCount;\n        }\n\n        private void RenderPage(PrintPageEventArgs e, int page, double left, double top, double width, double height)\n        {\n            var size = _document.PageSizes[page];\n\n            double pageScale = size.Height / size.Width;\n            double printScale = height / width;\n\n            double scaledWidth = width;\n            double scaledHeight = height;\n\n            if (pageScale > printScale)\n                scaledWidth = width * (printScale / pageScale);\n            else\n                scaledHeight = height * (pageScale / printScale);\n\n            left += (width - scaledWidth) / 2;\n            top += (height - scaledHeight) / 2;\n\n            _document.Render(\n                page,\n                e.Graphics,\n                e.Graphics.DpiX,\n                e.Graphics.DpiY,\n                new Rectangle(\n                    AdjustDpi(e.Graphics.DpiX, left),\n                    AdjustDpi(e.Graphics.DpiY, top),\n                    AdjustDpi(e.Graphics.DpiX, scaledWidth),\n                    AdjustDpi(e.Graphics.DpiY, scaledHeight)\n                ),\n                PdfRenderFlags.ForPrinting | PdfRenderFlags.Annotations\n            );\n        }\n\n        private static void Swap(ref double a, ref double b)\n        {\n            var tmp = a;\n            a = b;\n            b = tmp;\n        }\n\n        private static int AdjustDpi(double value, double dpi)\n        {\n            return (int)((value / 100.0) * dpi);\n        }\n\n        private Orientation GetOrientation(SizeF pageSize)\n        {\n            if (pageSize.Height > pageSize.Width)\n                return Orientation.Portrait;\n            return Orientation.Landscape;\n        }\n\n        private enum Orientation\n        {\n            Portrait,\n            Landscape\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Implementation of the default tool resolution strategy.\n    /// </summary>\n    public sealed class ToolResolutionStrategy : IToolResolutionStrategy\n    {\n        private readonly IFileSystem _fileSystem;\n        private readonly ICakeEnvironment _environment;\n        private readonly IGlobber _globber;\n        private readonly ICakeConfiguration _configuration;\n        private readonly object _lock;\n        private List<DirectoryPath> _path;\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"ToolResolutionStrategy\"/> class.\n        /// </summary>\n        /// <param name=\"fileSystem\">The file system.</param>\n        /// <param name=\"environment\">The environment.</param>\n        /// <param name=\"globber\">The globber.</param>\n        /// <param name=\"configuration\">The configuration.</param>\n        public ToolResolutionStrategy(\n            IFileSystem fileSystem,\n            ICakeEnvironment environment,\n            IGlobber globber,\n            ICakeConfiguration configuration)\n        {\n            if (fileSystem == null)\n            {\n                throw new ArgumentNullException(nameof(fileSystem));\n            }\n            if (environment == null)\n            {\n                throw new ArgumentNullException(nameof(environment));\n            }\n            if (globber == null)\n            {\n                throw new ArgumentNullException(nameof(globber));\n            }\n\n            _fileSystem = fileSystem;\n            _environment = environment;\n            _globber = globber;\n            _configuration = configuration;\n            _lock = new object();\n        }\n\n        /// <summary>\n        /// Resolves the specified tool using the specified tool repository.\n        /// </summary>\n        /// <param name=\"repository\">The tool repository.</param>\n        /// <param name=\"tool\">The tool.</param>\n        /// <returns>\n        /// The path to the tool; otherwise <c>null</c>.\n        /// </returns>\n        public FilePath Resolve(IToolRepository repository, string tool)\n        {\n            if (repository == null)\n            {\n                throw new ArgumentNullException(nameof(repository));\n            }\n            if (tool == null)\n            {\n                throw new ArgumentNullException(nameof(tool));\n            }\n            if (string.IsNullOrWhiteSpace(tool))\n            {\n                throw new ArgumentException(\"Tool name cannot be empty.\", nameof(tool));\n            }\n\n            // Does this file already have registrations?\n            var resolve = LookInRegistrations(repository, tool);\n            if (resolve == null)\n            {\n                // Look in ./tools/\n                resolve = LookInToolsDirectory(tool);\n                if (resolve == null)\n                {\n                    // Look in the path environment variable.\n                    resolve = LookInPath(tool);\n                }\n            }\n\n            return resolve;\n        }\n\n        private static FilePath LookInRegistrations(IToolRepository repository, string tool)\n        {\n            return repository.Resolve(tool).LastOrDefault();\n        }\n\n        private FilePath LookInToolsDirectory(string tool)\n        {\n            var pattern = string.Concat(GetToolsDirectory().FullPath, \"/**/\", tool);\n            var toolPath = _globber.GetFiles(pattern).FirstOrDefault();\n            return toolPath?.MakeAbsolute(_environment);\n        }\n\n        private FilePath LookInPath(string tool)\n        {\n            lock (_lock)\n            {\n                if (_path == null)\n                {\n                    _path = GetPathDirectories();\n                }\n\n                foreach (var pathDir in _path)\n                {\n                    var file = pathDir.CombineWithFilePath(tool);\n                    try\n                    {\n                        if (_fileSystem.Exist(file))\n                        {\n                            return file.MakeAbsolute(_environment);\n                        }\n                    }\n                    catch\n                    {\n                    }\n                }\n\n                return null;\n            }\n        }\n\n        private DirectoryPath GetToolsDirectory()\n        {\n            var toolPath = _configuration.GetValue(Constants.Paths.Tools);\n            if (!string.IsNullOrWhiteSpace(toolPath))\n            {\n                return new DirectoryPath(toolPath);\n            }\n\n            return new DirectoryPath(\"./tools\");\n        }\n\n        private List<DirectoryPath> GetPathDirectories()\n        {\n            var result = new List<DirectoryPath>();\n            var path = _environment.GetEnvironmentVariable(\"PATH\");\n            if (!string.IsNullOrEmpty(path))\n            {\n                var separator = new[] { _environment.Platform.IsUnix() ? ':' : ';' };\n                var paths = path.Split(separator, StringSplitOptions.RemoveEmptyEntries);\n                foreach (var p in paths)\n                {\n                    try\n                    {\n                        result.Add(new DirectoryPath(p.Trim(' ', '\"', '\\'')));\n                    }\n                    catch\n                    {\n                    }\n                }\n            }\n\n            return result;\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\tpublic class MeleeAttackBehavior : BehaviorBase\n\t{\n\t\tprivate static readonly ILog Log = LogManager.GetLogger(typeof(MeleeAttackBehavior));\n\n\t\tprotected readonly Mob _entity;\n\t\tprivate double _speedMultiplier;\n\t\tprivate readonly double _followRange;\n\n\t\tprivate int _attackCooldown;\n\t\tprivate int _delay;\n\t\tprivate Path _currentPath;\n\t\tprivate Vector3 _lastPlayerPos;\n\n\t\tpublic MeleeAttackBehavior(Mob entity, double speedMultiplier, double followRange)\n\t\t{\n\t\t\t_entity = entity;\n\t\t\t_speedMultiplier = speedMultiplier;\n\t\t\t_followRange = followRange;\n\t\t}\n\n\t\tpublic override bool ShouldStart()\n\t\t{\n\t\t\tvar target = _entity.Target;\n\t\t\tif (target == null) return false;\n\n\t\t\tvar pathfinder = new Pathfinder();\n\t\t\t_currentPath = pathfinder.FindPath(_entity, target, _followRange);\n\n\t\t\tif (!_currentPath.HavePath()) return false;\n\n\t\t\t_lastPlayerPos = target.KnownPosition;\n\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic override void OnStart()\n\t\t{\n\t\t\t_delay = 0;\n\t\t}\n\n\t\tpublic override bool CanContinue()\n\t\t{\n\t\t\treturn _entity.Target != null;\n\t\t}\n\n\t\tpublic override void OnTick(Entity[] entities)\n\t\t{\n\t\t\tEntity target = _entity.Target;\n\t\t\tif (target == null) return;\n\n\t\t\tdouble distanceToPlayer = _entity.DistanceTo(target);\n\n\t\t\t--_delay;\n\n\t\t\tfloat deltaDistance = Vector3.Distance(_lastPlayerPos, target.KnownPosition);\n\n\t\t\tbool canSee = _entity.CanSee(target);\n\n\t\t\tif (canSee || _delay <= 0 || deltaDistance > 1 || _entity.Level.Random.NextDouble() < 0.05)\n\t\t\t{\n\t\t\t\tvar pathfinder = new Pathfinder();\n\t\t\t\tStopwatch sw = Stopwatch.StartNew();\n\t\t\t\t_currentPath = pathfinder.FindPath(_entity, target, _followRange);\n\t\t\t\tif (Log.IsDebugEnabled)\n\t\t\t\t{\n\t\t\t\t\tsw.Stop();\n\t\t\t\t\tif (sw.ElapsedMilliseconds > 5) Log.Warn($\"A* search for {_entity.GetType()} on a distance of {_followRange}. Spent {sw.ElapsedMilliseconds}ms and lenght of path is {_currentPath.Current.Count}\");\n\t\t\t\t\t// DEBUG\n\t\t\t\t\t//_currentPath.PrintPath(_entity.Level);\n\t\t\t\t}\n\n\t\t\t\t_lastPlayerPos = target.KnownPosition;\n\n\t\t\t\t_delay = 4 + _entity.Level.Random.Next(7);\n\n\t\t\t\tif (distanceToPlayer > 32)\n\t\t\t\t{\n\t\t\t\t\t_delay += 10;\n\t\t\t\t}\n\t\t\t\telse if (distanceToPlayer > 16)\n\t\t\t\t{\n\t\t\t\t\t_delay += 5;\n\t\t\t\t}\n\n\t\t\t\tif (_currentPath.NoPath())\n\t\t\t\t{\n\t\t\t\t\t_delay += 15;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Movement\n\t\t\tif (_currentPath.HavePath())\n\t\t\t{\n\t\t\t\tif (_currentPath.GetNextTile(_entity, out Tile next /*, true*/))\n\t\t\t\t{\n\t\t\t\t\t_entity.Controller.RotateTowards(new Vector3(next.X + 0.5f, _entity.KnownPosition.Y, next.Y + 0.5f));\n\t\t\t\t\t_entity.Controller.MoveForward(_speedMultiplier, entities);\n\t\t\t\t} // else something is really wrong\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_entity.Velocity = Vector3.Zero;\n\t\t\t}\n\n\t\t\t_entity.Controller.LookAt(target);\n\n\t\t\t_attackCooldown = Math.Max(_attackCooldown - 1, 0);\n\t\t\tif (_attackCooldown <= 0 && distanceToPlayer < GetAttackReach())\n\t\t\t{\n\t\t\t\tvar damage = _entity.AttackDamage;\n\t\t\t\ttarget.HealthManager.TakeHit(_entity, damage, DamageCause.EntityAttack);\n\t\t\t\t_attackCooldown = 20;\n\t\t\t}\n\t\t}\n\n\t\tprivate double GetAttackReach()\n\t\t{\n\t\t\treturn _entity.Width * 2.0F + _entity.Target.Width;\n\t\t}\n\n\t\tpublic override void OnEnd()\n\t\t{\n\t\t\t_entity.Velocity = Vector3.Zero;\n\t\t\t_entity.KnownPosition.Pitch = 0;\n\t\t\t_attackCooldown = 0;\n\t\t\t_delay = 0;\n\t\t\t_currentPath = null;\n\t\t}\n\t}\n", "label": "FeatureEnvy"}
{"text": "    public partial class Map\n    {\n        public clsAutoTextureChanges AutoTextureChanges;\n        public clsSectorChanges SectorGraphicsChanges;\n        public clsSectorChanges SectorTerrainUndoChanges;\n        public clsSectorChanges SectorUnitHeightsChanges;\n        public clsTerrainUpdate TerrainInterpretChanges;\n    }\n    public partial class Map\n    {\n        public void GLDraw(DrawContext ctx)\n        {\n            var xyzDbl = default(XYZDouble);\n            var x2 = 0;\n            var y2 = 0;\n            var a = 0;\n            var b = 0;\n            var D = 0;\n            SRgba colourA;\n            SRgba colourB;\n            bool showMinimapViewPosBox;\n            var viewCorner0 = default(XYDouble);\n            var viewCorner1 = default(XYDouble);\n            var viewCorner2 = default(XYDouble);\n            var viewCorner3 = default(XYDouble);\n            double dblTemp = 0;\n            var vertex0 = default(XYZDouble);\n            var vertex1 = default(XYZDouble);\n            var vertex2 = default(XYZDouble);\n            var vertex3 = default(XYZDouble);\n            var screenPos = new XYInt();\n            var xyzDbl2 = default(XYZDouble);\n            var posA = default(XYDouble);\n            var posB = default(XYDouble);\n            var posC = default(XYDouble);\n            var posD = default(XYDouble);\n            var minimapSizeXy = new XYInt();\n            Unit unit;\n            var startXy = new XYInt();\n            var finishXy = new XYInt();\n            bool drawIt;\n            var drawCentreSector = new clsBrush.sPosNum();\n            var selectionLabel = new clsTextLabel();\n            var lightPosition = new float[4];\n            var matrixB = new Matrix3DMath.Matrix3D();\n            clsAction mapAction;\n            float zNearFar = 0;\n            var glSize = ctx.GlSize;\n            var drawCentre = default(XYDouble);\n\n            dblTemp = App.SettingsManager.MinimapSize;\n            ctx.ViewInfo.TilesPerMinimapPixel = Math.Sqrt(Terrain.TileSize.X * Terrain.TileSize.X + Terrain.TileSize.Y * Terrain.TileSize.Y) /\n                                               (MathUtil.RootTwo * dblTemp);\n            if ( ctx.MinimapGl.TextureSize > 0 & ctx.ViewInfo.TilesPerMinimapPixel > 0.0D )\n            {\n                minimapSizeXy.X = (Terrain.TileSize.X / ctx.ViewInfo.TilesPerMinimapPixel).ToInt();\n                minimapSizeXy.Y = (Terrain.TileSize.Y / ctx.ViewInfo.TilesPerMinimapPixel).ToInt();\n            }\n\n            if ( !ctx.ViewInfo.ScreenXYGetViewPlanePos(new XYInt((glSize.Width / 2.0D).ToInt(), (glSize.Height / 2.0D).ToInt()), dblTemp, ref drawCentre) )\n            {\n                Matrix3DMath.VectorForwardsRotationByMatrix(ctx.ViewInfo.ViewAngleMatrix, ref xyzDbl);\n                var dblTemp2 = App.VisionRadius * 2.0D / Math.Sqrt(xyzDbl.X * xyzDbl.X + xyzDbl.Z * xyzDbl.Z);\n                drawCentre.X = ctx.ViewInfo.ViewPos.X + xyzDbl.X * dblTemp2;\n                drawCentre.Y = ctx.ViewInfo.ViewPos.Z + xyzDbl.Z * dblTemp2;\n            }\n            drawCentre.X = MathUtil.ClampDbl(drawCentre.X, 0.0D, Terrain.TileSize.X * Constants.TerrainGridSpacing - 1.0D);\n            drawCentre.Y = MathUtil.ClampDbl(Convert.ToDouble(- drawCentre.Y), 0.0D, Terrain.TileSize.Y * Constants.TerrainGridSpacing - 1.0D);\n            drawCentreSector.Normal = GetPosSectorNum(new XYInt(drawCentre.X.ToInt(), drawCentre.Y.ToInt()));\n            drawCentreSector.Alignment = GetPosSectorNum(new XYInt((drawCentre.X - Constants.SectorTileSize * Constants.TerrainGridSpacing / 2.0D).ToInt(), (drawCentre.Y - Constants.SectorTileSize * Constants.TerrainGridSpacing / 2.0D).ToInt()));\n\n            var drawObjects = new clsDrawSectorObjects(ctx.GlSize, ctx.ViewInfo)\n                {\n                    Map = this,\n                    UnitTextLabels = new clsTextLabels(64)\n                };\n\n            drawObjects.Start();\n\n            xyzDbl.X = drawCentre.X - ctx.ViewInfo.ViewPos.X;\n            xyzDbl.Y = 128 - ctx.ViewInfo.ViewPos.Y;\n            xyzDbl.Z = - drawCentre.Y - ctx.ViewInfo.ViewPos.Z;\n            zNearFar = Convert.ToSingle(xyzDbl.GetMagnitude());\n\n            GL.Enable(EnableCap.DepthTest);\n            GL.MatrixMode(MatrixMode.Projection);\n            float aspectRatio = (float)glSize.Width / (float)glSize.Height;\n            var temp_mat = Matrix4.CreatePerspectiveFieldOfView(ctx.ViewInfo.FieldOfViewY, aspectRatio, zNearFar / 128.0F, zNearFar * 128.0F);\n            GL.LoadMatrix(ref temp_mat);\n            GL.MatrixMode(MatrixMode.Modelview);\n            GL.LoadIdentity();\n\n            Matrix3DMath.MatrixRotationByMatrix(ctx.ViewInfo.ViewAngleMatrixInverted, App.SunAngleMatrix, matrixB);\n            Matrix3DMath.VectorForwardsRotationByMatrix(matrixB, ref xyzDbl);\n            lightPosition[0] = Convert.ToSingle(xyzDbl.X);\n            lightPosition[1] = Convert.ToSingle(xyzDbl.Y);\n            lightPosition[2] = Convert.ToSingle(- xyzDbl.Z);\n            lightPosition[3] = 0.0F;\n            GL.Light(LightName.Light0, LightParameter.Position, lightPosition);\n            GL.Light(LightName.Light1, LightParameter.Position, lightPosition);\n\n            GL.Disable(EnableCap.Light0);\n            GL.Disable(EnableCap.Light1);\n            if ( App.Draw_Lighting != DrawLighting.Off )\n            {\n                if ( App.Draw_Lighting == DrawLighting.Half )\n                {\n                    GL.Enable(EnableCap.Light0);\n                }\n                else if ( App.Draw_Lighting == DrawLighting.Normal )\n                {\n                    GL.Enable(EnableCap.Light1);\n                }\n                GL.Enable(EnableCap.Lighting);\n            }\n            else\n            {\n                GL.Disable(EnableCap.Lighting);\n            }\n\n            dblTemp = 127.5D * HeightMultiplier;\n            if ( ctx.ViewInfo.ScreenXYGetViewPlanePosForwardDownOnly(0, 0, dblTemp, ref viewCorner0)\n                && ctx.ViewInfo.ScreenXYGetViewPlanePosForwardDownOnly(glSize.Width, 0, dblTemp, ref viewCorner1)\n                && ctx.ViewInfo.ScreenXYGetViewPlanePosForwardDownOnly(glSize.Width, glSize.Height, dblTemp, ref viewCorner2)\n                && ctx.ViewInfo.ScreenXYGetViewPlanePosForwardDownOnly(0, glSize.Height, dblTemp, ref viewCorner3) )\n            {\n                showMinimapViewPosBox = true;\n            }\n            else\n            {\n                showMinimapViewPosBox = false;\n            }\n\n            GL.Rotate((float)(ctx.ViewInfo.ViewAngleRPY.Roll / MathUtil.RadOf1Deg), 0.0F, 0.0F, -1.0F);\n            GL.Rotate((float)(ctx.ViewInfo.ViewAngleRPY.Pitch / MathUtil.RadOf1Deg), 1.0F, 0.0F, 0.0F);\n            GL.Rotate((float)(ctx.ViewInfo.ViewAngleRPY.Yaw / MathUtil.RadOf1Deg), 0.0F, 1.0F, 0.0F);\n            GL.Translate(Convert.ToDouble(- ctx.ViewInfo.ViewPos.X), Convert.ToDouble(- ctx.ViewInfo.ViewPos.Y), ctx.ViewInfo.ViewPos.Z);\n\n            GL.Enable(EnableCap.CullFace);\n\n            debugGLError(\"Matrix modes\");\n\n            if ( App.Draw_TileTextures )\n            {\n                GL.Color3(1.0F, 1.0F, 1.0F);\n                GL.Enable(EnableCap.Texture2D);\n                mapAction = new clsDrawCallTerrain();\n                mapAction.Map = this;\n                App.VisionSectors.PerformActionMapSectors(mapAction, drawCentreSector);\n                GL.Disable(EnableCap.Texture2D);\n\n                debugGLError(\"Tile textures\");\n            }\n\n            GL.Disable(EnableCap.DepthTest);\n            GL.Disable(EnableCap.Lighting);\n\n            if ( App.Draw_TileWireframe )\n            {\n                GL.Color3(0.0F, 1.0F, 0.0F);\n                GL.LineWidth(1.0F);\n                var DrawCallTerrainWireframe = new clsDrawCallTerrainWireframe();\n                DrawCallTerrainWireframe.Map = this;\n                App.VisionSectors.PerformActionMapSectors(DrawCallTerrainWireframe, drawCentreSector);\n\n                debugGLError(\"Wireframe\");\n            }\n\n            //draw tile orientation markers\n\n            if ( App.DisplayTileOrientation )\n            {\n                GL.Disable(EnableCap.CullFace);\n\n                GL.Begin(BeginMode.Triangles);\n                GL.Color3(1.0F, 1.0F, 0.0F);\n                mapAction = new clsDrawTileOrientation();\n                mapAction.Map = this;\n                App.VisionSectors.PerformActionMapSectors(mapAction, drawCentreSector);\n                GL.End();\n\n                GL.Enable(EnableCap.CullFace);\n\n                debugGLError(\"Tile orientation\");\n            }\n\n            //draw painted texture terrain type markers\n\n            SRgb rgb;\n\n            var mouseOverTerrain = ctx.ViewInfo.GetMouseOverTerrain();\n\n            if ( App.Draw_VertexTerrain )\n            {\n                GL.LineWidth(1.0F);\n                var drawVertexTerran = new clsDrawVertexTerrain();\n                drawVertexTerran.Map = this;\n                drawVertexTerran.ViewAngleMatrix = ctx.ViewInfo.ViewAngleMatrix;\n                App.VisionSectors.PerformActionMapSectors(drawVertexTerran, drawCentreSector);\n                debugGLError(\"Terrain type markers\");\n            }\n\n            selectionLabel.Text = \"\";\n\n            if ( SelectedAreaVertexA != null )\n            {\n                drawIt = false;\n                if ( SelectedAreaVertexB != null )\n                {\n                    //area is selected\n                    MathUtil.ReorderXY(SelectedAreaVertexA, SelectedAreaVertexB, ref startXy, ref finishXy);\n                    xyzDbl.X = SelectedAreaVertexB.X * Constants.TerrainGridSpacing - ctx.ViewInfo.ViewPos.X;\n                    xyzDbl.Z = - SelectedAreaVertexB.Y * Constants.TerrainGridSpacing - ctx.ViewInfo.ViewPos.Z;\n                    xyzDbl.Y = GetVertexAltitude(SelectedAreaVertexB) - ctx.ViewInfo.ViewPos.Y;\n                    drawIt = true;\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.TerrainSelect)\n                {\n                    if ( mouseOverTerrain != null )\n                    {\n                        //selection is changing under pointer\n                        MathUtil.ReorderXY(SelectedAreaVertexA, mouseOverTerrain.Vertex.Normal, ref startXy, ref finishXy);\n                        xyzDbl.X = mouseOverTerrain.Vertex.Normal.X * Constants.TerrainGridSpacing - ctx.ViewInfo.ViewPos.X;\n                        xyzDbl.Z = - mouseOverTerrain.Vertex.Normal.Y * Constants.TerrainGridSpacing - ctx.ViewInfo.ViewPos.Z;\n                        xyzDbl.Y = GetVertexAltitude(mouseOverTerrain.Vertex.Normal) - ctx.ViewInfo.ViewPos.Y;\n                        drawIt = true;\n                    }\n                }\n                if ( drawIt )\n                {\n                    Matrix3DMath.VectorRotationByMatrix(ctx.ViewInfo.ViewAngleMatrixInverted, xyzDbl, ref xyzDbl2);\n                    if ( ctx.ViewInfo.PosGetScreenXY(xyzDbl2, ref screenPos) )\n                    {\n                        if ( screenPos.X >= 0 & screenPos.X <= glSize.Width & screenPos.Y >= 0 & screenPos.Y <= glSize.Height )\n                        {\n                            selectionLabel.Colour.Red = 1.0F;\n                            selectionLabel.Colour.Green = 1.0F;\n                            selectionLabel.Colour.Blue = 1.0F;\n                            selectionLabel.Colour.Alpha = 1.0F;\n                            selectionLabel.TextFont = App.UnitLabelFont;\n                            selectionLabel.SizeY = App.SettingsManager.FontSize;\n                            selectionLabel.Pos = screenPos;\n                            selectionLabel.Text = finishXy.X - startXy.X + \"x\" + Convert.ToString(finishXy.Y - startXy.Y);\n                        }\n                    }\n                    GL.LineWidth(3.0F);\n                    var drawSelection = new clsDrawTileAreaOutline\n                        {\n                            Map = this, \n                            StartXY = startXy,\n                            FinishXY = finishXy,\n                            Colour = new SRgba(1.0F, 1.0F, 1.0F, 1.0F)\n                        };\n                    drawSelection.ActionPerform();\n                }\n\n                debugGLError(\"Terrain selection box\");\n            }\n\n            if (ctx.ToolOptions.MouseTool == MouseTool.TerrainSelect)\n            {\n                if ( mouseOverTerrain != null )\n                {\n                    //draw mouseover vertex\n                    GL.LineWidth(3.0F);\n\n                    vertex0.X = mouseOverTerrain.Vertex.Normal.X * Constants.TerrainGridSpacing;\n                    vertex0.Y = Convert.ToDouble(Terrain.Vertices[mouseOverTerrain.Vertex.Normal.X, mouseOverTerrain.Vertex.Normal.Y].Height * HeightMultiplier);\n                    vertex0.Z = - mouseOverTerrain.Vertex.Normal.Y * Constants.TerrainGridSpacing;\n                    GL.Begin(BeginMode.Lines);\n                    GL.Color3(1.0F, 1.0F, 1.0F);\n                    GL.Vertex3(vertex0.X - 8.0D, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                    GL.Vertex3(vertex0.X + 8.0D, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                    GL.Vertex3(vertex0.X, vertex0.Y, - vertex0.Z - 8.0D);\n                    GL.Vertex3(vertex0.X, vertex0.Y, - vertex0.Z + 8.0D);\n                    GL.End();\n                }\n                debugGLError(\"Terrain selection vertex\");\n            }\n\n            if ( App.Draw_Gateways )\n            {\n                GL.LineWidth(2.0F);\n                foreach ( var gateway in Gateways )\n                {\n                    var c = 0;\n                    if ( gateway.PosA.X == gateway.PosB.X )\n                    {\n                        if ( gateway.PosA.Y <= gateway.PosB.Y )\n                        {\n                            c = gateway.PosA.Y;\n                            D = gateway.PosB.Y;\n                        }\n                        else\n                        {\n                            c = gateway.PosB.Y;\n                            D = gateway.PosA.Y;\n                        }\n                        x2 = gateway.PosA.X;\n                        for ( y2 = c; y2 <= D; y2++ )\n                        {\n                            vertex0.X = x2 * Constants.TerrainGridSpacing;\n                            vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                            vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                            vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                            vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                            vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                            vertex2.X = x2 * Constants.TerrainGridSpacing;\n                            vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                            vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                            vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                            vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                            vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                            GL.Begin(BeginMode.LineLoop);\n                            GL.Color3(0.75F, 1.0F, 0.0F);\n                            GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                            GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                            GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                            GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                            GL.End();\n                        }\n                    }\n                    else if ( gateway.PosA.Y == gateway.PosB.Y )\n                    {\n                        if ( gateway.PosA.X <= gateway.PosB.X )\n                        {\n                            c = gateway.PosA.X;\n                            D = gateway.PosB.X;\n                        }\n                        else\n                        {\n                            c = gateway.PosB.X;\n                            D = gateway.PosA.X;\n                        }\n                        y2 = gateway.PosA.Y;\n                        for ( x2 = c; x2 <= D; x2++ )\n                        {\n                            vertex0.X = x2 * Constants.TerrainGridSpacing;\n                            vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                            vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                            vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                            vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                            vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                            vertex2.X = x2 * Constants.TerrainGridSpacing;\n                            vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                            vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                            vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                            vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                            vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                            GL.Begin(BeginMode.LineLoop);\n                            GL.Color3(0.75F, 1.0F, 0.0F);\n                            GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                            GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                            GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                            GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                            GL.End();\n                        }\n                    }\n                    else\n                    {\n                        //draw invalid gateways as red tile borders\n                        x2 = gateway.PosA.X;\n                        y2 = gateway.PosA.Y;\n\n                        vertex0.X = x2 * Constants.TerrainGridSpacing;\n                        vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                        vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                        vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex2.X = x2 * Constants.TerrainGridSpacing;\n                        vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                        vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                        vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        GL.Begin(BeginMode.LineLoop);\n                        GL.Color3(1.0F, 0.0F, 0.0F);\n                        GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                        GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                        GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                        GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                        GL.End();\n\n                        x2 = gateway.PosB.X;\n                        y2 = gateway.PosB.Y;\n\n                        vertex0.X = x2 * Constants.TerrainGridSpacing;\n                        vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                        vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                        vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex2.X = x2 * Constants.TerrainGridSpacing;\n                        vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                        vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                        vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        GL.Begin(BeginMode.LineLoop);\n                        GL.Color3(1.0F, 0.0F, 0.0F);\n                        GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                        GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                        GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                        GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                        GL.End();\n                    }\n                }\n                debugGLError(\"Gateways\");\n            }\n\n            if ( mouseOverTerrain != null )\n            {\n                if (ctx.ToolOptions.MouseTool == MouseTool.ObjectSelect)\n                {\n                    if ( UnitSelectedAreaVertexA != null )\n                    {\n                        //selection is changing under pointer\n                        MathUtil.ReorderXY(UnitSelectedAreaVertexA, mouseOverTerrain.Vertex.Normal, ref startXy, ref finishXy);\n                        GL.LineWidth(2.0F);\n                        GL.Color3(0.0F, 1.0F, 1.0F);\n                        var x = 0;\n                        for ( x = startXy.X; x <= finishXy.X - 1; x++ )\n                        {\n                            vertex0.X = x * Constants.TerrainGridSpacing;\n                            vertex0.Y = Convert.ToDouble(Terrain.Vertices[x, startXy.Y].Height * HeightMultiplier);\n                            vertex0.Z = - startXy.Y * Constants.TerrainGridSpacing;\n                            vertex1.X = (x + 1) * Constants.TerrainGridSpacing;\n                            vertex1.Y = Convert.ToDouble(Terrain.Vertices[x + 1, startXy.Y].Height * HeightMultiplier);\n                            vertex1.Z = - startXy.Y * Constants.TerrainGridSpacing;\n                            GL.Begin(BeginMode.Lines);\n                            GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                            GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                            GL.End();\n                        }\n                        for ( x = startXy.X; x <= finishXy.X - 1; x++ )\n                        {\n                            vertex0.X = x * Constants.TerrainGridSpacing;\n                            vertex0.Y = Convert.ToDouble(Terrain.Vertices[x, finishXy.Y].Height * HeightMultiplier);\n                            vertex0.Z = - finishXy.Y * Constants.TerrainGridSpacing;\n                            vertex1.X = (x + 1) * Constants.TerrainGridSpacing;\n                            vertex1.Y = Convert.ToDouble(Terrain.Vertices[x + 1, finishXy.Y].Height * HeightMultiplier);\n                            vertex1.Z = - finishXy.Y * Constants.TerrainGridSpacing;\n                            GL.Begin(BeginMode.Lines);\n                            GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                            GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                            GL.End();\n                        }\n                        var y = 0;\n                        for ( y = startXy.Y; y <= finishXy.Y - 1; y++ )\n                        {\n                            vertex0.X = startXy.X * Constants.TerrainGridSpacing;\n                            vertex0.Y = Convert.ToDouble(Terrain.Vertices[startXy.X, y].Height * HeightMultiplier);\n                            vertex0.Z = - y * Constants.TerrainGridSpacing;\n                            vertex1.X = startXy.X * Constants.TerrainGridSpacing;\n                            vertex1.Y = Convert.ToDouble(Terrain.Vertices[startXy.X, y + 1].Height * HeightMultiplier);\n                            vertex1.Z = - (y + 1) * Constants.TerrainGridSpacing;\n                            GL.Begin(BeginMode.Lines);\n                            GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                            GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                            GL.End();\n                        }\n                        for ( y = startXy.Y; y <= finishXy.Y - 1; y++ )\n                        {\n                            vertex0.X = finishXy.X * Constants.TerrainGridSpacing;\n                            vertex0.Y = Convert.ToDouble(Terrain.Vertices[finishXy.X, y].Height * HeightMultiplier);\n                            vertex0.Z = - y * Constants.TerrainGridSpacing;\n                            vertex1.X = finishXy.X * Constants.TerrainGridSpacing;\n                            vertex1.Y = Convert.ToDouble(Terrain.Vertices[finishXy.X, y + 1].Height * HeightMultiplier);\n                            vertex1.Z = - (y + 1) * Constants.TerrainGridSpacing;\n                            GL.Begin(BeginMode.Lines);\n                            GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                            GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                            GL.End();\n                        }\n\n                        debugGLError(\"Object selection box\");\n                    }\n                    else\n                    {\n                        GL.LineWidth(2.0F);\n                        GL.Color3(0.0F, 1.0F, 1.0F);\n                        GL.Begin(BeginMode.Lines);\n                        GL.Vertex3(mouseOverTerrain.Pos.Horizontal.X - 16.0D, mouseOverTerrain.Pos.Altitude, mouseOverTerrain.Pos.Horizontal.Y - 16.0D);\n                        GL.Vertex3(mouseOverTerrain.Pos.Horizontal.X + 16.0D, mouseOverTerrain.Pos.Altitude, mouseOverTerrain.Pos.Horizontal.Y + 16.0D);\n                        GL.Vertex3(mouseOverTerrain.Pos.Horizontal.X + 16.0D, mouseOverTerrain.Pos.Altitude, mouseOverTerrain.Pos.Horizontal.Y - 16.0D);\n                        GL.Vertex3(mouseOverTerrain.Pos.Horizontal.X - 16.0D, mouseOverTerrain.Pos.Altitude, mouseOverTerrain.Pos.Horizontal.Y + 16.0D);\n                        GL.End();\n\n                        debugGLError(\"Mouse over position\");\n                    }\n                }\n\n                if (ctx.ToolOptions.MouseTool == MouseTool.RoadPlace)\n                {\n                    GL.LineWidth(2.0F);\n\n                    if ( mouseOverTerrain.SideIsV )\n                    {\n                        vertex0.X = mouseOverTerrain.SideNum.X * Constants.TerrainGridSpacing;\n                        vertex0.Y = Convert.ToDouble(Terrain.Vertices[mouseOverTerrain.SideNum.X, mouseOverTerrain.SideNum.Y].Height * HeightMultiplier);\n                        vertex0.Z = - mouseOverTerrain.SideNum.Y * Constants.TerrainGridSpacing;\n                        vertex1.X = mouseOverTerrain.SideNum.X * Constants.TerrainGridSpacing;\n                        vertex1.Y = Convert.ToDouble(Terrain.Vertices[mouseOverTerrain.SideNum.X, mouseOverTerrain.SideNum.Y + 1].Height * HeightMultiplier);\n                        vertex1.Z = - (mouseOverTerrain.SideNum.Y + 1) * Constants.TerrainGridSpacing;\n                    }\n                    else\n                    {\n                        vertex0.X = mouseOverTerrain.SideNum.X * Constants.TerrainGridSpacing;\n                        vertex0.Y = Convert.ToDouble(Terrain.Vertices[mouseOverTerrain.SideNum.X, mouseOverTerrain.SideNum.Y].Height * HeightMultiplier);\n                        vertex0.Z = - mouseOverTerrain.SideNum.Y * Constants.TerrainGridSpacing;\n                        vertex1.X = (mouseOverTerrain.SideNum.X + 1) * Constants.TerrainGridSpacing;\n                        vertex1.Y = Convert.ToDouble(Terrain.Vertices[mouseOverTerrain.SideNum.X + 1, mouseOverTerrain.SideNum.Y].Height * HeightMultiplier);\n                        vertex1.Z = - mouseOverTerrain.SideNum.Y * Constants.TerrainGridSpacing;\n                    }\n\n                    GL.Begin(BeginMode.Lines);\n                    GL.Color3(0.0F, 1.0F, 1.0F);\n                    GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                    GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                    GL.End();\n\n                    debugGLError(\"Road place brush\");\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.RoadLines || \n                    ctx.ToolOptions.MouseTool == MouseTool.Gateways || \n                    ctx.ToolOptions.MouseTool == MouseTool.ObjectLines )\n                {\n                    GL.LineWidth(2.0F);\n\n                    if ( SelectedTileA != null )\n                    {\n                        x2 = SelectedTileA.X;\n                        y2 = SelectedTileA.Y;\n\n                        vertex0.X = x2 * Constants.TerrainGridSpacing;\n                        vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                        vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                        vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex2.X = x2 * Constants.TerrainGridSpacing;\n                        vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                        vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                        vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        GL.Begin(BeginMode.LineLoop);\n                        GL.Color3(0.0F, 1.0F, 1.0F);\n                        GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                        GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                        GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                        GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                        GL.End();\n\n                        if ( mouseOverTerrain.Tile.Normal.X == SelectedTileA.X )\n                        {\n                            if ( mouseOverTerrain.Tile.Normal.Y <= SelectedTileA.Y )\n                            {\n                                a = mouseOverTerrain.Tile.Normal.Y;\n                                b = SelectedTileA.Y;\n                            }\n                            else\n                            {\n                                a = SelectedTileA.Y;\n                                b = mouseOverTerrain.Tile.Normal.Y;\n                            }\n                            x2 = SelectedTileA.X;\n                            for ( y2 = a; y2 <= b; y2++ )\n                            {\n                                vertex0.X = x2 * Constants.TerrainGridSpacing;\n                                vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                                vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                                vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                                vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                                vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                                vertex2.X = x2 * Constants.TerrainGridSpacing;\n                                vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                                vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                                vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                                vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                                vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                                GL.Begin(BeginMode.LineLoop);\n                                GL.Color3(0.0F, 1.0F, 1.0F);\n                                GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                                GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                                GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                                GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                                GL.End();\n                            }\n                        }\n                        else if ( mouseOverTerrain.Tile.Normal.Y == SelectedTileA.Y )\n                        {\n                            if ( mouseOverTerrain.Tile.Normal.X <= SelectedTileA.X )\n                            {\n                                a = mouseOverTerrain.Tile.Normal.X;\n                                b = SelectedTileA.X;\n                            }\n                            else\n                            {\n                                a = SelectedTileA.X;\n                                b = mouseOverTerrain.Tile.Normal.X;\n                            }\n                            y2 = SelectedTileA.Y;\n                            for ( x2 = a; x2 <= b; x2++ )\n                            {\n                                vertex0.X = x2 * Constants.TerrainGridSpacing;\n                                vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                                vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                                vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                                vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                                vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                                vertex2.X = x2 * Constants.TerrainGridSpacing;\n                                vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                                vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                                vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                                vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                                vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                                GL.Begin(BeginMode.LineLoop);\n                                GL.Color3(0.0F, 1.0F, 1.0F);\n                                GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                                GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                                GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                                GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                                GL.End();\n                            }\n                        }\n                    }\n                    else\n                    {\n                        x2 = mouseOverTerrain.Tile.Normal.X;\n                        y2 = mouseOverTerrain.Tile.Normal.Y;\n\n                        vertex0.X = x2 * Constants.TerrainGridSpacing;\n                        vertex0.Y = Convert.ToDouble(Terrain.Vertices[x2, y2].Height * HeightMultiplier);\n                        vertex0.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex1.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex1.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2].Height * HeightMultiplier);\n                        vertex1.Z = - y2 * Constants.TerrainGridSpacing;\n                        vertex2.X = x2 * Constants.TerrainGridSpacing;\n                        vertex2.Y = Convert.ToDouble(Terrain.Vertices[x2, y2 + 1].Height * HeightMultiplier);\n                        vertex2.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.X = (x2 + 1) * Constants.TerrainGridSpacing;\n                        vertex3.Y = Convert.ToDouble(Terrain.Vertices[x2 + 1, y2 + 1].Height * HeightMultiplier);\n                        vertex3.Z = - (y2 + 1) * Constants.TerrainGridSpacing;\n                        GL.Begin(BeginMode.LineLoop);\n                        GL.Color3(0.0F, 1.0F, 1.0F);\n                        GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                        GL.Vertex3(vertex1.X, vertex1.Y, Convert.ToDouble(- vertex1.Z));\n                        GL.Vertex3(vertex3.X, vertex3.Y, Convert.ToDouble(- vertex3.Z));\n                        GL.Vertex3(vertex2.X, vertex2.Y, Convert.ToDouble(- vertex2.Z));\n                        GL.End();\n                    }\n                    debugGLError(\"Line brush\");\n                }\n\n                //draw mouseover tiles\n\n                clsBrush toolBrush;\n                if (ctx.ToolOptions.MouseTool == MouseTool.TextureBrush)\n                {\n                    toolBrush = ctx.ToolOptions.Textures.Brush;\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.CliffBrush)\n                {\n                    toolBrush = ctx.ToolOptions.Terrain.CliffBrush;\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.CliffRemove)\n                {\n                    toolBrush = ctx.ToolOptions.Terrain.CliffBrush;\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.RoadRemove)\n                {\n                    toolBrush = ctx.ToolOptions.Terrain.CliffBrush;\n                }\n                else\n                {\n                    toolBrush = null;\n                }\n\n                if ( toolBrush != null )\n                {\n                    GL.LineWidth(2.0F);\n                    var drawTileOutline = new clsDrawTileOutline\n                    {\n                        Map = this, \n                        Colour = {Red = 0.0F, Green = 1.0F, Blue = 1.0F, Alpha = 1.0F}\n                    };\n                    toolBrush.PerformActionMapTiles(drawTileOutline, mouseOverTerrain.Tile);\n\n                    debugGLError(\"Brush tiles\");\n                }\n\n                //draw mouseover vertex\n                if (ctx.ToolOptions.MouseTool == MouseTool.TerrainFill)\n                {\n                    GL.LineWidth(2.0F);\n\n                    vertex0.X = mouseOverTerrain.Vertex.Normal.X * Constants.TerrainGridSpacing;\n                    vertex0.Y = Convert.ToDouble(Terrain.Vertices[mouseOverTerrain.Vertex.Normal.X, mouseOverTerrain.Vertex.Normal.Y].Height * HeightMultiplier);\n                    vertex0.Z = - mouseOverTerrain.Vertex.Normal.Y * Constants.TerrainGridSpacing;\n                    GL.Begin(BeginMode.Lines);\n                    GL.Color3(0.0F, 1.0F, 1.0F);\n                    GL.Vertex3(vertex0.X - 8.0D, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                    GL.Vertex3(vertex0.X + 8.0D, vertex0.Y, Convert.ToDouble(- vertex0.Z));\n                    GL.Vertex3(vertex0.X, vertex0.Y, Convert.ToDouble(- vertex0.Z - 8.0D));\n                    GL.Vertex3(vertex0.X, vertex0.Y, - vertex0.Z + 8.0D);\n                    GL.End();\n\n                    debugGLError(\"Mouse over vertex\");\n                }\n\n                if (ctx.ToolOptions.MouseTool == MouseTool.TerrainBrush)\n                {\n                    toolBrush = ctx.ToolOptions.Terrain.Brush;\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.HeightSetBrush)\n                {\n                    toolBrush = ctx.ToolOptions.Height.Brush;\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.HeightChangeBrush)\n                {\n                    toolBrush = ctx.ToolOptions.Height.Brush;\n                }\n                else if (ctx.ToolOptions.MouseTool == MouseTool.HeightSmoothBrush)\n                {\n                    toolBrush = ctx.ToolOptions.Height.Brush;\n                }\n                else\n                {\n                    toolBrush = null;\n                }\n\n                if ( toolBrush != null )\n                {\n                    GL.LineWidth(2.0F);\n                    var drawVertexMarker = new clsDrawVertexMarker\n                        {\n                            Map = this, \n                            Colour = {Red = 0.0F, Green = 1.0F, Blue = 1.0F, Alpha = 1.0F}\n                        };\n                    toolBrush.PerformActionMapVertices(drawVertexMarker, mouseOverTerrain.Vertex);\n\n                    debugGLError(\"Brush vertices\");\n                }\n            }\n\n            GL.Enable(EnableCap.DepthTest);\n\n            GL.Disable(EnableCap.CullFace);\n\n            GL.LoadIdentity();\n            GL.Rotate((float)(ctx.ViewInfo.ViewAngleRPY.Roll / MathUtil.RadOf1Deg), 0.0F, 0.0F, -1.0F);\n            GL.Rotate((float)(ctx.ViewInfo.ViewAngleRPY.Pitch / MathUtil.RadOf1Deg), 1.0F, 0.0F, 0.0F);\n            GL.Rotate((float)(ctx.ViewInfo.ViewAngleRPY.Yaw / MathUtil.RadOf1Deg), 0.0F, 1.0F, 0.0F);\n\n            GL.Enable(EnableCap.Blend);\n            GL.BlendFunc(BlendingFactorSrc.SrcAlpha, BlendingFactorDest.OneMinusSrcAlpha);\n\n            debugGLError(\"Object matrix modes\");\n\n            if ( App.Draw_Units )\n            {\n                GL.Color3(1.0F, 1.0F, 1.0F);\n                GL.Enable(EnableCap.Texture2D);\n                App.VisionSectors.PerformActionMapSectors(drawObjects, drawCentreSector);\n                GL.Disable(EnableCap.Texture2D);\n                debugGLError(\"Objects\");\n            }\n\n            if ( mouseOverTerrain != null )\n            {\n                GL.Enable(EnableCap.Texture2D);\n                if (ctx.ToolOptions.MouseTool == MouseTool.ObjectPlace)\n                {\n                    var placeObject = ctx.ToolOptions.PlaceObject.SingleSelectedObjectTypeBase;\n                    if ( placeObject != null )\n                    {\n                        var rotation = Convert.ToInt32(ctx.ToolOptions.PlaceObject.Rotation);\n                        try\n                        {\n                            if ( rotation < 0 | rotation > 359 )\n                            {\n                                rotation = 0;\n                            }\n                        }\n                        catch\n                        {\n                            rotation = 0;\n                        }\n                        WorldPos worldPos = TileAlignedPosFromMapPos(mouseOverTerrain.Pos.Horizontal, placeObject.GetGetFootprintSelected(rotation));\n                        GL.PushMatrix();\n                        GL.Translate(worldPos.Horizontal.X - ctx.ViewInfo.ViewPos.X, worldPos.Altitude - ctx.ViewInfo.ViewPos.Y + 2.0D,\n                            ctx.ViewInfo.ViewPos.Z + worldPos.Horizontal.Y);\n                        placeObject.GLDraw(rotation);\n                        GL.PopMatrix();\n                    }\n                }\n                GL.Disable(EnableCap.Texture2D);\n                debugGLError(\"Mouse over object\");\n            }\n\n            GL.Disable(EnableCap.DepthTest);\n\n            var scriptMarkerTextLabels = new clsTextLabels(256);\n            clsTextLabel textLabel;\n            if ( App.Draw_ScriptMarkers )\n            {\n                clsScriptPosition scriptPosition;\n                clsScriptArea scriptArea;\n                GL.PushMatrix();\n                GL.Translate(Convert.ToDouble(- ctx.ViewInfo.ViewPos.X), Convert.ToDouble(- ctx.ViewInfo.ViewPos.Y), ctx.ViewInfo.ViewPos.Z);\n                foreach ( var tempLoopVar_ScriptPosition in ScriptPositions )\n                {\n                    scriptPosition = tempLoopVar_ScriptPosition;\n                    scriptPosition.GLDraw();\n                }\n                foreach ( var tempLoopVar_ScriptArea in ScriptAreas )\n                {\n                    scriptArea = tempLoopVar_ScriptArea;\n                    scriptArea.GLDraw();\n                }\n                foreach ( var tempLoopVar_ScriptPosition in ScriptPositions )\n                {\n                    scriptPosition = tempLoopVar_ScriptPosition;\n                    if ( scriptMarkerTextLabels.AtMaxCount() )\n                    {\n                        break;\n                    }\n                    xyzDbl.X = scriptPosition.PosX - ctx.ViewInfo.ViewPos.X;\n                    xyzDbl.Z = - scriptPosition.PosY - ctx.ViewInfo.ViewPos.Z;\n                    xyzDbl.Y = GetTerrainHeight(new XYInt(scriptPosition.PosX, scriptPosition.PosY)) - ctx.ViewInfo.ViewPos.Y;\n                    Matrix3DMath.VectorRotationByMatrix(ctx.ViewInfo.ViewAngleMatrixInverted, xyzDbl, ref xyzDbl2);\n                    if ( ctx.ViewInfo.PosGetScreenXY(xyzDbl2, ref screenPos) )\n                    {\n                        if ( screenPos.X >= 0 & screenPos.X <= glSize.Width & screenPos.Y >= 0 & screenPos.Y <= glSize.Height )\n                        {\n                            textLabel = new clsTextLabel();\n                            textLabel.Colour.Red = 1.0F;\n                            textLabel.Colour.Green = 1.0F;\n                            textLabel.Colour.Blue = 0.5F;\n                            textLabel.Colour.Alpha = 0.75F;\n                            textLabel.TextFont = App.UnitLabelFont;\n                            textLabel.SizeY = App.SettingsManager.FontSize;\n                            textLabel.Pos = screenPos;\n                            textLabel.Text = scriptPosition.Label;\n                            scriptMarkerTextLabels.Add(textLabel);\n                        }\n                    }\n                }\n                debugGLError(\"Script positions\");\n                foreach ( var tempLoopVar_ScriptArea in ScriptAreas )\n                {\n                    scriptArea = tempLoopVar_ScriptArea;\n                    if ( scriptMarkerTextLabels.AtMaxCount() )\n                    {\n                        break;\n                    }\n                    xyzDbl.X = scriptArea.PosAX - ctx.ViewInfo.ViewPos.X;\n                    xyzDbl.Z = - scriptArea.PosAY - ctx.ViewInfo.ViewPos.Z;\n                    xyzDbl.Y = GetTerrainHeight(new XYInt(scriptArea.PosAX, scriptArea.PosAY)) - ctx.ViewInfo.ViewPos.Y;\n                    Matrix3DMath.VectorRotationByMatrix(ctx.ViewInfo.ViewAngleMatrixInverted, xyzDbl, ref xyzDbl2);\n                    if ( ctx.ViewInfo.PosGetScreenXY(xyzDbl2, ref screenPos) )\n                    {\n                        if ( screenPos.X >= 0 & screenPos.X <= glSize.Width & screenPos.Y >= 0 & screenPos.Y <= glSize.Height )\n                        {\n                            textLabel = new clsTextLabel();\n                            textLabel.Colour.Red = 1.0F;\n                            textLabel.Colour.Green = 1.0F;\n                            textLabel.Colour.Blue = 0.5F;\n                            textLabel.Colour.Alpha = 0.75F;\n                            textLabel.TextFont = App.UnitLabelFont;\n                            textLabel.SizeY = App.SettingsManager.FontSize;\n                            textLabel.Pos = screenPos;\n                            textLabel.Text = scriptArea.Label;\n                            scriptMarkerTextLabels.Add(textLabel);\n                        }\n                    }\n                }\n                GL.PopMatrix();\n\n                debugGLError(\"Script areas\");\n            }\n\n            var messageTextLabels = new clsTextLabels(24);\n\n            b = 0;\n            for ( a = Math.Max(Messages.Count - messageTextLabels.MaxCount, 0); a <= Messages.Count - 1; a++ )\n            {\n                if ( !messageTextLabels.AtMaxCount() )\n                {\n                    textLabel = new clsTextLabel();\n                    textLabel.Colour.Red = 0.875F;\n                    textLabel.Colour.Green = 0.875F;\n                    textLabel.Colour.Blue = 1.0F;\n                    textLabel.Colour.Alpha = 1.0F;\n                    textLabel.TextFont = App.UnitLabelFont;\n                    textLabel.SizeY = App.SettingsManager.FontSize;\n                    textLabel.Pos.X = 32 + minimapSizeXy.X;\n                    textLabel.Pos.Y = 32 + Math.Ceiling((decimal)(b * textLabel.SizeY)).ToInt();\n                    textLabel.Text = Convert.ToString(Messages[a].Text);\n                    messageTextLabels.Add(textLabel);\n                    b++;\n                }\n            }\n\n            //draw unit selection\n\n            GL.Begin(BeginMode.Quads);\n            foreach ( var tempLoopVar_Unit in SelectedUnits )\n            {\n                unit = tempLoopVar_Unit;\n                rgb = GetUnitGroupColour(unit.UnitGroup);\n                colourA = new SRgba((1.0F + rgb.Red) / 2.0F, (1.0F + rgb.Green) / 2.0F, (1.0F + rgb.Blue) / 2.0F, 0.75F);\n                colourB = new SRgba(rgb.Red, rgb.Green, rgb.Blue, 0.75F);\n                DrawUnitRectangle(unit, 8, colourA, colourB, ctx.ViewInfo);\n            }\n            if ( mouseOverTerrain != null )\n            {\n                foreach ( var tempLoopVar_Unit in mouseOverTerrain.Units )\n                {\n                    unit = tempLoopVar_Unit;\n                    if ( unit != null && ctx.ToolOptions.MouseTool == MouseTool.ObjectSelect)\n                    {\n                        rgb = GetUnitGroupColour(unit.UnitGroup);\n                        GL.Color4((0.5F + rgb.Red) / 1.5F, (0.5F + rgb.Green) / 1.5F, (0.5F + rgb.Blue) / 1.5F, 0.75F);\n                        colourA = new SRgba((1.0F + rgb.Red) / 2.0F, (1.0F + rgb.Green) / 2.0F, (1.0F + rgb.Blue) / 2.0F, 0.75F);\n                        colourB = new SRgba(rgb.Red, rgb.Green, rgb.Blue, 0.875F);\n                        DrawUnitRectangle(unit, 16, colourA, colourB, ctx.ViewInfo);\n                    }\n                }\n            }\n            GL.End();\n\n            debugGLError(\"Unit selection\");\n\n            GL.MatrixMode(MatrixMode.Projection);\n            var tempMat2 = Matrix4.CreateOrthographicOffCenter(0.0F, glSize.Width, glSize.Height, 0.0F, -1.0F, 1.0F);\n            GL.LoadMatrix(ref tempMat2);\n            GL.MatrixMode(MatrixMode.Modelview);\n            GL.LoadIdentity();\n\n            debugGLError(\"Text label matrix modes\");\n\n            GL.Enable(EnableCap.Texture2D);\n\n            scriptMarkerTextLabels.Draw();\n            drawObjects.UnitTextLabels.Draw();\n            selectionLabel.Draw();\n            messageTextLabels.Draw();\n\n            debugGLError(\"Text labels\");\n\n            GL.Disable(EnableCap.Texture2D);\n\n            GL.Disable(EnableCap.Blend);\n\n            //draw minimap\n\n            GL.MatrixMode(MatrixMode.Projection);\n            var tempMat3 = Matrix4.CreateOrthographicOffCenter(0.0F, glSize.Width, 0.0F, glSize.Height, -1.0F, 1.0F);\n            GL.LoadMatrix(ref tempMat3);\n            GL.MatrixMode(MatrixMode.Modelview);\n            GL.LoadIdentity();\n\n            debugGLError(\"Minimap matrix modes\");\n\n            if ( ctx.MinimapGl.TextureSize > 0 & ctx.ViewInfo.TilesPerMinimapPixel > 0.0D )\n            {\n                GL.Translate(0.0F, glSize.Height - minimapSizeXy.Y, 0.0F);\n\n                xyzDbl.X = (double)Terrain.TileSize.X / ctx.MinimapGl.TextureSize;\n                xyzDbl.Z = (double)Terrain.TileSize.Y / ctx.MinimapGl.TextureSize;\n\n                if ( ctx.MinimapGl.GLTexture > 0 )\n                {\n                    GL.Enable(EnableCap.Texture2D);\n                    GL.BindTexture(TextureTarget.Texture2D, ctx.MinimapGl.GLTexture);\n                    GL.TexEnv(TextureEnvTarget.TextureEnv, TextureEnvParameter.TextureEnvMode, (int)TextureEnvMode.Decal);\n\n                    GL.Begin(BeginMode.Quads);\n\n                    GL.TexCoord2(0.0F, 0.0F);\n                    GL.Vertex2(0, minimapSizeXy.Y);\n\n                    GL.TexCoord2((float)xyzDbl.X, 0.0F);\n                    GL.Vertex2(minimapSizeXy.X, minimapSizeXy.Y);\n\n                    GL.TexCoord2((float)xyzDbl.X, (float)xyzDbl.Z);\n                    GL.Vertex2(minimapSizeXy.X, 0);\n\n                    GL.TexCoord2(0.0F, (float)xyzDbl.Z);\n                    GL.Vertex2(0, 0);\n\n                    GL.End();\n\n                    GL.Disable(EnableCap.Texture2D);\n\n                    debugGLError(\"Minimap\");\n                }\n\n                //draw minimap border\n\n                GL.LineWidth(1.0F);\n                GL.Begin(BeginMode.Lines);\n                GL.Color3(0.75F, 0.75F, 0.75F);\n                GL.Vertex2(minimapSizeXy.X, 0.0F);\n                GL.Vertex2(minimapSizeXy.X, minimapSizeXy.Y);\n                GL.Vertex2(0.0F, 0.0F);\n                GL.Vertex2(minimapSizeXy.X, 0.0F);\n                GL.End();\n\n                debugGLError(\"Minimap border\");\n\n                //draw minimap view pos box\n\n                if ( showMinimapViewPosBox )\n                {\n                    dblTemp = Constants.TerrainGridSpacing * ctx.ViewInfo.TilesPerMinimapPixel;\n\n                    posA.X = viewCorner0.X / dblTemp;\n                    posA.Y = minimapSizeXy.Y + viewCorner0.Y / dblTemp;\n                    posB.X = viewCorner1.X / dblTemp;\n                    posB.Y = minimapSizeXy.Y + viewCorner1.Y / dblTemp;\n                    posC.X = viewCorner2.X / dblTemp;\n                    posC.Y = minimapSizeXy.Y + viewCorner2.Y / dblTemp;\n                    posD.X = viewCorner3.X / dblTemp;\n                    posD.Y = minimapSizeXy.Y + viewCorner3.Y / dblTemp;\n\n                    GL.LineWidth(1.0F);\n                    GL.Begin(BeginMode.LineLoop);\n                    GL.Color3(1.0F, 1.0F, 1.0F);\n                    GL.Vertex2(posA.X, posA.Y);\n                    GL.Vertex2(posB.X, posB.Y);\n                    GL.Vertex2(posC.X, posC.Y);\n                    GL.Vertex2(posD.X, posD.Y);\n                    GL.End();\n\n                    debugGLError(\"Minimap view position polygon\");\n                }\n\n                if ( SelectedAreaVertexA != null )\n                {\n                    drawIt = false;\n                    if ( SelectedAreaVertexB != null )\n                    {\n                        //area is selected\n                        MathUtil.ReorderXY(SelectedAreaVertexA, SelectedAreaVertexB, ref startXy, ref finishXy);\n                        drawIt = true;\n                    }\n                    else if (ctx.ToolOptions.MouseTool == MouseTool.TerrainSelect)\n                    {\n                        if ( mouseOverTerrain != null )\n                        {\n                            //selection is changing under mouse\n                            MathUtil.ReorderXY(SelectedAreaVertexA, mouseOverTerrain.Vertex.Normal, ref startXy, ref finishXy);\n                            drawIt = true;\n                        }\n                    }\n                    if ( drawIt )\n                    {\n                        GL.LineWidth(1.0F);\n                        posA.X = startXy.X / ctx.ViewInfo.TilesPerMinimapPixel;\n                        posA.Y = minimapSizeXy.Y - startXy.Y / ctx.ViewInfo.TilesPerMinimapPixel;\n                        posB.X = finishXy.X / ctx.ViewInfo.TilesPerMinimapPixel;\n                        posB.Y = minimapSizeXy.Y - startXy.Y / ctx.ViewInfo.TilesPerMinimapPixel;\n                        posC.X = finishXy.X / ctx.ViewInfo.TilesPerMinimapPixel;\n                        posC.Y = minimapSizeXy.Y - finishXy.Y / ctx.ViewInfo.TilesPerMinimapPixel;\n                        posD.X = startXy.X / ctx.ViewInfo.TilesPerMinimapPixel;\n                        posD.Y = minimapSizeXy.Y - finishXy.Y / ctx.ViewInfo.TilesPerMinimapPixel;\n                        GL.Begin(BeginMode.LineLoop);\n                        GL.Color3(1.0F, 1.0F, 1.0F);\n                        GL.Vertex2(posA.X, posA.Y);\n                        GL.Vertex2(posB.X, posB.Y);\n                        GL.Vertex2(posC.X, posC.Y);\n                        GL.Vertex2(posD.X, posD.Y);\n                        GL.End();\n\n                        debugGLError(\"Minimap selection box\");\n                    }\n                }\n            }\n        }\n\n        private void debugGLError(string Name)\n        {\n            if ( App.DebugGL )\n            {\n                if ( Messages.Count < 8 )\n                {\n                    if ( GL.GetError() != ErrorCode.NoError )\n                    {\n                        var NewMessage = new Message();\n                        NewMessage.Text = \"OpenGL Error (\" + Name + \")\";\n                        Messages.Add(NewMessage);\n                        logger.Error(NewMessage.Text);\n                    }\n                }\n            }\n        }\n\n        public void DrawUnitRectangle(Unit Unit, int BorderInsideThickness, SRgba InsideColour, SRgba OutsideColour, ViewInfo viewInfo)\n        {\n            var posA = new XYInt();\n            var posB = new XYInt();\n            var a = 0;\n            var altitude = Unit.Pos.Altitude - viewInfo.ViewPos.Y;\n\n            GetFootprintTileRangeClamped(Unit.Pos.Horizontal, Unit.TypeBase.GetGetFootprintSelected(Unit.Rotation), ref posA, ref posB);\n            a = posA.Y;\n            posA.X = ((posA.X + 0.125D) * Constants.TerrainGridSpacing - viewInfo.ViewPos.X).ToInt();\n            posA.Y = ((posB.Y + 0.875D) * - Constants.TerrainGridSpacing - viewInfo.ViewPos.Z).ToInt();\n            posB.X = ((posB.X + 0.875D) * Constants.TerrainGridSpacing - viewInfo.ViewPos.X).ToInt();\n            posB.Y = ((a + 0.125D) * - Constants.TerrainGridSpacing - viewInfo.ViewPos.Z).ToInt();\n\n            GL.Color4(OutsideColour.Red, OutsideColour.Green, OutsideColour.Blue, OutsideColour.Alpha);\n            GL.Vertex3(posB.X, altitude, Convert.ToInt32(- posA.Y));\n            GL.Vertex3(posA.X, altitude, Convert.ToInt32(- posA.Y));\n            GL.Color4(InsideColour.Red, InsideColour.Green, InsideColour.Blue, InsideColour.Alpha);\n            GL.Vertex3(posA.X + BorderInsideThickness, altitude, Convert.ToInt32(- (posA.Y + BorderInsideThickness)));\n            GL.Vertex3(posB.X - BorderInsideThickness, altitude, Convert.ToInt32(- (posA.Y + BorderInsideThickness)));\n\n            GL.Color4(OutsideColour.Red, OutsideColour.Green, OutsideColour.Blue, OutsideColour.Alpha);\n            GL.Vertex3(posA.X, altitude, Convert.ToInt32(- posA.Y));\n            GL.Vertex3(posA.X, altitude, Convert.ToInt32(- posB.Y));\n            GL.Color4(InsideColour.Red, InsideColour.Green, InsideColour.Blue, InsideColour.Alpha);\n            GL.Vertex3(posA.X + BorderInsideThickness, altitude, Convert.ToInt32(- (posB.Y - BorderInsideThickness)));\n            GL.Vertex3(posA.X + BorderInsideThickness, altitude, Convert.ToInt32(- (posA.Y + BorderInsideThickness)));\n\n            GL.Color4(OutsideColour.Red, OutsideColour.Green, OutsideColour.Blue, OutsideColour.Alpha);\n            GL.Vertex3(posB.X, altitude, Convert.ToInt32(- posB.Y));\n            GL.Vertex3(posB.X, altitude, Convert.ToInt32(- posA.Y));\n            GL.Color4(InsideColour.Red, InsideColour.Green, InsideColour.Blue, InsideColour.Alpha);\n            GL.Vertex3(posB.X - BorderInsideThickness, altitude, - (posA.Y + BorderInsideThickness));\n            GL.Vertex3(posB.X - BorderInsideThickness, altitude, - (posB.Y - BorderInsideThickness));\n\n            GL.Color4(OutsideColour.Red, OutsideColour.Green, OutsideColour.Blue, OutsideColour.Alpha);\n            GL.Vertex3(posA.X, altitude, Convert.ToInt32(- posB.Y));\n            GL.Vertex3(posB.X, altitude, Convert.ToInt32(- posB.Y));\n            GL.Color4(InsideColour.Red, InsideColour.Green, InsideColour.Blue, InsideColour.Alpha);\n            GL.Vertex3(posB.X - BorderInsideThickness, altitude, - (posB.Y - BorderInsideThickness));\n            GL.Vertex3(posA.X + BorderInsideThickness, altitude, Convert.ToInt32(- (posB.Y - BorderInsideThickness)));\n        }\n    }\n    public partial class Map\n    {\n\n\n\n        public clsUnitGroup ScavengerUnitGroup;\n        public ConnectedList<clsUnitGroup, Map> UnitGroups;\n        public ConnectedList<Unit, Map> Units;\n\n        private clsUnitGroupContainer _SelectedUnitGroup;\n\n        public clsUnitGroupContainer SelectedUnitGroup\n        {\n            get { return _SelectedUnitGroup; }\n        }\n\n        public UInt32 GetAvailableID()\n        {\n            var Unit = default(Unit);\n            UInt32 ID = 0;\n\n            ID = 1U;\n            foreach ( var tempLoopVar_Unit in Units )\n            {\n                Unit = tempLoopVar_Unit;\n                if ( Unit.ID >= ID )\n                {\n                    ID = Unit.ID + 1U;\n                }\n            }\n\n            return ID;\n        }\n\n        public void UnitRemoveStoreChange(int num)\n        {\n            var unitChange = new UnitChange\n\t            {\n\t\t            Type = UnitChangeType.Deleted,\n\t\t\t\t\tUnit = Units[num]\n\t            };\n\t        UnitChanges.Add(unitChange);\n\n            UnitRemove(num);\n        }\n\n        public void UnitRemove(int num)\n        {\n\t        var unit = Units[num];\n\n            if ( SectorGraphicsChanges != null )\n            {\n                UnitSectorsGraphicsChanged(unit);\n            }\n\n            if ( this.ViewInfo != null )\n            {\n                var mouseOverTerrain = this.ViewInfo.GetMouseOverTerrain();\n                if ( mouseOverTerrain != null )\n                {\n                    var pos = mouseOverTerrain.Units.IndexOf(unit);\n                    if ( pos >= 0 )\n                    {\n                        mouseOverTerrain.Units.RemoveAt(pos);\n                    }\n                }\n            }\n\n            unit.DisconnectFromMap();\n        }\n\n        public void UnitSwap(Unit oldUnit, Unit newUnit)\n        {\n            if ( oldUnit.MapLink.Owner != this )\n            {\n                Debugger.Break();\n                return;\n            }\n\n            UnitRemoveStoreChange(oldUnit.MapLink.Position);\n            var unitAdd = new clsUnitAdd\n\t            {\n\t\t            Map = this, \n\t\t\t\t\tStoreChange = true,\n\t\t\t\t\tID = oldUnit.ID,\n\t\t\t\t\tNewUnit = newUnit,\n\t\t\t\t\tLabel = oldUnit.Label\n\t            };\n\t        unitAdd.Perform();\n            App.ErrorIDChange(oldUnit.ID, newUnit, \"UnitSwap\");\n        }\n\n        public void MakeDefaultUnitGroups()\n        {\n            var A = 0;\n            var NewGroup = default(clsUnitGroup);\n\n            UnitGroups.Clear();\n            for ( A = 0; A <= Constants.PlayerCountMax - 1; A++ )\n            {\n                NewGroup = new clsUnitGroup();\n                NewGroup.WZ_StartPos = A;\n                NewGroup.MapLink.Connect(UnitGroups);\n            }\n            ScavengerUnitGroup = new clsUnitGroup();\n            ScavengerUnitGroup.MapLink.Connect(UnitGroups);\n            ScavengerUnitGroup.WZ_StartPos = -1;\n        }\n\n        public SRgb GetUnitGroupColour(clsUnitGroup ColourUnitGroup)\n        {\n            if ( ColourUnitGroup.WZ_StartPos < 0 )\n            {\n                return new SRgb(1.0F, 1.0F, 1.0F);\n            }\n            return App.PlayerColour[ColourUnitGroup.WZ_StartPos].Colour;\n        }\n\n        public SRgb GetUnitGroupMinimapColour(clsUnitGroup ColourUnitGroup)\n        {\n            if ( ColourUnitGroup.WZ_StartPos < 0 )\n            {\n                return new SRgb(1.0F, 1.0F, 1.0F);\n            }\n            return App.PlayerColour[ColourUnitGroup.WZ_StartPos].MinimapColour;\n        }\n\n        public Unit IDUsage(UInt32 ID)\n        {\n            foreach ( var Unit in Units )\n            {\n                if ( Unit.ID == ID )\n                {\n                    return Unit;\n                    //\t\t\t\t\t\t\tbreak;\n                }\n            }\n\n            return null;\n        }\n\n        public void SetObjectCreatorDefaults(clsUnitCreate objectCreator, PlaceObjectOptions placeObject)\n        {\n            objectCreator.Map = this;\n\n            objectCreator.ObjectTypeBase = placeObject.SingleSelectedObjectTypeBase;\n            objectCreator.AutoWalls = placeObject.AutoWalls;\n            objectCreator.UnitGroup = SelectedUnitGroup.Item;\n            try\n            {\n\t            var Rotation = Convert.ToInt32(placeObject.Rotation);\n\n                if ( Rotation < 0 | Rotation > 359 )\n                {\n                    objectCreator.Rotation = 0;\n                }\n                else\n                {\n                    objectCreator.Rotation = Rotation;\n                }\n            }\n            catch\n            {\n                objectCreator.Rotation = 0;\n            }\n            objectCreator.RandomizeRotation = placeObject.RotationRandom;\n        }\n    }\n    public partial class Map\n    {\n        public ConnectedList<clsScriptArea, Map> ScriptAreas;\n        public ConnectedList<clsScriptPosition, Map> ScriptPositions;\n\n        public string GetDefaultScriptLabel(string Prefix)\n        {\n            var Number = 1;\n            var Valid = new SimpleResult();\n            var Label = \"\";\n\n            do\n            {\n                Label = Prefix + Number.ToStringInvariant();\n                Valid = ScriptLabelIsValid(Label);\n                if ( Valid.Success )\n                {\n                    return Label;\n                }\n                Number++;\n                if ( Number >= 16384 )\n                {\n                    MessageBox.Show(\"Error: Unable to set default script label.\");\n                    return \"\";\n                }\n            } while ( true );\n        }\n\n        public SimpleResult ScriptLabelIsValid(string Text)\n        {\n            var ReturnResult = new SimpleResult();\n            ReturnResult.Success = false;\n            ReturnResult.Problem = \"\";\n\n            if ( Text == null )\n            {\n                ReturnResult.Problem = \"Label cannot be nothing.\";\n                return ReturnResult;\n            }\n\n            var LCaseText = Text.ToLower();\n\n            if ( LCaseText.Length < 1 )\n            {\n                ReturnResult.Problem = \"Label cannot be nothing.\";\n                return ReturnResult;\n            }\n\n            var CurrentChar = (char)0;\n            var Invalid = default(bool);\n\n            Invalid = false;\n            foreach ( var tempLoopVar_CurrentChar in LCaseText )\n            {\n                CurrentChar = tempLoopVar_CurrentChar;\n                if ( !((CurrentChar >= 'a' && CurrentChar <= 'z') || (CurrentChar >= '0' && CurrentChar <= '9') || CurrentChar == '_') )\n                {\n                    Invalid = true;\n                    break;\n                }\n            }\n            if ( Invalid )\n            {\n                ReturnResult.Problem = \"Label contains invalid characters. Use only letters, numbers or underscores.\";\n                return ReturnResult;\n            }\n\n            var Unit = default(Unit);\n\n            foreach ( var tempLoopVar_Unit in Units )\n            {\n                Unit = tempLoopVar_Unit;\n                if ( Unit.Label != null )\n                {\n                    if ( LCaseText == Unit.Label.ToLower() )\n                    {\n                        ReturnResult.Problem = \"Label text is already in use.\";\n                        return ReturnResult;\n                    }\n                }\n            }\n\n            var ScriptPosition = default(clsScriptPosition);\n\n            foreach ( var tempLoopVar_ScriptPosition in ScriptPositions )\n            {\n                ScriptPosition = tempLoopVar_ScriptPosition;\n                if ( LCaseText == ScriptPosition.Label.ToLower() )\n                {\n                    ReturnResult.Problem = \"Label text is already in use.\";\n                    return ReturnResult;\n                }\n            }\n\n            var ScriptArea = default(clsScriptArea);\n\n            foreach ( var tempLoopVar_ScriptArea in ScriptAreas )\n            {\n                ScriptArea = tempLoopVar_ScriptArea;\n                if ( LCaseText == ScriptArea.Label.ToLower() )\n                {\n                    ReturnResult.Problem = \"Label text is already in use.\";\n                    return ReturnResult;\n                }\n            }\n\n            ReturnResult.Success = true;\n            return ReturnResult;\n        }\n    }\n    public partial class Map\n    {\n        public void Rotate(TileOrientation Orientation, Util.ObjectRotateMode ObjectRotateMode)\n        {\n            var X = 0;\n            var Y = 0;\n            var Pos = new XYInt(0, 0);\n            var RotatedPos = new XYInt();\n            var NewTerrainPosA = TileUtil.GetRotatedPos(Orientation, new XYInt(0, 0), Terrain.TileSize);\n            var NewTerrainPosB = TileUtil.GetRotatedPos(Orientation, Terrain.TileSize, Terrain.TileSize);\n            var VertexLimits = new XYInt(Math.Max(NewTerrainPosA.X, NewTerrainPosB.X), Math.Max(NewTerrainPosA.Y, NewTerrainPosB.Y));\n            var NewTerrain = new clsTerrain(VertexLimits);\n            var NewTileLimits = new XYInt(NewTerrain.TileSize.X - 1, NewTerrain.TileSize.Y - 1);\n            var NewSideHLimits = new XYInt(NewTerrain.TileSize.X - 1, NewTerrain.TileSize.Y);\n            var NewSideVLimits = new XYInt(NewTerrain.TileSize.X, NewTerrain.TileSize.Y - 1);\n            var OldTileLimits = new XYInt(Terrain.TileSize.X - 1, Terrain.TileSize.Y - 1);\n            var OldPosLimits = new XYInt(Terrain.TileSize.X * Constants.TerrainGridSpacing, Terrain.TileSize.Y * Constants.TerrainGridSpacing);\n            var ReverseOrientation = new TileOrientation();\n            var TriDirection = new TileDirection();\n\n            ReverseOrientation = Orientation;\n            ReverseOrientation.Reverse();\n\n            for ( Y = 0; Y <= NewTerrain.TileSize.Y; Y++ )\n            {\n                Pos.Y = Y;\n                for ( X = 0; X <= NewTerrain.TileSize.X; X++ )\n                {\n                    Pos.X = X;\n                    RotatedPos = TileUtil.GetRotatedPos(ReverseOrientation, Pos, VertexLimits);\n                    NewTerrain.Vertices[X, Y].Height = Terrain.Vertices[RotatedPos.X, RotatedPos.Y].Height;\n                    NewTerrain.Vertices[X, Y].Terrain = Terrain.Vertices[RotatedPos.X, RotatedPos.Y].Terrain;\n                }\n            }\n            for ( Y = 0; Y <= NewTerrain.TileSize.Y - 1; Y++ )\n            {\n                Pos.Y = Y;\n                for ( X = 0; X <= NewTerrain.TileSize.X - 1; X++ )\n                {\n                    Pos.X = X;\n                    RotatedPos = TileUtil.GetRotatedPos(ReverseOrientation, Pos, NewTileLimits);\n                    NewTerrain.Tiles[X, Y].Texture = Terrain.Tiles[RotatedPos.X, RotatedPos.Y].Texture;\n                    NewTerrain.Tiles[X, Y].Texture.Orientation = NewTerrain.Tiles[X, Y].Texture.Orientation.GetRotated(Orientation);\n                    NewTerrain.Tiles[X, Y].DownSide = Terrain.Tiles[RotatedPos.X, RotatedPos.Y].DownSide;\n                    NewTerrain.Tiles[X, Y].DownSide = NewTerrain.Tiles[X, Y].DownSide.GetRotated(Orientation);\n                    if ( Terrain.Tiles[RotatedPos.X, RotatedPos.Y].Tri )\n                    {\n                        TriDirection = TileUtil.TopLeft;\n                    }\n                    else\n                    {\n                        TriDirection = TileUtil.TopRight;\n                    }\n                    TriDirection = TriDirection.GetRotated(Orientation);\n                    NewTerrain.Tiles[X, Y].Tri =\n                        Convert.ToBoolean(TileUtil.IdenticalTileDirections(TriDirection, TileUtil.TopLeft) ||\n                                          TileUtil.IdenticalTileDirections(TriDirection, TileUtil.BottomRight));\n                    if ( Terrain.Tiles[RotatedPos.X, RotatedPos.Y].Tri )\n                    {\n                        if ( Terrain.Tiles[RotatedPos.X, RotatedPos.Y].TriTopLeftIsCliff )\n                        {\n                            TileUtil.RotateDirection(TileUtil.TopLeft, Orientation, ref TriDirection);\n                            NewTerrain.Tiles[X, Y].TriCliffAddDirection(TriDirection);\n                        }\n                        if ( Terrain.Tiles[RotatedPos.X, RotatedPos.Y].TriBottomRightIsCliff )\n                        {\n                            TileUtil.RotateDirection(TileUtil.BottomRight, Orientation, ref TriDirection);\n                            NewTerrain.Tiles[X, Y].TriCliffAddDirection(TriDirection);\n                        }\n                    }\n                    else\n                    {\n                        if ( Terrain.Tiles[RotatedPos.X, RotatedPos.Y].TriTopRightIsCliff )\n                        {\n                            TileUtil.RotateDirection(TileUtil.TopRight, Orientation, ref TriDirection);\n                            NewTerrain.Tiles[X, Y].TriCliffAddDirection(TriDirection);\n                        }\n                        if ( Terrain.Tiles[RotatedPos.X, RotatedPos.Y].TriBottomLeftIsCliff )\n                        {\n                            TileUtil.RotateDirection(TileUtil.BottomLeft, Orientation, ref TriDirection);\n                            NewTerrain.Tiles[X, Y].TriCliffAddDirection(TriDirection);\n                        }\n                    }\n                    NewTerrain.Tiles[X, Y].Terrain_IsCliff = Terrain.Tiles[RotatedPos.X, RotatedPos.Y].Terrain_IsCliff;\n                }\n            }\n            if ( Orientation.SwitchedAxes )\n            {\n                for ( Y = 0; Y <= NewTerrain.TileSize.Y; Y++ )\n                {\n                    Pos.Y = Y;\n                    for ( X = 0; X <= NewTerrain.TileSize.X - 1; X++ )\n                    {\n                        Pos.X = X;\n                        RotatedPos = TileUtil.GetRotatedPos(ReverseOrientation, Pos, NewSideHLimits);\n                        NewTerrain.SideH[X, Y].Road = Terrain.SideV[RotatedPos.X, RotatedPos.Y].Road;\n                    }\n                }\n                for ( Y = 0; Y <= NewTerrain.TileSize.Y - 1; Y++ )\n                {\n                    Pos.Y = Y;\n                    for ( X = 0; X <= NewTerrain.TileSize.X; X++ )\n                    {\n                        Pos.X = X;\n                        RotatedPos = TileUtil.GetRotatedPos(ReverseOrientation, Pos, NewSideVLimits);\n                        NewTerrain.SideV[X, Y].Road = Terrain.SideH[RotatedPos.X, RotatedPos.Y].Road;\n                    }\n                }\n            }\n            else\n            {\n                for ( Y = 0; Y <= NewTerrain.TileSize.Y; Y++ )\n                {\n                    Pos.Y = Y;\n                    for ( X = 0; X <= NewTerrain.TileSize.X - 1; X++ )\n                    {\n                        Pos.X = X;\n                        RotatedPos = TileUtil.GetRotatedPos(ReverseOrientation, Pos, NewSideHLimits);\n                        NewTerrain.SideH[X, Y].Road = Terrain.SideH[RotatedPos.X, RotatedPos.Y].Road;\n                    }\n                }\n                for ( Y = 0; Y <= NewTerrain.TileSize.Y - 1; Y++ )\n                {\n                    Pos.Y = Y;\n                    for ( X = 0; X <= NewTerrain.TileSize.X; X++ )\n                    {\n                        Pos.X = X;\n                        RotatedPos = TileUtil.GetRotatedPos(ReverseOrientation, Pos, NewSideVLimits);\n                        NewTerrain.SideV[X, Y].Road = Terrain.SideV[RotatedPos.X, RotatedPos.Y].Road;\n                    }\n                }\n            }\n\n            var Unit = default(Unit);\n            foreach ( var tempLoopVar_Unit in Units )\n            {\n                Unit = tempLoopVar_Unit;\n                Unit.Sectors.Clear();\n                if ( ObjectRotateMode == Util.ObjectRotateMode.All )\n                {\n                    Unit.Rotation = (MathUtil.AngleClamp(MathUtil.RadOf360Deg -\n                                                         TileUtil.GetRotatedAngle(Orientation,\n                                                             MathUtil.AngleClamp(MathUtil.RadOf360Deg - Unit.Rotation * MathUtil.RadOf1Deg))) / MathUtil.RadOf1Deg).ToInt();\n                    if ( Unit.Rotation < 0 )\n                    {\n                        Unit.Rotation += 360;\n                    }\n                }\n                else if ( ObjectRotateMode == ObjectRotateMode.Walls )\n                {\n                    if ( Unit.TypeBase.Type == UnitType.PlayerStructure )\n                    {\n                        if ( ((StructureTypeBase)Unit.TypeBase).StructureType == StructureType.Wall )\n                        {\n                            Unit.Rotation = (MathUtil.AngleClamp(MathUtil.RadOf360Deg -\n                                                                 TileUtil.GetRotatedAngle(Orientation,\n                                                                     MathUtil.AngleClamp(MathUtil.RadOf360Deg - Unit.Rotation * MathUtil.RadOf1Deg))) / MathUtil.RadOf1Deg)\n                                .ToInt();\n\n                            if ( Unit.Rotation < 0 )\n                            {\n                                Unit.Rotation += 360;\n                            }\n                            //If Unit.Rotation = 180 Then\n                            //    Unit.Rotation = 0\n                            //ElseIf Unit.Rotation = 270 Then\n                            //    Unit.Rotation = 90\n                            //End If\n                        }\n                    }\n                }\n                Unit.Pos.Horizontal = TileUtil.GetRotatedPos(Orientation, Unit.Pos.Horizontal, OldPosLimits);\n            }\n\n            var ZeroPos = new XYInt(0, 0);\n\n            var Position = 0;\n            foreach ( var tempLoopVar_Unit in Units.CopyList() )\n            {\n                Unit = tempLoopVar_Unit;\n                if ( !App.PosIsWithinTileArea(Unit.Pos.Horizontal, ZeroPos, NewTerrain.TileSize) )\n                {\n                    Position = Unit.MapLink.Position;\n                    UnitRemove(Position);\n                }\n            }\n\n            Terrain = NewTerrain;\n\n            \n            foreach ( var gateway in Gateways.CopyList() )\n            {\n                GatewayCreate(TileUtil.GetRotatedPos(Orientation, gateway.PosA, OldTileLimits),\n                    TileUtil.GetRotatedPos(Orientation, gateway.PosB, OldTileLimits));\n                gateway.Deallocate();\n            }\n\n            if ( readyForUserInput )\n            {\n                CancelUserInput();\n                InitializeUserInput();\n            }\n        }\n\n        public void RandomizeHeights(int LevelCount)\n        {\n            var hmSource = new clsHeightmap();\n            var hmA = new clsHeightmap();\n            var hmB = new clsHeightmap();\n            var IntervalCount = 0;\n            var AlterationLevels = new clsHeightmap.sHeights();\n            var hmAlteration = new sHeightmaps();\n            float LevelHeight = 0;\n            double HeightRange = 0;\n            var Level = 0;\n            double IntervalHeight = 0;\n            double Variation = 0;\n            var X = 0;\n            var Y = 0;\n\n            IntervalCount = LevelCount - 1;\n\n            AlterationLevels.Heights = new float[IntervalCount + 1];\n            var MinMax = new clsHeightmap.sMinMax();\n            hmAlteration.Heightmaps = new clsHeightmap[IntervalCount + 1];\n            hmSource.HeightData.Height = new long[Terrain.TileSize.Y + 1, Terrain.TileSize.X + 1];\n            hmSource.HeightData.SizeX = Terrain.TileSize.X + 1;\n            hmSource.HeightData.SizeY = Terrain.TileSize.Y + 1;\n            for ( Y = 0; Y <= Terrain.TileSize.Y; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X; X++ )\n                {\n                    hmSource.HeightData.Height[Y, X] = Convert.ToInt32(Terrain.Vertices[X, Y].Height / hmSource.HeightScale);\n                }\n            }\n            hmSource.MinMaxGet(ref MinMax);\n            HeightRange = 255.0D;\n            IntervalHeight = HeightRange / IntervalCount;\n            Variation = IntervalHeight / 4.0D;\n            for ( Level = 0; Level <= IntervalCount; Level++ )\n            {\n                LevelHeight =\n                    Convert.ToSingle(Convert.ToDouble(MinMax.Min + Convert.ToInt32(Level * MinMax.Max / IntervalCount)) * hmSource.HeightScale);\n                AlterationLevels.Heights[Level] = LevelHeight;\n                hmB.GenerateNewOfSize(Terrain.TileSize.Y + 1, Terrain.TileSize.X + 1, 2.0F, 10000.0D);\n                hmAlteration.Heightmaps[Level] = new clsHeightmap();\n                hmAlteration.Heightmaps[Level].Rescale(hmB, LevelHeight - Variation, LevelHeight + Variation);\n            }\n            hmA.FadeMultiple(hmSource, ref hmAlteration, ref AlterationLevels);\n            hmB.Rescale(hmA, Math.Max(Convert.ToDouble(Convert.ToDouble(MinMax.Min * hmSource.HeightScale) - Variation), 0.0D),\n                Math.Min(Convert.ToDouble(Convert.ToDouble(MinMax.Max * hmSource.HeightScale) + Variation), 255.9D));\n            for ( Y = 0; Y <= Terrain.TileSize.Y; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X; X++ )\n                {\n                    Terrain.Vertices[X, Y].Height = Convert.ToByte((hmB.HeightData.Height[Y, X] * hmB.HeightScale));\n                }\n            }\n        }\n\n        public void LevelWater()\n        {\n            var X = 0;\n            var Y = 0;\n            var TextureNum = 0;\n\n            if ( Tileset == null )\n            {\n                return;\n            }\n\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    TextureNum = Terrain.Tiles[X, Y].Texture.TextureNum;\n                    if ( TextureNum >= 0 & TextureNum < Tileset.Tiles.Count )\n                    {\n                        if ( Tileset.Tiles[TextureNum].DefaultType == Constants.TileTypeNumWater )\n                        {\n                            Terrain.Vertices[X, Y].Height = 0;\n                            Terrain.Vertices[X + 1, Y].Height = 0;\n                            Terrain.Vertices[X, Y + 1].Height = 0;\n                            Terrain.Vertices[X + 1, Y + 1].Height = 0;\n                        }\n                    }\n                }\n            }\n        }\n\n        public void GenerateMasterTerrain(ref sGenerateMasterTerrainArgs Args)\n        {\n            var X = 0;\n            var Y = 0;\n            var A = 0;\n            int[,] TerrainType = null;\n            float[,] Slope = null;\n\n            var TerrainNum = 0;\n\n            var bmA = new BooleanMap();\n            var Layer_Num = 0;\n            var LayerResult = new BooleanMap[Args.LayerCount];\n            var bmB = new BooleanMap();\n            double BestSlope = 0;\n            double CurrentSlope = 0;\n            var hmB = new clsHeightmap();\n            var hmC = new clsHeightmap();\n\n            double difA = 0;\n            double difB = 0;\n            var NewTri = default(bool);\n            var CliffSlope = Math.Atan(255.0D * Constants.DefaultHeightMultiplier / (2.0D * (Args.LevelCount - 1.0D) * Constants.TerrainGridSpacing)) -\n                             MathUtil.RadOf1Deg; //divided by 2 due to the terrain height randomization\n\n            Tileset = Args.Tileset.Tileset;\n\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    difA = Math.Abs((Terrain.Vertices[X + 1, Y + 1].Height) - Terrain.Vertices[X, Y].Height);\n                    difB = Math.Abs((Terrain.Vertices[X, Y + 1].Height) - Terrain.Vertices[X + 1, Y].Height);\n                    if ( difA == difB )\n                    {\n                        if ( App.Random.Next() >= 0.5F )\n                        {\n                            NewTri = false;\n                        }\n                        else\n                        {\n                            NewTri = true;\n                        }\n                    }\n                    else if ( difA < difB )\n                    {\n                        NewTri = false;\n                    }\n                    else\n                    {\n                        NewTri = true;\n                    }\n                    if ( !(Terrain.Tiles[X, Y].Tri == NewTri) )\n                    {\n                        Terrain.Tiles[X, Y].Tri = NewTri;\n                    }\n                }\n            }\n\n            for ( A = 0; A <= Args.LayerCount - 1; A++ )\n            {\n                Args.Layers[A].Terrainmap = new BooleanMap();\n                if ( Args.Layers[A].TerrainmapDensity == 1.0F )\n                {\n                    Args.Layers[A].Terrainmap.ValueData.Value = new bool[Terrain.TileSize.Y, Terrain.TileSize.X];\n                    Args.Layers[A].Terrainmap.ValueData.Size = Terrain.TileSize;\n                    for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n                    {\n                        for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                        {\n                            Args.Layers[A].Terrainmap.ValueData.Value[Y, X] = true;\n                        }\n                    }\n                }\n                else\n                {\n                    hmB.GenerateNewOfSize(Terrain.TileSize.Y, Terrain.TileSize.X, Convert.ToSingle(Args.Layers[A].TerrainmapScale), 1.0D);\n                    hmC.Rescale(hmB, 0.0D, 1.0D);\n                    Args.Layers[A].Terrainmap.Convert_Heightmap(hmC, ((1.0F - Args.Layers[A].TerrainmapDensity) / hmC.HeightScale).ToLong());\n                }\n            }\n\n            var Pos = new XYInt();\n\n            TerrainType = new int[Terrain.TileSize.X, Terrain.TileSize.Y];\n            Slope = new float[Terrain.TileSize.X, Terrain.TileSize.Y];\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    //get slope\n                    BestSlope = 0.0D;\n\n                    Pos.X = ((X + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Pos.X = ((X + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Pos.X = ((X + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Pos.X = ((X + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Slope[X, Y] = (float)BestSlope;\n                }\n            }\n            for ( Layer_Num = 0; Layer_Num <= Args.LayerCount - 1; Layer_Num++ )\n            {\n                TerrainNum = Args.Layers[Layer_Num].TileNum;\n                if ( TerrainNum >= 0 )\n                {\n                    //do other layer constraints\n                    LayerResult[Layer_Num] = new BooleanMap();\n                    LayerResult[Layer_Num].Copy(Args.Layers[Layer_Num].Terrainmap);\n                    if ( Args.Layers[Layer_Num].WithinLayer >= 0 )\n                    {\n                        if ( Args.Layers[Layer_Num].WithinLayer < Layer_Num )\n                        {\n                            bmA.Within(LayerResult[Layer_Num], LayerResult[Args.Layers[Layer_Num].WithinLayer]);\n                            LayerResult[Layer_Num].ValueData = bmA.ValueData;\n                            bmA.ValueData = new BooleanMapDataValue();\n                        }\n                    }\n                    for ( A = 0; A <= Layer_Num - 1; A++ )\n                    {\n                        if ( Args.Layers[Layer_Num].AvoidLayers[A] )\n                        {\n                            bmA.ExpandOneTile(LayerResult[A]);\n                            bmB.Remove(LayerResult[Layer_Num], bmA);\n                            LayerResult[Layer_Num].ValueData = bmB.ValueData;\n                            bmB.ValueData = new BooleanMapDataValue();\n                        }\n                    }\n                    //do height and slope constraints\n                    for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n                    {\n                        for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                        {\n                            if ( LayerResult[Layer_Num].ValueData.Value[Y, X] )\n                            {\n                                if ( Terrain.Vertices[X, Y].Height < Args.Layers[Layer_Num].HeightMin\n                                     || Terrain.Vertices[X, Y].Height > Args.Layers[Layer_Num].HeightMax )\n                                {\n                                    LayerResult[Layer_Num].ValueData.Value[Y, X] = false;\n                                }\n                                if ( Args.Layers[Layer_Num].IsCliff )\n                                {\n                                    if ( LayerResult[Layer_Num].ValueData.Value[Y, X] )\n                                    {\n                                        if ( Slope[X, Y] < CliffSlope )\n                                        {\n                                            LayerResult[Layer_Num].ValueData.Value[Y, X] = false;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n                    {\n                        for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                        {\n                            if ( LayerResult[Layer_Num].ValueData.Value[Y, X] )\n                            {\n                                TerrainType[X, Y] = TerrainNum;\n                            }\n                        }\n                    }\n                }\n            }\n\n            //set water tiles\n\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    if ( Args.Watermap.ValueData.Value[Y, X] )\n                    {\n                        if ( Slope[X, Y] < CliffSlope )\n                        {\n                            TerrainType[X, Y] = 17;\n                        }\n                    }\n                }\n            }\n\n            //set border tiles to cliffs\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= 2; X++ )\n                {\n                    TerrainType[X, Y] = Args.Tileset.BorderTextureNum;\n                }\n                for ( X = Terrain.TileSize.X - 4; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    TerrainType[X, Y] = Args.Tileset.BorderTextureNum;\n                }\n            }\n            for ( X = 3; X <= Terrain.TileSize.X - 5; X++ )\n            {\n                for ( Y = 0; Y <= 2; Y++ )\n                {\n                    TerrainType[X, Y] = Args.Tileset.BorderTextureNum;\n                }\n                for ( Y = Terrain.TileSize.Y - 4; Y <= Terrain.TileSize.Y - 1; Y++ )\n                {\n                    TerrainType[X, Y] = Args.Tileset.BorderTextureNum;\n                }\n            }\n\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    Terrain.Tiles[X, Y].Texture.TextureNum = TerrainType[X, Y];\n                }\n            }\n        }\n\n        public void RandomizeTileOrientations()\n        {\n            var X = 0;\n            var Y = 0;\n\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    Terrain.Tiles[X, Y].Texture.Orientation = new TileOrientation(App.Random.Next() >= 0.5F, App.Random.Next() >= 0.5F, App.Random.Next() >= 0.5F);\n                }\n            }\n            SectorTerrainUndoChanges.SetAllChanged();\n            SectorGraphicsChanges.SetAllChanged();\n        }\n\n        public void MapTexturer(ref sLayerList LayerList)\n        {\n            var X = 0;\n            var Y = 0;\n            var A = 0;\n            Terrain[,] TerrainType = null;\n            float[,] Slope = null;\n            var tmpTerrain = default(Terrain);\n            var bmA = new BooleanMap();\n            var bmB = new BooleanMap();\n            var LayerNum = 0;\n            var LayerResult = new BooleanMap[LayerList.LayerCount];\n            double BestSlope = 0;\n            double CurrentSlope = 0;\n            var AllowSlope = default(bool);\n            var Pos = new XYInt();\n\n            TerrainType = new Terrain[Terrain.TileSize.X + 1, Terrain.TileSize.Y + 1];\n            Slope = new float[Terrain.TileSize.X, Terrain.TileSize.Y];\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    //get slope\n                    BestSlope = 0.0D;\n\n                    Pos.X = ((X + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Pos.X = ((X + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Pos.X = ((X + 0.25D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Pos.X = ((X + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    Pos.Y = ((Y + 0.75D) * Constants.TerrainGridSpacing).ToInt();\n                    CurrentSlope = GetTerrainSlopeAngle(Pos);\n                    if ( CurrentSlope > BestSlope )\n                    {\n                        BestSlope = CurrentSlope;\n                    }\n\n                    Slope[X, Y] = (float)BestSlope;\n                }\n            }\n            for ( LayerNum = 0; LayerNum <= LayerList.LayerCount - 1; LayerNum++ )\n            {\n                tmpTerrain = LayerList.Layers[LayerNum].Terrain;\n                if ( tmpTerrain != null )\n                {\n                    //do other layer constraints\n                    LayerResult[LayerNum] = new BooleanMap();\n                    LayerResult[LayerNum].Copy(LayerList.Layers[LayerNum].Terrainmap);\n                    if ( LayerList.Layers[LayerNum].WithinLayer >= 0 )\n                    {\n                        if ( LayerList.Layers[LayerNum].WithinLayer < LayerNum )\n                        {\n                            bmA.Within(LayerResult[LayerNum], LayerResult[LayerList.Layers[LayerNum].WithinLayer]);\n                            LayerResult[LayerNum].ValueData = bmA.ValueData;\n                            bmA.ValueData = new BooleanMapDataValue();\n                        }\n                    }\n                    for ( A = 0; A <= LayerNum - 1; A++ )\n                    {\n                        if ( LayerList.Layers[LayerNum].AvoidLayers[A] )\n                        {\n                            bmA.ExpandOneTile(LayerResult[A]);\n                            bmB.Remove(LayerResult[LayerNum], bmA);\n                            LayerResult[LayerNum].ValueData = bmB.ValueData;\n                            bmB.ValueData = new BooleanMapDataValue();\n                        }\n                    }\n                    //do height and slope constraints\n                    for ( Y = 0; Y <= Terrain.TileSize.Y; Y++ )\n                    {\n                        for ( X = 0; X <= Terrain.TileSize.X; X++ )\n                        {\n                            if ( LayerResult[LayerNum].ValueData.Value[Y, X] )\n                            {\n                                if ( Terrain.Vertices[X, Y].Height < LayerList.Layers[LayerNum].HeightMin\n                                     || Terrain.Vertices[X, Y].Height > LayerList.Layers[LayerNum].HeightMax )\n                                {\n                                    LayerResult[LayerNum].ValueData.Value[Y, X] = false;\n                                }\n                                if ( LayerResult[LayerNum].ValueData.Value[Y, X] )\n                                {\n                                    AllowSlope = true;\n                                    if ( X > 0 )\n                                    {\n                                        if ( Y > 0 )\n                                        {\n                                            if ( Slope[X - 1, Y - 1] < LayerList.Layers[LayerNum].SlopeMin\n                                                 || Slope[X - 1, Y - 1] > LayerList.Layers[LayerNum].SlopeMax )\n                                            {\n                                                AllowSlope = false;\n                                            }\n                                        }\n                                        if ( Y < Terrain.TileSize.Y )\n                                        {\n                                            if ( Slope[X - 1, Y] < LayerList.Layers[LayerNum].SlopeMin\n                                                 || Slope[X - 1, Y] > LayerList.Layers[LayerNum].SlopeMax )\n                                            {\n                                                AllowSlope = false;\n                                            }\n                                        }\n                                    }\n                                    if ( X < Terrain.TileSize.X )\n                                    {\n                                        if ( Y > 0 )\n                                        {\n                                            if ( Slope[X, Y - 1] < LayerList.Layers[LayerNum].SlopeMin\n                                                 || Slope[X, Y - 1] > LayerList.Layers[LayerNum].SlopeMax )\n                                            {\n                                                AllowSlope = false;\n                                            }\n                                        }\n                                        if ( Y < Terrain.TileSize.Y )\n                                        {\n                                            if ( Slope[X, Y] < LayerList.Layers[LayerNum].SlopeMin\n                                                 || Slope[X, Y] > LayerList.Layers[LayerNum].SlopeMax )\n                                            {\n                                                AllowSlope = false;\n                                            }\n                                        }\n                                    }\n                                    if ( !AllowSlope )\n                                    {\n                                        LayerResult[LayerNum].ValueData.Value[Y, X] = false;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    LayerResult[LayerNum].RemoveDiagonals();\n\n                    for ( Y = 0; Y <= Terrain.TileSize.Y; Y++ )\n                    {\n                        for ( X = 0; X <= Terrain.TileSize.X; X++ )\n                        {\n                            if ( LayerResult[LayerNum].ValueData.Value[Y, X] )\n                            {\n                                TerrainType[X, Y] = tmpTerrain;\n                            }\n                        }\n                    }\n                }\n            }\n\n            //set vertex terrain by terrain map\n            for ( Y = 0; Y <= Terrain.TileSize.Y; Y++ )\n            {\n                for ( X = 0; X <= Terrain.TileSize.X; X++ )\n                {\n                    if ( TerrainType[X, Y] != null )\n                    {\n                        Terrain.Vertices[X, Y].Terrain = TerrainType[X, Y];\n                    }\n                }\n            }\n            AutoTextureChanges.SetAllChanged();\n            UpdateAutoTextures();\n        }\n\n        public BooleanMap GenerateTerrainMap(float Scale, float Density)\n        {\n            var ReturnResult = default(BooleanMap);\n            var hmB = new clsHeightmap();\n            var hmC = new clsHeightmap();\n\n            hmB.GenerateNewOfSize(Terrain.TileSize.Y + 1, Terrain.TileSize.X + 1, Scale, 1.0D);\n            hmC.Rescale(hmB, 0.0D, 1.0D);\n            ReturnResult = new BooleanMap();\n            ReturnResult.Convert_Heightmap(hmC, ((1.0D - Density) / hmC.HeightScale).ToLong());\n            return ReturnResult;\n        }\n\n        public void WaterTriCorrection()\n        {\n            if ( Tileset == null )\n            {\n                return;\n            }\n\n            var X = 0;\n            var Y = 0;\n            var TileNum = new XYInt();\n\n            for ( Y = 0; Y <= Terrain.TileSize.Y - 1; Y++ )\n            {\n                TileNum.Y = Y;\n                for ( X = 0; X <= Terrain.TileSize.X - 1; X++ )\n                {\n                    TileNum.X = X;\n                    if ( Terrain.Tiles[X, Y].Tri )\n                    {\n                        if ( Terrain.Tiles[X, Y].Texture.TextureNum >= 0 )\n                        {\n                            if ( Tileset.Tiles[Terrain.Tiles[X, Y].Texture.TextureNum].DefaultType == Constants.TileTypeNumWater )\n                            {\n                                Terrain.Tiles[X, Y].Tri = false;\n                                SectorGraphicsChanges.TileChanged(TileNum);\n                                SectorTerrainUndoChanges.TileChanged(TileNum);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    public partial class Map\n    {\n        public delegate void ChangedEventHandler();\n\n        private readonly ILogger logger;\n        public AutoSave AutoSave = new AutoSave();\n        private ChangedEventHandler changedEvent;\n        public bool ChangedSinceSave = false;\n        public Dialog CompileScreen;\n\n        public ObservableCollection<GatewayChange> GatewayChanges;\n        public ConnectedList<Gateway, Map> Gateways;\n\n        public int HeightMultiplier = Constants.DefaultHeightMultiplier;\n        public InterfaceOptions InterfaceOptions;\n        public ObservableCollection<Message> Messages;\n\n        public Painter Painter;\n        public PathInfo PathInfo;\n        public XYInt SectorCount;\n        public Sector[,] Sectors = new Sector[0, 0];\n        public ConnectedList<Unit, Map> SelectedUnits;\n        public XYInt SelectedAreaVertexA;\n        public XYInt SelectedAreaVertexB;\n        public XYInt SelectedTileA;\n        public XYInt SelectedTileB;\n        public ShadowSector[,] ShadowSectors = new ShadowSector[0, 0];\n        public clsTerrain Terrain;\n\n        public byte[] TileTypeNum = new byte[0];\n        public Tileset Tileset;\n        public int UndoPosition;\n        public ObservableCollection<Undo> Undos;\n        public ObservableCollection<UnitChange> UnitChanges;\n        public XYInt UnitSelectedAreaVertexA;\n        private bool readyForUserInput;\n\n\t    private readonly IEventBroker eventBroker;\n\t    public ViewInfo ViewInfo { get; set; }\n       \n        public Map(ILoggerFactory logFactory, IEventBroker eventBroker)\n        {\n            logger = logFactory.GetCurrentClassLogger();\n\n\t        this.eventBroker = eventBroker;\n\n            SectorCount = new XYInt(0, 0);\n            SelectedAreaVertexA = new XYInt(0, 0);\n            SelectedAreaVertexB = new XYInt(0, 0);           \n\n            Sectors = new Sector[0, 0];\n            ShadowSectors = new ShadowSector[0, 0];\n            HeightMultiplier = 2;\n            readyForUserInput = false;\n            ChangedSinceSave = false;\n            AutoSave = new AutoSave();\n            Painter = new Painter();\n            TileTypeNum = new byte[0];\n            Gateways = new ConnectedList<Gateway, Map>(this);\n            Units = new ConnectedList<Unit, Map>(this);\n            UnitGroups = new ConnectedList<clsUnitGroup, Map>(this);\n            ScriptPositions = new ConnectedList<clsScriptPosition, Map>(this);\n            ScriptAreas = new ConnectedList<clsScriptArea, Map>(this);\n            InterfaceOptions = new InterfaceOptions();\n\n            InitializeMap();\n        }\n\n        public Map Create(XYInt tileSize) {\n            TerrainBlank(tileSize);\n            TileType_Reset();\n\n            return this;\n        }\n\n        public Map Copy(Map mapToCopy, XYInt offset, XYInt area)\n        {\n            var endX = 0;\n            var endY = 0;\n            var index0 = 0;\n            var index1 = 0;\n\n            //make some map data for selection\n\n            endX = Math.Min(mapToCopy.Terrain.TileSize.X - offset.X, area.X);\n            endY = Math.Min(mapToCopy.Terrain.TileSize.Y - offset.Y, area.Y);\n\n            Terrain = new clsTerrain(area);\n\n            for ( index1 = 0; index1 <= Terrain.TileSize.Y - 1; index1++ )\n            {\n                for ( index0 = 0; index0 <= Terrain.TileSize.X - 1; index0++ )\n                {\n                    Terrain.Tiles[index0, index1].Texture.TextureNum = -1;\n                }\n            }\n\n            for ( index1 = 0; index1 <= endY; index1++ )\n            {\n                for ( index0 = 0; index0 <= endX; index0++ )\n                {\n                    Terrain.Vertices[index0, index1].Height = mapToCopy.Terrain.Vertices[offset.X + index0, offset.Y + index1].Height;\n                    Terrain.Vertices[index0, index1].Terrain = mapToCopy.Terrain.Vertices[offset.X + index0, offset.Y + index1].Terrain;\n                }\n            }\n            for ( index1 = 0; index1 <= endY - 1; index1++ )\n            {\n                for ( index0 = 0; index0 <= endX - 1; index0++ )\n                {\n                    Terrain.Tiles[index0, index1].Copy(mapToCopy.Terrain.Tiles[offset.X + index0, offset.Y + index1]);\n                }\n            }\n            for ( index1 = 0; index1 <= endY; index1++ )\n            {\n                for ( index0 = 0; index0 <= endX - 1; index0++ )\n                {\n                    Terrain.SideH[index0, index1].Road = mapToCopy.Terrain.SideH[offset.X + index0, offset.Y + index1].Road;\n                }\n            }\n            for ( index1 = 0; index1 <= endY - 1; index1++ )\n            {\n                for ( index0 = 0; index0 <= endX; index0++ )\n                {\n                    Terrain.SideV[index0, index1].Road = mapToCopy.Terrain.SideV[offset.X + index0, offset.Y + index1].Road;\n                }\n            }\n\n            SectorCount.X = Math.Ceiling((double)area.X / Constants.SectorTileSize).ToInt();\n            SectorCount.Y = Math.Ceiling((double)area.Y / Constants.SectorTileSize).ToInt();\n            Sectors = new Sector[SectorCount.X, SectorCount.Y];\n            for ( index1 = 0; index1 <= SectorCount.Y - 1; index1++ )\n            {\n                for ( index0 = 0; index0 <= SectorCount.X - 1; index0++ )\n                {\n                    Sectors[index0, index1] = new Sector(new XYInt(index0, index1));\n                }\n            }\n\n            var posDif = new XYInt();\n            var newUnitAdd = new clsUnitAdd();\n            newUnitAdd.Map = this;\n\n            foreach ( var gateway in mapToCopy.Gateways )\n            {\n                GatewayCreate(new XYInt(gateway.PosA.X - offset.X, gateway.PosA.Y - offset.Y),\n                    new XYInt(gateway.PosB.X - offset.X, gateway.PosB.Y - offset.Y));\n            }\n\n            posDif.X = - offset.X * Constants.TerrainGridSpacing;\n            posDif.Y = - offset.Y * Constants.TerrainGridSpacing;\n            foreach ( var unit in mapToCopy.Units )\n            {\n                var newPos = unit.Pos.Horizontal + posDif;\n                if ( PosIsOnMap(newPos) )\n                {\n                    var newUnit = new Unit(unit, this);\n                    newUnit.Pos.Horizontal = newPos;\n                    newUnitAdd.NewUnit = newUnit;\n                    newUnitAdd.Label = unit.Label;\n                    newUnitAdd.Perform();\n                }\n            }\n\n            return this;\n        }\n\n        public bool ReadyForUserInput\n        {\n            get { return readyForUserInput; }\n        }\n\n        public bool IsMainMap { get; set; }\n\n        public event ChangedEventHandler Changed\n        {\n            add { changedEvent = (ChangedEventHandler)Delegate.Combine(changedEvent, value); }\n            remove { changedEvent = (ChangedEventHandler)Delegate.Remove(changedEvent, value); }\n        }\n\n        private void InitializeMap()\n        {\n            MakeDefaultUnitGroups();\n        }\n\n        public void TerrainBlank(XYInt tileSize)\n        {\n            var index0 = 0;\n            var index1 = 0;\n\n            Terrain = new clsTerrain(tileSize);\n            SectorCount.X = Math.Ceiling((double)Terrain.TileSize.X / Constants.SectorTileSize).ToInt();\n            SectorCount.Y = Math.Ceiling((double)Terrain.TileSize.Y / Constants.SectorTileSize).ToInt();\n            Sectors = new Sector[SectorCount.X, SectorCount.Y];\n            for ( index1 = 0; index1 <= SectorCount.Y - 1; index1++ )\n            {\n                for ( index0 = 0; index0 <= SectorCount.X - 1; index0++ )\n                {\n                    Sectors[index0, index1] = new Sector(new XYInt(index0, index1));\n                }\n            }\n        }\n\n        public bool GetTerrainTri(XYInt horizontal)\n        {\n            var x1 = 0;\n            var y1 = 0;\n            double inTileX = 0;\n            double inTileZ = 0;\n            var xg = 0;\n            var yg = 0;\n\n            xg = horizontal.X / Constants.TerrainGridSpacing;\n            yg = (horizontal.Y / Constants.TerrainGridSpacing);\n            inTileX = MathUtil.ClampDbl(horizontal.X / Constants.TerrainGridSpacing - xg, 0.0D, 1.0D);\n            inTileZ = MathUtil.ClampDbl(horizontal.Y / Constants.TerrainGridSpacing - yg, 0.0D, 1.0D);\n            x1 = MathUtil.ClampInt(xg, 0, Terrain.TileSize.X - 1);\n            y1 = MathUtil.ClampInt(yg, 0, Terrain.TileSize.Y - 1);\n            if ( Terrain.Tiles[x1, y1].Tri )\n            {\n                if ( inTileZ <= 1.0D - inTileX )\n                {\n                    return false;\n                }\n                return true;\n            }\n            if ( inTileZ <= inTileX )\n            {\n                return true;\n            }\n            return false;\n        }\n\n        public double GetTerrainSlopeAngle(XYInt horizontal)\n        {\n            var X1 = 0;\n            var X2 = 0;\n            var Y1 = 0;\n            var Y2 = 0;\n            double InTileX = 0;\n            double InTileZ = 0;\n            var XG = 0;\n            var YG = 0;\n            double GradientX = 0;\n            double GradientY = 0;\n            double Offset = 0;\n            var XYZ_dbl = default(XYZDouble);\n            var XYZ_dbl2 = default(XYZDouble);\n            var XYZ_dbl3 = default(XYZDouble);\n            var AnglePY = default(Angles.AnglePY);\n\n            XG = (horizontal.X / Constants.TerrainGridSpacing);\n            YG = horizontal.Y / Constants.TerrainGridSpacing;\n            InTileX = MathUtil.ClampDbl(horizontal.X / Constants.TerrainGridSpacing - XG, 0.0D, 1.0D);\n            InTileZ = MathUtil.ClampDbl(horizontal.Y / Constants.TerrainGridSpacing - YG, 0.0D, 1.0D);\n            X1 = MathUtil.ClampInt(XG, 0, Terrain.TileSize.X - 1);\n            Y1 = MathUtil.ClampInt(YG, 0, Terrain.TileSize.Y - 1);\n            X2 = MathUtil.ClampInt(XG + 1, 0, Terrain.TileSize.X);\n            Y2 = MathUtil.ClampInt(YG + 1, 0, Terrain.TileSize.Y);\n            if ( Terrain.Tiles[X1, Y1].Tri )\n            {\n                if ( InTileZ <= 1.0D - InTileX )\n                {\n                    Offset = Terrain.Vertices[X1, Y1].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X2, Y1].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X1, Y2].Height - Offset);\n                }\n                else\n                {\n                    Offset = Terrain.Vertices[X2, Y2].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X1, Y2].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X2, Y1].Height - Offset);\n                }\n            }\n            else\n            {\n                if ( InTileZ <= InTileX )\n                {\n                    Offset = Terrain.Vertices[X2, Y1].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X1, Y1].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X2, Y2].Height - Offset);\n                }\n                else\n                {\n                    Offset = Terrain.Vertices[X1, Y2].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X2, Y2].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X1, Y1].Height - Offset);\n                }\n            }\n\n            XYZ_dbl.X = Constants.TerrainGridSpacing;\n            XYZ_dbl.Y = GradientX * HeightMultiplier;\n            XYZ_dbl.Z = 0.0D;\n            XYZ_dbl2.X = 0.0D;\n            XYZ_dbl2.Y = GradientY * HeightMultiplier;\n            XYZ_dbl2.Z = Constants.TerrainGridSpacing;\n            Matrix3DMath.VectorCrossProduct(XYZ_dbl, XYZ_dbl2, ref XYZ_dbl3);\n            if ( XYZ_dbl3.X != 0.0D | XYZ_dbl3.Z != 0.0D )\n            {\n                Matrix3DMath.VectorToPY(XYZ_dbl3, ref AnglePY);\n                return MathUtil.RadOf90Deg - Math.Abs(AnglePY.Pitch);\n            }\n            return 0.0D;\n        }\n\n        public double GetTerrainHeight(XYInt Horizontal)\n        {\n            var X1 = 0;\n            var X2 = 0;\n            var Y1 = 0;\n            var Y2 = 0;\n            double InTileX = 0;\n            double InTileZ = 0;\n            var XG = 0;\n            var YG = 0;\n            double GradientX = 0;\n            double GradientY = 0;\n            double Offset = 0;\n            double RatioX = 0;\n            double RatioY = 0;\n\n            XG = (Horizontal.X / Constants.TerrainGridSpacing);\n            YG = Horizontal.Y / Constants.TerrainGridSpacing;\n            InTileX = MathUtil.ClampDbl(Horizontal.X / Constants.TerrainGridSpacing - XG, 0.0D, 1.0D);\n            InTileZ = MathUtil.ClampDbl(Horizontal.Y / Constants.TerrainGridSpacing - YG, 0.0D, 1.0D);\n            X1 = MathUtil.ClampInt(XG, 0, Terrain.TileSize.X - 1);\n            Y1 = MathUtil.ClampInt(YG, 0, Terrain.TileSize.Y - 1);\n            X2 = MathUtil.ClampInt(XG + 1, 0, Terrain.TileSize.X);\n            Y2 = MathUtil.ClampInt(YG + 1, 0, Terrain.TileSize.Y);\n            if ( Terrain.Tiles[X1, Y1].Tri )\n            {\n                if ( InTileZ <= 1.0D - InTileX )\n                {\n                    Offset = Terrain.Vertices[X1, Y1].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X2, Y1].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X1, Y2].Height - Offset);\n                    RatioX = InTileX;\n                    RatioY = InTileZ;\n                }\n                else\n                {\n                    Offset = Terrain.Vertices[X2, Y2].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X1, Y2].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X2, Y1].Height - Offset);\n                    RatioX = 1.0D - InTileX;\n                    RatioY = 1.0D - InTileZ;\n                }\n            }\n            else\n            {\n                if ( InTileZ <= InTileX )\n                {\n                    Offset = Terrain.Vertices[X2, Y1].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X1, Y1].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X2, Y2].Height - Offset);\n                    RatioX = 1.0D - InTileX;\n                    RatioY = InTileZ;\n                }\n                else\n                {\n                    Offset = Terrain.Vertices[X1, Y2].Height;\n                    GradientX = Convert.ToDouble(Terrain.Vertices[X2, Y2].Height - Offset);\n                    GradientY = Convert.ToDouble(Terrain.Vertices[X1, Y1].Height - Offset);\n                    RatioX = InTileX;\n                    RatioY = 1.0D - InTileZ;\n                }\n            }\n            return (Offset + GradientX * RatioX + GradientY * RatioY) * HeightMultiplier;\n        }\n\n        public XYZDouble TerrainVertexNormalCalc(int X, int Y)\n        {\n            var ReturnResult = default(XYZDouble);\n            var TerrainHeightX1 = 0;\n            var TerrainHeightX2 = 0;\n            var TerrainHeightY1 = 0;\n            var TerrainHeightY2 = 0;\n            var X2 = 0;\n            var Y2 = 0;\n            var vector1 = default(XYZDouble);\n            var vector2 = default(XYZDouble);\n            double dblTemp = 0;\n\n            X2 = MathUtil.ClampInt(X - 1, 0, Terrain.TileSize.X);\n            Y2 = MathUtil.ClampInt(Y, 0, Terrain.TileSize.Y);\n            TerrainHeightX1 = Terrain.Vertices[X2, Y2].Height;\n            X2 = MathUtil.ClampInt(X + 1, 0, Terrain.TileSize.X);\n            Y2 = MathUtil.ClampInt(Y, 0, Terrain.TileSize.Y);\n            TerrainHeightX2 = Terrain.Vertices[X2, Y2].Height;\n            X2 = MathUtil.ClampInt(X, 0, Terrain.TileSize.X);\n            Y2 = MathUtil.ClampInt(Y - 1, 0, Terrain.TileSize.Y);\n            TerrainHeightY1 = Terrain.Vertices[X2, Y2].Height;\n            X2 = MathUtil.ClampInt(X, 0, Terrain.TileSize.X);\n            Y2 = MathUtil.ClampInt(Y + 1, 0, Terrain.TileSize.Y);\n            TerrainHeightY2 = Terrain.Vertices[X2, Y2].Height;\n            vector1.X = (TerrainHeightX1 - TerrainHeightX2) * HeightMultiplier;\n            vector1.Y = Constants.TerrainGridSpacing * 2.0D;\n            vector1.Z = 0.0D;\n            vector2.X = 0.0D;\n            vector2.Y = Constants.TerrainGridSpacing * 2.0D;\n            vector2.Z = (TerrainHeightY1 - TerrainHeightY2) * HeightMultiplier;\n            vector1.X += vector2.X;\n            vector1.Y += vector2.Y;\n            vector1.Z += vector2.Z;\n            //dblTemp = Math.Sqrt(vector1.X * vector1.X + vector1.Y * vector1.Y + vector1.Z * vector1.Z);\n            dblTemp = vector1.GetMagnitude();\n            ReturnResult.X = vector1.X / dblTemp;\n            ReturnResult.Y = vector1.Y / dblTemp;\n            ReturnResult.Z = vector1.Z / dblTemp;\n            return ReturnResult;\n        }\n\n        public void SectorAll_GLLists_Delete()\n        {\n            var X = 0;\n            var Y = 0;\n\n            for ( Y = 0; Y <= SectorCount.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= SectorCount.X - 1; X++ )\n                {\n                    Sectors[X, Y].DeleteLists();\n                }\n            }\n        }\n\n        public virtual void Deallocate()\n        {\n            CancelUserInput();\n\n            UnitGroups.Deallocate();\n            UnitGroups = null;\n\n            while ( Units.Count > 0 )\n            {\n                if(Units[0] != null)\n                {\n                    Units[0].Deallocate();\n                } else\n                {\n                    Units.Remove(0);\n                }\n            }\n            Units.Deallocate();\n            Units = null;\n\n            while ( Gateways.Count > 0 )\n            {\n                if(Gateways[0] != null)\n                {\n                    Gateways[0].Deallocate();\n                } else\n                {\n                    Gateways.Remove(0);\n                }\n            }\n            Gateways.Deallocate();\n            Gateways = null;\n\n            while ( ScriptPositions.Count > 0 )\n            {\n                ScriptPositions[0].Deallocate();\n            }\n            ScriptPositions.Deallocate();\n            ScriptPositions = null;\n\n            while ( ScriptAreas.Count > 0 )\n            {\n                ScriptAreas[0].Deallocate();\n            }\n            ScriptAreas.Deallocate();\n            ScriptAreas = null;\n        }\n\n        public void TerrainResize(XYInt Offset, XYInt Size)\n        {\n            var StartX = 0;\n            var StartY = 0;\n            var EndX = 0;\n            var EndY = 0;\n            var X = 0;\n            var Y = 0;\n            var NewTerrain = new clsTerrain(Size);\n\n            StartX = Math.Max(0 - Offset.X, 0);\n            StartY = Math.Max(0 - Offset.Y, 0);\n            EndX = Math.Min(Terrain.TileSize.X - Offset.X, Size.X);\n            EndY = Math.Min(Terrain.TileSize.Y - Offset.Y, Size.Y);\n\n            for ( Y = 0; Y <= NewTerrain.TileSize.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= NewTerrain.TileSize.X - 1; X++ )\n                {\n                    NewTerrain.Tiles[X, Y].Texture.TextureNum = -1;\n                }\n            }\n\n            for ( Y = StartY; Y <= EndY; Y++ )\n            {\n                for ( X = StartX; X <= EndX; X++ )\n                {\n                    NewTerrain.Vertices[X, Y].Height = Terrain.Vertices[Offset.X + X, Offset.Y + Y].Height;\n                    NewTerrain.Vertices[X, Y].Terrain = Terrain.Vertices[Offset.X + X, Offset.Y + Y].Terrain;\n                }\n            }\n            for ( Y = StartY; Y <= EndY - 1; Y++ )\n            {\n                for ( X = StartX; X <= EndX - 1; X++ )\n                {\n                    NewTerrain.Tiles[X, Y].Copy(Terrain.Tiles[Offset.X + X, Offset.Y + Y]);\n                }\n            }\n            for ( Y = StartY; Y <= EndY; Y++ )\n            {\n                for ( X = StartX; X <= EndX - 1; X++ )\n                {\n                    NewTerrain.SideH[X, Y].Road = Terrain.SideH[Offset.X + X, Offset.Y + Y].Road;\n                }\n            }\n            for ( Y = StartY; Y <= EndY - 1; Y++ )\n            {\n                for ( X = StartX; X <= EndX; X++ )\n                {\n                    NewTerrain.SideV[X, Y].Road = Terrain.SideV[Offset.X + X, Offset.Y + Y].Road;\n                }\n            }\n\n            var PosDifX = 0;\n            var PosDifZ = 0;\n            var Unit = default(Unit);\n            var Gateway = default(Gateway);\n\n            PosDifX = - Offset.X * Constants.TerrainGridSpacing;\n            PosDifZ = - Offset.Y * Constants.TerrainGridSpacing;\n            foreach ( var tempLoopVar_Unit in Units )\n            {\n                Unit = tempLoopVar_Unit;\n                Unit.Pos.Horizontal.X += PosDifX;\n                Unit.Pos.Horizontal.Y += PosDifZ;\n            }\n            foreach ( var tempLoopVar_Gateway in Gateways )\n            {\n                Gateway = tempLoopVar_Gateway;\n                Gateway.PosA.X -= Offset.X;\n                Gateway.PosA.Y -= Offset.Y;\n                Gateway.PosB.X -= Offset.X;\n                Gateway.PosB.Y -= Offset.Y;\n            }\n\n            var ZeroPos = new XYInt(0, 0);\n\n            var Position = 0;\n            foreach ( var tempLoopVar_Unit in Units.CopyList() )\n            {\n                Unit = tempLoopVar_Unit;\n                Position = Unit.MapLink.Position;\n                if ( !App.PosIsWithinTileArea(Units[Position].Pos.Horizontal, ZeroPos, NewTerrain.TileSize) )\n                {\n                    UnitRemove(Position);\n                }\n            }\n\n            Terrain = NewTerrain;\n\n            foreach ( var tempLoopVar_Gateway in Gateways.CopyList() )\n            {\n                Gateway = tempLoopVar_Gateway;\n                if ( Gateway.IsOffMap() )\n                {\n                    Gateway.Deallocate();\n                }\n            }\n\n            var PosOffset = new XYInt(Offset.X * Constants.TerrainGridSpacing, Offset.Y * Constants.TerrainGridSpacing);\n\n            var ScriptPosition = default(clsScriptPosition);\n            foreach ( var tempLoopVar_ScriptPosition in ScriptPositions.CopyList() )\n            {\n                ScriptPosition = tempLoopVar_ScriptPosition;\n                ScriptPosition.MapResizing(PosOffset);\n            }\n\n            var ScriptArea = default(clsScriptArea);\n            foreach ( var tempLoopVar_ScriptArea in ScriptAreas.CopyList() )\n            {\n                ScriptArea = tempLoopVar_ScriptArea;\n                ScriptArea.MapResizing(PosOffset);\n            }\n\n            if ( readyForUserInput )\n            {\n                CancelUserInput();\n                InitializeUserInput();\n            }\n        }\n\n        public void Sector_GLList_Make(int X, int Y)\n        {\n            var TileX = 0;\n            var TileY = 0;\n            var StartX = 0;\n            var StartY = 0;\n            var FinishX = 0;\n            var FinishY = 0;\n\n            Sectors[X, Y].DeleteLists();\n\n            StartX = X * Constants.SectorTileSize;\n            StartY = Y * Constants.SectorTileSize;\n            FinishX = Math.Min(StartX + Constants.SectorTileSize, Terrain.TileSize.X) - 1;\n            FinishY = Math.Min(StartY + Constants.SectorTileSize, Terrain.TileSize.Y) - 1;\n\n            Sectors[X, Y].GLList_Textured = GL.GenLists(1);\n            GL.NewList(Convert.ToInt32(Sectors[X, Y].GLList_Textured), ListMode.Compile);\n\n            if ( App.Draw_Units )\n            {\n                var IsBasePlate = new bool[Constants.SectorTileSize, Constants.SectorTileSize];\n                var Unit = default(Unit);\n                var structureTypeBase = default(StructureTypeBase);\n                var Footprint = new XYInt();\n                var Connection = default(UnitSectorConnection);\n                var FootprintStart = new XYInt();\n                var FootprintFinish = new XYInt();\n                foreach ( var tempLoopVar_Connection in Sectors[X, Y].Units )\n                {\n                    Connection = tempLoopVar_Connection;\n                    Unit = Connection.Unit;\n                    if ( Unit.TypeBase.Type == UnitType.PlayerStructure )\n                    {\n                        structureTypeBase = (StructureTypeBase)Unit.TypeBase;\n                        if ( structureTypeBase.StructureBasePlate != null )\n                        {\n                            Footprint = structureTypeBase.GetGetFootprintSelected(Unit.Rotation);\n                            GetFootprintTileRangeClamped(Unit.Pos.Horizontal, Footprint, ref FootprintStart, ref FootprintFinish);\n                            for ( TileY = Math.Max(FootprintStart.Y, StartY); TileY <= Math.Min(FootprintFinish.Y, FinishY); TileY++ )\n                            {\n                                for ( TileX = Math.Max(FootprintStart.X, StartX); TileX <= Math.Min(FootprintFinish.X, FinishX); TileX++ )\n                                {\n                                    IsBasePlate[TileX - StartX, TileY - StartY] = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            // Draw Terrain\n            clsDrawTile drawTile = new clsDrawTileMiddleVertex();\n            drawTile.Map = this;\n            for ( TileY = StartY; TileY <= FinishY; TileY++ )\n            {\n                drawTile.TileY = TileY;\n                for ( TileX = StartX; TileX <= FinishX; TileX++ )\n                {\n                    drawTile.TileX = TileX;\n                    drawTile.Perform();\n                }\n            }\n\n            GL.EndList();\n\n            Sectors[X, Y].GLList_Wireframe = GL.GenLists(1);\n            GL.NewList(Sectors[X, Y].GLList_Wireframe, ListMode.Compile);\n\n            for ( TileY = StartY; TileY <= FinishY; TileY++ )\n            {\n                for ( TileX = StartX; TileX <= FinishX; TileX++ )\n                {\n                    DrawTileWireframe(TileX, TileY);\n                }\n            }\n\n            GL.EndList();\n\t        this.eventBroker.RefreshMinimap(this);\n        }\n\n        public void DrawTileWireframe(int TileX, int TileY)\n        {\n            var TileTerrainHeight = new double[4];\n            var Vertex0 = new XYZDouble();\n            var Vertex1 = new XYZDouble();\n            var Vertex2 = new XYZDouble();\n            var Vertex3 = new XYZDouble();\n\n            TileTerrainHeight[0] = Terrain.Vertices[TileX, TileY].Height;\n            TileTerrainHeight[1] = Terrain.Vertices[TileX + 1, TileY].Height;\n            TileTerrainHeight[2] = Terrain.Vertices[TileX, TileY + 1].Height;\n            TileTerrainHeight[3] = Terrain.Vertices[TileX + 1, TileY + 1].Height;\n\n            Vertex0.X = TileX * Constants.TerrainGridSpacing;\n            Vertex0.Y = (float)(TileTerrainHeight[0] * HeightMultiplier);\n            Vertex0.Z = - TileY * Constants.TerrainGridSpacing;\n            Vertex1.X = (TileX + 1) * Constants.TerrainGridSpacing;\n            Vertex1.Y = (float)(TileTerrainHeight[1] * HeightMultiplier);\n            Vertex1.Z = - TileY * Constants.TerrainGridSpacing;\n            Vertex2.X = TileX * Constants.TerrainGridSpacing;\n            Vertex2.Y = (float)(TileTerrainHeight[2] * HeightMultiplier);\n            Vertex2.Z = - (TileY + 1) * Constants.TerrainGridSpacing;\n            Vertex3.X = (TileX + 1) * Constants.TerrainGridSpacing;\n            Vertex3.Y = (float)(TileTerrainHeight[3] * HeightMultiplier);\n            Vertex3.Z = - (TileY + 1) * Constants.TerrainGridSpacing;\n\n            GL.Begin(BeginMode.Lines);\n            if ( Terrain.Tiles[TileX, TileY].Tri )\n            {\n                GL.Vertex3(Vertex0.X, Vertex0.Y, Convert.ToDouble(- Vertex0.Z));\n                GL.Vertex3(Vertex2.X, Vertex2.Y, Convert.ToDouble(- Vertex2.Z));\n                GL.Vertex3(Vertex2.X, Vertex2.Y, Convert.ToDouble(- Vertex2.Z));\n                GL.Vertex3(Vertex1.X, Vertex1.Y, Convert.ToDouble(- Vertex1.Z));\n                GL.Vertex3(Vertex1.X, Vertex1.Y, Convert.ToDouble(- Vertex1.Z));\n                GL.Vertex3(Vertex0.X, Vertex0.Y, Convert.ToDouble(- Vertex0.Z));\n\n                GL.Vertex3(Vertex1.X, Vertex1.Y, Convert.ToDouble(- Vertex1.Z));\n                GL.Vertex3(Vertex2.X, Vertex2.Y, Convert.ToDouble(- Vertex2.Z));\n                GL.Vertex3(Vertex2.X, Vertex2.Y, Convert.ToDouble(- Vertex2.Z));\n                GL.Vertex3(Vertex3.X, Vertex3.Y, Convert.ToDouble(- Vertex3.Z));\n                GL.Vertex3(Vertex3.X, Vertex3.Y, Convert.ToDouble(- Vertex3.Z));\n                GL.Vertex3(Vertex1.X, Vertex1.Y, Convert.ToDouble(- Vertex1.Z));\n            }\n            else\n            {\n                GL.Vertex3(Vertex0.X, Vertex0.Y, Convert.ToDouble(- Vertex0.Z));\n                GL.Vertex3(Vertex2.X, Vertex2.Y, Convert.ToDouble(- Vertex2.Z));\n                GL.Vertex3(Vertex2.X, Vertex2.Y, Convert.ToDouble(- Vertex2.Z));\n                GL.Vertex3(Vertex3.X, Vertex3.Y, Convert.ToDouble(- Vertex3.Z));\n                GL.Vertex3(Vertex3.X, Vertex3.Y, Convert.ToDouble(- Vertex3.Z));\n                GL.Vertex3(Vertex0.X, Vertex0.Y, Convert.ToDouble(- Vertex0.Z));\n\n                GL.Vertex3(Vertex0.X, Vertex0.Y, Convert.ToDouble(- Vertex0.Z));\n                GL.Vertex3(Vertex3.X, Vertex3.Y, Convert.ToDouble(- Vertex3.Z));\n                GL.Vertex3(Vertex3.X, Vertex3.Y, Convert.ToDouble(- Vertex3.Z));\n                GL.Vertex3(Vertex1.X, Vertex1.Y, Convert.ToDouble(- Vertex1.Z));\n                GL.Vertex3(Vertex1.X, Vertex1.Y, Convert.ToDouble(- Vertex1.Z));\n                GL.Vertex3(Vertex0.X, Vertex0.Y, Convert.ToDouble(- Vertex0.Z));\n            }\n            GL.End();\n        }\n\n        public void DrawTileOrientation(XYInt Tile)\n        {\n            var UnrotatedPos = new XYInt();\n            var Vertex0 = new WorldPos();\n            var Vertex1 = new WorldPos();\n            var Vertex2 = new WorldPos();\n\n            UnrotatedPos.X = 32;\n            UnrotatedPos.Y = 32;\n            Vertex0 = GetTileOffsetRotatedWorldPos(Tile, UnrotatedPos);\n\n            UnrotatedPos.X = 64;\n            UnrotatedPos.Y = 32;\n            Vertex1 = GetTileOffsetRotatedWorldPos(Tile, UnrotatedPos);\n\n            UnrotatedPos.X = 64;\n            UnrotatedPos.Y = 64;\n            Vertex2 = GetTileOffsetRotatedWorldPos(Tile, UnrotatedPos);\n\n            GL.Vertex3(Vertex0.Horizontal.X, Vertex0.Altitude, Vertex0.Horizontal.Y);\n            GL.Vertex3(Vertex1.Horizontal.X, Vertex1.Altitude, Vertex1.Horizontal.Y);\n            GL.Vertex3(Vertex2.Horizontal.X, Vertex2.Altitude, Vertex2.Horizontal.Y);\n        }\n            \n        public XYInt GetTileSectorNum(XYInt Tile)\n        {\n            var Result = new XYInt();\n\n            Result.X = (Tile.X / Constants.SectorTileSize);\n            Result.Y = (Tile.Y / Constants.SectorTileSize);\n\n            return Result;\n        }\n\n        public void GetTileSectorRange(XYInt StartTile, XYInt FinishTile, ref XYInt ResultSectorStart,\n            ref XYInt ResultSectorFinish)\n        {\n            ResultSectorStart = GetTileSectorNum(StartTile);\n            ResultSectorFinish = GetTileSectorNum(FinishTile);\n            ResultSectorStart.X = MathUtil.ClampInt(ResultSectorStart.X, 0, SectorCount.X - 1);\n            ResultSectorStart.Y = MathUtil.ClampInt(ResultSectorStart.Y, 0, SectorCount.Y - 1);\n            ResultSectorFinish.X = MathUtil.ClampInt(ResultSectorFinish.X, 0, SectorCount.X - 1);\n            ResultSectorFinish.Y = MathUtil.ClampInt(ResultSectorFinish.Y, 0, SectorCount.Y - 1);\n        }\n\n        public WorldPos TileAlignedPos(XYInt TileNum, XYInt Footprint)\n        {\n            var Result = new WorldPos();\n\n            Result.Horizontal.X = ((TileNum.X + Footprint.X / 2.0D) * Constants.TerrainGridSpacing).ToInt();\n            Result.Horizontal.Y = ((TileNum.Y + Footprint.Y / 2.0D) * Constants.TerrainGridSpacing).ToInt();\n            Result.Altitude = (GetTerrainHeight(Result.Horizontal)).ToInt();\n\n            return Result;\n        }\n\n        public WorldPos TileAlignedPosFromMapPos(XYInt Horizontal, XYInt Footprint)\n        {\n            var Result = new WorldPos();\n\n            Result.Horizontal.X = ((Math.Round(Convert.ToDouble((Horizontal.X - Footprint.X * Constants.TerrainGridSpacing / 2.0D) / Constants.TerrainGridSpacing)) +\n                      Footprint.X / 2.0D) * Constants.TerrainGridSpacing).ToInt();\n            Result.Horizontal.Y = ((Math.Round(Convert.ToDouble((Horizontal.Y - Footprint.Y * Constants.TerrainGridSpacing / 2.0D) / Constants.TerrainGridSpacing)) +\n                      Footprint.Y / 2.0D) * Constants.TerrainGridSpacing).ToInt();\n            Result.Altitude = GetTerrainHeight(Result.Horizontal).ToInt();\n\n            return Result;\n        }\n\n        // TODO: Think that code is useless - Ren\u00e9\n        public void UnitSectorsCalc(Unit Unit)\n        {\n            var Start = new XYInt();\n            var Finish = new XYInt();\n            var TileStart = new XYInt();\n            var TileFinish = new XYInt();\n            var X = 0;\n            var Y = 0;\n\n            GetFootprintTileRangeClamped(Unit.Pos.Horizontal, Unit.TypeBase.GetGetFootprintSelected(Unit.Rotation), ref TileStart, ref TileFinish);\n            Start = GetTileSectorNum(TileStart);\n            Finish = GetTileSectorNum(TileFinish);\n            Start.X = MathUtil.ClampInt(Start.X, 0, SectorCount.X - 1);\n            Start.Y = MathUtil.ClampInt(Start.Y, 0, SectorCount.Y - 1);\n            Finish.X = MathUtil.ClampInt(Finish.X, 0, SectorCount.X - 1);\n            Finish.Y = MathUtil.ClampInt(Finish.Y, 0, SectorCount.Y - 1);\n            Unit.Sectors.Clear();\n            for ( Y = Start.Y; Y <= Finish.Y; Y++ )\n            {\n                for ( X = Start.X; X <= Finish.X; X++ )\n                {\n                    UnitSectorConnection.Create(Unit, Sectors[X, Y]);\n                }\n            }\n        }\n\n        public void AutoSaveTest()\n        {\n            if ( !App.SettingsManager.AutoSaveEnabled )\n            {\n                return;\n            }\n            if ( AutoSave.ChangeCount < App.SettingsManager.AutoSaveMinIntervalSeconds )\n            {\n                return;\n            }\n\n            var timeDiff = DateTime.Now - AutoSave.SavedDate;\n            if ( timeDiff.TotalSeconds < App.SettingsManager.AutoSaveMinIntervalSeconds )\n            {\n                logger.Debug(string.Format(\"No autosave, we have {0} seconds of {1}\",\n                    timeDiff.TotalSeconds, App.SettingsManager.AutoSaveMinIntervalSeconds));\n                return;\n            }\n\n            AutoSave.ChangeCount = 0;\n            AutoSave.SavedDate = DateTime.Now;\n\n            App.ShowWarnings(AutoSavePerform());\n        }\n\n        public Result AutoSavePerform()\n        {\n            var ReturnResult = new Result(\"Autosave\", false);\n\n            var DateNow = DateTime.Now;\n            var path = string.Format(\"{0}autosaved-{1}-{2}-{3}-{4}-{5}-{6}-{7}.fmap\",\n                App.AutoSavePath, DateNow.Year, App.MinDigits(DateNow.Month, 2),\n                App.MinDigits(DateNow.Day, 2), App.MinDigits(DateNow.Hour, 2),\n                App.MinDigits(DateNow.Minute, 2), App.MinDigits(DateNow.Second, 2),\n                App.MinDigits(DateNow.Millisecond, 3));\n\n            logger.Info(string.Format(\"Autosave to: \\\"{0}\\\"\", path));\n\n            var fmap = App.Kernel.Get<FMapSaver>();\n            ReturnResult.Add(fmap.Save(path, this, false, App.SettingsManager.AutoSaveCompress));\n\n            return ReturnResult;\n        }\n\n        public void UndoStepCreate(string StepName)\n        {\n            var NewUndo = new Undo();\n\n            NewUndo.Name = StepName;\n\n            var SectorNum = default(XYInt);\n            foreach ( var tempLoopVar_SectorNum in SectorTerrainUndoChanges.ChangedPoints )\n            {\n                SectorNum = tempLoopVar_SectorNum;\n                NewUndo.ChangedSectors.Add(ShadowSectors[SectorNum.X, SectorNum.Y]);\n                ShadowSector_Create(SectorNum);\n            }\n            SectorTerrainUndoChanges.Clear();\n\n            NewUndo.UnitChanges.AddRange(UnitChanges);\n            UnitChanges.Clear();\n\n            NewUndo.GatewayChanges.AddRange(GatewayChanges);\n            GatewayChanges.Clear();\n\n            if ( NewUndo.ChangedSectors.Count + NewUndo.UnitChanges.Count + NewUndo.GatewayChanges.Count > 0 )\n            {\n                while ( Undos.Count > UndoPosition ) //a new line has been started so remove redos\n                {\n                    Undos.RemoveAt(Undos.Count - 1);\n                }\n\n                Undos.Add(NewUndo);\n                UndoPosition = Undos.Count;\n\n                SetChanged();\n            }\n        }\n\n        public void ShadowSector_Create(XYInt SectorNum)\n        {\n            var TileX = 0;\n            var TileY = 0;\n            var StartX = 0;\n            var StartY = 0;\n            var X = 0;\n            var Y = 0;\n            var Sector = default(ShadowSector);\n            var LastTileX = 0;\n            var LastTileY = 0;\n\n            Sector = new ShadowSector();\n            ShadowSectors[SectorNum.X, SectorNum.Y] = Sector;\n            Sector.Num = SectorNum;\n            StartX = SectorNum.X * Constants.SectorTileSize;\n            StartY = SectorNum.Y * Constants.SectorTileSize;\n            LastTileX = Math.Min(Constants.SectorTileSize, Terrain.TileSize.X - StartX);\n            LastTileY = Math.Min(Constants.SectorTileSize, Terrain.TileSize.Y - StartY);\n            for ( Y = 0; Y <= LastTileY; Y++ )\n            {\n                for ( X = 0; X <= LastTileX; X++ )\n                {\n                    TileX = StartX + X;\n                    TileY = StartY + Y;\n                    Sector.Terrain.Vertices[X, Y].Height = Terrain.Vertices[TileX, TileY].Height;\n                    Sector.Terrain.Vertices[X, Y].Terrain = Terrain.Vertices[TileX, TileY].Terrain;\n                }\n            }\n            for ( Y = 0; Y <= LastTileY - 1; Y++ )\n            {\n                for ( X = 0; X <= LastTileX - 1; X++ )\n                {\n                    TileX = StartX + X;\n                    TileY = StartY + Y;\n                    Sector.Terrain.Tiles[X, Y].Copy(Terrain.Tiles[TileX, TileY]);\n                }\n            }\n            for ( Y = 0; Y <= LastTileY; Y++ )\n            {\n                for ( X = 0; X <= LastTileX - 1; X++ )\n                {\n                    TileX = StartX + X;\n                    TileY = StartY + Y;\n                    Sector.Terrain.SideH[X, Y].Road = Terrain.SideH[TileX, TileY].Road;\n                }\n            }\n            for ( Y = 0; Y <= LastTileY - 1; Y++ )\n            {\n                for ( X = 0; X <= LastTileX; X++ )\n                {\n                    TileX = StartX + X;\n                    TileY = StartY + Y;\n                    Sector.Terrain.SideV[X, Y].Road = Terrain.SideV[TileX, TileY].Road;\n                }\n            }\n        }\n\n        public void UndoClear()\n        {\n            UndoStepCreate(\"\"); //absorb current changes\n            var UnitChange = default(UnitChange);\n            var Undo = default(Undo);\n\n            foreach ( var tempLoopVar_Undo in Undos )\n            {\n                Undo = tempLoopVar_Undo;\n                foreach ( var tempLoopVar_UnitChange in Undo.UnitChanges )\n                {\n                    UnitChange = tempLoopVar_UnitChange;\n                    UnitChange.Unit.Deallocate();\n                }\n            }\n\n            Undos.Clear();\n            UndoPosition = Undos.Count;\n        }\n\n        public void UndoPerform()\n        {\n            var ThisUndo = default(Undo);\n\n            UndoStepCreate(\"Incomplete Action\"); //make another redo step incase something has changed, such as if user presses undo while still dragging a tool\n\n            UndoPosition--;\n\n            ThisUndo = Undos[UndoPosition];\n\n            var SectorNum = new XYInt();\n            var CurrentSector = default(ShadowSector);\n            var UndoSector = default(ShadowSector);\n            var NewSectorsForThisUndo = new ObservableCollection<ShadowSector>();\n            foreach ( var tempLoopVar_UndoSector in ThisUndo.ChangedSectors )\n            {\n                UndoSector = tempLoopVar_UndoSector;\n                SectorNum = UndoSector.Num;\n                //store existing state for redo\n                CurrentSector = ShadowSectors[SectorNum.X, SectorNum.Y];\n                //remove graphics from sector\n                Sectors[SectorNum.X, SectorNum.Y].DeleteLists();\n                //perform the undo\n                Undo_Sector_Rejoin(UndoSector);\n                //update the backup\n                ShadowSector_Create(SectorNum);\n                //add old state to the redo step (that was this undo step)\n                NewSectorsForThisUndo.Add(CurrentSector);\n                //prepare to update graphics on this sector\n                SectorGraphicsChanges.Changed(SectorNum);\n            }\n            ThisUndo.ChangedSectors = NewSectorsForThisUndo;\n\n            UInt32 ID = 0;\n            var UnitAdd = new clsUnitAdd();\n            UnitAdd.Map = this;\n            var Unit = default(Unit);\n            for ( var A = ThisUndo.UnitChanges.Count - 1; A >= 0; A-- ) //must do in reverse order, otherwise may try to delete units that havent been added yet\n            {\n                Unit = ThisUndo.UnitChanges[A].Unit;\n                if ( ThisUndo.UnitChanges[A].Type == UnitChangeType.Added )\n                {\n                    //remove the unit from the map\n                    UnitRemove(Unit.MapLink.Position);\n                }\n                else if ( ThisUndo.UnitChanges[A].Type == UnitChangeType.Deleted )\n                {\n                    //add the unit back on to the map\n                    ID = Unit.ID;\n                    UnitAdd.ID = ID;\n                    UnitAdd.NewUnit = Unit;\n                    UnitAdd.Perform();\n                    App.ErrorIDChange(ID, Unit, \"Undo_Perform\");\n                }\n                else\n                {\n                    Debugger.Break();\n                }\n            }\n\n            var GatewayChange = default(GatewayChange);\n            for ( var A = ThisUndo.GatewayChanges.Count - 1; A >= 0; A-- )\n            {\n                GatewayChange = ThisUndo.GatewayChanges[A];\n                switch ( GatewayChange.Type )\n                {\n                    case GatewayChangeType.Added:\n                        //remove the unit from the map\n                        GatewayChange.Gateway.MapLink.Disconnect();\n                        break;\n                    case GatewayChangeType.Deleted:\n                        //add the unit back on to the map\n                        GatewayChange.Gateway.MapLink.Connect(Gateways);\n                        break;\n                    default:\n                        Debugger.Break();\n                        break;\n                }\n            }\n\n            SectorsUpdateGraphics();\n\t        this.eventBroker.RefreshMinimap(this);\n            Program.frmMainInstance.SelectedObject_Changed();\n        }\n\n        public void RedoPerform()\n        {\n            var ThisUndo = default(Undo);\n\n            ThisUndo = Undos[UndoPosition];\n\n            var SectorNum = new XYInt();\n            var CurrentSector = default(ShadowSector);\n            var UndoSector = default(ShadowSector);\n            var NewSectorsForThisUndo = new ObservableCollection<ShadowSector>();\n            foreach ( var tempLoopVar_UndoSector in ThisUndo.ChangedSectors )\n            {\n                UndoSector = tempLoopVar_UndoSector;\n                SectorNum = UndoSector.Num;\n                //store existing state for undo\n                CurrentSector = ShadowSectors[SectorNum.X, SectorNum.Y];\n                //remove graphics from sector\n                Sectors[SectorNum.X, SectorNum.Y].DeleteLists();\n                //perform the redo\n                Undo_Sector_Rejoin(UndoSector);\n                //update the backup\n                ShadowSector_Create(SectorNum);\n                //add old state to the undo step (that was this redo step)\n                NewSectorsForThisUndo.Add(CurrentSector);\n                //prepare to update graphics on this sector\n                SectorGraphicsChanges.Changed(SectorNum);\n            }\n            ThisUndo.ChangedSectors = NewSectorsForThisUndo;\n\n            UInt32 ID = 0;\n            var UnitAdd = new clsUnitAdd();\n            UnitAdd.Map = this;\n            var Unit = default(Unit);\n            for ( var A = 0; A <= ThisUndo.UnitChanges.Count - 1; A++ ) //forward order is important\n            {\n                Unit = ThisUndo.UnitChanges[A].Unit;\n                if ( ThisUndo.UnitChanges[A].Type == UnitChangeType.Added )\n                {\n                    //add the unit back on to the map\n                    ID = Unit.ID;\n                    UnitAdd.ID = ID;\n                    UnitAdd.NewUnit = Unit;\n                    UnitAdd.Perform();\n                    App.ErrorIDChange(ID, Unit, \"Redo_Perform\");\n                }\n                else if ( ThisUndo.UnitChanges[A].Type == UnitChangeType.Deleted )\n                {\n                    //remove the unit from the map\n                    UnitRemove(Unit.MapLink.Position);\n                }\n                else\n                {\n                    Debugger.Break();\n                }\n            }\n\n            var GatewayChange = default(GatewayChange);\n            for ( var A = 0; A <= ThisUndo.GatewayChanges.Count - 1; A++ ) //forward order is important\n            {\n                GatewayChange = ThisUndo.GatewayChanges[A];\n                switch ( GatewayChange.Type )\n                {\n                    case GatewayChangeType.Added:\n                        //add the unit back on to the map\n                        GatewayChange.Gateway.MapLink.Connect(Gateways);\n                        break;\n                    case GatewayChangeType.Deleted:\n                        //remove the unit from the map\n                        GatewayChange.Gateway.MapLink.Disconnect();\n                        break;\n                    default:\n                        Debugger.Break();\n                        break;\n                }\n            }\n\n            UndoPosition++;\n\n            SectorsUpdateGraphics();\n\t        this.eventBroker.RefreshMinimap(this);\n            Program.frmMainInstance.SelectedObject_Changed();\n        }\n\n        public void Undo_Sector_Rejoin(ShadowSector Shadow_Sector_To_Rejoin)\n        {\n            var TileX = 0;\n            var TileZ = 0;\n            var StartX = 0;\n            var StartZ = 0;\n            var X = 0;\n            var Y = 0;\n            var LastTileX = 0;\n            var LastTileZ = 0;\n\n            StartX = Shadow_Sector_To_Rejoin.Num.X * Constants.SectorTileSize;\n            StartZ = Shadow_Sector_To_Rejoin.Num.Y * Constants.SectorTileSize;\n            LastTileX = Math.Min(Constants.SectorTileSize, Terrain.TileSize.X - StartX);\n            LastTileZ = Math.Min(Constants.SectorTileSize, Terrain.TileSize.Y - StartZ);\n            for ( Y = 0; Y <= LastTileZ; Y++ )\n            {\n                for ( X = 0; X <= LastTileX; X++ )\n                {\n                    TileX = StartX + X;\n                    TileZ = StartZ + Y;\n                    Terrain.Vertices[TileX, TileZ].Height = Shadow_Sector_To_Rejoin.Terrain.Vertices[X, Y].Height;\n                    Terrain.Vertices[TileX, TileZ].Terrain = Shadow_Sector_To_Rejoin.Terrain.Vertices[X, Y].Terrain;\n                }\n            }\n            for ( Y = 0; Y <= LastTileZ - 1; Y++ )\n            {\n                for ( X = 0; X <= LastTileX - 1; X++ )\n                {\n                    TileX = StartX + X;\n                    TileZ = StartZ + Y;\n                    Terrain.Tiles[TileX, TileZ].Copy(Shadow_Sector_To_Rejoin.Terrain.Tiles[X, Y]);\n                }\n            }\n            for ( Y = 0; Y <= LastTileZ; Y++ )\n            {\n                for ( X = 0; X <= LastTileX - 1; X++ )\n                {\n                    TileX = StartX + X;\n                    TileZ = StartZ + Y;\n                    Terrain.SideH[TileX, TileZ].Road = Shadow_Sector_To_Rejoin.Terrain.SideH[X, Y].Road;\n                }\n            }\n            for ( Y = 0; Y <= LastTileZ - 1; Y++ )\n            {\n                for ( X = 0; X <= LastTileX; X++ )\n                {\n                    TileX = StartX + X;\n                    TileZ = StartZ + Y;\n                    Terrain.SideV[TileX, TileZ].Road = Shadow_Sector_To_Rejoin.Terrain.SideV[X, Y].Road;\n                }\n            }\n        }\n\n        public void MapInsert(Map MapToInsert, XYInt Offset, XYInt Area, bool InsertHeights, bool InsertTextures, bool InsertUnits,\n            bool DeleteUnits, bool InsertGateways, bool DeleteGateways)\n        {\n            var Finish = new XYInt();\n            var X = 0;\n            var Y = 0;\n            var SectorStart = new XYInt();\n            var SectorFinish = new XYInt();\n            var AreaAdjusted = new XYInt();\n            var SectorNum = new XYInt();\n\n            Finish.X = Math.Min(Offset.X + Math.Min(Area.X, MapToInsert.Terrain.TileSize.X), Terrain.TileSize.X);\n            Finish.Y = Math.Min(Offset.Y + Math.Min(Area.Y, MapToInsert.Terrain.TileSize.Y), Terrain.TileSize.Y);\n            AreaAdjusted.X = Finish.X - Offset.X;\n            AreaAdjusted.Y = Finish.Y - Offset.Y;\n\n            GetTileSectorRange(new XYInt(Offset.X - 1, Offset.Y - 1), Finish, ref SectorStart, ref SectorFinish);\n            for ( Y = SectorStart.Y; Y <= SectorFinish.Y; Y++ )\n            {\n                SectorNum.Y = Y;\n                for ( X = SectorStart.X; X <= SectorFinish.X; X++ )\n                {\n                    SectorNum.X = X;\n                    SectorGraphicsChanges.Changed(SectorNum);\n                    SectorUnitHeightsChanges.Changed(SectorNum);\n                    SectorTerrainUndoChanges.Changed(SectorNum);\n                }\n            }\n\n            if ( InsertHeights )\n            {\n                for ( Y = 0; Y <= AreaAdjusted.Y; Y++ )\n                {\n                    for ( X = 0; X <= AreaAdjusted.X; X++ )\n                    {\n                        Terrain.Vertices[Offset.X + X, Offset.Y + Y].Height = MapToInsert.Terrain.Vertices[X, Y].Height;\n                    }\n                }\n                for ( Y = 0; Y <= AreaAdjusted.Y - 1; Y++ )\n                {\n                    for ( X = 0; X <= AreaAdjusted.X - 1; X++ )\n                    {\n                        Terrain.Tiles[Offset.X + X, Offset.Y + Y].Tri = MapToInsert.Terrain.Tiles[X, Y].Tri;\n                    }\n                }\n            }\n            if ( InsertTextures )\n            {\n                for ( Y = 0; Y <= AreaAdjusted.Y; Y++ )\n                {\n                    for ( X = 0; X <= AreaAdjusted.X; X++ )\n                    {\n                        Terrain.Vertices[Offset.X + X, Offset.Y + Y].Terrain = MapToInsert.Terrain.Vertices[X, Y].Terrain;\n                    }\n                }\n                var TriDirection = default(bool);\n                for ( Y = 0; Y <= AreaAdjusted.Y - 1; Y++ )\n                {\n                    for ( X = 0; X <= AreaAdjusted.X - 1; X++ )\n                    {\n                        TriDirection = Terrain.Tiles[Offset.X + X, Offset.Y + Y].Tri;\n                        Terrain.Tiles[Offset.X + X, Offset.Y + Y].Copy(MapToInsert.Terrain.Tiles[X, Y]);\n                        Terrain.Tiles[Offset.X + X, Offset.Y + Y].Tri = TriDirection;\n                    }\n                }\n                for ( Y = 0; Y <= AreaAdjusted.Y; Y++ )\n                {\n                    for ( X = 0; X <= AreaAdjusted.X - 1; X++ )\n                    {\n                        Terrain.SideH[Offset.X + X, Offset.Y + Y].Road = MapToInsert.Terrain.SideH[X, Y].Road;\n                    }\n                }\n                for ( Y = 0; Y <= AreaAdjusted.Y - 1; Y++ )\n                {\n                    for ( X = 0; X <= AreaAdjusted.X; X++ )\n                    {\n                        Terrain.SideV[Offset.X + X, Offset.Y + Y].Road = MapToInsert.Terrain.SideV[X, Y].Road;\n                    }\n                }\n            }\n\n            var LastTile = new XYInt();\n            LastTile = Finish;\n            LastTile.X--;\n            LastTile.Y--;\n            if ( DeleteGateways )\n            {\n                var A = 0;\n                A = 0;\n                while ( A < Gateways.Count )\n                {\n                    if ( Gateways[A].PosA.IsInRange(Offset, LastTile) || Gateways[A].PosB.IsInRange(Offset, LastTile) )\n                    {\n                        GatewayRemoveStoreChange(A);\n                    }\n                    else\n                    {\n                        A++;\n                    }\n                }\n            }\n            if ( InsertGateways )\n            {\n                var GateStart = new XYInt();\n                var GateFinish = new XYInt();\n                var Gateway = default(Gateway);\n                foreach ( var tempLoopVar_Gateway in MapToInsert.Gateways )\n                {\n                    Gateway = tempLoopVar_Gateway;\n                    GateStart.X = Offset.X + Gateway.PosA.X;\n                    GateStart.Y = Offset.Y + Gateway.PosA.Y;\n                    GateFinish.X = Offset.X + Gateway.PosB.X;\n                    GateFinish.Y = Offset.Y + Gateway.PosB.Y;\n                    if ( GateStart.IsInRange(Offset, LastTile) || GateFinish.IsInRange(Offset, LastTile) )\n                    {\n                        GatewayCreateStoreChange(GateStart, GateFinish);\n                    }\n                }\n            }\n\n            if ( DeleteUnits )\n            {\n                var UnitsToDelete = new ObservableCollection<Unit>();\n                var Unit = default(Unit);\n                for ( Y = SectorStart.Y; Y <= SectorFinish.Y; Y++ )\n                {\n                    for ( X = SectorStart.X; X <= SectorFinish.X; X++ )\n                    {\n                        var Connection = default(UnitSectorConnection);\n                        foreach ( var tempLoopVar_Connection in Sectors[X, Y].Units )\n                        {\n                            Connection = tempLoopVar_Connection;\n                            Unit = Connection.Unit;\n                            if ( App.PosIsWithinTileArea(Unit.Pos.Horizontal, Offset, Finish) )\n                            {\n                                UnitsToDelete.Add(Unit);\n                            }\n                        }\n                    }\n                }\n                foreach ( var tempLoopVar_Unit in UnitsToDelete )\n                {\n                    Unit = tempLoopVar_Unit;\n                    if ( Unit.MapLink.IsConnected ) //units may be in the list multiple times and already be deleted\n                    {\n                        UnitRemoveStoreChange(Unit.MapLink.Position);\n                    }\n                }\n            }\n            if ( InsertUnits )\n            {\n                var PosDif = new XYInt();\n                var NewUnit = default(Unit);\n                var Unit = default(Unit);\n                var ZeroPos = new XYInt(0, 0);\n                var UnitAdd = new clsUnitAdd();\n\n                UnitAdd.Map = this;\n                UnitAdd.StoreChange = true;\n\n                PosDif.X = Offset.X * Constants.TerrainGridSpacing;\n                PosDif.Y = Offset.Y * Constants.TerrainGridSpacing;\n                foreach ( var tempLoopVar_Unit in MapToInsert.Units )\n                {\n                    Unit = tempLoopVar_Unit;\n                    if ( App.PosIsWithinTileArea(Unit.Pos.Horizontal, ZeroPos, AreaAdjusted) )\n                    {\n                        NewUnit = new Unit(Unit, this);\n                        NewUnit.Pos.Horizontal.X += PosDif.X;\n                        NewUnit.Pos.Horizontal.Y += PosDif.Y;\n                        UnitAdd.NewUnit = NewUnit;\n                        UnitAdd.Label = Unit.Label;\n                        UnitAdd.Perform();\n                    }\n                }\n            }\n\n            SectorsUpdateGraphics();\n            SectorsUpdateUnitHeights();\n\t        this.eventBroker.RefreshMinimap(this);\n        }\n\n        public Gateway GatewayCreate(XYInt PosA, XYInt PosB)\n        {\n            if ( PosA.X >= 0 & PosA.X < Terrain.TileSize.X &\n                 PosA.Y >= 0 & PosA.Y < Terrain.TileSize.Y &\n                 PosB.X >= 0 & PosB.X < Terrain.TileSize.X &\n                 PosB.Y >= 0 & PosB.Y < Terrain.TileSize.Y ) //is on map\n            {\n                if ( PosA.X == PosB.X | PosA.Y == PosB.Y ) //is straight\n                {\n                    var Gateway = new Gateway();\n\n                    Gateway.PosA = PosA;\n                    Gateway.PosB = PosB;\n\n                    Gateway.MapLink.Connect(Gateways);\n\n                    return Gateway;\n                }\n                return null;\n            }\n            return null;\n        }\n\n        public Gateway GatewayCreateStoreChange(XYInt PosA, XYInt PosB)\n        {\n            var Gateway = default(Gateway);\n\n            Gateway = GatewayCreate(PosA, PosB);\n\n            var GatewayChange = new GatewayChange();\n            GatewayChange.Type = GatewayChangeType.Added;\n            GatewayChange.Gateway = Gateway;\n            GatewayChanges.Add(GatewayChange);\n\n            return Gateway;\n        }\n\n        public void GatewayRemoveStoreChange(int Num)\n        {\n            var GatewayChange = new GatewayChange();\n            GatewayChange.Type = GatewayChangeType.Deleted;\n            GatewayChange.Gateway = Gateways[Num];\n            GatewayChanges.Add(GatewayChange);\n\n            Gateways[Num].MapLink.Disconnect();\n        }\n\n        public void TileType_Reset()\n        {\n            if ( Tileset == null )\n            {\n                TileTypeNum = new byte[0];\n            }\n            else\n            {\n                var A = 0;\n\n                TileTypeNum = new byte[Tileset.Tiles.Count];\n                for ( A = 0; A <= Tileset.Tiles.Count - 1; A++ )\n                {\n                    TileTypeNum[A] = Tileset.Tiles[A].DefaultType;\n                }\n            }\n        }\n\n        public void SetPainterToDefaults()\n        {\n            if ( Tileset == null )\n            {\n                Painter = new Painter();\n            }\n            else if ( Tileset == App.Tileset_Arizona )\n            {\n                Painter = App.Painter_Arizona;\n            }\n            else if ( Tileset == App.Tileset_Urban )\n            {\n                Painter = App.Painter_Urban;\n            }\n            else if ( Tileset == App.Tileset_Rockies )\n            {\n                Painter = App.Painter_Rockies;\n            }\n            else\n            {\n                Painter = new Painter();\n            }\n        }\n\n        internal void UnitSectorsGraphicsChanged(Unit UnitToUpdateFor)\n        {\n            if ( SectorGraphicsChanges == null )\n            {\n                Debugger.Break();\n                return;\n            }\n\n            var Connection = default(UnitSectorConnection);\n\n            foreach ( var tempLoopVar_Connection in UnitToUpdateFor.Sectors )\n            {\n                Connection = tempLoopVar_Connection;\n                SectorGraphicsChanges.Changed(Connection.Sector.Pos);\n            }\n        }\n\n        public WorldPos GetTileOffsetRotatedWorldPos(XYInt Tile, XYInt TileOffsetToRotate)\n        {\n            var Result = new WorldPos();\n\n            var RotatedOffset = new XYInt();\n\n            RotatedOffset = TileUtil.GetTileRotatedOffset(Terrain.Tiles[Tile.X, Tile.Y].Texture.Orientation, TileOffsetToRotate);\n            Result.Horizontal.X = Tile.X * Constants.TerrainGridSpacing + RotatedOffset.X;\n            Result.Horizontal.Y = Tile.Y * Constants.TerrainGridSpacing + RotatedOffset.Y;\n            Result.Altitude = GetTerrainHeight(Result.Horizontal).ToInt();\n\n            return Result;\n        }\n\n        public void GetFootprintTileRangeClamped(XYInt Horizontal, XYInt Footprint, ref XYInt ResultStart, ref XYInt ResultFinish)\n        {\n            var Remainder = 0;\n            var Centre = GetPosTileNum(Horizontal);\n            var Half = 0;\n\n            Half = Math.DivRem(Footprint.X, 2, out Remainder);\n            ResultStart.X = MathUtil.ClampInt(Centre.X - Half, 0, Terrain.TileSize.X - 1);\n            ResultFinish.X = MathUtil.ClampInt(ResultStart.X + Footprint.X - 1, 0, Terrain.TileSize.X - 1);\n            Half = Math.DivRem(Footprint.Y, 2, out Remainder);\n            ResultStart.Y = MathUtil.ClampInt(Centre.Y - Half, 0, Terrain.TileSize.Y - 1);\n            ResultFinish.Y = MathUtil.ClampInt(ResultStart.Y + Footprint.Y - 1, 0, Terrain.TileSize.Y - 1);\n        }\n\n        public void GetFootprintTileRange(XYInt Horizontal, XYInt Footprint, ref XYInt ResultStart, ref XYInt ResultFinish)\n        {\n            var Remainder = 0;\n            var Centre = GetPosTileNum(Horizontal);\n            var Half = 0;\n\n            Half = Math.DivRem(Footprint.X, 2, out Remainder);\n            ResultStart.X = Centre.X - Half;\n            ResultFinish.X = ResultStart.X + Footprint.X - 1;\n            Half = Math.DivRem(Footprint.Y, 2, out Remainder);\n            ResultStart.Y = Centre.Y - Half;\n            ResultFinish.Y = ResultStart.Y + Footprint.Y - 1;\n        }\n\n        public XYInt GetPosTileNum(XYInt Horizontal)\n        {\n            var Result = new XYInt();\n\n            Result.X = Horizontal.X / Constants.TerrainGridSpacing;\n            Result.Y = (Horizontal.Y / Constants.TerrainGridSpacing);\n\n            return Result;\n        }\n\n        public XYInt GetPosVertexNum(XYInt Horizontal)\n        {\n            var Result = new XYInt();\n\n            Result.X = Math.Round((double)Horizontal.X / Constants.TerrainGridSpacing).ToInt();\n            Result.Y = Math.Round((double)Horizontal.Y / Constants.TerrainGridSpacing).ToInt();\n\n            return Result;\n        }\n\n        public XYInt GetPosSectorNum(XYInt Horizontal)\n        {\n            var Result = new XYInt();\n\n            Result = GetTileSectorNum(GetPosTileNum(Horizontal));\n\n            return Result;\n        }\n\n        public XYInt GetSectorNumClamped(XYInt SectorNum)\n        {\n            var Result = new XYInt();\n\n            Result.X = MathUtil.ClampInt(SectorNum.X, 0, SectorCount.X - 1);\n            Result.Y = MathUtil.ClampInt(SectorNum.Y, 0, SectorCount.Y - 1);\n\n            return Result;\n        }\n\n        public int GetVertexAltitude(XYInt VertexNum)\n        {\n            return Terrain.Vertices[VertexNum.X, VertexNum.Y].Height * HeightMultiplier;\n        }\n\n        public bool PosIsOnMap(XYInt Horizontal)\n        {\n            return App.PosIsWithinTileArea(Horizontal, new XYInt(0, 0), Terrain.TileSize);\n        }\n\n        public XYInt TileNumClampToMap(XYInt TileNum)\n        {\n            var Result = new XYInt();\n\n            Result.X = MathUtil.ClampInt(TileNum.X, 0, Terrain.TileSize.X - 1);\n            Result.Y = MathUtil.ClampInt(TileNum.Y, 0, Terrain.TileSize.Y - 1);\n\n            return Result;\n        }\n\n        public void CancelUserInput()\n        {\n            if ( !readyForUserInput )\n            {\n                return;\n            }\n\n            readyForUserInput = false;\n\n            var X = 0;\n            var Y = 0;\n\n            if ( CompileScreen != null )\n            {\n                CompileScreen.Close();\n                CompileScreen = null;\n            }\n\n            SectorAll_GLLists_Delete();\n\n            ShadowSectors = null;\n            for ( Y = 0; Y <= SectorCount.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= SectorCount.X - 1; X++ )\n                {\n                    Sectors[X, Y].Deallocate();\n                }\n            }\n            Sectors = null;\n            SectorGraphicsChanges.Deallocate();\n            SectorGraphicsChanges = null;\n            SectorUnitHeightsChanges.Deallocate();\n            SectorUnitHeightsChanges = null;\n            SectorTerrainUndoChanges.Deallocate();\n            SectorTerrainUndoChanges = null;\n            AutoTextureChanges.Deallocate();\n            AutoTextureChanges = null;\n            TerrainInterpretChanges.Deallocate();\n            TerrainInterpretChanges = null;\n\n            UnitChanges = null;\n            GatewayChanges = null;\n            Undos = null;\n\n            SelectedUnits.Deallocate();\n            SelectedUnits = null;\n\n            SelectedTileA = new XYInt(0, 0);\n            SelectedTileB = new XYInt(0, 0);\n            SelectedAreaVertexA = new XYZInt(0, 0, 0);\n            SelectedAreaVertexB = new XYZInt(0, 0, 0);\n            UnitSelectedAreaVertexA = new XYZInt(0, 0, 0);\n\n            _SelectedUnitGroup = null;\n\n            Messages = null;\n        }\n\n        public void InitializeUserInput()\n        {\n            if ( readyForUserInput )\n            {\n                return;\n            }\n\n            readyForUserInput = true;\n\n            var X = 0;\n            var Y = 0;\n\n            SectorCount.X = Math.Ceiling((double)Terrain.TileSize.X / Constants.SectorTileSize).ToInt();\n            SectorCount.Y = Math.Ceiling((double)Terrain.TileSize.Y / Constants.SectorTileSize).ToInt();\n            Sectors = new Sector[SectorCount.X, SectorCount.Y];\n            for ( Y = 0; Y <= SectorCount.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= SectorCount.X - 1; X++ )\n                {\n                    Sectors[X, Y] = new Sector(new XYInt(X, Y));\n                }\n            }\n\n            foreach ( var unit in Units )\n            {\n                UnitSectorsCalc(unit);\n            }\n\n            ShadowSectors = new ShadowSector[SectorCount.X, SectorCount.Y];\n            for ( Y = 0; Y <= SectorCount.Y - 1; Y++ )\n            {\n                for ( X = 0; X <= SectorCount.X - 1; X++ )\n                {\n                    ShadowSector_Create(new XYInt(X, Y));\n                }\n            }\n\n            SectorGraphicsChanges = new clsSectorChanges(this);\n            SectorGraphicsChanges.SetAllChanged();\n            SectorUnitHeightsChanges = new clsSectorChanges(this);\n            SectorTerrainUndoChanges = new clsSectorChanges(this);\n            AutoTextureChanges = new clsAutoTextureChanges(this);\n            TerrainInterpretChanges = new clsTerrainUpdate(Terrain.TileSize);\n\n            UnitChanges = new ObservableCollection<UnitChange>();\n            GatewayChanges = new ObservableCollection<GatewayChange>();\n            \n            Undos = new ObservableCollection<Undo>();\n            UndoPosition = 0;\n\n            SelectedUnits = new ConnectedList<Unit, Map>(this);\n\n            _SelectedUnitGroup = new clsUnitGroupContainer();\n            SelectedUnitGroup.Item = ScavengerUnitGroup;\n\n            Messages = new ObservableCollection<Message>();\n        }\n\n        public void Update(MinimapGl minimapGl)\n        {\n            var lastSuppress = minimapGl?.Suppress ?? false;\n\n            if ( minimapGl != null )\n            {\n                minimapGl.Suppress = true;\n            }\n\n            UpdateAutoTextures();\n            TerrainInterpretUpdate();\n            SectorsUpdateGraphics();\n            SectorsUpdateUnitHeights();\n\n            if( minimapGl != null )\n            {\n                minimapGl.Suppress = lastSuppress;\n                minimapGl.Refresh = true;\n            }\n        }\n\n        public void SectorsUpdateUnitHeights()\n        {\n            var UpdateSectorUnitHeights = new clsUpdateSectorUnitHeights();\n            UpdateSectorUnitHeights.Map = this;\n\n            UpdateSectorUnitHeights.Start();\n            SectorUnitHeightsChanges.PerformTool(UpdateSectorUnitHeights);\n            UpdateSectorUnitHeights.Finish();\n            SectorUnitHeightsChanges.Clear();\n        }\n\n        public void SectorsUpdateGraphics()\n        {\n            var UpdateSectorGraphics = new clsUpdateSectorGraphics();\n            UpdateSectorGraphics.Map = this;\n\n            if (IsMainMap)\n            {\n                SectorGraphicsChanges.PerformTool(UpdateSectorGraphics);\n            }\n            SectorGraphicsChanges.Clear();\n        }\n\n        public void UpdateAutoTextures()\n        {\n            var UpdateAutotextures = new clsUpdateAutotexture();\n            UpdateAutotextures.Map = this;\n            //TODO: Change to UiOptions\n            //UpdateAutotextures.MakeInvalidTiles = Program.frmMainInstance.cbxInvalidTiles.Checked;\n\n            AutoTextureChanges.PerformTool(UpdateAutotextures);\n            AutoTextureChanges.Clear();\n        }\n\n        public void TerrainInterpretUpdate()\n        {\n            var ApplyVertexInterpret = new clsApplyVertexTerrainInterpret();\n            var ApplyTileInterpret = new clsApplyTileTerrainInterpret();\n            var ApplySideHInterpret = new clsApplySideHTerrainInterpret();\n            var ApplySideVInterpret = new clsApplySideVTerrainInterpret();\n            ApplyVertexInterpret.Map = this;\n            ApplyTileInterpret.Map = this;\n            ApplySideHInterpret.Map = this;\n            ApplySideVInterpret.Map = this;\n\n            TerrainInterpretChanges.Vertices.PerformTool(ApplyVertexInterpret);\n            TerrainInterpretChanges.Tiles.PerformTool(ApplyTileInterpret);\n            TerrainInterpretChanges.SidesH.PerformTool(ApplySideHInterpret);\n            TerrainInterpretChanges.SidesV.PerformTool(ApplySideVInterpret);\n            TerrainInterpretChanges.ClearAll();\n        }\n\n        public void TileNeedsInterpreting(XYInt Pos)\n        {\n            TerrainInterpretChanges.Tiles.Changed(Pos);\n            TerrainInterpretChanges.Vertices.Changed(new XYInt(Pos.X, Pos.Y));\n            TerrainInterpretChanges.Vertices.Changed(new XYInt(Pos.X + 1, Pos.Y));\n            TerrainInterpretChanges.Vertices.Changed(new XYInt(Pos.X, Pos.Y + 1));\n            TerrainInterpretChanges.Vertices.Changed(new XYInt(Pos.X + 1, Pos.Y + 1));\n            TerrainInterpretChanges.SidesH.Changed(new XYInt(Pos.X, Pos.Y));\n            TerrainInterpretChanges.SidesH.Changed(new XYInt(Pos.X, Pos.Y + 1));\n            TerrainInterpretChanges.SidesV.Changed(new XYInt(Pos.X, Pos.Y));\n            TerrainInterpretChanges.SidesV.Changed(new XYInt(Pos.X + 1, Pos.Y));\n        }\n\n        public void TileTextureChangeTerrainAction(XYInt Pos, TerrainMode Action)\n        {\n            switch ( Action )\n            {\n            case TerrainMode.Ignore:\n                break;\n\n            case TerrainMode.Reinterpret:\n                TileNeedsInterpreting(Pos);\n                break;\n            case TerrainMode.Remove:\n                Terrain.Vertices[Pos.X, Pos.Y].Terrain = null;\n                Terrain.Vertices[Pos.X + 1, Pos.Y].Terrain = null;\n                Terrain.Vertices[Pos.X, Pos.Y + 1].Terrain = null;\n                Terrain.Vertices[Pos.X + 1, Pos.Y + 1].Terrain = null;\n                break;\n            }\n        }\n\n        public string GetTitle()\n        {\n            var ReturnResult = \"\";\n\n            if ( PathInfo == null )\n            {\n                ReturnResult = \"Unsaved map\";\n            }\n            else\n            {\n                var SplitPath = new sSplitPath(PathInfo.Path);\n                if ( PathInfo.IsFMap )\n                {\n                    ReturnResult = SplitPath.FileTitleWithoutExtension;\n                }\n                else\n                {\n                    ReturnResult = SplitPath.FileTitle;\n                }\n            }\n            return ReturnResult;\n        }\n\n        public void SetChanged()\n        {\n            ChangedSinceSave = true;\n            if ( changedEvent != null )\n                changedEvent();\n\n            AutoSave.ChangeCount++;\n            AutoSaveTest();\n        }\n\n        public void SetTabText()\n        {\n            const int MaxLength = 24;\n\n            var result = \"\";\n            result = GetTitle();\n            if ( result.Length > MaxLength )\n            {\n                result = result.Substring(0, MaxLength - 3) + \"...\";\n            }\n        }\n\n        public bool SideHIsCliffOnBothSides(XYInt SideNum)\n        {\n            var TileNum = new XYInt();\n\n            if ( SideNum.Y > 0 )\n            {\n                TileNum.X = SideNum.X;\n                TileNum.Y = SideNum.Y - 1;\n                if ( Terrain.Tiles[TileNum.X, TileNum.Y].Tri )\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriBottomRightIsCliff )\n                    {\n                        return false;\n                    }\n                }\n                else\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriBottomLeftIsCliff )\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            if ( SideNum.Y < Terrain.TileSize.Y )\n            {\n                TileNum.X = SideNum.X;\n                TileNum.Y = SideNum.Y;\n                if ( Terrain.Tiles[TileNum.X, TileNum.Y].Tri )\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriTopLeftIsCliff )\n                    {\n                        return false;\n                    }\n                }\n                else\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriTopRightIsCliff )\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        public bool SideVIsCliffOnBothSides(XYInt SideNum)\n        {\n            var TileNum = new XYInt();\n\n            if ( SideNum.X > 0 )\n            {\n                TileNum.X = SideNum.X - 1;\n                TileNum.Y = SideNum.Y;\n                if ( Terrain.Tiles[TileNum.X, TileNum.Y].Tri )\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriBottomRightIsCliff )\n                    {\n                        return false;\n                    }\n                }\n                else\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriTopRightIsCliff )\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            if ( SideNum.X < Terrain.TileSize.X )\n            {\n                TileNum.X = SideNum.X;\n                TileNum.Y = SideNum.Y;\n                if ( Terrain.Tiles[TileNum.X, TileNum.Y].Tri )\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriTopLeftIsCliff )\n                    {\n                        return false;\n                    }\n                }\n                else\n                {\n                    if ( !Terrain.Tiles[TileNum.X, TileNum.Y].TriBottomLeftIsCliff )\n                    {\n                        return false;\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        public bool VertexIsCliffEdge(XYInt VertexNum)\n        {\n            var TileNum = new XYInt();\n\n            if ( VertexNum.X > 0 )\n            {\n                if ( VertexNum.Y > 0 )\n                {\n                    TileNum.X = VertexNum.X - 1;\n                    TileNum.Y = VertexNum.Y - 1;\n                    if ( Terrain.Tiles[TileNum.X, TileNum.Y].Terrain_IsCliff )\n                    {\n                        return true;\n                    }\n                }\n                if ( VertexNum.Y < Terrain.TileSize.Y )\n                {\n                    TileNum.X = VertexNum.X - 1;\n                    TileNum.Y = VertexNum.Y;\n                    if ( Terrain.Tiles[TileNum.X, TileNum.Y].Terrain_IsCliff )\n                    {\n                        return true;\n                    }\n                }\n            }\n            if ( VertexNum.X < Terrain.TileSize.X )\n            {\n                if ( VertexNum.Y > 0 )\n                {\n                    TileNum.X = VertexNum.X;\n                    TileNum.Y = VertexNum.Y - 1;\n                    if ( Terrain.Tiles[TileNum.X, TileNum.Y].Terrain_IsCliff )\n                    {\n                        return true;\n                    }\n                }\n                if ( VertexNum.Y < Terrain.TileSize.Y )\n                {\n                    TileNum.X = VertexNum.X;\n                    TileNum.Y = VertexNum.Y;\n                    if ( Terrain.Tiles[TileNum.X, TileNum.Y].Terrain_IsCliff )\n                    {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\n        public void SelectedUnitsAction(clsObjectAction Tool)\n        {\n            var SelectAction = new clsObjectSelect();\n\n            SelectedUnits.CopyList().PerformTool(Tool);\n            SelectedUnits.Clear();\n            Tool.ResultUnits.PerformTool(SelectAction);\n        }\n\n        public bool CheckMessages()\n        {\n            var A = 0;\n            var DateNow = DateTime.Now;\n            var Changed = false;\n\n            while ( A < Messages.Count )\n            {\n                var timeDiff = DateTime.Now - Convert.ToDateTime(Messages[A].CreatedDate);\n                if ( timeDiff.TotalSeconds >= 6 )\n                {\n                    Messages.RemoveAt(A);\n                    Changed = true;\n                }\n                else\n                {\n                    A++;\n                }\n            }\n            return Changed;\n        }\n\n        public void PerformTileWall(clsWallType WallType, XYInt TileNum, bool Expand)\n        {\n            var SectorNum = new XYInt();\n            var Unit = default(Unit);\n            var UnitTile = new XYInt();\n            var Difference = new XYInt();\n            var TileWalls = Util.TileWalls.None;\n            var Walls = new ObservableCollection<Unit>();\n            var Removals = new ObservableCollection<Unit>();\n            var unitTypeBase = default(UnitTypeBase);\n            var structureTypeBase = default(StructureTypeBase);\n            var X = 0;\n            var Y = 0;\n            var MinTile = new XYInt();\n            var MaxTile = new XYInt();\n            var Connection = default(UnitSectorConnection);\n            MinTile.X = TileNum.X - 1;\n            MinTile.Y = TileNum.Y - 1;\n            MaxTile.X = TileNum.X + 1;\n            MaxTile.Y = TileNum.Y + 1;\n            var SectorStart = GetSectorNumClamped(GetTileSectorNum(MinTile));\n            var SectorFinish = GetSectorNumClamped(GetTileSectorNum(MaxTile));\n\n            for ( Y = SectorStart.Y; Y <= SectorFinish.Y; Y++ )\n            {\n                for ( X = SectorStart.X; X <= SectorFinish.X; X++ )\n                {\n                    SectorNum.X = X;\n                    SectorNum.Y = Y;\n                    foreach ( var tempLoopVar_Connection in Sectors[SectorNum.X, SectorNum.Y].Units )\n                    {\n                        Connection = tempLoopVar_Connection;\n                        Unit = Connection.Unit;\n                        unitTypeBase = Unit.TypeBase;\n                        if ( unitTypeBase.Type == UnitType.PlayerStructure )\n                        {\n                            structureTypeBase = (StructureTypeBase)unitTypeBase;\n                            if ( structureTypeBase.WallLink.Owner == WallType )\n                            {\n                                UnitTile = GetPosTileNum(Unit.Pos.Horizontal);\n                                Difference.X = UnitTile.X - TileNum.X;\n                                Difference.Y = UnitTile.Y - TileNum.Y;\n                                if ( Difference.Y == 1 )\n                                {\n                                    if ( Difference.X == 0 )\n                                    {\n                                        TileWalls = TileWalls | TileWalls.Bottom;\n                                        Walls.Add(Unit);\n                                    }\n                                }\n                                else if ( Difference.Y == 0 )\n                                {\n                                    if ( Difference.X == 0 )\n                                    {\n                                        Removals.Add(Unit);\n                                    }\n                                    else if ( Difference.X == -1 )\n                                    {\n                                        TileWalls = TileWalls | TileWalls.Left;\n                                        Walls.Add(Unit);\n                                    }\n                                    else if ( Difference.X == 1 )\n                                    {\n                                        TileWalls = TileWalls | TileWalls.Right;\n                                        Walls.Add(Unit);\n                                    }\n                                }\n                                else if ( Difference.Y == -1 )\n                                {\n                                    if ( Difference.X == 0 )\n                                    {\n                                        TileWalls = TileWalls | TileWalls.Top;\n                                        Walls.Add(Unit);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            foreach ( var tempLoopVar_Unit in Removals )\n            {\n                Unit = tempLoopVar_Unit;\n                UnitRemoveStoreChange(Unit.MapLink.Position);\n            }\n\n            var NewUnit = new Unit();\n            UnitTypeBase newUnitTypeBase = WallType.Segments[WallType.TileWalls_Segment[(int)TileWalls]];\n            NewUnit.Rotation = WallType.TileWalls_Direction[(int)TileWalls];\n            if ( Expand )\n            {\n                NewUnit.UnitGroup = SelectedUnitGroup.Item;\n            }\n            else\n            {\n                if ( Removals.Count == 0 )\n                {\n                    Debugger.Break();\n                    return;\n                }\n                NewUnit.UnitGroup = Removals[0].UnitGroup;\n            }\n            NewUnit.Pos = TileAlignedPos(TileNum, new XYInt(1, 1));\n            NewUnit.TypeBase = newUnitTypeBase;\n            var UnitAdd = new clsUnitAdd();\n            UnitAdd.Map = this;\n            UnitAdd.NewUnit = NewUnit;\n            UnitAdd.StoreChange = true;\n            UnitAdd.Perform();\n\n            if ( Expand )\n            {\n                var Wall = default(Unit);\n                foreach ( var tempLoopVar_Wall in Walls )\n                {\n                    Wall = tempLoopVar_Wall;\n                    PerformTileWall(WallType, GetPosTileNum(Wall.Pos.Horizontal), false);\n                }\n            }\n        }\n\t\t\n        public bool ClosePrompt()\n        {\n            // TODO: Implement me.\n//            if ( ChangedSinceSave )\n//            {\n//                var Prompt = new frmClose(GetTitle());\n//                var Result = Prompt.ShowDialog(Program.frmMainInstance);\n//                switch ( Result )\n//                {\n//                    case DialogResult.OK:\n//                        return Save_FMap_Prompt();\n//                    case DialogResult.Yes:\n//                        return Save_FMap_Quick();\n//                    case DialogResult.No:\n//                        return true;\n//                    case DialogResult.Cancel:\n//                        return false;\n//                    default:\n//                        Debugger.Break();\n//                        return false;\n//                }\n//            }\n            return true;\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\t/// <remarks>A PGP signature object.</remarks>\n    public class PgpSignature\n    {\n        public const int BinaryDocument = 0x00;\n        public const int CanonicalTextDocument = 0x01;\n        public const int StandAlone = 0x02;\n\n        public const int DefaultCertification = 0x10;\n        public const int NoCertification = 0x11;\n        public const int CasualCertification = 0x12;\n        public const int PositiveCertification = 0x13;\n\n        public const int SubkeyBinding = 0x18;\n\t\tpublic const int PrimaryKeyBinding = 0x19;\n\t\tpublic const int DirectKey = 0x1f;\n        public const int KeyRevocation = 0x20;\n        public const int SubkeyRevocation = 0x28;\n        public const int CertificationRevocation = 0x30;\n        public const int Timestamp = 0x40;\n\n        private readonly SignaturePacket\tsigPck;\n        private readonly int\t\t\t\tsignatureType;\n        private readonly TrustPacket\t\ttrustPck;\n\n\t\tprivate ISigner\tsig;\n\t\tprivate byte\tlastb; // Initial value anything but '\\r'\n\n\t\tinternal PgpSignature(\n            BcpgInputStream bcpgInput)\n            : this((SignaturePacket)bcpgInput.ReadPacket())\n        {\n        }\n\n\t\tinternal PgpSignature(\n            SignaturePacket sigPacket)\n\t\t\t: this(sigPacket, null)\n        {\n        }\n\n        internal PgpSignature(\n            SignaturePacket\tsigPacket,\n            TrustPacket\t\ttrustPacket)\n        {\n\t\t\tif (sigPacket == null)\n\t\t\t\tthrow new ArgumentNullException(\"sigPacket\");\n\n\t\t\tthis.sigPck = sigPacket;\n\t\t\tthis.signatureType = sigPck.SignatureType;\n\t\t\tthis.trustPck = trustPacket;\n        }\n\n\t\tprivate void GetSig()\n        {\n            this.sig = SignerUtilities.GetSigner(\n\t\t\t\tPgpUtilities.GetSignatureName(sigPck.KeyAlgorithm, sigPck.HashAlgorithm));\n        }\n\n\t\t/// <summary>The OpenPGP version number for this signature.</summary>\n\t\tpublic int Version\n\t\t{\n\t\t\tget { return sigPck.Version; }\n\t\t}\n\n\t\t/// <summary>The key algorithm associated with this signature.</summary>\n\t\tpublic PublicKeyAlgorithmTag KeyAlgorithm\n\t\t{\n\t\t\tget { return sigPck.KeyAlgorithm; }\n\t\t}\n\n\t\t/// <summary>The hash algorithm associated with this signature.</summary>\n\t\tpublic HashAlgorithmTag HashAlgorithm\n\t\t{\n\t\t\tget { return sigPck.HashAlgorithm; }\n\t\t}\n\n        /// <summary>Return true if this signature represents a certification.</summary>\n        public bool IsCertification()\n        {\n            return IsCertification(SignatureType);\n        }\n\n\t\tpublic void InitVerify(\n            PgpPublicKey pubKey)\n        {\n\t\t\tlastb = 0;\n            if (sig == null)\n            {\n                GetSig();\n            }\n            try\n            {\n                sig.Init(false, pubKey.GetKey());\n            }\n            catch (InvalidKeyException e)\n            {\n                throw new PgpException(\"invalid key.\", e);\n            }\n        }\n\n        public void Update(\n            byte b)\n        {\n            if (signatureType == CanonicalTextDocument)\n            {\n\t\t\t\tdoCanonicalUpdateByte(b);\n            }\n            else\n            {\n                sig.Update(b);\n            }\n        }\n\n\t\tprivate void doCanonicalUpdateByte(\n\t\t\tbyte b)\n\t\t{\n\t\t\tif (b == '\\r')\n\t\t\t{\n\t\t\t\tdoUpdateCRLF();\n\t\t\t}\n\t\t\telse if (b == '\\n')\n\t\t\t{\n\t\t\t\tif (lastb != '\\r')\n\t\t\t\t{\n\t\t\t\t\tdoUpdateCRLF();\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsig.Update(b);\n\t\t\t}\n\n\t\t\tlastb = b;\n\t\t}\n\n\t\tprivate void doUpdateCRLF()\n\t\t{\n\t\t\tsig.Update((byte)'\\r');\n\t\t\tsig.Update((byte)'\\n');\n\t\t}\n\n\t\tpublic void Update(\n            params byte[] bytes)\n        {\n\t\t\tUpdate(bytes, 0, bytes.Length);\n        }\n\n\t\tpublic void Update(\n            byte[]\tbytes,\n            int\t\toff,\n            int\t\tlength)\n        {\n            if (signatureType == CanonicalTextDocument)\n            {\n                int finish = off + length;\n\n\t\t\t\tfor (int i = off; i != finish; i++)\n                {\n                    doCanonicalUpdateByte(bytes[i]);\n                }\n            }\n            else\n            {\n                sig.BlockUpdate(bytes, off, length);\n            }\n        }\n\n\t\tpublic bool Verify()\n        {\n            byte[] trailer = GetSignatureTrailer();\n            sig.BlockUpdate(trailer, 0, trailer.Length);\n\n\t\t\treturn sig.VerifySignature(GetSignature());\n        }\n\n\t\tprivate void UpdateWithIdData(\n\t\t\tint\t\theader,\n\t\t\tbyte[]\tidBytes)\n\t\t{\n\t\t\tthis.Update(\n\t\t\t\t(byte) header,\n\t\t\t\t(byte)(idBytes.Length >> 24),\n\t\t\t\t(byte)(idBytes.Length >> 16),\n\t\t\t\t(byte)(idBytes.Length >> 8),\n\t\t\t\t(byte)(idBytes.Length));\n\t\t\tthis.Update(idBytes);\n\t\t}\n\n\t\tprivate void UpdateWithPublicKey(\n\t\t\tPgpPublicKey key)\n\t\t{\n\t\t\tbyte[] keyBytes = GetEncodedPublicKey(key);\n\n\t\t\tthis.Update(\n\t\t\t\t(byte) 0x99,\n\t\t\t\t(byte)(keyBytes.Length >> 8),\n\t\t\t\t(byte)(keyBytes.Length));\n\t\t\tthis.Update(keyBytes);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Verify the signature as certifying the passed in public key as associated\n\t\t/// with the passed in user attributes.\n\t\t/// </summary>\n\t\t/// <param name=\"userAttributes\">User attributes the key was stored under.</param>\n\t\t/// <param name=\"key\">The key to be verified.</param>\n\t\t/// <returns>True, if the signature matches, false otherwise.</returns>\n\t\tpublic bool VerifyCertification(\n\t\t\tPgpUserAttributeSubpacketVector\tuserAttributes,\n\t\t\tPgpPublicKey\t\t\t\t\tkey)\n\t\t{\n\t\t\tUpdateWithPublicKey(key);\n\n\t\t\t//\n\t\t\t// hash in the userAttributes\n\t\t\t//\n\t\t\ttry\n\t\t\t{\n\t\t\t\tMemoryStream bOut = new MemoryStream();\n\t\t\t\tforeach (UserAttributeSubpacket packet in userAttributes.ToSubpacketArray())\n\t\t\t\t{\n\t\t\t\t\tpacket.Encode(bOut);\n\t\t\t\t}\n\t\t\t\tUpdateWithIdData(0xd1, bOut.ToArray());\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new PgpException(\"cannot encode subpacket array\", e);\n\t\t\t}\n\n\t\t\tthis.Update(sigPck.GetSignatureTrailer());\n\n\t\t\treturn sig.VerifySignature(this.GetSignature());\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Verify the signature as certifying the passed in public key as associated\n\t\t/// with the passed in ID.\n\t\t/// </summary>\n\t\t/// <param name=\"id\">ID the key was stored under.</param>\n\t\t/// <param name=\"key\">The key to be verified.</param>\n\t\t/// <returns>True, if the signature matches, false otherwise.</returns>\n        public bool VerifyCertification(\n            string\t\t\tid,\n            PgpPublicKey\tkey)\n        {\n\t\t\tUpdateWithPublicKey(key);\n\n\t\t\t//\n            // hash in the id\n            //\n            UpdateWithIdData(0xb4, Strings.ToUtf8ByteArray(id));\n\n\t\t\tUpdate(sigPck.GetSignatureTrailer());\n\n\t\t\treturn sig.VerifySignature(GetSignature());\n        }\n\n\t\t/// <summary>Verify a certification for the passed in key against the passed in master key.</summary>\n\t\t/// <param name=\"masterKey\">The key we are verifying against.</param>\n\t\t/// <param name=\"pubKey\">The key we are verifying.</param>\n\t\t/// <returns>True, if the certification is valid, false otherwise.</returns>\n        public bool VerifyCertification(\n            PgpPublicKey\tmasterKey,\n            PgpPublicKey\tpubKey)\n        {\n\t\t\tUpdateWithPublicKey(masterKey);\n\t\t\tUpdateWithPublicKey(pubKey);\n\n\t\t\tUpdate(sigPck.GetSignatureTrailer());\n\n\t\t\treturn sig.VerifySignature(GetSignature());\n        }\n\n\t\t/// <summary>Verify a key certification, such as revocation, for the passed in key.</summary>\n\t\t/// <param name=\"pubKey\">The key we are checking.</param>\n\t\t/// <returns>True, if the certification is valid, false otherwise.</returns>\n        public bool VerifyCertification(\n            PgpPublicKey pubKey)\n        {\n            if (SignatureType != KeyRevocation\n                && SignatureType != SubkeyRevocation)\n            {\n                throw new InvalidOperationException(\"signature is not a key signature\");\n            }\n\n\t\t\tUpdateWithPublicKey(pubKey);\n\n            Update(sigPck.GetSignatureTrailer());\n\n\t\t\treturn sig.VerifySignature(GetSignature());\n        }\n\n\t\tpublic int SignatureType\n        {\n\t\t\tget { return sigPck.SignatureType; }\n        }\n\n\t\t/// <summary>The ID of the key that created the signature.</summary>\n        public long KeyId\n        {\n            get { return sigPck.KeyId; }\n        }\n\n\t\t[Obsolete(\"Use 'CreationTime' property instead\")]\n\t\tpublic DateTime GetCreationTime()\n\t\t{\n\t\t\treturn CreationTime;\n\t\t}\n\n\t\t/// <summary>The creation time of this signature.</summary>\n        public DateTime CreationTime\n        {\n\t\t\tget { return DateTimeUtilities.UnixMsToDateTime(sigPck.CreationTime); }\n        }\n\n\t\tpublic byte[] GetSignatureTrailer()\n        {\n            return sigPck.GetSignatureTrailer();\n        }\n\n\t\t/// <summary>\n\t\t/// Return true if the signature has either hashed or unhashed subpackets.\n\t\t/// </summary>\n\t\tpublic bool HasSubpackets\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn sigPck.GetHashedSubPackets() != null\n\t\t\t\t\t|| sigPck.GetUnhashedSubPackets() != null;\n\t\t\t}\n\t\t}\n\n\t\tpublic PgpSignatureSubpacketVector GetHashedSubPackets()\n        {\n            return createSubpacketVector(sigPck.GetHashedSubPackets());\n        }\n\n\t\tpublic PgpSignatureSubpacketVector GetUnhashedSubPackets()\n        {\n            return createSubpacketVector(sigPck.GetUnhashedSubPackets());\n        }\n\n\t\tprivate PgpSignatureSubpacketVector createSubpacketVector(SignatureSubpacket[] pcks)\n\t\t{\n\t\t\treturn pcks == null ? null : new PgpSignatureSubpacketVector(pcks);\n\t\t}\n\n\t\tpublic byte[] GetSignature()\n        {\n            MPInteger[] sigValues = sigPck.GetSignature();\n            byte[] signature;\n\n\t\t\tif (sigValues != null)\n\t\t\t{\n\t\t\t\tif (sigValues.Length == 1)    // an RSA signature\n\t\t\t\t{\n\t\t\t\t\tsignature = sigValues[0].Value.ToByteArrayUnsigned();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\t\tsignature = new DerSequence(\n\t\t\t\t\t\t\tnew DerInteger(sigValues[0].Value),\n\t\t\t\t\t\t\tnew DerInteger(sigValues[1].Value)).GetEncoded();\n\t\t\t\t\t}\n\t\t\t\t\tcatch (IOException e)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new PgpException(\"exception encoding DSA sig.\", e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsignature = sigPck.GetSignatureBytes();\n\t\t\t}\n\n\t\t\treturn signature;\n        }\n\n\t\t// TODO Handle the encoding stuff by subclassing BcpgObject?\n\t\tpublic byte[] GetEncoded()\n        {\n            MemoryStream bOut = new MemoryStream();\n\n\t\t\tEncode(bOut);\n\n\t\t\treturn bOut.ToArray();\n        }\n\n\t\tpublic void Encode(\n            Stream outStream)\n        {\n            BcpgOutputStream bcpgOut = BcpgOutputStream.Wrap(outStream);\n\n\t\t\tbcpgOut.WritePacket(sigPck);\n\n\t\t\tif (trustPck != null)\n            {\n                bcpgOut.WritePacket(trustPck);\n            }\n        }\n\n\t\tprivate byte[] GetEncodedPublicKey(\n\t\t\tPgpPublicKey pubKey) \n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn pubKey.publicPk.GetEncodedContents();\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new PgpException(\"exception preparing key.\", e);\n\t\t\t}\n\t\t}\n\n        /// <summary>\n        /// Return true if the passed in signature type represents a certification, false if the signature type is not.\n        /// </summary>\n        /// <param name=\"signatureType\"></param>\n        /// <returns>true if signatureType is a certification, false otherwise.</returns>\n        public static bool IsCertification(int signatureType)\n        {\n            switch (signatureType)\n            {\n                case DefaultCertification:\n                case NoCertification:\n                case CasualCertification:\n                case PositiveCertification:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Interaction logic for MultipleCameraWnd.xaml\n    /// </summary>\n    public partial class MultipleCameraWnd : IWindow\n    {\n        public bool DisbleAutofocus { get; set; }\n        public int DelaySec { get; set; }\n        public int WaitSec { get; set; }\n        public int NumOfPhotos { get; set; }\n        ProgressWindow dlg = new ProgressWindow();\n\n        private System.Timers.Timer _timer = new System.Timers.Timer(1000);\n        private int _secounter = 0;\n        private int _photocounter = 0;\n\n        public bool UseExternal { get; set; }\n\n        public CustomConfig SelectedConfig { get; set; }\n\n        public MultipleCameraWnd()\n        {\n            NumOfPhotos = 1;\n\n            InitializeComponent();\n            _timer.Elapsed += new ElapsedEventHandler(_timer_Elapsed);\n        }\n\n        private void _timer_Elapsed(object sender, ElapsedEventArgs e)\n        {\n            _secounter++;\n            if (_secounter > WaitSec)\n            {\n                _secounter = 0;\n                _timer.Stop();\n                CapturePhotos();\n            }\n            else\n            {\n                StaticHelper.Instance.SystemMessage = string.Format(\"Waiting {0})\", _secounter);\n            }\n        }\n\n        #region Implementation of IWindow\n\n        public void ExecuteCommand(string cmd, object param)\n        {\n            switch (cmd)\n            {\n                case WindowsCmdConsts.MultipleCamera_Start:\n                    Dispatcher.Invoke(() => btn_shot_Click(null, null));\n                    break;\n                case WindowsCmdConsts.MultipleCamera_Stop:\n                    Dispatcher.Invoke(() => btn_stop_Click(null, null));\n                    break;\n                case WindowsCmdConsts.MultipleCamera_Reset:\n                    Dispatcher.Invoke(() => btn_resetCounters_Click(null, null));\n                    break;\n                case WindowsCmdConsts.MultipleCameraWnd_Show:\n                    Dispatcher.Invoke(new Action(delegate\n                                                     {\n                                                         Owner = ServiceProvider.PluginManager.SelectedWindow as Window;\n                                                         Show();\n                                                         Activate();\n                                                         Focus();\n                                                     }));\n                    break;\n                case WindowsCmdConsts.MultipleCameraWnd_Hide:\n                    Hide();\n                    break;\n                case CmdConsts.All_Close:\n                    Dispatcher.Invoke(new Action(delegate\n                                                     {\n                                                         Hide();\n                                                         Close();\n                                                     }));\n                    break;\n            }\n        }\n\n        #endregion\n\n        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)\n        {\n            if (IsVisible)\n            {\n                e.Cancel = true;\n                ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.MultipleCameraWnd_Hide);\n            }\n        }\n\n        private void btn_shot_Click(object sender, RoutedEventArgs e)\n        {\n            if (UseExternal)\n            {\n                try\n                {\n                    if (SelectedConfig != null)\n                        ServiceProvider.ExternalDeviceManager.AssertFocus(SelectedConfig);\n                }\n                catch (Exception exception)\n                {\n                    Log.Error(\"Error set focus\", exception);\n                    StaticHelper.Instance.SystemMessage = \"Error set focus\" + exception.Message;\n                }\n            }\n            _secounter = 0;\n            _photocounter = 0;\n            _timer.Start();\n        }\n\n        private void CapturePhotos()\n        {\n            _photocounter++;\n            StaticHelper.Instance.SystemMessage = string.Format(\"Capture started multiple cameras {0}\", _photocounter);\n            Thread thread = new Thread(new ThreadStart(delegate\n                                                           {\n                                                               while (CamerasAreBusy())\n                                                               {\n                                                               }\n                                                               try\n                                                               {\n                                                                   if (UseExternal)\n                                                                   {\n                                                                       if (SelectedConfig != null)\n                                                                       {\n                                                                           ServiceProvider.ExternalDeviceManager.\n                                                                               OpenShutter(SelectedConfig);\n                                                                           Thread.Sleep(300);\n                                                                           ServiceProvider.ExternalDeviceManager.\n                                                                               CloseShutter(SelectedConfig);\n                                                                       }\n                                                                   }\n                                                                   else\n                                                                   {\n                                                                       CameraHelper.CaptureAll(DelaySec);\n                                                                   }\n                                                               }\n                                                               catch (Exception exception)\n                                                               {\n                                                                   Log.Error(exception);\n                                                               }\n\n                                                               Thread.Sleep(DelaySec);\n                                                               if (_photocounter < NumOfPhotos)\n                                                                   _timer.Start();\n                                                               else\n                                                               {\n                                                                   StopCapture();\n                                                               }\n                                                           }));\n            thread.Start();\n        }\n\n\n        private bool CamerasAreBusy()\n        {\n            return ServiceProvider.DeviceManager.ConnectedDevices.Aggregate(false,\n                                                                            (current, connectedDevice) =>\n                                                                            connectedDevice.IsBusy || current);\n        }\n\n        private void btn_stop_Click(object sender, RoutedEventArgs e)\n        {\n            _timer.Stop();\n            _photocounter = NumOfPhotos;\n            StopCapture();\n        }\n\n        private void StopCapture()\n        {\n            if (UseExternal && SelectedConfig != null)\n            {\n                ServiceProvider.ExternalDeviceManager.CloseShutter(SelectedConfig);\n                ServiceProvider.ExternalDeviceManager.DeassertFocus(SelectedConfig);\n            }\n            StaticHelper.Instance.SystemMessage = \"All captures done !\";\n        }\n\n        private void MenuItem_Click(object sender, RoutedEventArgs e)\n        {\n            //if (listBox1.SelectedItem != null)\n            //    ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.CameraPropertyWnd_Show,\n            //                                                  listBox1.SelectedItem);\n        }\n\n        private void MenuItem_Click_1(object sender, RoutedEventArgs e)\n        {\n            //if (listBox1.SelectedItem != null)\n            //{\n            //    CameraPreset preset = new CameraPreset();\n            //    preset.Get((ICameraDevice) listBox1.SelectedItem);\n            //    foreach (ICameraDevice connectedDevice in ServiceProvider.DeviceManager.ConnectedDevices)\n            //    {\n            //        if (connectedDevice.IsConnected && connectedDevice.IsChecked)\n            //            preset.Set(connectedDevice);\n            //    }\n            //}\n        }\n\n        private void btn_help_Click(object sender, RoutedEventArgs e)\n        {\n            HelpProvider.Run(HelpSections.MultipleCamera);\n        }\n\n        private void btn_resetCounters_Click(object sender, RoutedEventArgs e)\n        {\n            foreach (ICameraDevice connectedDevice in ServiceProvider.DeviceManager.ConnectedDevices)\n            {\n                CameraProperty property = ServiceProvider.Settings.CameraProperties.Get(connectedDevice);\n                property.Counter = 0;\n            }\n        }\n\n        private void btn_set_counter_Click(object sender, RoutedEventArgs e)\n        {\n            int counter = 0;\n            if (int.TryParse(txt_counter.Text, out counter))\n            {\n                foreach (ICameraDevice connectedDevice in ServiceProvider.DeviceManager.ConnectedDevices)\n                {\n                    CameraProperty property = ServiceProvider.Settings.CameraProperties.Get(connectedDevice);\n                    property.Counter = counter;\n                }\n            }\n        }\n\n        private void btn_focus_Click(object sender, RoutedEventArgs e)\n        {\n            if (SelectedConfig != null)\n                ServiceProvider.ExternalDeviceManager.Focus(SelectedConfig);\n        }\n\n        private void btn_capture_Click(object sender, RoutedEventArgs e)\n        {\n            if (SelectedConfig != null)\n                ServiceProvider.ExternalDeviceManager.Capture(SelectedConfig);\n        }\n\n        private void btn_liveview_Click(object sender, RoutedEventArgs e)\n        {\n            ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.MultipleLiveViewWnd_Show);\n            ServiceProvider.WindowsManager.ExecuteCommand(WindowsCmdConsts.MultipleLiveViewWnd_Maximize);\n        }\n\n        private void chk_noautofocus_Checked(object sender, RoutedEventArgs e)\n        {\n            this.ShowMessageAsync(\"Warning\", \"This feature not working reliable \");\n        }\n\n        private void btn_saveOrder_Click(object sender, RoutedEventArgs e)\n        {\n            for (int i = 0; i < ServiceProvider.DeviceManager.ConnectedDevices.Count; i++)\n            {\n                ServiceProvider.DeviceManager.ConnectedDevices[i].LoadProperties().SortOrder = i;\n            }\n            ServiceProvider.Settings.Save();\n        }\n\n        private void btn_format_Click(object sender, RoutedEventArgs e)\n        {\n            if (MessageBox.Show(TranslationStrings.LabelAskForDelete, \"\", MessageBoxButtons.YesNo) !=\n                System.Windows.Forms.DialogResult.Yes)\n                return;\n            dlg.Show();\n            Thread thread = new Thread(Format);\n            thread.Start();\n            Log.Debug(\"Start format multiple cameras\");\n            //thread.Join();\n        }\n\n        private void Format()\n        {\n            //Dispatcher.Invoke(new Action(dlg.Show));\n            for (int i = 0; i < ServiceProvider.DeviceManager.ConnectedDevices.Count; i++)\n            {\n                ICameraDevice device = ServiceProvider.DeviceManager.ConnectedDevices[i];\n                if (!device.IsChecked)\n                    continue;\n                dlg.Label = device.DisplayName;\n                dlg.Progress = i;\n                Thread thread = new Thread(() => FormatCard(device));\n                thread.Start();\n                thread.Join(5 * 1000);\n            }\n            Dispatcher.Invoke(new Action(dlg.Hide));\n           \n        }\n\n        private void FormatCard(ICameraDevice connectedDevice)\n        {\n            try\n            {\n                connectedDevice.IsBusy = true;\n                Log.Debug(\"Start format\");\n                Log.Debug(connectedDevice.PortName);\n                connectedDevice.FormatStorage(null);\n                Thread.Sleep(200);\n                Log.Debug(\"Format done\");\n                connectedDevice.IsBusy = false;\n            }\n            catch (Exception exception)\n            {\n                Log.Error(\"Unable to format device \", exception);\n            }\n        }\n\n        private void MetroWindow_PreviewKeyDown(object sender, System.Windows.Input.KeyEventArgs e)\n        {\n            TriggerClass.KeyDown(e);\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\n    internal static class WriteDictionary<TSerializer>\n        where TSerializer : ITypeSerializer\n    {\n        private static readonly ITypeSerializer Serializer = JsWriter.GetTypeSerializer<TSerializer>();\n\n        internal class MapKey\n        {\n            internal Type KeyType;\n            internal Type ValueType;\n\n            public MapKey(Type keyType, Type valueType)\n            {\n                KeyType = keyType;\n                ValueType = valueType;\n            }\n\n            public bool Equals(MapKey other)\n            {\n                if (ReferenceEquals(null, other)) return false;\n                if (ReferenceEquals(this, other)) return true;\n                return Equals(other.KeyType, KeyType) && Equals(other.ValueType, ValueType);\n            }\n\n            public override bool Equals(object obj)\n            {\n                if (ReferenceEquals(null, obj)) return false;\n                if (ReferenceEquals(this, obj)) return true;\n                if (obj.GetType() != typeof(MapKey)) return false;\n                return Equals((MapKey)obj);\n            }\n\n            public override int GetHashCode()\n            {\n                unchecked\n                {\n                    return ((KeyType != null ? KeyType.GetHashCode() : 0) * 397) ^ (ValueType != null ? ValueType.GetHashCode() : 0);\n                }\n            }\n        }\n\n        static Dictionary<MapKey, WriteMapDelegate> CacheFns = new Dictionary<MapKey, WriteMapDelegate>();\n\n        public static Action<TextWriter, object, WriteObjectDelegate, WriteObjectDelegate>\n            GetWriteGenericDictionary(Type keyType, Type valueType)\n        {\n            WriteMapDelegate writeFn;\n            var mapKey = new MapKey(keyType, valueType);\n            if (CacheFns.TryGetValue(mapKey, out writeFn)) return writeFn.Invoke;\n\n            var genericType = typeof(ToStringDictionaryMethods<,,>).MakeGenericType(keyType, valueType, typeof(TSerializer));\n            var mi = genericType.GetPublicStaticMethod(\"WriteIDictionary\");\n            writeFn = (WriteMapDelegate)mi.MakeDelegate(typeof(WriteMapDelegate));\n\n            Dictionary<MapKey, WriteMapDelegate> snapshot, newCache;\n            do\n            {\n                snapshot = CacheFns;\n                newCache = new Dictionary<MapKey, WriteMapDelegate>(CacheFns);\n                newCache[mapKey] = writeFn;\n\n            } while (!ReferenceEquals(\n                Interlocked.CompareExchange(ref CacheFns, newCache, snapshot), snapshot));\n\n            return writeFn.Invoke;\n        }\n\n        public static void WriteIDictionary(TextWriter writer, object oMap)\n        {\n            WriteObjectDelegate writeKeyFn = null;\n            WriteObjectDelegate writeValueFn = null;\n\n            writer.Write(JsWriter.MapStartChar);\n            var encodeMapKey = false;\n            Type lastKeyType = null;\n            Type lastValueType = null;\n\n            var map = (IDictionary)oMap;\n            var ranOnce = false;\n            foreach (var key in map.Keys)\n            {\n                var dictionaryValue = map[key];\n\n                var isNull = (dictionaryValue == null);\n                if (isNull && !Serializer.IncludeNullValues) continue;\n\n                var keyType = key.GetType();\n                if (writeKeyFn == null || lastKeyType != keyType)\n                {\n                    lastKeyType = keyType;\n                    writeKeyFn = Serializer.GetWriteFn(keyType);\n                    encodeMapKey = Serializer.GetTypeInfo(keyType).EncodeMapKey;\n                }\n\n                JsWriter.WriteItemSeperatorIfRanOnce(writer, ref ranOnce);\n\n                JsState.WritingKeyCount++;\n                JsState.IsWritingValue = false;\n\n                if (encodeMapKey)\n                {\n                    JsState.IsWritingValue = true; //prevent \"\"null\"\"\n                    writer.Write(JsWriter.QuoteChar);\n                    writeKeyFn(writer, key);\n                    writer.Write(JsWriter.QuoteChar);\n                }\n                else\n                {\n                    writeKeyFn(writer, key);\n                }\n\n                JsState.WritingKeyCount--;\n\n                writer.Write(JsWriter.MapKeySeperator);\n\n                if (isNull)\n                {\n                    writer.Write(JsonUtils.Null);\n                }\n                else\n                {\n                    var valueType = dictionaryValue.GetType();\n                    if (writeValueFn == null || lastValueType != valueType)\n                    {\n                        lastValueType = valueType;\n                        writeValueFn = Serializer.GetWriteFn(valueType);\n                    }\n\n                    JsState.IsWritingValue = true;\n                    writeValueFn(writer, dictionaryValue);\n                    JsState.IsWritingValue = false;\n                }\n            }\n\n            writer.Write(JsWriter.MapEndChar);\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\tpublic class LogStructureWithInput\n\t{\n\t\tprivate readonly LogFlowStructure _flowStructure;\n\n\t\tinternal LogStructureWithInput(LogFlowStructure flowStructure)\n\t\t{\n\t\t\t_flowStructure = flowStructure;\n\t\t}\n\n\t\tpublic LogStructureWithInput Then(ILogProcessor processor)\n\t\t{\n\t\t\tprocessor.SetContext(_flowStructure.Context);\n\t\t\t_flowStructure.Processors.Add(processor);\n\t\t\treturn new LogStructureWithInput(_flowStructure);\n\t\t}\n\n\t\t[Obsolete(\"Use then method\")]\n\t\tpublic void ToOutput(ILogOutput output)\n\t\t{\n\t\t\toutput.SetContext(_flowStructure.Context);\n\t\t\t_flowStructure.Output = output;\n\t\t}\n\t}\n", "label": "FeatureEnvy"}
{"text": "\n\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public partial class reportContacts_args : TBase\n    {\n      private long _syncOpRevision;\n      private SyncCategory _category;\n      private List<ContactReport> _contactReports;\n      private SyncActionType _actionType;\n\n      public long SyncOpRevision\n      {\n        get\n        {\n          return _syncOpRevision;\n        }\n        set\n        {\n          __isset.syncOpRevision = true;\n          this._syncOpRevision = value;\n        }\n      }\n\n      /// <summary>\n      /// \n      /// <seealso cref=\"SyncCategory\"/>\n      /// </summary>\n      public SyncCategory Category\n      {\n        get\n        {\n          return _category;\n        }\n        set\n        {\n          __isset.category = true;\n          this._category = value;\n        }\n      }\n\n      public List<ContactReport> ContactReports\n      {\n        get\n        {\n          return _contactReports;\n        }\n        set\n        {\n          __isset.contactReports = true;\n          this._contactReports = value;\n        }\n      }\n\n      /// <summary>\n      /// \n      /// <seealso cref=\"SyncActionType\"/>\n      /// </summary>\n      public SyncActionType ActionType\n      {\n        get\n        {\n          return _actionType;\n        }\n        set\n        {\n          __isset.actionType = true;\n          this._actionType = value;\n        }\n      }\n\n\n      public Isset __isset;\n      #if !SILVERLIGHT\n      [Serializable]\n      #endif\n      public struct Isset {\n        public bool syncOpRevision;\n        public bool category;\n        public bool contactReports;\n        public bool actionType;\n      }\n\n      public reportContacts_args() {\n      }\n\n      public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 2:\n              if (field.Type == TType.I64) {\n                SyncOpRevision = iprot.ReadI64();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 3:\n              if (field.Type == TType.I32) {\n                Category = (SyncCategory)iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 4:\n              if (field.Type == TType.List) {\n                {\n                  ContactReports = new List<ContactReport>();\n                  TList _list360 = iprot.ReadListBegin();\n                  for( int _i361 = 0; _i361 < _list360.Count; ++_i361)\n                  {\n                    ContactReport _elem362 = new ContactReport();\n                    _elem362 = new ContactReport();\n                    _elem362.Read(iprot);\n                    ContactReports.Add(_elem362);\n                  }\n                  iprot.ReadListEnd();\n                }\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 5:\n              if (field.Type == TType.I32) {\n                ActionType = (SyncActionType)iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }\n\n      public void Write(TProtocol oprot) {\n        TStruct struc = new TStruct(\"reportContacts_args\");\n        oprot.WriteStructBegin(struc);\n        TField field = new TField();\n        if (__isset.syncOpRevision) {\n          field.Name = \"syncOpRevision\";\n          field.Type = TType.I64;\n          field.ID = 2;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI64(SyncOpRevision);\n          oprot.WriteFieldEnd();\n        }\n        if (__isset.category) {\n          field.Name = \"category\";\n          field.Type = TType.I32;\n          field.ID = 3;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32((int)Category);\n          oprot.WriteFieldEnd();\n        }\n        if (ContactReports != null && __isset.contactReports) {\n          field.Name = \"contactReports\";\n          field.Type = TType.List;\n          field.ID = 4;\n          oprot.WriteFieldBegin(field);\n          {\n            oprot.WriteListBegin(new TList(TType.Struct, ContactReports.Count));\n            foreach (ContactReport _iter363 in ContactReports)\n            {\n              _iter363.Write(oprot);\n            }\n            oprot.WriteListEnd();\n          }\n          oprot.WriteFieldEnd();\n        }\n        if (__isset.actionType) {\n          field.Name = \"actionType\";\n          field.Type = TType.I32;\n          field.ID = 5;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32((int)ActionType);\n          oprot.WriteFieldEnd();\n        }\n        oprot.WriteFieldStop();\n        oprot.WriteStructEnd();\n      }\n\n      public override string ToString() {\n        StringBuilder sb = new StringBuilder(\"reportContacts_args(\");\n        sb.Append(\"SyncOpRevision: \");\n        sb.Append(SyncOpRevision);\n        sb.Append(\",Category: \");\n        sb.Append(Category);\n        sb.Append(\",ContactReports: \");\n        sb.Append(ContactReports);\n        sb.Append(\",ActionType: \");\n        sb.Append(ActionType);\n        sb.Append(\")\");\n        return sb.ToString();\n      }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class Sample11_Logger\n    {\n        // UniRx.Diagnostics.Logger\n        // logger is threadsafe, define per class with name.\n\t\tstatic readonly UniRx.Diagnostics.Logger logger = new UniRx.Diagnostics.Logger(\"Sample11\");\n\n        // call once at applicationinit\n        public void ApplicationInitialize()\n        {\n            // Log as Stream, UniRx.Diagnostics.ObservableLogger.Listener is IObservable<LogEntry>\n            // You can subscribe and output to any place.\n            ObservableLogger.Listener.LogToUnityDebug();\n\n            // for example, filter only Exception and upload to web.\n            // (make custom sink(IObserver<EventEntry>) is better to use)\n            ObservableLogger.Listener\n                .Where(x => x.LogType == LogType.Exception)\n                .Subscribe(x =>\n                {\n                    // ObservableWWW.Post(\"\", null).Subscribe();\n                });\n        }\n\n        public void Run()\n        {\n            // Debug is write only DebugBuild.\n            logger.Debug(\"Debug Message\");\n\n            // or other logging methods\n            logger.Log(\"Message\");\n            logger.Exception(new Exception(\"test exception\"));\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class TransactionService : ITransactionService\n    {\n        private readonly ILocalhost localhost;\n        private readonly ITransfer transfer;\n        private readonly ISearchService searchService;\n\n        public TransactionService(ILocalhost localhost, ITransfer transfer, ISearchService searchService)\n        {\n            this.localhost = localhost;\n            this.transfer = transfer;\n            this.searchService = searchService;\n        }\n\n        public IList<Tuple<Entry, FhirResponse>> HandleTransaction(IList<Entry> interactions, IInteractionHandler interactionHandler)\n        {\n            if (interactionHandler == null)\n            {\n                throw new InvalidOperationException(\"Unable to run transaction operation\");\n            }\n\n            return HandleTransaction(interactions, interactionHandler, null);\n        }\n\n        public FhirResponse HandleTransaction(ResourceManipulationOperation operation, IInteractionHandler interactionHandler)\n        {\n            return HandleOperation(operation, interactionHandler);\n        }\n\n        public FhirResponse HandleOperation(ResourceManipulationOperation operation, IInteractionHandler interactionHandler, Mapper<string, IKey> mapper = null)\n        {\n            IList<Entry> interactions = operation.GetEntries().ToList();\n            if(mapper != null)\n            transfer.Internalize(interactions, mapper);\n\n            FhirResponse response = null;\n            foreach (Entry interaction in interactions)\n            {\n                response = MergeFhirResponse(response, interactionHandler.HandleInteraction(interaction));\n                if (!response.IsValid) throw new Exception();\n                interaction.Resource = response.Resource;\n            }\n\n            transfer.Externalize(interactions);\n\n            return response;\n        }\n\n        private FhirResponse MergeFhirResponse(FhirResponse previousResponse, FhirResponse response)\n        {\n            //CCR: How to handle responses?\n            //Currently we assume that all FhirResponses from one ResourceManipulationOperation should be equivalent - kind of hackish\n            if (previousResponse == null)\n                return response;\n            if (!response.IsValid)\n                return response;\n            if(response.StatusCode != previousResponse.StatusCode)\n                throw new Exception(\"Incompatible responses\");\n            if (response.Key != null && previousResponse.Key != null && response.Key.Equals(previousResponse.Key) == false)\n                throw new Exception(\"Incompatible responses\");\n            if((response.Key != null && previousResponse.Key== null) || (response.Key == null && previousResponse.Key != null))\n                throw new Exception(\"Incompatible responses\");\n            return response;\n        }\n\n        private void AddMappingsForOperation(Mapper<string, IKey> mapper, ResourceManipulationOperation operation, IList<Entry> interactions)\n        {\n            if(mapper == null)\n                return;\n            if (interactions.Count() == 1)\n            {\n                Entry entry = interactions.First();\n                if (!entry.Key.Equals(operation.OperationKey))\n                {\n                    if (localhost.GetKeyKind(operation.OperationKey) == KeyKind.Temporary)\n                    {\n                        mapper.Remap(operation.OperationKey.ResourceId, entry.Key.WithoutVersion());\n                    }\n                    else\n                    {\n                        mapper.Remap(operation.OperationKey.ToString(), entry.Key.WithoutVersion());\n                    }\n                }\n            }\n        }\n\n        public IList<Tuple<Entry, FhirResponse>> HandleTransaction(Bundle bundle, IInteractionHandler interactionHandler)\n        {\n            if (interactionHandler == null)\n            {\n                throw new InvalidOperationException(\"Unable to run transaction operation\");\n            }\n\n            var entries = new List<Entry>();\n            Mapper<string, IKey> mapper = new Mapper<string, IKey>();\n\n            foreach (var operation in bundle.Entry.Select(e => ResourceManipulationOperationFactory.GetManipulationOperation(e, localhost, searchService)))\n            {\n                IList<Entry> atomicOperations = operation.GetEntries().ToList();\n                AddMappingsForOperation(mapper, operation, atomicOperations);\n                entries.AddRange(atomicOperations);\n            }\n\n            return HandleTransaction(entries, interactionHandler, mapper);\n        }\n\n        private IList<Tuple<Entry, FhirResponse>> HandleTransaction(IList<Entry> interactions, IInteractionHandler interactionHandler, Mapper<string, IKey> mapper)\n        {\n            List<Tuple<Entry, FhirResponse>> responses = new List<Tuple<Entry, FhirResponse>>();\n\n            transfer.Internalize(interactions, mapper);\n\n            foreach (Entry interaction in interactions)\n            {\n                FhirResponse response = interactionHandler.HandleInteraction(interaction);\n                if (!response.IsValid) throw new Exception();\n                interaction.Resource = response.Resource;\n                response.Resource = null;\n\n                responses.Add(new Tuple<Entry, FhirResponse>(interaction, response)); //CCR: How to handle responses for transactions? \n                                                                                      //The specifications says only one response should be sent per EntryComponent, \n                                                                                      //but one EntryComponent might correpond to multiple atomic entries (Entry)\n                                                                                      //Example: conditional delete\n            }\n\n            transfer.Externalize(interactions);\n            return responses;\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public static class Types\n    {\n        private static java.util.Map jclass2type;\n\n        static Types()\n        {\n            jclass2type = java.util.Collections.synchronizedMap(new java.util.HashMap());\n        }\n\n        public static Type GetTypeForJavaClass(java.lang.Class jclass)\n        {\n            if (jclass2type.containsKey(jclass))\n                return (Type)jclass2type.get(jclass);\n\n            Type t = new InternalTypes.InternalType(jclass);\n            jclass2type.put(jclass, t);\n            return t;\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\t\tclass InvalidMDPhase : ProtectionPhase {\n\t\t\tRandomGenerator random;\n\n\t\t\tpublic InvalidMDPhase(InvalidMetadataProtection parent)\n\t\t\t\t: base(parent) { }\n\n\t\t\tpublic override ProtectionTargets Targets {\n\t\t\t\tget { return ProtectionTargets.Modules; }\n\t\t\t}\n\n\t\t\tpublic override string Name {\n\t\t\t\tget { return \"Invalid metadata addition\"; }\n\t\t\t}\n\n\t\t\tprotected override void Execute(ConfuserContext context, ProtectionParameters parameters) {\n\t\t\t\tif (parameters.Targets.Contains(context.CurrentModule)) {\n\t\t\t\t\trandom = context.Registry.GetService<IRandomService>().GetRandomGenerator(_FullId);\n\t\t\t\t\tcontext.CurrentModuleWriterListener.OnWriterEvent += OnWriterEvent;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid Randomize<T>(MDTable<T> table) where T : IRawRow {\n\t\t\t\tList<T> rows = table.ToList();\n\t\t\t\trandom.Shuffle(rows);\n\t\t\t\ttable.Reset();\n\t\t\t\tforeach (T row in rows)\n\t\t\t\t\ttable.Add(row);\n\t\t\t}\n\n\t\t\tvoid OnWriterEvent(object sender, ModuleWriterListenerEventArgs e) {\n\t\t\t\tvar writer = (ModuleWriterBase)sender;\n\t\t\t\tif (e.WriterEvent == ModuleWriterEvent.MDEndCreateTables) {\n\t\t\t\t\t// These hurts reflection\n\n\t\t\t\t\t/*\n\t\t\t\t\tuint methodLen = (uint)writer.MetaData.TablesHeap.MethodTable.Rows + 1;\n\t\t\t\t\tuint fieldLen = (uint)writer.MetaData.TablesHeap.FieldTable.Rows + 1;\n\n\t\t\t\t\tvar root = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(\n\t\t\t\t\t\t\t0, 0x7fff7fff, 0, 0x3FFFD, fieldLen, methodLen));\n\t\t\t\t\twriter.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, root));\n\n\t\t\t\t\tvar namespaces = writer.MetaData.TablesHeap.TypeDefTable\n\t\t\t\t\t\t.Select(row => row.Namespace)\n\t\t\t\t\t\t.Distinct()\n\t\t\t\t\t\t.ToList();\n\t\t\t\t\tforeach (var ns in namespaces)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (ns == 0) continue;\n\t\t\t\t\t\tvar type = writer.MetaData.TablesHeap.TypeDefTable.Add(new RawTypeDefRow(\n\t\t\t\t\t\t\t0, 0, ns, 0x3FFFD, fieldLen, methodLen));\n\t\t\t\t\t\twriter.MetaData.TablesHeap.NestedClassTable.Add(new RawNestedClassRow(root, type));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tforeach (var row in writer.MetaData.TablesHeap.ParamTable)\n\t\t\t\t\t\trow.Name = 0x7fff7fff;\n\t\t\t\t\t*/\n\n\t\t\t\t\twriter.MetaData.TablesHeap.ModuleTable.Add(new RawModuleRow(0, 0x7fff7fff, 0, 0, 0));\n\t\t\t\t\twriter.MetaData.TablesHeap.AssemblyTable.Add(new RawAssemblyRow(0, 0, 0, 0, 0, 0, 0, 0x7fff7fff, 0));\n\n\t\t\t\t\tint r = random.NextInt32(8, 16);\n\t\t\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\t\t\twriter.MetaData.TablesHeap.ENCLogTable.Add(new RawENCLogRow(random.NextUInt32(), random.NextUInt32()));\n\t\t\t\t\tr = random.NextInt32(8, 16);\n\t\t\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\t\t\twriter.MetaData.TablesHeap.ENCMapTable.Add(new RawENCMapRow(random.NextUInt32()));\n\n\t\t\t\t\t//Randomize(writer.MetaData.TablesHeap.NestedClassTable);\n\t\t\t\t\tRandomize(writer.MetaData.TablesHeap.ManifestResourceTable);\n\t\t\t\t\t//Randomize(writer.MetaData.TablesHeap.GenericParamConstraintTable);\n\n\t\t\t\t\twriter.TheOptions.MetaDataOptions.TablesHeapOptions.ExtraData = random.NextUInt32();\n\t\t\t\t\twriter.TheOptions.MetaDataOptions.TablesHeapOptions.UseENC = false;\n\t\t\t\t\twriter.TheOptions.MetaDataOptions.MetaDataHeaderOptions.VersionString += \"\\0\\0\\0\\0\";\n\n\t\t\t\t\t/*\n\t\t\t\t\tWe are going to create a new specific '#GUID' Heap to avoid UnConfuserEX to work.\n\t\t\t\t\t<sarcasm>UnConfuserEX is so well coded, it relies on static cmp between values</sarcasm>\n\t\t\t\t\tIf you deobfuscate this tool, you can see that it check for #GUID size and compare it to\n\t\t\t\t\t'16', so we have to create a new array of byte wich size is exactly 16 and put it into \n\t\t\t\t\tour brand new Heap\n\t\t\t\t\t*/\n\t\t\t\t\t//\n                    writer.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#GUID\", Guid.NewGuid().ToByteArray()));\n\t\t\t\t\t//\n\t\t\t\t\twriter.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#Strings\", new byte[1]));\n\t\t\t\t\twriter.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#Blob\", new byte[1]));\n\t\t\t\t\twriter.TheOptions.MetaDataOptions.OtherHeapsEnd.Add(new RawHeap(\"#Schema\", new byte[1]));\n\t\t\t\t}\n\t\t\t\telse if (e.WriterEvent == ModuleWriterEvent.MDOnAllTablesSorted) {\n\t\t\t\t\twriter.MetaData.TablesHeap.DeclSecurityTable.Add(new RawDeclSecurityRow(\n\t\t\t\t\t\t                                                 unchecked(0x7fff), 0xffff7fff, 0xffff7fff));\n\t\t\t\t\t/*\n\t\t\t\t\twriter.MetaData.TablesHeap.ManifestResourceTable.Add(new RawManifestResourceRow(\n\t\t\t\t\t\t0x7fff7fff, (uint)ManifestResourceAttributes.Private, 0x7fff7fff, 2));\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// RockPage is the base abstract class that all page templates in Rock should inherit from\n    /// </summary>\n    public abstract class RockPage : Page\n    {\n        #region Private Variables\n\n        private PlaceHolder phLoadStats;\n        private LinkButton _btnRestoreImpersonatedByUser;\n        private ScriptManager _scriptManager;\n        private PageCache _pageCache = null;\n\n        private string _clientType = null;\n        private BrowserInfo _browserInfo = null;\n        private BrowserClient _browserClient = null;\n\n        private PageStatePersister _PageStatePersister = null;\n        #endregion\n\n        #region Protected Variables\n\n        /// <summary>\n        /// The full name of the currently logged in user\n        /// </summary>\n        protected string UserName = string.Empty;\n\n        /// <summary>\n        /// Gets a dictionary of the current context items (models).\n        /// </summary>\n        internal Dictionary<string, Rock.Data.KeyEntity> ModelContext = new Dictionary<string, Data.KeyEntity>();\n\n        #endregion\n\n        #region Public Properties\n\n        /// <summary>\n        /// Gets the current <see cref=\"Rock.Model.Page\">Page's</see> logical Rock Page Id.\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"System.Int32\"/> representing the PageId of the current logical <see cref=\"Rock.Model.Page\"/>.\n        /// </value>\n        public int PageId\n        {\n            get { return _pageCache.Id; }\n        }\n\n        /// <summary>\n        /// Gets or sets the browser title.\n        /// </summary>\n        /// <value>\n        /// The browser title.\n        /// </value>\n        public string BrowserTitle { get; set; }\n\n        /// <summary>\n        /// Gets or sets the page title.\n        /// </summary>\n        /// <value>\n        /// The page title.\n        /// </value>\n        public string PageTitle { get; set; }\n\n        /// <summary>\n        /// Gets or sets the page title.\n        /// </summary>\n        /// <value>\n        /// The page icon.\n        /// </value>\n        public string PageIcon { get; set; }\n\n        /// <summary>\n        /// Gets the title for the page and sets both the browser and template title\n        /// </summary>\n        /// <returns>The title of the page.</returns>\n        public new string Title\n        {\n            get\n            {\n                return BrowserTitle;\n            }\n            set\n            {\n                BrowserTitle = value;\n                PageTitle = value;\n            }\n        }\n\n        /// <summary>\n        /// Gets the current <see cref=\"Rock.Model.Page\">Page's</see> logical Rock Page Guid.\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"System.Guid\"/> representing the Guid identifier for the current logical <see cref=\"Rock.Model.Page\"/>\n        /// </value>\n        public Guid Guid\n        {\n            get { return _pageCache.Guid; }\n        }\n\n        /// <summary>\n        /// Gets or sets the body CSS class.\n        /// </summary>\n        /// <value>\n        /// The body CSS class.\n        /// </value>\n        public string BodyCssClass { get; set; }\n\n        /// <summary>\n        /// Gets the current <see cref=\"Rock.Model.Page\">Page's</see> layout.\n        /// </summary>\n        /// <value>\n        /// The <see cref=\"LayoutCache\"/> representing the current <see cref=\"Rock.Model.Page\">Page's</see> layout.\n        /// </value>\n        public LayoutCache Layout\n        {\n            get { return _pageCache.Layout; }\n        }\n\n        /// <summary>\n        /// Gets the <see cref=\"Rock.Model.Site\"/> that the current <see cref=\"Rock.Model.Page\"/> is on.\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"SiteCache\"/> representing the <see cref=\"Rock.Model.Site\"/> that the current <see cref=\"Rock.Model.Page\"/>\n        /// is on.\n        /// </value>\n        public new SiteCache Site\n        {\n            get { return _pageCache.Layout.Site; }\n        }\n\n        /// <summary>\n        /// Gets or sets the current <see cref=\"Rock.Web.PageReference\"/>\n        /// </summary>\n        /// <value>\n        /// The current <see cref=\"Rock.Web.PageReference\"/>.\n        /// </value>\n        public PageReference PageReference\n        {\n            get\n            {\n                if ( _PageReference == null && Context.Items.Contains( \"Rock:PageReference\" ) )\n                {\n                    _PageReference = Context.Items[\"Rock:PageReference\"] as PageReference;\n                }\n\n                return _PageReference;\n            }\n\n            set\n            {\n                _PageReference = value;\n                SaveContextItem( \"Rock:PageReference\", _PageReference );\n            }\n        }\n        private PageReference _PageReference = null;\n\n        /// <summary>\n        /// Public gets and privately sets the content areas on a layout page that blocks can be added to.\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"System.Collections.Generic.Dictionary{String, KeyValuePair}\"/> representing the content\n        /// areas on the page that content can be added to. Each <see cref=\"System.Collections.Generic.KeyValuePair{String, KeyValuePair}\"/>\n        /// has a Key representing the <see cref=\"Rock.Web.UI.Controls.Zone\">Zone's</see> ZoneKey and a value containing\n        /// a <see cref=\"System.Collections.Generic.Dictionary{String, Zone}\"/> with the key referencing the <see cref=\"Rock.Web.UI.Controls.Zone\">Zone's</see>\n        /// friendly name and the <see cref=\"Rock.Web.UI.Controls.Zone\"/>.\n        /// </value>\n        /// <remarks>\n        /// The Dictionary's key is the zonekey and the KeyValuePair is a combination\n        /// of the friendly zone name and the zone control\n        /// </remarks>\n        public Dictionary<string, KeyValuePair<string, Zone>> Zones { get; private set; }\n\n        /// <summary>\n        /// Publicly Gets and privately sets a list containing the Page's <see cref=\"Rock.Web.UI.BreadCrumb\">BreadCrumbs</see>\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"System.Collections.Generic.List{BreakdCrumb}\"/> containing the <see cref=\"Rock.Web.UI.BreadCrumb\">BreadCrumbs</see>\n        /// for this Page.\n        /// </value>\n        public List<BreadCrumb> BreadCrumbs { get; private set; }\n\n        /// <summary>\n        /// Publicly gets and privately sets the currently logged in user.\n        /// </summary>\n        /// <value>\n        /// The <see cref=\"Rock.Model.UserLogin\"/> of the currently logged in user.\n        /// </value>\n        public Rock.Model.UserLogin CurrentUser\n        {\n            get\n            {\n                if ( _CurrentUser != null )\n                {\n                    return _CurrentUser;\n                }\n\n                if ( Context.Items.Contains( \"CurrentUser\" ) )\n                {\n                    _CurrentUser = Context.Items[\"CurrentUser\"] as Rock.Model.UserLogin;\n                }\n\n                if ( _CurrentUser == null )\n                {\n                    _CurrentUser = Rock.Model.UserLoginService.GetCurrentUser();\n                    if ( _CurrentUser != null )\n                    {\n                        Context.Items.Add( \"CurrentUser\", _CurrentUser );\n                    }\n                }\n\n                if ( _CurrentUser != null && _CurrentUser.Person != null && _currentPerson == null )\n                {\n                    CurrentPerson = _CurrentUser.Person;\n                }\n\n                return _CurrentUser;\n            }\n\n            private set\n            {\n                Context.Items.Remove( \"CurrentUser\" );\n                _CurrentUser = value;\n\n                if ( _CurrentUser != null )\n                {\n                    Context.Items.Add( \"CurrentUser\", _CurrentUser );\n                    CurrentPerson = _CurrentUser.Person;\n                }\n                else\n                {\n                    CurrentPerson = null;\n                }\n            }\n        }\n        private Rock.Model.UserLogin _CurrentUser;\n\n        /// <summary>\n        /// Publicly gets the current <see cref=\"Rock.Model.Person\"/>.  This is either the currently logged in user, or if the user\n        /// has not logged in, it may also be an impersonated person determined from using the encrypted\n        /// person key.\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"Rock.Model.Person\"/> representing the currently logged in person or impersonated person.\n        /// </value>\n        public Person CurrentPerson\n        {\n            get\n            {\n                if ( _currentPerson != null )\n                {\n                    return _currentPerson;\n                }\n\n                if ( _currentPerson == null && Context.Items.Contains( \"CurrentPerson\" ) )\n                {\n                    _currentPerson = Context.Items[\"CurrentPerson\"] as Person;\n                    return _currentPerson;\n                }\n\n                return null;\n            }\n\n            private set\n            {\n                Context.Items.Remove( \"CurrentPerson\" );\n\n                _currentPerson = value;\n                if ( _currentPerson != null )\n                {\n                    Context.Items.Add( \"CurrentPerson\", value );\n                }\n\n                _currentPersonAlias = null;\n            }\n        }\n        private Person _currentPerson;\n\n        /// <summary>\n        /// The Person ID of the currently logged in user.  Returns null if there is not a user logged in\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"System.Int32\" /> representing the PersonId of the <see cref=\"Rock.Model.Person\"/>\n        /// who is logged in as the current user. If a user is not logged in.\n        /// </value>\n        public int? CurrentPersonId\n        {\n            get\n            {\n                if ( CurrentPerson != null )\n                {\n                    return CurrentPerson.Id;\n                }\n                else\n                {\n                    return null;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the current person alias.\n        /// </summary>\n        /// <value>\n        /// The current person alias.\n        /// </value>\n        public PersonAlias CurrentPersonAlias\n        {\n            get\n            {\n                if ( _currentPersonAlias != null )\n                {\n                    return _currentPersonAlias;\n                }\n\n                if ( _currentPerson != null )\n                {\n                    _currentPersonAlias = _currentPerson.PrimaryAlias;\n                    return _currentPersonAlias;\n                }\n\n                return null;\n            }\n        }\n        private PersonAlias _currentPersonAlias = null;\n\n        /// <summary>\n        /// Gets the current person alias identifier.\n        /// </summary>\n        /// <value>\n        /// The current person alias identifier.\n        /// </value>\n        public int? CurrentPersonAliasId\n        {\n            get\n            {\n                if ( CurrentPersonAlias != null )\n                {\n                    return CurrentPersonAlias.Id;\n                }\n                else\n                {\n                    return null;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the all the <see cref=\"Rock.Web.UI.RockBlock\">RockBlocks</see> on the Page.\n        /// </summary>\n        /// <value>\n        /// A <see cref=\"System.Collections.Generic.List{RockBlock}\"/> containing all the <see cref=\"Rock.Web.UI.RockBlock\">RockBlocks</see> on the page.\n        /// </value>\n        public List<RockBlock> RockBlocks\n        {\n            get\n            {\n                return this.ControlsOfTypeRecursive<RockBlock>();\n            }\n        }\n\n        /// <summary>\n        /// Gets the type of the client.\n        /// </summary>\n        /// <value>\n        /// The type of the client.\n        /// </value>\n        public string ClientType\n        {\n            get\n            {\n                if ( _clientType == null )\n                {\n                    _clientType = InteractionDeviceType.GetClientType( Request.UserAgent ?? \"\" );\n                }\n                return _clientType;\n            }\n\n        }\n\n        /// <summary>\n        /// Gets the client information.\n        /// </summary>\n        /// <value>\n        /// The client information.\n        /// </value>\n        public BrowserInfo BrowserInfo\n        {\n            get\n            {\n                if ( _browserInfo == null )\n                {\n                    _browserInfo = new BrowserInfo( Request.UserAgent ?? \"\" );\n                }\n                return _browserInfo;\n            }\n        }\n\n        /// <summary>\n        /// Gets a value indicating whether this instance is mobile request.\n        /// </summary>\n        /// <value>\n        /// <c>true</c> if this instance is mobile request; otherwise, <c>false</c>.\n        /// </value>\n        public bool IsMobileRequest\n        {\n            get\n            {\n                return this.ClientType == \"Mobile\";\n            }\n        }\n\n        /// <summary>\n        /// Gets a single object that contains all of the information about the web browser.\n        /// </summary>\n        /// <value>\n        /// The browser client.\n        /// </value>\n        public BrowserClient BrowserClient\n        {\n            get\n            {\n                if ( _browserClient == null )\n                {\n                    _browserClient = new BrowserClient();\n                    _browserClient.BrowserInfo = BrowserInfo;\n                    _browserClient.IsMobile = IsMobileRequest;\n                    _browserClient.ClientType = ClientType;\n                }\n                return _browserClient;\n            }\n        }\n\n        /// <summary>\n        /// Gets the size of the view state.\n        /// </summary>\n        /// <value>\n        /// The size of the view state.\n        /// </value>\n        public int ViewStateSize { get; private set; }\n\n\n        /// <summary>\n        /// Gets the view state size compressed.\n        /// </summary>\n        /// <value>\n        /// The view state size compressed.\n        /// </value>\n        public int ViewStateSizeCompressed { get; private set; }\n\n        /// <summary>\n        /// Gets the view state value.\n        /// </summary>\n        /// <value>\n        /// The view state value.\n        /// </value>\n        public string ViewStateValue { get; private set; }\n\n        /// <summary>\n        /// Gets a value indicating whether [view state is compressed].\n        /// </summary>\n        /// <value>\n        /// <c>true</c> if [view state is compressed]; otherwise, <c>false</c>.\n        /// </value>\n        public bool ViewStateIsCompressed { get; private set; }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether [enable view state inspection].\n        /// </summary>\n        /// <value>\n        /// <c>true</c> if [enable view state inspection]; otherwise, <c>false</c>.\n        /// </value>\n        public bool EnableViewStateInspection { get; set; }\n\n    #endregion\n\n        #region Overridden Properties\n\n        /// <summary>\n        /// Gets the PageStatePersister object associated with the page.\n        /// </summary>\n        protected override PageStatePersister PageStatePersister\n        {\n            get {\n                if ( _PageStatePersister == null )\n                {\n                    _PageStatePersister = new RockHiddenFieldPageStatePersister( this, RockHiddenFieldPageStatePersister.ViewStateCompressionThreshold );\n                }\n                return _PageStatePersister;\n            }\n        }\n\n        #endregion\n\n        #region Protected Methods\n\n        /// <summary>\n        /// Recurses the page's <see cref=\"System.Web.UI.ControlCollection\"/> looking for any <see cref=\"Rock.Web.UI.Controls.Zone\"/> controls\n        /// </summary>\n        /// <param name=\"controls\">A <see cref=\"System.Web.UI.ControlCollection\"/> containing the page's controls.</param>\n        protected virtual void FindRockControls( ControlCollection controls )\n        {\n            if ( controls != null )\n            {\n                foreach ( Control control in controls )\n                {\n                    if ( control is Zone )\n                    {\n                        Zone zone = control as Zone;\n                        if ( zone != null )\n                            Zones.Add( zone.Name.Replace( \" \", \"\" ), new KeyValuePair<string, Zone>( zone.Name, zone ) );\n                    }\n\n                    FindRockControls( control.Controls );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Find the <see cref=\"Rock.Web.UI.Controls.Zone\"/> for the specified zone name.  Looks in the\n        /// <see cref=\"Zones\"/> property to see if it has been defined.  If an existing zone\n        /// <see cref=\"Rock.Web.UI.Controls.Zone\"/> cannot be found, the <see cref=\"HtmlForm\"/> control\n        /// is returned\n        /// </summary>\n        /// <param name=\"zoneName\">A <see cref=\"System.String\"/> representing the name of the zone.</param>\n        /// <returns>The <see cref=\"System.Web.UI.Control\"/> for the zone, if the zone is not found, the form control is returned.</returns>\n        [RockObsolete( \"1.7\" )]\n        [Obsolete(\"Use the other FindZone()\", true )]\n        protected virtual Control FindZone( string zoneName )\n        {\n            // Find the zone, or use the Form if not found\n            return FindZone( zoneName, this.Form );\n        }\n\n        /// <summary>\n        /// Find the <see cref=\"Rock.Web.UI.Controls.Zone\" /> for the specified zone name.  Looks in the\n        /// <see cref=\"Zones\" /> property to see if it has been defined.  If an existing zone\n        /// <see cref=\"Rock.Web.UI.Controls.Zone\" /> cannot be found, the defaultZone will be returned\n        /// </summary>\n        /// <param name=\"zoneName\">A <see cref=\"System.String\" /> representing the name of the zone.</param>\n        /// <param name=\"defaultZone\">The default zone.</param>\n        /// <returns>\n        /// The <see cref=\"System.Web.UI.Control\" /> for the zone, if the zone is not found, the defaultZone is returned.\n        /// </returns>\n        protected virtual Control FindZone( string zoneName, Control defaultZone )\n        {\n            // First look in the Zones dictionary\n            if ( Zones.ContainsKey( zoneName ) )\n                return Zones[zoneName].Value;\n\n            // If no match, return the defaultZone\n            return defaultZone;\n        }\n\n        #endregion\n\n        #region Custom Events\n        /// <summary>\n        /// Occurs when view state persisted.\n        /// </summary>\n        public event EventHandler ViewStatePersisted;\n\n        /// <summary>\n        /// Called when [view state persisted].\n        /// </summary>\n        protected void OnViewStatePersisted()\n        {\n            if ( this.ViewStatePersisted != null )\n            {\n                ViewStatePersisted( this, EventArgs.Empty );\n            }\n        }\n\n        #endregion\n\n        #region Overridden Methods\n\n        /// <summary>\n        /// Saves any view-state and control-state information for the page.\n        /// </summary>\n        /// <param name=\"state\">An <see cref=\"T:System.Object\" /> in which to store the view-state information.</param>\n        protected override void SavePageStateToPersistenceMedium( object state )\n        {\n            base.SavePageStateToPersistenceMedium( state );\n\n            var customPersister = this.PageStatePersister as RockHiddenFieldPageStatePersister;\n\n            if (customPersister != null )\n            {\n                this.ViewStateValue = customPersister.ViewStateValue;\n            }\n\n            OnViewStatePersisted();\n        }\n\n        /// <summary>\n        /// Initializes the page's culture to use the culture specified by the browser (\"auto\")\n        /// </summary>\n        protected override void InitializeCulture()\n        {\n            base.UICulture = \"Auto\";\n            base.Culture = \"Auto\";\n\n            base.InitializeCulture();\n        }\n\n        /// <summary>\n        /// Loads all of the configured blocks for the current page into the control tree\n        /// </summary>\n        /// <param name=\"e\"></param>\n        protected override void OnInit( EventArgs e )\n        {\n            var slDebugTimings = new StringBuilder();\n            var stopwatchInitEvents = Stopwatch.StartNew();\n            bool showDebugTimings = this.PageParameter( \"ShowDebugTimings\" ).AsBoolean();\n            bool canAdministratePage = false;\n            bool canEditPage = false;\n\n            if ( showDebugTimings )\n            {\n                TimeSpan tsDuration = RockDateTime.Now.Subtract( (DateTime)Context.Items[\"Request_Start_Time\"] );\n                slDebugTimings.AppendFormat( \"OnInit [{0}ms] @ {1} \\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds, tsDuration.TotalMilliseconds );\n                stopwatchInitEvents.Restart();\n            }\n\n            // Add the ScriptManager to each page\n            _scriptManager = ScriptManager.GetCurrent( this.Page );\n\n            if ( _scriptManager == null )\n            {\n                _scriptManager = new ScriptManager { ID = \"sManager\" };\n                Page.Trace.Warn( \"Adding script manager\" );\n                Page.Form.Controls.AddAt( 0, _scriptManager );\n            }\n\n            // enable history on the ScriptManager\n            _scriptManager.EnableHistory = true;\n\n            // increase the postback timeout\n            _scriptManager.AsyncPostBackTimeout = 180;\n\n            // wire up navigation event\n            _scriptManager.Navigate += new EventHandler<HistoryEventArgs>( scriptManager_Navigate );\n\n            // Add library and UI bundles during init, that way theme developers will only\n            // need to worry about registering any custom scripts or script bundles they need\n            _scriptManager.Scripts.Add( new ScriptReference( \"~/Bundles/WebFormsJs\" ) );\n            _scriptManager.Scripts.Add( new ScriptReference( \"~/Scripts/Bundles/RockLibs\" ) );\n            _scriptManager.Scripts.Add( new ScriptReference( \"~/Scripts/Bundles/RockUi\" ) );\n            _scriptManager.Scripts.Add( new ScriptReference( \"~/Scripts/Bundles/RockValidation\" ) );\n\n            // Recurse the page controls to find the rock page title and zone controls\n            Page.Trace.Warn( \"Recursing layout to find zones\" );\n            Zones = new Dictionary<string, KeyValuePair<string, Zone>>();\n            FindRockControls( this.Controls );\n\n            // Add a Rock version meta tag\n            Page.Trace.Warn( \"Adding Rock metatag\" );\n            string version = typeof( Rock.Web.UI.RockPage ).Assembly.GetName().Version.ToString();\n            HtmlMeta rockVersion = new HtmlMeta();\n            rockVersion.Attributes.Add( \"name\", \"generator\" );\n            rockVersion.Attributes.Add( \"content\", string.Format( \"Rock v{0}\", version ) );\n            AddMetaTag( this.Page, rockVersion );\n\n            if ( showDebugTimings )\n            {\n                slDebugTimings.AppendFormat( \"CheckingForLogout [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                stopwatchInitEvents.Restart();\n            }\n\n            // If the logout parameter was entered, delete the user's forms authentication cookie and redirect them\n            // back to the same page.\n            Page.Trace.Warn( \"Checking for logout request\" );\n            if ( PageParameter( \"logout\" ) != string.Empty )\n            {\n                if ( CurrentUser != null )\n                {\n                    var transaction = new Rock.Transactions.UserLastActivityTransaction();\n                    transaction.UserId = CurrentUser.Id;\n                    transaction.LastActivityDate = RockDateTime.Now;\n                    transaction.IsOnLine = false;\n                    Rock.Transactions.RockQueue.TransactionQueue.Enqueue( transaction );\n                }\n\n                Authorization.SignOut();\n\n                // After logging out check to see if an anonymous user is allowed to view the current page.  If so\n                // redirect back to the current page, otherwise redirect to the site's default page\n                if ( _pageCache != null )\n                {\n                    if ( _pageCache.IsAuthorized( Authorization.VIEW, null ) )\n                    {\n                        // Remove the 'logout' queryparam before redirecting\n                        var pageReference = new PageReference( PageReference.PageId, PageReference.RouteId, PageReference.Parameters );\n                        foreach ( string key in PageReference.QueryString )\n                        {\n                            if ( key != null && !key.Equals( \"logout\", StringComparison.OrdinalIgnoreCase ) )\n                            {\n                                pageReference.Parameters.Add( key, PageReference.QueryString[key] );\n                            }\n                        }\n                        Response.Redirect( pageReference.BuildUrl(), false );\n                        Context.ApplicationInstance.CompleteRequest();\n                    }\n                    else\n                    {\n                        _pageCache.Layout.Site.RedirectToDefaultPage();\n                    }\n                    return;\n                }\n                else\n                {\n                    CurrentPerson = null;\n                    CurrentUser = null;\n                }\n            }\n\n            var rockContext = new RockContext();\n\n            if ( showDebugTimings )\n            {\n                slDebugTimings.AppendFormat( \"CreateRockContext [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                stopwatchInitEvents.Restart();\n            }\n\n            // If the impersonated query key was included or is in session then set the current person\n            Page.Trace.Warn( \"Checking for person impersonation\" );\n            if (!ProcessImpersonation( rockContext ) )\n            {\n                return;\n            }\n\n            // Get current user/person info\n            Page.Trace.Warn( \"Getting CurrentUser\" );\n            Rock.Model.UserLogin user = CurrentUser;\n\n            if ( showDebugTimings )\n            {\n                slDebugTimings.AppendFormat( \"GetCurrentUser [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                stopwatchInitEvents.Restart();\n            }\n\n            // If there is a logged in user, see if it has an associated Person Record.  If so, set the UserName to\n            // the person's full name (which is then cached in the Session state for future page requests)\n            if ( user != null )\n            {\n                Page.Trace.Warn( \"Setting CurrentPerson\" );\n                UserName = user.UserName;\n                int? personId = user.PersonId;\n\n                if ( personId.HasValue )\n                {\n                    string personNameKey = \"PersonName_\" + personId.Value.ToString();\n                    if ( Session[personNameKey] != null )\n                    {\n                        UserName = Session[personNameKey].ToString();\n                    }\n                    else\n                    {\n                        Rock.Model.PersonService personService = new Model.PersonService( rockContext );\n                        Rock.Model.Person person = personService.Get( personId.Value );\n                        if ( person != null )\n                        {\n                            UserName = person.FullName;\n                            CurrentPerson = person;\n                        }\n\n                        Session[personNameKey] = UserName;\n                    }\n                }\n\n                if ( showDebugTimings )\n                {\n                    slDebugTimings.AppendFormat( \"GetCurrentPerson [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                    stopwatchInitEvents.Restart();\n                }\n\n                // check that they aren't required to change their password\n                if ( user.IsPasswordChangeRequired == true && Site.ChangePasswordPageReference != null )\n                {\n                    // don't redirect if this is the change password page\n                    if ( Site.ChangePasswordPageReference.PageId != this.PageId )\n                    {\n                        Site.RedirectToChangePasswordPage( true, true );\n                    }\n                }\n\n                // Check if there is a ROCK_PERSONALDEVICE_ADDRESS cookie, link person to device\n                HandleRockWiFiCookie( CurrentPersonAliasId );\n            }\n\n            // If a PageInstance exists\n            if ( _pageCache != null )\n            {\n                BrowserTitle = _pageCache.BrowserTitle;\n                PageTitle = _pageCache.PageTitle;\n                PageIcon = _pageCache.IconCssClass;\n                BodyCssClass = _pageCache.BodyCssClass;\n\n                // If there's a master page, update its reference to Current Page\n                if ( this.Master is RockMasterPage )\n                {\n                    ( (RockMasterPage)this.Master ).SetPage( _pageCache );\n                }\n\n                // Add CSS class to body\n                if ( !string.IsNullOrWhiteSpace( this.BodyCssClass ) && this.Master != null )\n                {\n                    // attempt to find the body tag\n                    var body = (HtmlGenericControl)this.Master.FindControl( \"body\" );\n                    if ( body != null )\n                    {\n                        // determine if we need to append or add the class\n                        if ( body.Attributes[\"class\"] != null )\n                        {\n                            body.Attributes[\"class\"] += \" \" + this.BodyCssClass;\n                        }\n                        else\n                        {\n                            body.Attributes.Add( \"class\", this.BodyCssClass );\n                        }\n                    }\n                }\n\n                // Add Favicon\n                if ( Site.FavIconBinaryFileId.HasValue )\n                {\n                    AddIconLink( Site.FavIconBinaryFileId.Value, 192, \"shortcut icon\" );\n                    AddIconLink( Site.FavIconBinaryFileId.Value, 16 );\n                    AddIconLink( Site.FavIconBinaryFileId.Value, 32 );\n                    AddIconLink( Site.FavIconBinaryFileId.Value, 144 );\n                    AddIconLink( Site.FavIconBinaryFileId.Value, 180 );\n                    AddIconLink( Site.FavIconBinaryFileId.Value, 192 );\n                }\n\n                // check if page should have been loaded via ssl\n                Page.Trace.Warn( \"Checking for SSL request\" );\n                if ( !WebRequestHelper.IsSecureConnection(HttpContext.Current)  && ( _pageCache.RequiresEncryption || Site.RequiresEncryption ) )\n                {\n                    string redirectUrl = Request.Url.ToString().Replace( \"http:\", \"https:\" );\n\n                    // Clear the session state cookie so it can be recreated as secured (see engineering note in Global.asax EndRequest)\n                    SessionStateSection sessionState = ( SessionStateSection ) ConfigurationManager.GetSection( \"system.web/sessionState\" );\n                    string sidCookieName = sessionState.CookieName; // ASP.NET_SessionId\n                    Response.Cookies[sidCookieName].Expires = DateTime.Now.AddDays( -1 );\n\n                    Response.Redirect( redirectUrl, false );\n                    Context.ApplicationInstance.CompleteRequest();\n                    return;\n                }\n\n                // Verify that the current user is allowed to view the page.\n                Page.Trace.Warn( \"Checking if user is authorized\" );\n\n                var isCurrentPersonAuthorized = _pageCache.IsAuthorized( Authorization.VIEW, CurrentPerson );\n\n                if ( showDebugTimings )\n                {\n                    slDebugTimings.AppendFormat( \"isCurrentPersonAuthorized [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                    stopwatchInitEvents.Restart();\n                }\n\n                if ( !isCurrentPersonAuthorized )\n                {\n                    if ( user == null )\n                    {\n                        // If not authorized, and the user hasn't logged in yet, redirect to the login page\n                        Page.Trace.Warn( \"Redirecting to login page\" );\n\n                        var site = _pageCache.Layout.Site;\n                        if ( site.LoginPageId.HasValue )\n                        {\n                            site.RedirectToLoginPage( true );\n                        }\n                        else\n                        {\n                            FormsAuthentication.RedirectToLoginPage();\n                        }\n                    }\n                    else\n                    {\n                        // If not authorized, and the user has logged in, redirect to error page\n                        Page.Trace.Warn( \"Redirecting to error page\" );\n\n                        if ( Site != null && !string.IsNullOrWhiteSpace( Site.ErrorPage ) )\n                        {\n                            Context.Response.Redirect( string.Format( \"{0}?type=security\", Site.ErrorPage.TrimEnd( new char[] { '/' } ) ), false );\n                            Context.ApplicationInstance.CompleteRequest();\n                            return;\n                        }\n                        else\n                        {\n                            Response.Redirect( \"~/Error.aspx?type=security\", false );\n                            Context.ApplicationInstance.CompleteRequest();\n                        }\n                    }\n                }\n                else\n                {\n                    // Set current models (context)\n                    Page.Trace.Warn( \"Checking for Context\" );\n                    try\n                    {\n                        char[] delim = new char[1] { ',' };\n\n                        // Check to see if a context from query string should be saved to a cookie first\n                        foreach ( string param in PageParameter( \"SetContext\", true ).Split( delim, StringSplitOptions.RemoveEmptyEntries ) )\n                        {\n                            string[] parts = param.Split( '|' );\n                            if ( parts.Length == 2 )\n                            {\n                                var contextModelEntityType = EntityTypeCache.Get( parts[0], false, rockContext );\n                                int? contextId = parts[1].AsIntegerOrNull();\n\n                                if ( contextModelEntityType != null && contextId.HasValue )\n                                {\n                                    var contextModelType = contextModelEntityType.GetEntityType();\n                                    var contextDbContext = Reflection.GetDbContextForEntityType( contextModelType );\n                                    if ( contextDbContext != null )\n                                    {\n                                        var contextService = Reflection.GetServiceForEntityType( contextModelType, contextDbContext );\n                                        if ( contextService != null )\n                                        {\n                                            MethodInfo getMethod = contextService.GetType().GetMethod( \"Get\", new Type[] { typeof( int ) } );\n                                            if ( getMethod != null )\n                                            {\n                                                var getResult = getMethod.Invoke( contextService, new object[] { contextId.Value } );\n                                                var contextEntity = getResult as IEntity;\n                                                if ( contextEntity != null )\n                                                {\n                                                    SetContextCookie( contextEntity, false, false );\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n\n                        if ( showDebugTimings )\n                        {\n                            slDebugTimings.AppendFormat( \"Set Page Context(s) [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                            stopwatchInitEvents.Restart();\n                        }\n\n                        // first search the cookies for any saved context, but pageContext can replace it\n                        GetCookieContext( GetContextCookieName( false ) );      // Site\n                        GetCookieContext( GetContextCookieName( true ) );       // Page (will replace any site values)\n\n                        // check to see if any of the ModelContext.Keys that got set from Cookies are on the URL. If so, the URL value overrides the Cookie value\n                        foreach ( var modelContextName in ModelContext.Keys.ToList() )\n                        {\n                            var type = Type.GetType( modelContextName, false, false );\n                            if ( type != null )\n                            {\n                                int? contextId = PageParameter( type.Name + \"Id\" ).AsIntegerOrNull();\n                                if ( contextId.HasValue )\n                                {\n                                    ModelContext.AddOrReplace( modelContextName, new Data.KeyEntity( contextId.Value ) );\n                                }\n                            }\n                        }\n\n                        // check for page context (that were explicitly set in Page Properties)\n                        foreach ( var pageContext in _pageCache.PageContexts )\n                        {\n                            int? contextId = PageParameter( pageContext.Value ).AsIntegerOrNull();\n                            if ( contextId.HasValue )\n                            {\n                                ModelContext.AddOrReplace( pageContext.Key, new Data.KeyEntity( contextId.Value ) );\n                            }\n                        }\n\n                        // check for any encrypted contextkeys specified in query string\n                        foreach ( string param in PageParameter( \"context\", true ).Split( delim, StringSplitOptions.RemoveEmptyEntries ) )\n                        {\n                            string contextItem = Rock.Security.Encryption.DecryptString( param );\n                            string[] parts = contextItem.Split( '|' );\n                            if ( parts.Length == 2 )\n                            {\n                                ModelContext.AddOrReplace( parts[0], new Data.KeyEntity( parts[1] ) );\n                            }\n                        }\n\n                        if ( showDebugTimings )\n                        {\n                            slDebugTimings.AppendFormat( \"Check Page Context(s) [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                            stopwatchInitEvents.Restart();\n                        }\n\n                    }\n                    catch\n                    {\n                        // intentionally ignore exception\n                    }\n\n                    // set viewstate on/off\n                    this.EnableViewState = _pageCache.EnableViewState;\n\n                    Page.Trace.Warn( \"Checking if user can administer\" );\n                    canAdministratePage = _pageCache.IsAuthorized( Authorization.ADMINISTRATE, CurrentPerson );\n                    canEditPage = _pageCache.IsAuthorized( Authorization.EDIT, CurrentPerson );\n\n                    // If the current person isn't allowed to edit or administrate the page, check to see if they are being impersonated by someone who\n                    // may have edit and/or administrate access to the page.\n                    if ( !canAdministratePage || !canEditPage )\n                    {\n                        // if the current user is being impersonated by another user (typically an admin), then check their security\n                        var impersonatedByUser = Session[\"ImpersonatedByUser\"] as UserLogin;\n                        var currentUserIsImpersonated = ( HttpContext.Current?.User?.Identity?.Name ?? string.Empty ).StartsWith( \"rckipid=\" );\n                        if ( impersonatedByUser != null && currentUserIsImpersonated )\n                        {\n                            canAdministratePage = canAdministratePage || _pageCache.IsAuthorized( Authorization.ADMINISTRATE, impersonatedByUser.Person );\n                            canEditPage = canEditPage || _pageCache.IsAuthorized( Authorization.EDIT, impersonatedByUser.Person );\n                        }\n                    }\n\n                    if ( showDebugTimings )\n                    {\n                        slDebugTimings.AppendFormat( \"canAdministratePage [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                        stopwatchInitEvents.Restart();\n                    }\n\n                    // Create a javascript object to store information about the current page for client side scripts to use\n                    Page.Trace.Warn( \"Creating JS objects\" );\n                    if ( !ClientScript.IsStartupScriptRegistered( \"rock-js-object\" ) )\n                    {\n                        string script = string.Format( @\"\n    Rock.settings.initialize({{\n        siteId: {0},\n        layoutId: {1},\n        pageId: {2},\n        layout: '{3}',\n        baseUrl: '{4}'\n    }});\",\n                            _pageCache.Layout.SiteId, _pageCache.LayoutId, _pageCache.Id, _pageCache.Layout.FileName, ResolveUrl( \"~\" ) );\n\n                        ClientScript.RegisterStartupScript( this.Page.GetType(), \"rock-js-object\", script, true );\n                    }\n\n                    AddTriggerPanel();\n\n                    // Add config elements\n                    if ( _pageCache.IncludeAdminFooter )\n                    {\n                        Page.Trace.Warn( \"Adding popup controls (footer elements)\" );\n                        AddPopupControls();\n\n                        Page.Trace.Warn( \"Adding zone elements\" );\n                        AddZoneElements( canAdministratePage );\n                    }\n\n                    // Initialize the list of breadcrumbs for the current page (and blocks on the page)\n                    Page.Trace.Warn( \"Setting breadcrumbs\" );\n                    PageReference.BreadCrumbs = new List<BreadCrumb>();\n\n                    // If the page is configured to display in the breadcrumbs...\n                    string bcName = _pageCache.BreadCrumbText;\n                    if ( bcName != string.Empty )\n                    {\n                        PageReference.BreadCrumbs.Add( new BreadCrumb( bcName, PageReference.BuildUrl() ) );\n                    }\n\n                    // Add the Google Analytics Code script if a code was specified for the site\n                    if ( !string.IsNullOrWhiteSpace( _pageCache.Layout.Site.GoogleAnalyticsCode ) )\n                    {\n                        AddGoogleAnalytics( _pageCache.Layout.Site.GoogleAnalyticsCode );\n                    }\n\n                    // Flag indicating if user has rights to administer one or more of the blocks on page\n                    bool canAdministrateBlockOnPage = false;\n\n                    if ( showDebugTimings )\n                    {\n                        slDebugTimings.AppendFormat( \"start loading blocks [{0}ms]\\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds );\n                        stopwatchInitEvents.Restart();\n                    }\n\n                    // If the block's AttributeProperty values have not yet been verified verify them.\n                    // (This provides a mechanism for block developers to define the needed block\n                    //  attributes in code and have them automatically added to the database)\n                    Page.Trace.Warn( \"\\tChecking if block attributes need refresh\" );\n                    VerifyBlockTypeInstanceProperties();\n\n                    // Load the blocks and insert them into page zones\n                    Page.Trace.Warn( \"Loading Blocks\" );\n                    var pageBlocks = _pageCache.Blocks;\n\n                    foreach ( BlockCache block in pageBlocks )\n                    {\n                        var stopwatchBlockInit= Stopwatch.StartNew();\n                        Page.Trace.Warn( string.Format( \"\\tLoading '{0}' block\", block.Name ) );\n\n                        // Get current user's permissions for the block instance\n                        Page.Trace.Warn( \"\\tChecking permission\" );\n                        bool canAdministrate = block.IsAuthorized( Authorization.ADMINISTRATE, CurrentPerson );\n                        bool canEdit = block.IsAuthorized( Authorization.EDIT, CurrentPerson );\n                        bool canView = block.IsAuthorized( Authorization.VIEW, CurrentPerson );\n\n                        // if this is a Site-wide block, only render it if its Zone exists on this page\n                        // In other cases, Rock will add the block to the Form (at the very bottom of the page)\n                        Control zone = FindZone( block.Zone, block.BlockLocation == BlockLocation.Site ? null : this.Form );\n\n                        // Make sure there is a Zone for the block, and make sure user has access to view block instance\n                        if ( zone != null && (canAdministrate || canEdit || canView) )\n                        {\n                            // Load the control and add to the control tree\n                            Page.Trace.Warn( \"\\tLoading control\" );\n                            Control control = null;\n\n                            // Check to see if block is configured to use a \"Cache Duration'\n                            if ( block.OutputCacheDuration > 0 )\n                            {\n                                // Cache object used for block output caching\n                                Page.Trace.Warn( \"Getting memory cache\" );\n                                string blockCacheKey = string.Format( \"Rock:BlockOutput:{0}\", block.Id );\n                                var blockCacheString = RockCache.Get( blockCacheKey ) as string;\n                                if ( blockCacheString.IsNotNullOrWhiteSpace() )\n                                {\n                                    // If the current block exists in our custom output cache, add the cached output instead of adding the control\n                                    control = new LiteralControl( blockCacheString );\n                                }\n                            }\n\n                            if ( control == null )\n                            {\n                                try\n                                {\n                                    if ( !string.IsNullOrWhiteSpace( block.BlockType.Path ) )\n                                    {\n                                        control = TemplateControl.LoadControl( block.BlockType.Path );\n                                        control.ClientIDMode = ClientIDMode.AutoID;\n                                    }\n                                    else if ( block.BlockType.EntityTypeId.HasValue )\n                                    {\n                                        var blockEntity = Activator.CreateInstance( block.BlockType.EntityType.GetEntityType() );\n\n                                        if ( blockEntity is Rock.Blocks.IRockBlockType rockBlockEntity )\n                                        {\n                                            var wrapper = new RockBlockTypeWrapper\n                                            {\n                                                Page = this,\n                                                Block = rockBlockEntity\n                                            };\n\n                                            wrapper.InitializeAsUserControl( this );\n                                            wrapper.AppRelativeTemplateSourceDirectory = \"~\";\n\n                                            control = wrapper;\n                                            control.ClientIDMode = ClientIDMode.AutoID;\n                                        }\n                                    }\n\n                                    if ( control == null )\n                                    {\n                                        throw new Exception( \"Cannot instantiate unknown block type\" );\n                                    }\n                                }\n                                catch ( Exception ex )\n                                {\n                                    try\n                                    {\n                                        LogException( ex );\n                                    }\n                                    catch\n                                    {\n                                        //\n                                    }\n\n                                    NotificationBox nbBlockLoad = new NotificationBox();\n                                    nbBlockLoad.ID = string.Format( \"nbBlockLoad_{0}\", block.Id );\n                                    nbBlockLoad.CssClass = \"system-error\";\n                                    nbBlockLoad.NotificationBoxType = NotificationBoxType.Danger;\n                                    nbBlockLoad.Text = string.Format( \"Error Loading Block: {0}\", block.Name );\n                                    nbBlockLoad.Details = string.Format( \"{0}<pre>{1}</pre>\", HttpUtility.HtmlEncode( ex.Message ), HttpUtility.HtmlEncode( ex.StackTrace ) );\n                                    nbBlockLoad.Dismissable = true;\n                                    control = nbBlockLoad;\n\n                                    if ( this.IsPostBack )\n                                    {\n                                        // throw an error on PostBack so that the ErrorPage gets shown (vs nothing happening)\n                                        throw;\n                                    }\n                                }\n                            }\n\n                            if ( control != null )\n                            {\n                                if ( canAdministrate || ( canEdit && control is RockBlockCustomSettings ) )\n                                {\n                                    canAdministrateBlockOnPage = true;\n                                }\n\n                                // If the current control is a block, set its properties\n                                var blockControl = control as RockBlock;\n                                if ( blockControl != null )\n                                {\n                                    Page.Trace.Warn( \"\\tSetting block properties\" );\n                                    blockControl.SetBlock( _pageCache, block, canEdit, canAdministrate );\n                                    control = new RockBlockWrapper( blockControl );\n\n                                    // Add any breadcrumbs to current page reference that the block creates\n                                    Page.Trace.Warn( \"\\tAdding any breadcrumbs from block\" );\n                                    if ( block.BlockLocation == BlockLocation.Page )\n                                    {\n                                        blockControl.GetBreadCrumbs( PageReference ).ForEach( c => PageReference.BreadCrumbs.Add( c ) );\n                                    }\n\n                                    // If the blocktype's security actions have not yet been loaded, load them now\n                                    block.BlockType.SetSecurityActions( blockControl );\n                                }\n\n                                if ( control is RockBlockTypeWrapper wrapper )\n                                {\n                                    // If the blocktype's security actions have not yet been loaded, load them now\n                                    block.BlockType.SetSecurityActions( wrapper.Block.GetType() );\n                                }\n                            }\n\n                            zone.Controls.Add( control );\n                            if ( control is RockBlockWrapper )\n                            {\n                                ( (RockBlockWrapper)control ).EnsureBlockControls();\n                            }\n\n                            if ( showDebugTimings )\n                            {\n                                stopwatchBlockInit.Stop();\n                                slDebugTimings.AppendFormat(\n                                    \"create/init block {0} <span class='label label-{2}'>[{1}ms]</span>\\n\",\n                                    block.Name,\n                                    stopwatchBlockInit.Elapsed.TotalMilliseconds,\n                                    stopwatchBlockInit.Elapsed.TotalMilliseconds > 500 ? \"danger\" : \"info\");\n                            }\n                        }\n                    }\n\n                    // Make the last crumb for this page the active one\n                    Page.Trace.Warn( \"Setting active breadcrumb\" );\n                    if ( PageReference.BreadCrumbs.Any() )\n                    {\n                        PageReference.BreadCrumbs.Last().Active = true;\n                    }\n\n                    Page.Trace.Warn( \"Getting parent page references\" );\n                    var pageReferences = PageReference.GetParentPageReferences( this, _pageCache, PageReference );\n                    pageReferences.Add( PageReference );\n                    PageReference.SavePageReferences( pageReferences );\n\n                    // Update breadcrumbs\n                    Page.Trace.Warn( \"Updating breadcrumbs\" );\n                    BreadCrumbs = new List<BreadCrumb>();\n                    foreach ( var pageReference in pageReferences )\n                    {\n                        pageReference.BreadCrumbs.ForEach( c => BreadCrumbs.Add( c ) );\n                    }\n\n                    // Add the page admin footer if the user is authorized to edit the page\n                    if ( _pageCache.IncludeAdminFooter && ( canAdministratePage || canAdministrateBlockOnPage || canEditPage ) )\n                    {\n                        // Add the page admin script\n                        AddScriptLink( Page, \"~/Scripts/Bundles/RockAdmin\", false );\n\n                        Page.Trace.Warn( \"Adding admin footer to page\" );\n                        HtmlGenericControl adminFooter = new HtmlGenericControl( \"div\" );\n                        adminFooter.ID = \"cms-admin-footer\";\n                        adminFooter.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                        this.Form.Controls.Add( adminFooter );\n\n                        phLoadStats = new PlaceHolder();\n                        adminFooter.Controls.Add( phLoadStats );\n\n                        // If the current user is Impersonated by another user, show a link on the admin bar to login back in as the original user\n                        var impersonatedByUser = Session[\"ImpersonatedByUser\"] as UserLogin;\n                        var currentUserIsImpersonated = ( HttpContext.Current?.User?.Identity?.Name ?? string.Empty ).StartsWith( \"rckipid=\" );\n                        if ( canAdministratePage && currentUserIsImpersonated && impersonatedByUser != null)\n                        {\n                            HtmlGenericControl impersonatedByUserDiv = new HtmlGenericControl( \"span\" );\n                            impersonatedByUserDiv.AddCssClass( \"label label-default margin-l-md\" );\n                            _btnRestoreImpersonatedByUser = new LinkButton();\n                            _btnRestoreImpersonatedByUser.ID = \"_btnRestoreImpersonatedByUser\";\n                            //_btnRestoreImpersonatedByUser.CssClass = \"btn\";\n                            _btnRestoreImpersonatedByUser.Visible = impersonatedByUser != null;\n                            _btnRestoreImpersonatedByUser.Click += _btnRestoreImpersonatedByUser_Click;\n                            _btnRestoreImpersonatedByUser.Text = $\"<i class='fa-fw fa fa-unlock'></i> \"+ $\"Restore { impersonatedByUser?.Person?.ToString()}\";\n                            impersonatedByUserDiv.Controls.Add( _btnRestoreImpersonatedByUser );\n                            adminFooter.Controls.Add( impersonatedByUserDiv );\n                        }\n\n                        HtmlGenericControl buttonBar = new HtmlGenericControl( \"div\" );\n                        adminFooter.Controls.Add( buttonBar );\n                        buttonBar.Attributes.Add( \"class\", \"button-bar\" );\n\n                        // RockBlock Config\n                        if ( canAdministratePage || canAdministrateBlockOnPage )\n                        {\n                            HtmlGenericControl aBlockConfig = new HtmlGenericControl( \"a\" );\n                            buttonBar.Controls.Add( aBlockConfig );\n                            aBlockConfig.Attributes.Add( \"class\", \"btn block-config\" );\n                            aBlockConfig.Attributes.Add( \"href\", \"javascript: Rock.admin.pageAdmin.showBlockConfig();\" );\n                            aBlockConfig.Attributes.Add( \"Title\", \"Block Configuration\" );\n                            HtmlGenericControl iBlockConfig = new HtmlGenericControl( \"i\" );\n                            aBlockConfig.Controls.Add( iBlockConfig );\n                            iBlockConfig.Attributes.Add( \"class\", \"fa fa-th-large\" );\n                        }\n\n                        if ( canEditPage || canAdministratePage)\n                        {\n                            // RockPage Properties\n                            HtmlGenericControl aPageProperties = new HtmlGenericControl( \"a\" );\n                            buttonBar.Controls.Add( aPageProperties );\n                            aPageProperties.ID = \"aPageProperties\";\n                            aPageProperties.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                            aPageProperties.Attributes.Add( \"class\", \"btn properties\" );\n                            aPageProperties.Attributes.Add( \"href\", \"javascript: Rock.controls.modal.show($(this), '\" + ResolveUrl( string.Format( \"~/PageProperties/{0}?t=Page Properties\", _pageCache.Id ) ) + \"')\" );\n                            aPageProperties.Attributes.Add( \"Title\", \"Page Properties\" );\n                            HtmlGenericControl iPageProperties = new HtmlGenericControl( \"i\" );\n                            aPageProperties.Controls.Add( iPageProperties );\n                            iPageProperties.Attributes.Add( \"class\", \"fa fa-cog\" );\n                        }\n\n                        if ( canAdministratePage )\n                        {\n                            // Child Pages\n                            HtmlGenericControl aChildPages = new HtmlGenericControl( \"a\" );\n                            buttonBar.Controls.Add( aChildPages );\n                            aChildPages.ID = \"aChildPages\";\n                            aChildPages.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                            aChildPages.Attributes.Add( \"class\", \"btn page-child-pages\" );\n                            aChildPages.Attributes.Add( \"href\", \"javascript: Rock.controls.modal.show($(this), '\" + ResolveUrl( string.Format( \"~/pages/{0}?t=Child Pages&pb=&sb=Done\", _pageCache.Id ) ) + \"')\" );\n                            aChildPages.Attributes.Add( \"Title\", \"Child Pages\" );\n                            HtmlGenericControl iChildPages = new HtmlGenericControl( \"i\" );\n                            aChildPages.Controls.Add( iChildPages );\n                            iChildPages.Attributes.Add( \"class\", \"fa fa-sitemap\" );\n\n                            // RockPage Zones\n                            HtmlGenericControl aPageZones = new HtmlGenericControl( \"a\" );\n                            buttonBar.Controls.Add( aPageZones );\n                            aPageZones.Attributes.Add( \"class\", \"btn page-zones\" );\n                            aPageZones.Attributes.Add( \"href\", \"javascript: Rock.admin.pageAdmin.showPageZones();\" );\n                            aPageZones.Attributes.Add( \"Title\", \"Page Zones\" );\n                            HtmlGenericControl iPageZones = new HtmlGenericControl( \"i\" );\n                            aPageZones.Controls.Add( iPageZones );\n                            iPageZones.Attributes.Add( \"class\", \"fa fa-columns\" );\n\n                            // RockPage Security\n                            HtmlGenericControl aPageSecurity = new HtmlGenericControl( \"a\" );\n                            buttonBar.Controls.Add( aPageSecurity );\n                            aPageSecurity.ID = \"aPageSecurity\";\n                            aPageSecurity.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                            aPageSecurity.Attributes.Add( \"class\", \"btn page-security\" );\n                            aPageSecurity.Attributes.Add( \"href\", \"javascript: Rock.controls.modal.show($(this), '\" + ResolveUrl( string.Format( \"~/Secure/{0}/{1}?t=Page Security&pb=&sb=Done\",\n                                EntityTypeCache.Get( typeof( Rock.Model.Page ) ).Id, _pageCache.Id ) ) + \"')\" );\n                            aPageSecurity.Attributes.Add( \"Title\", \"Page Security\" );\n                            HtmlGenericControl iPageSecurity = new HtmlGenericControl( \"i\" );\n                            aPageSecurity.Controls.Add( iPageSecurity );\n                            iPageSecurity.Attributes.Add( \"class\", \"fa fa-lock\" );\n\n                            // ShorLink Properties\n                            HtmlGenericControl aShortLink = new HtmlGenericControl( \"a\" );\n                            buttonBar.Controls.Add( aShortLink );\n                            aShortLink.ID = \"aShortLink\";\n                            aShortLink.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                            aShortLink.Attributes.Add( \"class\", \"btn properties\" );\n                            aShortLink.Attributes.Add( \"href\", \"javascript: Rock.controls.modal.show($(this), '\" +\n                                ResolveUrl( string.Format( \"~/ShortLink/{0}?t=Shortened Link&url={1}\", _pageCache.Id, Server.UrlEncode( HttpContext.Current.Request.Url.AbsoluteUri.ToString() ) ) )\n                                + \"')\" );\n                            aShortLink.Attributes.Add( \"Title\", \"Add Short Link\" );\n                            HtmlGenericControl iShortLink = new HtmlGenericControl( \"i\" );\n                            aShortLink.Controls.Add( iShortLink );\n                            iShortLink.Attributes.Add( \"class\", \"fa fa-link\" );\n\n                            // System Info\n                            HtmlGenericControl aSystemInfo = new HtmlGenericControl( \"a\" );\n                            buttonBar.Controls.Add( aSystemInfo );\n                            aSystemInfo.ID = \"aSystemInfo\";\n                            aSystemInfo.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                            aSystemInfo.Attributes.Add( \"class\", \"btn system-info\" );\n                            aSystemInfo.Attributes.Add( \"href\", \"javascript: Rock.controls.modal.show($(this), '\" + ResolveUrl( \"~/SystemInfo?t=System Information&pb=&sb=Done\" ) + \"')\" );\n                            aSystemInfo.Attributes.Add( \"Title\", \"Rock Information\" );\n                            HtmlGenericControl iSystemInfo = new HtmlGenericControl( \"i\" );\n                            aSystemInfo.Controls.Add( iSystemInfo );\n                            iSystemInfo.Attributes.Add( \"class\", \"fa fa-info-circle\" );\n                        }\n                    }\n\n                    // Check to see if page output should be cached.  The RockRouteHandler\n                    // saves the PageCacheData information for the current page to memorycache\n                    // so it should always exist\n                    if ( _pageCache.OutputCacheDuration > 0 )\n                    {\n                        Response.Cache.SetCacheability( System.Web.HttpCacheability.Public );\n                        Response.Cache.SetExpires( RockDateTime.Now.AddSeconds( _pageCache.OutputCacheDuration ) );\n                        Response.Cache.SetValidUntilExpires( true );\n                    }\n                }\n\n                stopwatchInitEvents.Restart();\n\n                string pageTitle = BrowserTitle ?? string.Empty;\n                string siteTitle = _pageCache.Layout.Site.Name;\n                string seperator = pageTitle.Trim() != string.Empty && siteTitle.Trim() != string.Empty ? \" | \" : \"\";\n\n                base.Title = pageTitle + seperator + siteTitle;\n\n                if ( !string.IsNullOrWhiteSpace( _pageCache.Description ) )\n                {\n                    HtmlMeta metaTag = new HtmlMeta();\n                    metaTag.Attributes.Add( \"name\", \"description\" );\n                    metaTag.Attributes.Add( \"content\", _pageCache.Description.Trim() );\n                    AddMetaTag( this.Page, metaTag );\n                }\n\n                if ( !string.IsNullOrWhiteSpace( _pageCache.KeyWords ) )\n                {\n                    HtmlMeta metaTag = new HtmlMeta();\n                    metaTag.Attributes.Add( \"name\", \"keywords\" );\n                    metaTag.Attributes.Add( \"content\", _pageCache.KeyWords.Trim() );\n                    AddMetaTag( this.Page, metaTag );\n                }\n\n                if (!string.IsNullOrWhiteSpace( _pageCache.Layout.Site.PageHeaderContent ))\n                {\n                    Page.Header.Controls.Add( new LiteralControl( _pageCache.Layout.Site.PageHeaderContent ) );\n                }\n\n                if ( !string.IsNullOrWhiteSpace( _pageCache.HeaderContent ) )\n                {\n                    Page.Header.Controls.Add( new LiteralControl( _pageCache.HeaderContent ) );\n                }\n\n                if ( !_pageCache.AllowIndexing || !_pageCache.Layout.Site.AllowIndexing )\n                {\n                    Page.Header.Controls.Add( new LiteralControl( \"<meta name=\\\"robots\\\" content=\\\"noindex, nofollow\\\"/>\" ) );\n                }\n\n                if ( showDebugTimings )\n                {\n                    TimeSpan tsDuration = RockDateTime.Now.Subtract( (DateTime)Context.Items[\"Request_Start_Time\"] );\n                    slDebugTimings.AppendFormat( \"done oninit [{0}ms] @ {1} \\n\", stopwatchInitEvents.Elapsed.TotalMilliseconds, tsDuration.TotalMilliseconds );\n                    stopwatchInitEvents.Restart();\n                }\n\n                if ( showDebugTimings && canAdministratePage )\n                {\n                    Page.Form.Controls.Add( new Label\n                    {\n                        ID=\"lblShowDebugTimings\",\n                        Text = string.Format( \"<pre>{0}</pre>\", slDebugTimings.ToString() )\n                    } );\n                }\n            }\n        }\n\n\n        /// <summary>\n        /// The verify block type instance properties lock object\n        /// </summary>\n        private static readonly object _verifyBlockTypeInstancePropertiesLockObj = new object();\n\n        /// <summary>\n        /// Verifies the block type instance properties.\n        /// </summary>\n        private void VerifyBlockTypeInstanceProperties()\n        {\n            var blockTypesIdToVerify = _pageCache.Blocks.Select( a => a.BlockType ).Distinct().Where( a => a.IsInstancePropertiesVerified == false ).Select( a => a.Id ).ToList();\n            foreach ( int blockTypeId in blockTypesIdToVerify )\n            {\n                Page.Trace.Warn( \"\\tCreating block attributes\" );\n\n                try\n                {\n                    if ( BlockTypeCache.Get( blockTypeId )?.IsInstancePropertiesVerified == false )\n                    {\n                        // make sure that only one thread is trying to compile block properties so that we don't get collisions and unneeded compiler overhead\n                        lock ( _verifyBlockTypeInstancePropertiesLockObj )\n                        {\n                            if ( BlockTypeCache.Get( blockTypeId )?.IsInstancePropertiesVerified == false )\n                            {\n                                using ( var rockContext = new RockContext() )\n                                {\n                                    var blockTypeCache = BlockTypeCache.Get( blockTypeId );\n                                    Type blockCompiledType = blockTypeCache.GetCompiledType();\n\n                                    bool attributesUpdated = RockBlock.CreateAttributes( rockContext, blockCompiledType, blockTypeId );\n                                    BlockTypeCache.Get( blockTypeId )?.MarkInstancePropertiesVerified( true );\n                                }\n                            }\n                        }\n                    }\n                }\n                catch\n                {\n                    // ignore if the block couldn't be compiled, it'll get logged and shown when the page tries to load the block into the page\n                }\n            }\n        }\n\n        /// <summary>\n        /// Raises the <see cref=\"E:System.Web.UI.Page.LoadComplete\" /> event at the end of the page load stage.\n        /// </summary>\n        /// <param name=\"e\">An <see cref=\"T:System.EventArgs\" /> that contains the event data.</param>\n        protected override void OnLoadComplete( EventArgs e )\n        {\n            base.OnLoadComplete( e );\n\n            // create a page view transaction if enabled\n            // moved this from OnLoad so we could get the updated title (if Lava or the block changed it)\n            if ( !Page.IsPostBack && _pageCache != null )\n            {\n                if ( _pageCache.Layout.Site.EnablePageViews )\n                {\n                    var pageViewTransaction = new InteractionTransaction( DefinedValueCache.Get( Rock.SystemGuid.DefinedValue.INTERACTIONCHANNELTYPE_WEBSITE ), this.Site, this._pageCache );\n                    pageViewTransaction.Enqueue();\n                }\n            }\n        }\n\n        /// <summary>\n        /// Handles the Click event of the _btnRestoreImpersonatedByUser control.\n        /// </summary>\n        /// <param name=\"sender\">The source of the event.</param>\n        /// <param name=\"e\">The <see cref=\"EventArgs\"/> instance containing the event data.</param>\n        private void _btnRestoreImpersonatedByUser_Click( object sender, EventArgs e )\n        {\n            var impersonatedByUser = Session[\"ImpersonatedByUser\"] as UserLogin;\n            if ( impersonatedByUser != null )\n            {\n                Authorization.SignOut();\n                UserLoginService.UpdateLastLogin( impersonatedByUser.UserName );\n                Rock.Security.Authorization.SetAuthCookie( impersonatedByUser.UserName, false, false );\n                Response.Redirect( PageReference.BuildUrl( true ), false );\n                Context.ApplicationInstance.CompleteRequest();\n            }\n        }\n\n        /// <summary>\n        /// Checks for and processes any impersonation parameters\n        /// Returns False if an invalid token was specified\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        private bool ProcessImpersonation( RockContext rockContext )\n        {\n            string impersonatedPersonKeyParam = PageParameter( \"rckipid\" );\n            string impersonatedPersonKeyIdentity = string.Empty;\n            if ( HttpContext.Current?.User?.Identity?.Name != null )\n            {\n                if ( HttpContext.Current.User.Identity.Name.StartsWith( \"rckipid=\" ) )\n                {\n                    // get the impersonatedPersonKey from the Auth ticket\n                    impersonatedPersonKeyIdentity = HttpContext.Current.User.Identity.Name.Substring( 8 );\n                }\n            }\n\n            // if there is a impersonatedPersonKeyParam specified, and it isn't already associated with the current HttpContext.Current.User.Identity,\n            // then set the currentuser and ticket using the impersonatedPersonKeyParam\n            if ( !string.IsNullOrEmpty( impersonatedPersonKeyParam ) && impersonatedPersonKeyParam != impersonatedPersonKeyIdentity )\n            {\n                Rock.Model.PersonService personService = new Model.PersonService( rockContext );\n\n                Rock.Model.Person impersonatedPerson = personService.GetByImpersonationToken( impersonatedPersonKeyParam, true, this.PageId );\n                if ( impersonatedPerson != null )\n                {\n                    Authorization.SignOut();\n                    Rock.Security.Authorization.SetAuthCookie( \"rckipid=\" + impersonatedPersonKeyParam, false, true );\n                    CurrentUser = impersonatedPerson.GetImpersonatedUser();\n                    UserLoginService.UpdateLastLogin( \"rckipid=\" + impersonatedPersonKeyParam );\n\n                    // reload page as the impersonated user (we probably could remove the token from the URL, but some blocks might be looking for rckipid in the PageParameters, so just leave it)\n                    Response.Redirect( Request.RawUrl, false );\n                    Context.ApplicationInstance.CompleteRequest();\n                }\n                else\n                {\n                    // Attempting to use an impersonation token that doesn't exist or is no longer valid, so log them out\n                    Authorization.SignOut();\n                    Session[\"InvalidPersonToken\"] = true;\n                    Response.Redirect( PageReference.BuildUrl( true ), false );\n                    Context.ApplicationInstance.CompleteRequest();\n                    return false;\n                }\n            }\n            else if ( !string.IsNullOrEmpty( impersonatedPersonKeyIdentity ) )\n            {\n                if ( !this.IsPostBack )\n                {\n                    var impersonationToken = impersonatedPersonKeyIdentity;\n                    var personToken = new PersonTokenService( rockContext ).GetByImpersonationToken( impersonationToken );\n                    if ( personToken != null )\n                    {\n                        // attempting to use a page specific impersonation token for a different page, so log them out\n                        if ( personToken.PageId.HasValue && personToken.PageId != this.PageId )\n                        {\n                            Authorization.SignOut();\n                            Session[\"InvalidPersonToken\"] = true;\n                            Response.Redirect( Request.RawUrl, false );\n                            Context.ApplicationInstance.CompleteRequest();\n                            return false;\n                        }\n                    }\n                }\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Adds the google maps javascript API to the page\n        /// </summary>\n        public void LoadGoogleMapsApi()\n        {\n            var googleAPIKey = GlobalAttributesCache.Get().GetValue( \"GoogleAPIKey\" );\n            string keyParameter = string.IsNullOrWhiteSpace( googleAPIKey ) ? \"\" : string.Format( \"key={0}&\", googleAPIKey );\n            string scriptUrl = string.Format( \"https://maps.googleapis.com/maps/api/js?{0}libraries=drawing,visualization,geometry\", keyParameter );\n\n            // first, add it to the page to handle cases where the api is needed on first page load\n            if ( this.Page != null && this.Page.Header != null )\n            {\n                var control = new LiteralControl();\n                control.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n\n                // note: ID must match the what it is called in \\RockWeb\\Scripts\\Rock\\Controls\\util.js\n                control.ID = \"googleMapsApi\";\n                control.Text = string.Format( \"<script id=\\\"googleMapsApi\\\" src=\\\"{0}\\\" ></script>\", scriptUrl );\n                if ( !this.Page.Header.Controls.OfType<LiteralControl>().Any( a => a.ID == control.ID ) )\n                {\n                    this.Page.Header.Controls.Add( control );\n                }\n            }\n\n            // also, do this in cases where the api is added on a postback, and the above didn't end up getting rendered\n            if ( !ClientScript.IsStartupScriptRegistered( \"googleMapsApiScript\" ) )\n            {\n                string script = string.Format( @\"Rock.controls.util.loadGoogleMapsApi('{0}');\", scriptUrl );\n                ScriptManager.RegisterStartupScript( this.Page, this.Page.GetType(), \"googleMapsApiScript\", script, true );\n            }\n        }\n\n        /// <summary>\n        /// Raises the <see cref=\"E:System.Web.UI.Control.Load\"/> event.\n        /// </summary>\n        /// <param name=\"e\">The <see cref=\"T:System.EventArgs\"/> object that contains the event data.</param>\n        protected override void OnLoad( EventArgs e )\n        {\n            Stopwatch onLoadStopwatch = Stopwatch.StartNew();\n\n            base.OnLoad( e );\n\n            Page.Header.DataBind();\n\n            try\n            {\n                bool showDebugTimings = this.PageParameter( \"ShowDebugTimings\" ).AsBoolean();\n                if ( showDebugTimings && onLoadStopwatch.Elapsed.TotalMilliseconds > 500 )\n                {\n                    if ( _pageCache.IsAuthorized( Authorization.ADMINISTRATE, CurrentPerson ) )\n                    {\n                        Page.Form.Controls.Add( new Literal\n                        {\n\n                            Text = string.Format( \"OnLoad [{0}ms]\", onLoadStopwatch.Elapsed.TotalMilliseconds )\n                        } );\n                    }\n                }\n            }\n            catch\n            {\n                // ignore\n            }\n        }\n\n        /// <summary>\n        /// Raises the <see cref=\"E:System.Web.UI.Page.SaveStateComplete\" /> event after the page state has been saved to the persistence medium.\n        /// </summary>\n        /// <param name=\"e\">A <see cref=\"T:System.EventArgs\" /> object containing the event data.</param>\n        protected override void OnSaveStateComplete( EventArgs e )\n        {\n            base.OnSaveStateComplete( e );\n\n            if ( phLoadStats != null )\n            {\n                TimeSpan tsDuration = RockDateTime.Now.Subtract( (DateTime)Context.Items[\"Request_Start_Time\"] );\n\n                var customPersister = this.PageStatePersister as RockHiddenFieldPageStatePersister;\n\n                if ( customPersister != null )\n                {\n                    this.ViewStateSize = customPersister.ViewStateSize;\n                    this.ViewStateSizeCompressed = customPersister.ViewStateSizeCompressed;\n                    this.ViewStateIsCompressed = customPersister.ViewStateIsCompressed;\n                }\n\n                phLoadStats.Controls.Add( new LiteralControl( $\"<span>Page Load Time: {tsDuration.TotalSeconds:N2}s </span><span class='margin-l-md js-view-state-stats'></span> <span class='margin-l-md js-html-size-stats'></span>\" ) );\n\n                if ( !ClientScript.IsStartupScriptRegistered( \"rock-js-view-state-size\" ) )\n                {\n                    string script = @\"\nSys.Application.add_load(function () {\n    if ($('#__CVIEWSTATESIZE').length > 0 && $('#__CVIEWSTATESIZE').val() != '0') {\n        $('.js-view-state-stats').html('ViewState Size: ' + ($('#__CVIEWSTATESIZE').val() / 1024).toFixed(0) + ' KB (' + ($('#__CVIEWSTATE').val().length / 1024).toFixed(0) + ' KB Compressed)');\n    } else {\n        $('.js-view-state-stats').html('ViewState Size: ' + ($('#__CVIEWSTATE').val().length / 1024).toFixed(0) + ' KB');\n    }\n    $('.js-html-size-stats').html('HTML Size: ' + ($('html').html().length / 1024).toFixed(0) + ' KB');\n});\n\";\n                    ClientScript.RegisterStartupScript( this.Page.GetType(), \"rock-js-view-state-size\", script, true );\n                }\n            }\n        }\n\n        #endregion\n\n        #region Public Methods\n\n        /// <summary>\n        /// Sets the page.\n        /// </summary>\n        /// <param name=\"pageCache\">The <see cref=\"PageCache\"/>.</param>\n        internal void SetPage( PageCache pageCache )\n        {\n            _pageCache = pageCache;\n\n            SaveContextItem( \"Rock:PageId\", _pageCache.Id );\n            SaveContextItem( \"Rock:LayoutId\", _pageCache.LayoutId );\n            SaveContextItem( \"Rock:SiteId\", _pageCache.Layout.SiteId );\n\n            if ( this.Master is RockMasterPage )\n            {\n                var masterPage = (RockMasterPage)this.Master;\n                masterPage.SetPage( pageCache );\n            }\n        }\n\n        /// <summary>\n        /// Returns the current page's first value for the selected attribute\n        /// If the attribute doesn't exist, null is returned\n        /// </summary>\n        /// <param name=\"key\">A <see cref=\"System.String\"/> representing the argument key.</param>\n        /// <returns>A <see cref=\"System.String\" /> representing the first attribute value, if the attribute doesn't exist, null is returned.</returns>\n        public string GetAttributeValue( string key )\n        {\n            if ( _pageCache != null )\n            {\n                return _pageCache.GetAttributeValue( key );\n            }\n            return null;\n        }\n\n        /// <summary>\n        /// Returns the current page's values for the selected attribute.\n        /// If the attribute doesn't exist an empty list is returned.\n        /// </summary>\n        /// <param name=\"key\"> A <see cref=\"System.String\"/> representing the key of the selected attribute\n        /// </param>\n        /// <returns>A <see cref=\"System.Collections.Generic.List{String}\"/> containing the attribute values for specified key or an empty list if none exists</returns>\n        public List<string> GetAttributeValues( string key )\n        {\n            if ( _pageCache != null )\n            {\n                return _pageCache.GetAttributeValues( key );\n            }\n\n            return new List<string>();\n        }\n\n        #region HtmlLinks\n\n        /// <summary>\n        /// Adds a new CSS link that will be added to the page header prior to the page being rendered\n        /// </summary>\n        /// <param name=\"href\">A <see cref=\"System.String\" /> representing the path to css file.  Should be relative to layout template.  Will be resolved at runtime.</param>\n        /// <param name=\"fingerprint\">if set to <c>true</c> [fingerprint].</param>\n        public void AddCSSLink( string href, bool fingerprint = true )\n        {\n            RockPage.AddCSSLink( this, href, fingerprint );\n        }\n\n        /// <summary>\n        /// Adds the CSS link to the page\n        /// </summary>\n        /// <param name=\"href\">A <see cref=\"System.String\" /> representing the path to css file.  Should be relative to layout template.  Will be resolved at runtime</param>\n        /// <param name=\"mediaType\">A <see cref=\"System.String\" /> representing the type of the media to use for the css link.</param>\n        /// <param name=\"fingerprint\">if set to <c>true</c> [fingerprint].</param>\n        public void AddCSSLink( string href, string mediaType, bool fingerprint = true )\n        {\n            RockPage.AddCSSLink( this, href, mediaType, fingerprint );\n        }\n\n        /// <summary>\n        /// Adds a meta tag to the page header prior to the page being rendered\n        /// </summary>\n        /// <param name=\"htmlMeta\">The <see cref=\"System.Web.UI.HtmlControls.HtmlMeta\"/> tag.</param>\n        public void AddMetaTag( HtmlMeta htmlMeta )\n        {\n            RockPage.AddMetaTag( this, htmlMeta );\n        }\n\n        /// <summary>\n        /// Adds a new Html literal link that will be added to the page header prior to the page being rendered.\n        /// </summary>\n        /// <param name=\"htmlLink\">The <see cref=\"System.Web.UI.WebControls.Literal\"/>.</param>\n        private void AddHtmlLink( Literal htmlLink )\n        {\n            RockPage.AddHtmlLink( this, htmlLink );\n        }\n\n        /// <summary>\n        /// Adds a new Html link that will be added to the page header prior to the page being rendered.\n        /// </summary>\n        /// <param name=\"htmlLink\">The <see cref=\"System.Web.UI.HtmlControls.HtmlLink\"/>.</param>\n        public void AddHtmlLink( HtmlLink htmlLink )\n        {\n            RockPage.AddHtmlLink( this, htmlLink );\n        }\n\n        /// <summary>\n        /// Adds a new script tag to the page body prior to the page being rendered.\n        /// </summary>\n        /// <param name=\"path\">A <see cref=\"System.String\" /> representing the path to the script link.</param>\n        /// <param name=\"fingerprint\">if set to <c>true</c> [fingerprint].</param>\n        public void AddScriptLink( string path, bool fingerprint = true )\n        {\n            RockPage.AddScriptLink( this, path, fingerprint );\n        }\n\n        /// <summary>\n        /// Adds the google analytics script\n        /// </summary>\n        /// <param name=\"code\">The GoogleAnalyticsCode.</param>\n        private void AddGoogleAnalytics( string code )\n        {\n            try\n            {\n                string scriptTemplate = Application[\"GoogleAnalyticsScript\"] as string;\n                if ( scriptTemplate == null )\n                {\n                    string scriptFile = MapPath( \"~/Assets/Misc/GoogleAnalytics.txt\" );\n                    if ( File.Exists( scriptFile ) )\n                    {\n                        scriptTemplate = File.ReadAllText( scriptFile );\n                        Application[\"GoogleAnalyticsScript\"] = scriptTemplate;\n                    }\n                }\n\n                if ( scriptTemplate != null )\n                {\n                    string script = scriptTemplate.Contains( \"{0}\" ) ? string.Format( scriptTemplate, code ) : scriptTemplate;\n                    AddScriptToHead( this.Page, script, true );\n                }\n            }\n            catch ( Exception ex )\n            {\n                LogException( ex );\n            }\n        }\n\n        /// <summary>\n        /// Adds an icon icon (favicon) link using a binary file id.\n        /// </summary>\n        /// <param name=\"binaryFileId\">The binary file identifier.</param>\n        /// <param name=\"size\">The size.</param>\n        /// <param name=\"rel\">The relative.</param>\n        /// <returns></returns>\n        public void AddIconLink( int binaryFileId, int size, string rel = \"apple-touch-icon-precomposed\" )\n        {\n            Literal favIcon = new Literal();\n            favIcon.Mode = LiteralMode.PassThrough;\n            var url = ResolveRockUrl( $\"~/GetImage.ashx?id={binaryFileId}&width={size}&height={size}&mode=crop&format=png\" );\n            favIcon.Text = $\"<link rel=\\\"{rel}\\\" sizes=\\\"{size}x{size}\\\" href=\\\"{url}\\\" />\";\n\n            AddHtmlLink( favIcon );\n        }\n\n        #endregion\n\n        /// <summary>\n        /// Hides any secondary blocks.\n        /// </summary>\n        /// <param name=\"caller\">The <see cref=\"Rock.Web.UI.RockBlock\"/> that is the caller</param>\n        /// <param name=\"hidden\">A <see cref=\"System.Boolean\"/> value that signifies if secondary blocks should be hidden.</param>\n        public void HideSecondaryBlocks( RockBlock caller, bool hidden )\n        {\n            foreach ( ISecondaryBlock secondaryBlock in this.RockBlocks.Where( a => a is ISecondaryBlock ) )\n            {\n                if ( secondaryBlock != caller )\n                {\n                    secondaryBlock.SetVisible( !hidden );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Disables the idle redirect blocks if disable = true, or re-enables them if disable = false\n        /// </summary>\n        /// <param name=\"caller\">The caller.</param>\n        /// <param name=\"disable\">if set to <c>true</c> [disable].</param>\n        public void DisableIdleRedirectBlocks( RockBlock caller, bool disable )\n        {\n            foreach (  IIdleRedirectBlock idleRedirectBlock in this.RockBlocks.Where( a => a is IIdleRedirectBlock ) )\n            {\n                if ( idleRedirectBlock != caller )\n                {\n                    idleRedirectBlock.Disable( disable );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Logs the exception.\n        /// </summary>\n        /// <param name=\"ex\">The <see cref=\"System.Exception\"/> to log.</param>\n        public void LogException( Exception ex )\n        {\n            ExceptionLogService.LogException( ex, Context, _pageCache.Id, _pageCache.Layout.SiteId, CurrentPersonAlias );\n        }\n\n        /// <summary>\n        /// Adds a history point to the ScriptManager.\n        /// Note: ScriptManager's EnableHistory property must be set to True\n        /// </summary>\n        /// <param name=\"key\">A <see cref=\"System.String\"/> representing the key to use for the history point.</param>\n        /// <param name=\"state\">A <see cref=\"System.String\"/> representing any state information to store for the history point.</param>\n        /// <param name=\"title\">A <see cref=\"System.String\"/> representing the title to be used by the browser, will use an empty string by default.</param>\n        public void AddHistory( string key, string state, string title = \"\" )\n        {\n            if ( ScriptManager.GetCurrent( Page ) != null )\n            {\n                ScriptManager sManager = ScriptManager.GetCurrent( Page );\n                if ( string.IsNullOrWhiteSpace( title ) )\n                {\n                    sManager.AddHistoryPoint( key, state );\n                }\n                else\n                {\n                    sManager.AddHistoryPoint( key, state, title );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Returns a resolved Rock URL.  Similar to\n        /// <see cref=\"System.Web.UI.Control\">System.Web.UI.Control's</see>\n        /// <c>ResolveUrl</c> method except that you can prefix\n        /// a url with '~~' to indicate a virtual path to Rock's current theme root folder.\n        /// </summary>\n        /// <param name=\"url\">A <see cref=\"System.String\" /> representing the URL to resolve.</param>\n        /// <returns>\n        /// A <see cref=\"System.String\" /> with the resolved URL.\n        /// </returns>\n        public string ResolveRockUrl( string url )\n        {\n            string themeUrl = url;\n            if ( url.StartsWith( \"~~\" ) )\n            {\n                themeUrl = \"~/Themes/\" + _pageCache.Layout.Site.Theme + ( url.Length > 2 ? url.Substring( 2 ) : string.Empty );\n            }\n\n            return ResolveUrl( themeUrl );\n        }\n\n        /// <summary>\n        /// Resolves the rock URL and includes root.\n        /// </summary>\n        /// <param name=\"url\">The URL.</param>\n        /// <returns></returns>\n        public string ResolveRockUrlIncludeRoot( string url )\n        {\n            string virtualPath = this.ResolveRockUrl( url );\n            if ( Context.Request != null && Context.Request.Url != null )\n            {\n                return string.Format( \"{0}://{1}{2}\", Context.Request.Url.Scheme, Context.Request.Url.Authority, virtualPath );\n            }\n\n            return GlobalAttributesCache.Get().GetValue(\"PublicApplicationRoot\").EnsureTrailingForwardslash() + virtualPath.RemoveLeadingForwardslash();\n        }\n\n        /// <summary>\n        /// Resolves the rock URL.\n        /// </summary>\n        /// <param name=\"url\">The URL.</param>\n        /// <param name=\"fingerprint\">if set to <c>true</c> [fingerprint].</param>\n        /// <returns></returns>\n        public string ResolveRockUrl( string url, bool fingerprint )\n        {\n            var resolvedUrl = this.ResolveRockUrl( url );\n\n            if ( fingerprint )\n            {\n                resolvedUrl = Fingerprint.Tag( resolvedUrl );\n            }\n\n            return resolvedUrl;\n        }\n\n        /// <summary>\n        /// Gets the context entity types.\n        /// </summary>\n        /// <returns></returns>\n        public List<EntityTypeCache> GetContextEntityTypes()\n        {\n            var result = new List<EntityTypeCache>();\n\n            if ( this.ModelContext != null )\n            {\n                foreach ( var item in this.ModelContext.Keys )\n                {\n                    var entityType = EntityTypeCache.Get( item );\n                    if ( entityType != null )\n                    {\n                        result.Add( entityType );\n                    }\n                }\n            }\n            return result;\n        }\n\n        /// <summary>\n        /// Gets the current context object for a given entity type.\n        /// </summary>\n        /// <param name=\"entity\">The <see cref=\"EntityTypeCache\"/> containing a reference to the entity.</param>\n        /// <returns>An object that implements the <see cref=\"Rock.Data.IEntity\"/> interface referencing the context object. </returns>\n        public Rock.Data.IEntity GetCurrentContext( EntityTypeCache entity )\n        {\n            if ( this.ModelContext.ContainsKey( entity.Name ) )\n            {\n                var keyModel = this.ModelContext[entity.Name];\n\n                if ( keyModel.Entity == null )\n                {\n                    if ( entity.Name.Equals( \"Rock.Model.Person\", StringComparison.OrdinalIgnoreCase ) )\n                    {\n                        if ( string.IsNullOrWhiteSpace( keyModel.Key ) )\n                        {\n                            keyModel.Entity = new PersonService( new RockContext() )\n                                .Queryable( true, true )\n                                .Include( p => p.MaritalStatusValue)\n                                .Include( p => p.ConnectionStatusValue )\n                                .Include( p => p.RecordStatusValue )\n                                .Include( p => p.RecordStatusReasonValue )\n                                .Include( p => p.RecordTypeValue )\n                                .Include( p => p.SuffixValue )\n                                .Include( p => p.TitleValue )\n                                .Include( p => p.GivingGroup )\n                                .Include( p => p.Photo )\n                                .Include( p => p.Aliases )\n                                .Where( p => p.Id == keyModel.Id ).FirstOrDefault();\n                        }\n                        else\n                        {\n                            keyModel.Entity = new PersonService( new RockContext() ).GetByPublicKey( keyModel.Key );\n                        }\n                    }\n                    else\n                    {\n\n                        Type modelType = entity.GetEntityType();\n\n                        if ( modelType == null )\n                        {\n                            // if the Type isn't found in the Rock.dll (it might be from a Plugin), lookup which assembly it is in and look in there\n                            string[] assemblyNameParts = entity.AssemblyName.Split( new char[] { ',' } );\n                            if ( assemblyNameParts.Length > 1 )\n                            {\n                                modelType = Type.GetType( string.Format( \"{0}, {1}\", entity.Name, assemblyNameParts[1] ) );\n                            }\n                        }\n\n                        if ( modelType != null )\n                        {\n                            // In the case of core Rock.dll Types, we'll just use Rock.Data.Service<> and Rock.Data.RockContext<>\n                            // otherwise find the first (and hopefully only) Service<> and dbContext we can find in the Assembly.\n                            System.Data.Entity.DbContext dbContext = Reflection.GetDbContextForEntityType( modelType );\n                            IService serviceInstance = Reflection.GetServiceForEntityType( modelType, dbContext );\n\n                            if ( string.IsNullOrWhiteSpace( keyModel.Key ) )\n                            {\n                                MethodInfo getMethod = serviceInstance.GetType().GetMethod( \"Get\", new Type[] { typeof( int ) } );\n                                keyModel.Entity = getMethod.Invoke( serviceInstance, new object[] { keyModel.Id } ) as Rock.Data.IEntity;\n                            }\n                            else\n                            {\n                                MethodInfo getMethod = serviceInstance.GetType().GetMethod( \"GetByPublicKey\" );\n                                keyModel.Entity = getMethod.Invoke( serviceInstance, new object[] { keyModel.Key } ) as Rock.Data.IEntity;\n                            }\n                        }\n\n                    }\n\n                    if ( keyModel.Entity != null && keyModel.Entity is IHasAttributes )\n                    {\n                        Attribute.Helper.LoadAttributes( keyModel.Entity as IHasAttributes );\n                    }\n\n                }\n\n                return keyModel.Entity;\n            }\n\n            return null;\n        }\n\n        /// <summary>\n        /// Sets the context cookie.\n        /// </summary>\n        /// <param name=\"entity\">The entity.</param>\n        /// <param name=\"pageSpecific\">if set to <c>true</c> [page specific].</param>\n        /// <param name=\"refreshPage\">if set to <c>true</c> [refresh page].</param>\n        public void SetContextCookie( IEntity entity, bool pageSpecific = false, bool refreshPage = true )\n        {\n            string cookieName = GetContextCookieName( pageSpecific );\n\n            var contextCookie = Request.Cookies[cookieName];\n            if ( contextCookie == null )\n            {\n                contextCookie = new HttpCookie( cookieName );\n            }\n\n            Type entityType = entity.GetType();\n            if ( entityType.IsDynamicProxyType() )\n            {\n                entityType = entityType.BaseType;\n            }\n\n            contextCookie.Values[entityType.FullName] = HttpUtility.UrlDecode( entity.ContextKey );\n            contextCookie.Expires = RockDateTime.Now.AddYears( 1 );\n\n            Response.Cookies.Add( contextCookie );\n\n            if ( refreshPage )\n            {\n                Response.Redirect( Request.RawUrl, false );\n                Context.ApplicationInstance.CompleteRequest();\n            }\n        }\n\n        /// <summary>\n        /// Clears the context cookie.\n        /// </summary>\n        /// <param name=\"entityType\">Type of the entity.</param>\n        /// <param name=\"pageSpecific\">if set to <c>true</c> [page specific].</param>\n        /// <param name=\"refreshPage\">if set to <c>true</c> [refresh page].</param>\n        public void ClearContextCookie( Type entityType, bool pageSpecific = false, bool refreshPage = true )\n        {\n            string cookieName = GetContextCookieName( pageSpecific );\n\n            var contextCookie = Request.Cookies[cookieName];\n            if ( contextCookie == null )\n            {\n                contextCookie = new HttpCookie( cookieName );\n            }\n\n            if ( entityType.IsDynamicProxyType() )\n            {\n                entityType = entityType.BaseType;\n            }\n\n            contextCookie.Values[entityType.FullName] = null;\n            contextCookie.Expires = RockDateTime.Now.AddYears( 1 );\n\n            Response.Cookies.Add( contextCookie );\n\n            if ( refreshPage )\n            {\n                Response.Redirect( Request.RawUrl, false );\n                Context.ApplicationInstance.CompleteRequest();\n            }\n        }\n\n        private void GetCookieContext( string cookieName )\n        {\n            HttpCookie cookie = null;\n            if ( Response.Cookies.AllKeys.Contains(cookieName))\n            {\n                cookie = Response.Cookies[cookieName];\n            }\n            else if ( Request.Cookies.AllKeys.Contains(cookieName))\n            {\n                cookie = Request.Cookies[cookieName];\n            }\n\n            if ( cookie != null )\n            {\n                for ( int valueIndex = 0; valueIndex < cookie.Values.Count; valueIndex++ )\n                {\n                    string cookieValue = cookie.Values[valueIndex];\n                    if ( !string.IsNullOrWhiteSpace( cookieValue ) )\n                    {\n                        try\n                        {\n                            string contextItem = Rock.Security.Encryption.DecryptString( cookieValue );\n                            string[] parts = contextItem.Split( '|' );\n                            if ( parts.Length == 2 )\n                            {\n                                ModelContext.AddOrReplace( parts[0], new Data.KeyEntity( parts[1] ) );\n                            }\n                        }\n                        catch\n                        {\n                            // intentionally ignore exception in case cookie is corrupt\n                        }\n                    }\n                }\n            }\n        }\n\n        private void HandleRockWiFiCookie( int? personAliasId )\n        {\n            if ( personAliasId == null)\n            {\n                return;\n            }\n\n            if ( Request.Cookies[\"rock_wifi\"] != null )\n            {\n                HttpCookie httpCookie = Request.Cookies[\"rock_wifi\"];\n                if ( LinkPersonAliasToDevice( ( int ) personAliasId, httpCookie.Values[\"ROCK_PERSONALDEVICE_ADDRESS\"] ) )\n                {\n                    Response.Cookies[\"rock_wifi\"].Expires = DateTime.Now.AddDays( -1 );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the name of the context cookie.\n        /// </summary>\n        /// <param name=\"pageSpecific\">if set to <c>true</c> [page specific].</param>\n        /// <returns></returns>\n        public string GetContextCookieName( bool pageSpecific )\n        {\n            return \"Rock_Context\" + ( pageSpecific ? ( \":\" + PageId.ToString() ) : \"\" );\n        }\n\n        /// <summary>\n        /// Adds an update trigger for when the block instance properties are updated.\n        /// </summary>\n        /// <param name=\"updatePanel\">The <see cref=\"System.Web.UI.UpdatePanel\"/> to add the <see cref=\"System.Web.UI.AsyncPostBackTrigger\"/> to.</param>\n        public void AddConfigurationUpdateTrigger( UpdatePanel updatePanel )\n        {\n            AsyncPostBackTrigger trigger = new AsyncPostBackTrigger();\n            trigger.ControlID = \"rock-config-trigger\";\n            trigger.EventName = \"Click\";\n            updatePanel.Triggers.Add( trigger );\n        }\n\n        /// <summary>\n        /// Links the person alias to device.\n        /// </summary>\n        /// <param name=\"personAliasId\">The person alias identifier.</param>\n        /// <param name=\"macAddress\">The mac address.</param>\n        public bool LinkPersonAliasToDevice(int personAliasId, string macAddress)\n        {\n            using ( var rockContext = new RockContext() )\n            {\n                PersonalDeviceService personalDeviceService = new PersonalDeviceService( rockContext );\n                PersonalDevice personalDevice = personalDeviceService.GetByMACAddress( macAddress );\n\n                // It's possible that the device was deleted from the DB but a cookie still exists\n                if ( personalDevice == null || personAliasId == 0 )\n                {\n                    return false;\n                }\n\n                // Assign the current Person.Alias to the device and save\n                if ( personalDevice.PersonAliasId == null || personalDevice.PersonAliasId != personAliasId )\n                {\n                    personalDevice.PersonAliasId = personAliasId;\n                    rockContext.SaveChanges();\n                }\n\n                // Update interactions for this device with this person.alias if they don't already have one.\n                InteractionService interactionService = new InteractionService( rockContext );\n                interactionService.UpdateInteractionsWithPersonAliasIdForDeviceId( personAliasId, personalDevice.Id );\n\n                return true;\n            }\n        }\n\n        #endregion\n\n        #region Cms Admin Content\n\n        /// <summary>\n        /// Adds the popup controls.\n        /// </summary>\n        private void AddPopupControls()\n        {\n            ModalIFrameDialog modalPopup = new ModalIFrameDialog();\n            modalPopup.ID = \"modal-popup\";\n            this.Form.Controls.Add( modalPopup );\n        }\n\n        // Adds the necessary script elements for managing the page/zone/blocks\n        /// <summary>\n        /// Adds the config elements.\n        /// </summary>\n        private void AddTriggerPanel()\n        {\n            CompiledTemplateBuilder upContent = new CompiledTemplateBuilder(\n                delegate( Control content )\n                {\n                    Button trigger = new Button();\n                    trigger.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                    trigger.ID = \"rock-config-trigger\";\n                    trigger.Click += trigger_Click;\n                    content.Controls.Add( trigger );\n\n                    HiddenField triggerData = new HiddenField();\n                    triggerData.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                    triggerData.ID = \"rock-config-trigger-data\";\n                    content.Controls.Add( triggerData );\n                }\n            );\n\n            UpdatePanel upTrigger = new UpdatePanel();\n            upTrigger.ContentTemplate = upContent;\n            this.Form.Controls.Add( upTrigger );\n            upTrigger.Attributes.Add( \"style\", \"display:none\" );\n        }\n\n        // Adds the necessary script elements for managing the page/zone/blocks\n        /// <summary>\n        /// Adds the config elements.\n        /// </summary>\n        private void AddZoneElements( bool canConfigPage )\n        {\n            if ( canConfigPage )\n            {\n                AddBlockMove();\n            }\n\n            // Add Zone Wrappers\n            foreach ( KeyValuePair<string, KeyValuePair<string, Zone>> zoneControl in this.Zones )\n            {\n                var control = zoneControl.Value.Value;\n                Control parent = zoneControl.Value.Value.Parent;\n\n                HtmlGenericControl zoneWrapper = new HtmlGenericControl( \"div\" );\n                parent.Controls.AddAt( parent.Controls.IndexOf( control ), zoneWrapper );\n                zoneWrapper.ID = string.Format( \"zone-{0}\", zoneControl.Key.ToLower() );\n                zoneWrapper.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                zoneWrapper.Attributes.Add( \"class\", (\"zone-instance\" + ( canConfigPage ? \" can-configure \" : \" \" ) + control.CssClass).Trim() );\n\n                if ( canConfigPage )\n                {\n                    // Zone content configuration widget\n                    HtmlGenericControl zoneConfig = new HtmlGenericControl( \"div\" );\n                    zoneWrapper.Controls.Add( zoneConfig );\n                    zoneConfig.Attributes.Add( \"class\", \"zone-configuration config-bar\" );\n\n                    HtmlGenericControl zoneConfigLink = new HtmlGenericControl( \"a\" );\n                    zoneConfigLink.Attributes.Add( \"class\", \"zoneinstance-config\" );\n                    zoneConfigLink.Attributes.Add( \"href\", \"#\" );\n                    zoneConfig.Controls.Add( zoneConfigLink );\n                    HtmlGenericControl iZoneConfig = new HtmlGenericControl( \"i\" );\n                    iZoneConfig.Attributes.Add( \"class\", \"fa fa-arrow-circle-right\" );\n                    zoneConfigLink.Controls.Add( iZoneConfig );\n\n                    HtmlGenericControl zoneConfigBar = new HtmlGenericControl( \"div\" );\n                    zoneConfigBar.Attributes.Add( \"class\", \"zone-configuration-bar\" );\n                    zoneConfig.Controls.Add( zoneConfigBar );\n\n                    HtmlGenericControl zoneConfigTitle = new HtmlGenericControl( \"span\" );\n                    zoneConfigTitle.InnerText = zoneControl.Value.Key;\n                    zoneConfigBar.Controls.Add( zoneConfigTitle );\n\n                    // Configure Blocks icon\n                    HtmlGenericControl aBlockConfig = new HtmlGenericControl( \"a\" );\n                    zoneConfigBar.Controls.Add( aBlockConfig );\n                    aBlockConfig.ID = string.Format( \"aBlockConfig-{0}\", zoneControl.Key );\n                    aBlockConfig.ClientIDMode = System.Web.UI.ClientIDMode.Static;\n                    aBlockConfig.Attributes.Add( \"class\", \"zone-blocks\" );\n                    aBlockConfig.Attributes.Add( \"href\", \"javascript: Rock.controls.modal.show($(this), '\" + ResolveUrl( string.Format( \"~/ZoneBlocks/{0}/{1}?t=Zone Blocks&pb=&sb=Done\", _pageCache.Id, zoneControl.Key ) ) + \"')\" );\n                    aBlockConfig.Attributes.Add( \"Title\", \"Zone Blocks\" );\n                    aBlockConfig.Attributes.Add( \"zone\", zoneControl.Key );\n                    //aBlockConfig.InnerText = \"Blocks\";\n                    HtmlGenericControl iZoneBlocks = new HtmlGenericControl( \"i\" );\n                    iZoneBlocks.Attributes.Add( \"class\", \"fa fa-th-large\" );\n                    aBlockConfig.Controls.Add( iZoneBlocks );\n                }\n\n                HtmlGenericContainer zoneContent = new HtmlGenericContainer( \"div\" );\n                zoneContent.Attributes.Add( \"class\", \"zone-content\" );\n                zoneWrapper.Controls.Add( zoneContent );\n\n                parent.Controls.Remove( control );\n                zoneContent.Controls.Add( control );\n            }\n        }\n\n        /// <summary>\n        /// Adds a control to move the block to another zone on the page.\n        /// </summary>\n        private void AddBlockMove()\n        {\n            // Add Zone Selection Popup (for moving blocks to another zone)\n            ModalDialog modalBlockMove = new ModalDialog();\n            modalBlockMove.CssClass = \"js-modal-block-move\";\n            modalBlockMove.Title = \"Move Block\";\n            modalBlockMove.OnOkScript = \"Rock.admin.pageAdmin.saveBlockMove();\";\n            this.Form.Controls.Add( modalBlockMove );\n            modalBlockMove.Visible = true;\n\n            HtmlGenericControl fsZoneSelect = new HtmlGenericControl( \"fieldset\" );\n            fsZoneSelect.ClientIDMode = ClientIDMode.Static;\n            fsZoneSelect.Attributes.Add( \"id\", \"fsZoneSelect\" );\n            modalBlockMove.Content.Controls.Add( fsZoneSelect );\n\n            HtmlGenericControl legend = new HtmlGenericControl( \"legend\" );\n            legend.InnerText = \"New Location\";\n            fsZoneSelect.Controls.Add( legend );\n\n            RockDropDownList ddlZones = new RockDropDownList();\n            ddlZones.ClientIDMode = ClientIDMode.Static;\n            ddlZones.ID = \"block-move-zone\";\n            ddlZones.Label = \"Zone\";\n            foreach ( var zone in Zones )\n                ddlZones.Items.Add( new ListItem( zone.Value.Key, zone.Key ) );\n            fsZoneSelect.Controls.Add( ddlZones );\n\n            RockRadioButtonList rblLocation = new RockRadioButtonList();\n            rblLocation.RepeatDirection = RepeatDirection.Horizontal;\n            rblLocation.ClientIDMode = ClientIDMode.Static;\n            rblLocation.ID = \"block-move-Location\";\n            rblLocation.CssClass = \"inputs-list\";\n            rblLocation.Items.Add( new ListItem( string.Format( \"Page ({0})\", _pageCache.InternalName), \"Page\" ) );\n            rblLocation.Items.Add( new ListItem( string.Format( \"Layout ({0})\", _pageCache.Layout.Name ), \"Layout\" ) );\n            rblLocation.Items.Add( new ListItem( string.Format( \"Site ({0})\", _pageCache.Layout.Site.Name ), \"Site\" ) );\n            rblLocation.Label = \"Parent\";\n            fsZoneSelect.Controls.Add( rblLocation );\n        }\n\n        #endregion\n\n        #region SharedItemCaching\n\n        /// <summary>\n        /// Used to save an item to the current HTTPRequests items collection.  This is useful if multiple blocks\n        /// on the same page will need access to the same object.  The first block can read the object and save\n        /// it using this method for the other blocks to reference\n        /// </summary>\n        /// <param name=\"key\">A <see cref=\"System.String\"/> representing the item's key</param>\n        /// <param name=\"item\">The <see cref=\"System.Object\"/> to save.</param>\n        public void SaveSharedItem( string key, object item )\n        {\n            string itemKey = $\"SharedItem:Page:{PageId}:Item:{key}\";\n            SaveContextItem( itemKey, item );\n        }\n\n        private void SaveContextItem( string key, object item )\n        {\n            System.Collections.IDictionary items = HttpContext.Current.Items;\n            if ( items.Contains( key ) )\n            {\n                items[key] = item;\n            }\n            else\n            {\n                items.Add( key, item );\n            }\n        }\n\n        /// <summary>\n        /// Retrieves an item from the current HTTPRequest items collection.  This is useful to retrieve an object\n        /// that was saved by a previous block on the same page.\n        /// </summary>\n        /// <param name=\"key\">A <see cref=\"System.String\"/> representing the object's key value.</param>\n        /// <returns>The shared <see cref=\"System.Object\"/>, if a match for the key is not found, a null value will be returned.</returns>\n        public object GetSharedItem( string key )\n        {\n            string itemKey = $\"SharedItem:Page:{PageId}:Item:{key}\";\n\n            System.Collections.IDictionary items = HttpContext.Current.Items;\n            if ( items.Contains( itemKey ) )\n            {\n                return items[itemKey];\n            }\n\n            return null;\n        }\n\n        #endregion\n\n        #region Static Helper Methods\n\n        /// <summary>\n        /// Checks the page's RouteData values and then the query string for a\n        /// parameter matching the specified name, and if found returns the string\n        /// value\n        /// </summary>\n        /// <param name=\"name\">A <see cref=\"System.String\" /> representing the name of the page parameter.</param>\n        /// <param name=\"searchFormParams\">if set to <c>true</c> [search form parameters].</param>\n        /// <returns>\n        /// A <see cref=\"System.String\" /> containing the parameter value; otherwise an empty string.\n        /// </returns>\n        public string PageParameter( string name, bool searchFormParams = false )\n        {\n            if ( !string.IsNullOrWhiteSpace( name ) )\n            {\n                if ( Page.RouteData.Values.ContainsKey( name ) )\n                {\n                    return (string)Page.RouteData.Values[name];\n                }\n\n                if ( !string.IsNullOrEmpty( Request.QueryString[name] ) )\n                {\n                    return Request.QueryString[name];\n                }\n\n                if ( PageReference.Parameters.ContainsKey( name ) )\n                {\n                    return PageReference.Parameters[name];\n                }\n\n                if ( searchFormParams )\n                {\n                    if ( !string.IsNullOrEmpty( this.Page.Request.Params[name] ) )\n                    {\n                        return this.Page.Request.Params[name];\n                    }\n                }\n            }\n\n            return string.Empty;\n        }\n\n        /// <summary>\n        /// Checks the page reference's parms and querystring for a\n        /// parameter matching the specified name, and if found returns the string\n        /// </summary>\n        /// <param name=\"pageReference\">The <see cref=\"Rock.Web.PageReference\"/>.</param>\n        /// <param name=\"name\">A <see cref=\"System.String\"/> containing the name of the parameter.</param>\n        /// <returns>A <see cref=\"System.String\"/> containing the value.</returns>\n        public string PageParameter( PageReference pageReference, string name )\n        {\n            if ( String.IsNullOrEmpty( name ) )\n            {\n                return string.Empty;\n            }\n\n            if ( pageReference.Parameters.ContainsKey( name ) )\n            {\n                return (string)pageReference.Parameters[name];\n            }\n\n            if ( String.IsNullOrEmpty( pageReference.QueryString[name] ) )\n            {\n                return string.Empty;\n            }\n            else\n            {\n                return pageReference.QueryString[name];\n            }\n        }\n\n        /// <summary>\n        /// Gets the page route and query string parameters\n        /// </summary>\n        /// <returns>A <see cref=\"System.Collections.Generic.Dictionary{String, Object}\"/> containing the page route and query string value, the Key is the is the parameter name/key and the object is the value.</returns>\n        public Dictionary<string, object> PageParameters()\n        {\n            var parameters = new Dictionary<string, object>();\n\n            foreach ( var key in Page.RouteData.Values.Keys )\n            {\n                parameters.Add( key, Page.RouteData.Values[key] );\n            }\n\n            foreach ( string param in Request.QueryString.Keys )\n            {\n                if ( param != null )\n                {\n                    parameters.Add( param, Request.QueryString[param] );\n                }\n            }\n\n            return parameters;\n        }\n\n        /// <summary>\n        /// Adds a new CSS link that will be added to the page header prior to the page being rendered\n        /// </summary>\n        /// <param name=\"page\">The <see cref=\"System.Web.UI.Page\" />.</param>\n        /// <param name=\"href\">A <see cref=\"System.String\" /> representing the path to css file.  Should be relative to layout template.  Will be resolved at runtime</param>\n        /// <param name=\"fingerprint\">if set to <c>true</c> [fingerprint].</param>\n        public static void AddCSSLink( Page page, string href, bool fingerprint = true )\n        {\n            AddCSSLink( page, href, string.Empty, fingerprint );\n        }\n\n        /// <summary>\n        /// Adds the CSS link to the page\n        /// </summary>\n        /// <param name=\"page\">The <see cref=\"System.Web.UI.Page\" />.</param>\n        /// <param name=\"href\">A <see cref=\"System.String\" /> representing the path to css file.  Should be relative to layout template.  Will be resolved at runtime</param>\n        /// <param name=\"mediaType\">A <see cref=\"System.String\" /> representing the type of the media to use for the css link.</param>\n        /// <param name=\"fingerprint\">if set to <c>true</c> [fingerprint].</param>\n        public static void AddCSSLink( Page page, string href, string mediaType, bool fingerprint = true )\n        {\n            HtmlLink htmlLink = new HtmlLink();\n\n            if ( fingerprint )\n            {\n                htmlLink.Attributes.Add( \"href\", Fingerprint.Tag( page.ResolveUrl( href ) ) );\n            }\n            else\n            {\n                htmlLink.Attributes.Add( \"href\", page.ResolveUrl( href ) );\n            }\n\n            htmlLink.Attributes.Add( \"type\", \"text/css\" );\n            htmlLink.Attributes.Add( \"rel\", \"stylesheet\" );\n\n            if ( mediaType != string.Empty )\n            {\n                htmlLink.Attributes.Add( \"media\", mediaType );\n            }\n\n            AddHtmlLink( page, htmlLink, \"css\" );\n        }\n\n        /// <summary>\n        /// Adds a meta tag to the page\n        /// </summary>\n        /// <param name=\"page\">The <see cref=\"System.Web.UI.Page\"/>.</param>\n        /// <param name=\"htmlMeta\">A <see cref=\"System.String\"/>representing the HTML meta tag.</param>\n        public static void AddMetaTag( Page page, HtmlMeta htmlMeta )\n        {\n            if ( page != null && page.Header != null )\n            {\n                if ( !HtmlMetaExists( page, htmlMeta ) )\n                {\n                    // Find last meta element\n                    int index = 0;\n                    for ( int i = page.Header.Controls.Count - 1; i >= 0; i-- )\n                    {\n                        if ( page.Header.Controls[i] is HtmlMeta )\n                        {\n                            index = i;\n                            break;\n                        }\n                    }\n\n                    if ( index == page.Header.Controls.Count )\n                    {\n                        page.Header.Controls.Add( new LiteralControl( \"\\n\\t\" ) );\n                        page.Header.Controls.Add( htmlMeta );\n                    }\n                    else\n                    {\n                        page.Header.Controls.AddAt( ++index, new LiteralControl( \"\\n\\t\" ) );\n                        page.Header.Controls.AddAt( ++index, htmlMeta );\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Returns a flag indicating if a meta tag exists on the page.\n        /// </summary>\n        /// <param name=\"page\">The <see cref=\"System.Web.UI.Page\"/>.</param>\n        /// <param name=\"newMeta\">The <see cref=\"System.Web.UI.HtmlControls.HtmlMeta\"/> tag to check for..</param>\n        /// <returns>A <see cref=\"System.Boolean\"/> that is <c>true</c> if the meta tag already exists; otherwise <c>false</c>.</returns>\n        private static bool HtmlMetaExists( Page page, HtmlMeta newMeta )\n        {\n            bool existsAlready = false;\n\n            if ( page != null && page.Header != null )\n            {\n                foreach ( Control control in page.Header.Controls )\n                {\n                    if ( control is HtmlMeta )\n                    {\n                        HtmlMeta existingMeta = (HtmlMeta)control;\n\n                        bool sameAttributes = true;\n\n                        foreach ( string attributeKey in newMeta.Attributes.Keys )\n                        {\n                            if ( existingMeta.Attributes[attributeKey] == null ||\n                                existingMeta.Attributes[attributeKey].ToLower() != newMeta.Attributes[attributeKey].ToLower() )\n                            {\n                                sameAttributes = false;\n                                break;\n                            }\n                        }\n\n                        if ( sameAttributes )\n                        {\n                            existsAlready = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return existsAlready;\n        }\n\n        /// <summary>\n        /// Adds a new Html link Literal that will be added to the page header prior to the page being rendered.\n        /// NOTE: This method differs from the other AddHtmlLink because a literal whose Mode\n        /// is set to PassThrough will not have its parameters/attributes encoded (the ampersande char changed to &amp;).\n        /// </summary>\n        /// <param name=\"page\">The <see cref=\"System.Web.UI.Page\"/>.</param>\n        /// <param name=\"htmlLink\">The <see cref=\"System.Web.UI.WebControls.Literal\"/> to add to the page.</param>\n        /// <param name=\"contentPlaceHolderId\">A <see cref=\"System.String\"/> representing the Id of the content placeholder to add the link to.</param>\n        private static void AddHtmlLink( Page page, Literal htmlLink, string contentPlaceHolderId = \"\" )\n        {\n            if ( page != null && page.Header != null )\n            {\n                var header = page.Header;\n                if ( !HtmlLinkExists( header, htmlLink ) )\n                {\n                    bool inserted = false;\n\n                    if ( !string.IsNullOrWhiteSpace( contentPlaceHolderId ) )\n                    {\n                        for ( int i = 0; i < header.Controls.Count; i++ )\n                        {\n                            if ( header.Controls[i] is ContentPlaceHolder )\n                            {\n                                var ph = ( ContentPlaceHolder ) header.Controls[i];\n                                if ( ph.ID == contentPlaceHolderId )\n                                {\n                                    ph.Controls.Add( new LiteralControl( \"\\n\\t\" ) );\n                                    ph.Controls.Add( htmlLink );\n\n                                    inserted = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ( !inserted )\n                    {\n                        header.Controls.Add( new LiteralControl( \"\\n\\t\" ) );\n                        header.Controls.Add( htmlLink );\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Adds a new Html link that will be added to the page header prior to the page being rendered.\n        /// </summary>\n        /// <param name=\"page\">The <see cref=\"System.Web.UI.Page\"/>.</param>\n        /// <param name=\"htmlLink\">The <see cref=\"System.Web.UI.HtmlControls.HtmlLink\"/> to add to the page.</param>\n        /// <param name=\"contentPlaceHolderId\">A <see cref=\"System.String\"/> representing the Id of the content placeholder to add the link to.</param>\n        public static void AddHtmlLink( Page page, HtmlLink htmlLink, string contentPlaceHolderId = \"\" )\n        {\n            if ( page != null && page.Header != null )\n            {\n                var header = page.Header;\n                if ( !HtmlLinkExists( header, htmlLink ) )\n                {\n                    bool inserted = false;\n\n                    if ( !string.IsNullOrWhiteSpace( contentPlaceHolderId ) )\n                    {\n                        for ( int i = 0; i < header.Controls.Count; i++ )\n                        {\n                            if ( header.Controls[i] is ContentPlaceHolder )\n                            {\n                                var ph = (ContentPlaceHolder)header.Controls[i];\n                                if ( ph.ID == contentPlaceHolderId )\n                                {\n                                    ph.Controls.Add( new LiteralControl( \"\\n\\t\" ) );\n                                    ph.Controls.Add( htmlLink );\n\n                                    inserted = true;\n                                    break;\n                                }\n                            }\n                        }\n                    }\n\n                    if ( !inserted )\n                    {\n                        header.Controls.Add( new LiteralControl( \"\\n\\t\" ) );\n                        header.Controls.Add( htmlLink );\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Returns a <see cref=\"System.Boolean\"/> flag indicating if a specified parent control contains the specified HtmlLink literal.\n        /// </summary>\n        /// <param name=\"parentControl\">The <see cref=\"System.Web.UI.Control\"/> to search for the HtmlLink.</param>\n        /// <param name=\"newLink\">The <see cref=\"System.Web.UI.WebControls.Literal\"/> to search for.</param>\n        /// <returns>A <see cref=\"System.Boolean\"/> value that is <c>true</c> if the HtmlLink exists in the parent control; otherwise <c>false</c>.</returns>\n        private static bool HtmlLinkExists( Control parentControl, Literal newLink )\n        {\n            bool existsAlready = false;\n\n            if ( parentControl != null )\n            {\n                foreach ( Control control in parentControl.Controls )\n                {\n                    if ( control is ContentPlaceHolder )\n                    {\n                        if ( HtmlLinkExists( control, newLink ) )\n                        {\n                            existsAlready = true;\n                            break;\n                        }\n                    }\n                    else if ( control is Literal )\n                    {\n                        Literal existingLink = ( Literal ) control;\n\n                        if ( newLink.Text == existingLink.Text )\n                        {\n                            existsAlready = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return existsAlready;\n        }\n\n        /// <summary>\n        /// Returns a <see cref=\"System.Boolean\"/> flag indicating if a specified parent control contains the specified HtmlLink.\n        /// </summary>\n        /// <param name=\"parentControl\">The <see cref=\"System.Web.UI.Control\"/> to search for the HtmlLink.</param>\n        /// <param name=\"newLink\">The <see cref=\"System.Web.UI.HtmlControls.HtmlLink\"/> to search for.</param>\n        /// <returns>A <see cref=\"System.Boolean\"/> value that is <c>true</c> if the HtmlLink exists in the parent control; otherwise <c>false</c>.</returns>\n        private static bool HtmlLinkExists( Control parentControl, HtmlLink newLink )\n        {\n            bool existsAlready = false;\n\n            if ( parentControl != null )\n            {\n                foreach ( Control control in parentControl.Controls )\n                {\n                    if ( control is ContentPlaceHolder )\n                    {\n                        if ( HtmlLinkExists( control, newLink ) )\n                        {\n                            existsAlready = true;\n                            break;\n                        }\n                    }\n                    else if ( control is HtmlLink )\n                    {\n                        HtmlLink existingLink = (HtmlLink)control;\n\n                        bool sameAttributes = true;\n\n                        foreach ( string attributeKey in newLink.Attributes.Keys )\n                            if ( existingLink.Attributes[attributeKey] != null &&\n                                existingLink.Attributes[attributeKey].ToLower() != newLink.Attributes[attributeKey].ToLower() )\n                            {\n                                sameAttributes = false;\n                                break;\n                            }\n\n                        if ( sameAttributes )\n                        {\n                            existsAlready = true;\n                            break;\n                        }\n                    }\n                }\n            }\n\n            return existsAlready;\n        }\n\n        /// <summary>\n        /// Adds a new script tag to the page body prior to the page being rendered\n        /// </summary>\n        /// <param name=\"page\">The <see cref=\"System.Web.UI.Page\" />.</param>\n        /// <param name=\"path\">A <see cref=\"System.String\" /> representing the path to script file.  Should be relative to layout template.  Will be resolved at runtime.</param>\n        /// <param name=\"fingerprint\">if set to <c>true</c> [fingerprint].</param>\n        public static void AddScriptLink( Page page, string path, bool fingerprint = true )\n        {\n            var scriptManager = ScriptManager.GetCurrent( page );\n             \n            if ( fingerprint )\n            {\n                path = Fingerprint.Tag( page.ResolveUrl( path ) );\n            }\n\n            if ( scriptManager != null && !scriptManager.Scripts.Any( s => s.Path == path ) )\n            {\n                scriptManager.Scripts.Add( new ScriptReference( path ) );\n            }\n        }\n\n        /// <summary>\n        /// Adds the script to head.\n        /// </summary>\n        /// <param name=\"page\">The page.</param>\n        /// <param name=\"script\">The script.</param>\n        /// <param name=\"addScriptTags\">if set to <c>true</c> [add script tags].</param>\n        public static void AddScriptToHead( Page page, string script, bool addScriptTags )\n        {\n            if ( page != null && page.Header != null )\n            {\n                var header = page.Header;\n\n                Literal l = new Literal();\n\n                if ( addScriptTags )\n                {\n                    l.Text = string.Format( @\"\n    <script type=\"\"text/javascript\"\">\n{0}\n    </script>\n\n\", script );\n                }\n                else\n                {\n                    l.Text = script;\n                }\n\n                header.Controls.Add( l );\n            }\n        }\n\n        /// <summary>\n        /// Adds a script tag with the specified id and source to head (if it doesn't already exist)\n        /// </summary>\n        /// <param name=\"scriptId\">The script identifier.</param>\n        /// <param name=\"src\">The source.</param>\n        public void AddScriptSrcToHead( string scriptId, string src )\n        {\n            RockPage.AddScriptSrcToHead( this.Page, scriptId, src );\n        }\n\n        /// <summary>\n        /// Adds a script tag with the specified id and source to head (if it doesn't already exist)\n        /// </summary>\n        /// <param name=\"page\">The page.</param>\n        /// <param name=\"scriptId\">The script identifier.</param>\n        /// <param name=\"src\">The source.</param>\n        public static void AddScriptSrcToHead( Page page, string scriptId, string src )\n        {\n            if ( page != null && page.Header != null )\n            {\n                var header = page.Header;\n\n                if ( !header.Controls.OfType<Literal>().Any( a => a.ID == scriptId ) )\n                {\n                    Literal l = new Literal {\n                        ID = scriptId,\n                        Text = $\"<script id='{scriptId}' src='{src}'></script>\"\n                    };\n\n                    header.Controls.Add( l );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the client's ip address.\n        /// </summary>\n        /// <returns></returns>\n        public static string GetClientIpAddress()\n        {\n            return WebRequestHelper.GetClientIpAddress( new HttpRequestWrapper( HttpContext.Current.Request ) );\n        }\n\n        #region User Preferences\n\n        /// <summary>\n        /// Returns a user preference for the current user and given key.\n        /// </summary>\n        /// <param name=\"key\">A <see cref=\"System.String\" /> representing the key to the user preference.</param>\n        /// <returns>A <see cref=\"System.String\" /> representing the specified user preference value, if a match is not found an empty string will be returned.</returns>\n        public string GetUserPreference( string key )\n        {\n            var values = SessionUserPreferences();\n            if ( values.ContainsKey( key ) )\n            {\n                return values[key];\n            }\n\n            return string.Empty;\n        }\n\n        /// <summary>\n        /// Returns the preference values for the current user that start with a given key.\n        /// </summary>\n        /// <param name=\"keyPrefix\">A <see cref=\"System.String\"/> representing the key prefix. Preference values, for the current user, with a key that begins with this value will be included.</param>\n        /// <returns>A <see cref=\"System.Collections.Generic.Dictionary{String,String}\"/> containing  the current user's preference values containing a key that begins with the specified value.\n        /// Each <see cref=\"System.Collections.Generic.KeyValuePair{String,String}\"/> contains a key that represents the user preference key and a value that contains the user preference value associated\n        /// with that key.\n        /// </returns>\n        public Dictionary<string, string> GetUserPreferences( string keyPrefix )\n        {\n            var selectedValues = new Dictionary<string, string>();\n\n            var values = SessionUserPreferences();\n            foreach ( var key in values.Where( v => v.Key.StartsWith( keyPrefix ) ) )\n            {\n                selectedValues.Add( key.Key, key.Value );\n            }\n\n            return selectedValues;\n        }\n\n        /// <summary>\n        /// Sets a user preference value for the specified key. If the key already exists, the value will be updated,\n        /// if it is a new key it will be added. Value is then optionally saved to database.\n        /// </summary>\n        /// <param name=\"key\">A <see cref=\"System.String\" /> representing the name of the key.</param>\n        /// <param name=\"value\">A <see cref=\"System.String\" /> representing the preference value.</param>\n        /// <param name=\"saveValue\">if set to <c>true</c> [save value].</param>\n        public void SetUserPreference( string key, string value, bool saveValue = true )\n        {\n            var sessionValues = SessionUserPreferences();\n            if ( sessionValues.ContainsKey( key ) )\n            {\n                sessionValues[key] = value;\n            }\n            else\n            {\n                sessionValues.Add( key, value );\n            }\n\n            if ( saveValue && CurrentPerson != null )\n            {\n                PersonService.SaveUserPreference( CurrentPerson, key, value );\n            }\n        }\n\n        /// <summary>\n        /// Saves the user preferences.\n        /// </summary>\n        /// <param name=\"keyPrefix\">The key prefix.</param>\n        public void SaveUserPreferences( string keyPrefix )\n        {\n            if ( CurrentPerson != null )\n            {\n                var values = new Dictionary<string, string>();\n                SessionUserPreferences()\n                    .Where( p => p.Key.StartsWith( keyPrefix ) )\n                    .ToList()\n                    .ForEach( kv => values.Add( kv.Key, kv.Value ) );\n\n                PersonService.SaveUserPreferences( CurrentPerson, values );\n            }\n        }\n\n        /// <summary>\n        /// Deletes a user preference value for the specified key\n        /// </summary>\n        /// <param name=\"key\">A <see cref=\"System.String\"/> representing the name of the key.</param>\n        public void DeleteUserPreference( string key )\n        {\n            var sessionValues = SessionUserPreferences();\n            if ( sessionValues.ContainsKey( key ) )\n            {\n                sessionValues.Remove( key );\n            }\n\n            if ( CurrentPerson != null )\n            {\n                PersonService.DeleteUserPreference( CurrentPerson, key );\n            }\n        }\n\n        /// <summary>\n        /// Returns the current user's preferences, if they have previously been loaded into the session, they\n        /// will be retrieved from there, otherwise they will be retrieved from the database, added to session and\n        /// then returned\n        /// </summary>\n        /// <returns>A <see cref=\"System.Collections.Generic.Dictionary{String, List}\"/> containing the user preferences\n        /// for the current user. If the current user is anonymous or unknown an empty dictionary will be returned.</returns>\n        public Dictionary<string, string> SessionUserPreferences()\n        {\n            string sessionKey = string.Format( \"{0}_{1}\",\n                Person.USER_VALUE_ENTITY, CurrentPerson != null ? CurrentPerson.Id : 0 );\n\n            var userPreferences = Session[sessionKey] as Dictionary<string, string>;\n            if ( userPreferences == null )\n            {\n                if ( CurrentPerson != null )\n                {\n                    userPreferences = PersonService.GetUserPreferences( CurrentPerson );\n                }\n                else\n                {\n                    userPreferences = new Dictionary<string, string>();\n                }\n                Session[sessionKey] = userPreferences;\n            }\n\n            return userPreferences;\n        }\n\n        #endregion\n\n        #endregion\n\n        #region Event Handlers\n\n        /// <summary>\n        /// Handles the Click event of the trigger control.\n        /// </summary>\n        /// <param name=\"sender\">The source of the event.</param>\n        /// <param name=\"e\">The <see cref=\"EventArgs\"/> instance containing the event data.</param>\n        protected void trigger_Click( object sender, EventArgs e )\n        {\n            var dataControl = this.Form.FindControl( \"rock-config-trigger-data\" );\n            if ( dataControl != null && dataControl is HiddenField )\n            {\n                string triggerData = ( (HiddenField)dataControl ).Value;\n\n                if ( triggerData.StartsWith( \"BLOCK_UPDATED:\" ) )\n                {\n                    int blockId = int.MinValue;\n                    if ( int.TryParse( triggerData.Replace( \"BLOCK_UPDATED:\", \"\" ), out blockId ) )\n                    {\n                        OnBlockUpdated( blockId );\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// Updates the blocks.\n        /// </summary>\n        /// <param name=\"blockTypePath\">The block type path.</param>\n        public void UpdateBlocks( string blockTypePath )\n        {\n            foreach ( var rockBlock in RockBlocks )\n            {\n                if ( rockBlock.BlockCache.BlockType.Path?.Equals( blockTypePath, StringComparison.OrdinalIgnoreCase ) ?? false )\n                {\n                    OnBlockUpdated( rockBlock.BlockId );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Occurs when a block's properties are updated.\n        /// </summary>\n        internal event EventHandler<BlockUpdatedEventArgs> BlockUpdated;\n\n        /// <summary>\n        /// Called when a block's properties are updated.\n        /// </summary>\n        /// <param name=\"blockId\">The block identifier.</param>\n        private void OnBlockUpdated( int blockId )\n        {\n            if ( BlockUpdated != null )\n            {\n                BlockUpdated( this, new BlockUpdatedEventArgs( blockId ) );\n            }\n        }\n        /// <summary>\n        /// Handles the Navigate event of the scriptManager control.\n        /// </summary>\n        /// <param name=\"sender\">The source of the event.</param>\n        /// <param name=\"e\">The <see cref=\"HistoryEventArgs\"/> instance containing the event data.</param>\n        protected void scriptManager_Navigate( object sender, HistoryEventArgs e )\n        {\n            if ( PageNavigate != null )\n            {\n                PageNavigate( this, e );\n            }\n        }\n\n        /// <summary>\n        /// Occurs when the ScriptManager detects a history change. This allows UpdatePanels to work when the\n        /// browser's back button is pressed.\n        /// </summary>\n        public event PageNavigateEventHandler PageNavigate;\n\n        #endregion\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\tpublic class LuaSvr \n\t{\n\t\tstatic public MainState mainState;\n\n\t\tpublic class MainState : LuaState {\n\n\t\t\tint errorReported = 0;\n\n\t\t\tprotected override void tick() {\n\t\t\t\tbase.tick ();\n\t\t\t\t#if !SLUA_STANDALONE\n\t\t\t\tLuaTimer.tick(Time.deltaTime);\n\t\t\t\t#endif\n\t\t\t\tcheckTop ();\n\t\t\t}\n\n\t\t\tinternal void checkTop()\n\t\t\t{\n\t\t\t\tif (LuaDLL.lua_gettop(L) != errorReported)\n\t\t\t\t{\n\t\t\t\t\terrorReported = LuaDLL.lua_gettop(L);\n\t\t\t\t\tLogger.LogError(string.Format(\"Some function not remove temp value({0}) from lua stack. You should fix it.\",LuaDLL.luaL_typename(L,errorReported)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic LuaSvr()\n\t\t{\n\t\t\tmainState = new MainState();\n            mainState.Name = \"main\";\n\t\t}\n\n\t\tstatic List<Action<IntPtr>> collectBindInfo() {\n\n\t\t\tList<Action<IntPtr>> list = new List<Action<IntPtr>>();\n\n\t\t\t#if !SLUA_STANDALONE\n\t\t\t#if !USE_STATIC_BINDER\n\t\t\tAssembly[] ams = AppDomain.CurrentDomain.GetAssemblies();\n\n\t\t\tList<Type> bindlist = new List<Type>();\n\t\t\tfor (int n = 0; n < ams.Length;n++ )\n\t\t\t{\n\t\t\t\tAssembly a = ams[n];\n\t\t\t\tType[] ts = null;\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tts = a.GetExportedTypes();\n\t\t\t\t}\n\t\t\t\tcatch\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int k = 0; k < ts.Length; k++)\n\t\t\t\t{\n\t\t\t\t\tType t = ts[k];\n\t\t\t\t\tif (t.IsDefined(typeof(LuaBinderAttribute), false))\n\t\t\t\t\t{\n\t\t\t\t\t\tbindlist.Add(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbindlist.Sort(new System.Comparison<Type>((Type a, Type b) => {\n\t\t\t\tLuaBinderAttribute la = System.Attribute.GetCustomAttribute( a, typeof(LuaBinderAttribute) ) as LuaBinderAttribute;\n\t\t\t\tLuaBinderAttribute lb = System.Attribute.GetCustomAttribute( b, typeof(LuaBinderAttribute) ) as LuaBinderAttribute;\n\n\t\t\t\treturn la.order.CompareTo(lb.order);\n\t\t\t}));\n\n\t\t\tfor (int n = 0; n < bindlist.Count; n++)\n\t\t\t{\n\t\t\t\tType t = bindlist[n];\n\t\t\t\tvar sublist = (Action<IntPtr>[])t.GetMethod(\"GetBindList\").Invoke(null, null);\n\t\t\t\tlist.AddRange(sublist);\n\t\t\t}\n\t\t\t#else\n\t\t\tvar assemblyName = \"Assembly-CSharp\";\n\t\t\tAssembly assembly = Assembly.Load(assemblyName);\n\t\t\tlist.AddRange(getBindList(assembly,\"SLua.BindUnity\"));\n\t\t\tlist.AddRange(getBindList(assembly,\"SLua.BindUnityUI\"));\n\t\t\tlist.AddRange(getBindList(assembly,\"SLua.BindDll\"));\n\t\t\tlist.AddRange(getBindList(assembly,\"SLua.BindCustom\"));\n\t\t\t#endif\n\t\t\t#endif\n\n\t\t\treturn list;\n\n\t\t}\n\n\n\t\tstatic internal void doBind(IntPtr L)\n\t\t{\n\t\t\tvar list = collectBindInfo ();\n\n\t\t\tint count = list.Count;\n\t\t\tfor (int n = 0; n < count; n++)\n\t\t\t{\n\t\t\t\tAction<IntPtr> action = list[n];\n\t\t\t\taction(L);\n\t\t\t}\n\t\t}\n\n\n\n\t\tstatic internal IEnumerator doBind(IntPtr L,Action<int> _tick,Action complete)\n\t\t{\n\t\t\tAction<int> tick = (int p) => {\n\t\t\t\tif (_tick != null)\n\t\t\t\t\t_tick (p);\n\t\t\t};\n\n\t\t\ttick (0);\n\t\t\tvar list = collectBindInfo ();\n\n\t\t\ttick (2);\n\n\t\t\tint bindProgress = 2;\n\t\t\tint lastProgress = bindProgress;\n\t\t\tfor (int n = 0; n < list.Count; n++)\n\t\t\t{\n\t\t\t\tAction<IntPtr> action = list[n];\n\t\t\t\taction(L);\n\t\t\t\tbindProgress = (int)(((float)n / list.Count) * 98.0) + 2;\n\t\t\t\tif (_tick!=null && lastProgress != bindProgress && bindProgress % 5 == 0) {\n                    lastProgress = bindProgress;\n\t\t\t\t\ttick (bindProgress);\n\t\t\t\t\tyield return null;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttick (100);\n\t\t\tcomplete ();\n\t\t}\n\n\t\tAction<IntPtr>[] getBindList(Assembly assembly,string ns) {\n\t\t\tType t=assembly.GetType(ns);\n\t\t\tif(t!=null)\n\t\t\t\treturn (Action<IntPtr>[]) t.GetMethod(\"GetBindList\").Invoke(null, null);\n\t\t\treturn new Action<IntPtr>[0];\n\t\t}\n\n        protected void doinit(LuaState L,LuaSvrFlag flag)\n\t\t{\n\t\t\tL.openSluaLib ();\n\t\t\tLuaValueType.reg(L.L);\n\t\t\tif ((flag & LuaSvrFlag.LSF_EXTLIB)!=0) {\n\t\t\t\tL.openExtLib ();\n\t\t\t}\n\n\t\t\tif((flag & LuaSvrFlag.LSF_3RDDLL)!=0)\n\t\t\t\tLua3rdDLL.open(L.L);\n\n\t\t}\n\n\t\tpublic void init(Action<int> tick,Action complete,LuaSvrFlag flag=LuaSvrFlag.LSF_BASIC|LuaSvrFlag.LSF_EXTLIB)\n\t\t{\n\t\t\t\n\t\t\tIntPtr L = mainState.L;\n\t\t\tLuaObject.init(L);\n\n\t\t\t#if SLUA_STANDALONE\n\t\t\tdoBind(L);\n\t\t\tdoinit(mainState, flag);\n\t\t\tcomplete();\n\t\t\tmainState.checkTop();\n\t\t\t#else\n\n\n\t\t\t#if UNITY_EDITOR\n\t\t\tif (!UnityEditor.EditorApplication.isPlaying)\n\t\t\t{\n\t\t\t\tdoBind(L);\n\t\t\t\tdoinit(mainState, flag);\n\t\t\t\tcomplete();\n\t\t\t\tmainState.checkTop();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t#endif\n\t\t\t\tmainState.lgo.StartCoroutine(doBind(L,tick, () =>\n\t\t\t\t\t{\n\t\t\t\t\t\tdoinit(mainState, flag);\n\t\t\t\t\t\tcomplete();\n\t\t\t\t\t\tmainState.checkTop();\n\t\t\t\t\t}));\n\t\t\t#if UNITY_EDITOR\n\t\t\t}\n\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\n\t\tpublic object start(string main)\n\t\t{\n\t\t\tif (main != null)\n\t\t\t{\n\t\t\t\tmainState.doFile(main);\n                return mainState.run(\"main\");\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\t}\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Report Filter control\n    /// </summary>\n    [ToolboxData( \"<{0}:CheckinGroup runat=server></{0}:CheckinGroup>\" )]\n    public class CheckinGroup : CompositeControl, IHasValidationGroup\n    {\n        private HiddenField _hfGroupGuid;\n        private HiddenField _hfGroupId;\n        private HiddenField _hfGroupTypeId;\n        private Literal _lblGroupName;\n\n        private DataTextBox _tbGroupName;\n        private RockCheckBox _cbIsActive;\n        private PlaceHolder _phGroupAttributes;\n        private Grid _gLocations;\n\n        /// <summary>\n        /// Gets or sets the validation group.\n        /// </summary>\n        /// <value>\n        /// The validation group.\n        /// </value>\n        public string ValidationGroup\n        {\n            get\n            {\n                return ViewState[\"ValidationGroup\"] as string;\n            }\n            set\n            {\n                ViewState[\"ValidationGroup\"] = value;\n            }\n        }\n\n        /// <summary>\n        /// Raises the <see cref=\"E:System.Web.UI.Control.Load\" /> event.\n        /// </summary>\n        /// <param name=\"e\">The <see cref=\"T:System.EventArgs\" /> object that contains the event data.</param>\n        protected override void OnLoad( EventArgs e )\n        {\n            base.OnLoad( e );\n\n            if ( Page.IsPostBack )\n            {\n                HandleGridEvents();\n            }\n        }\n\n        /// <summary>\n        /// Handles the grid events.\n        /// </summary>\n        private void HandleGridEvents()\n        {\n            // manually wireup the grid events since they don't seem to do it automatically \n            string eventTarget = Page.Request.Params[\"__EVENTTARGET\"];\n            if ( eventTarget.StartsWith( _gLocations.UniqueID ) )\n            {\n                List<string> subTargetList = eventTarget.Replace( _gLocations.UniqueID, string.Empty ).Split( new char[] { '$' }, StringSplitOptions.RemoveEmptyEntries ).ToList();\n                EnsureChildControls();\n\n                // make sure it's not a reorder event\n                if ( subTargetList.Count != 0 )\n                {\n                    string lblAddControlId = subTargetList.Where( n => n.EndsWith( \"Add\" ) ).LastOrDefault();\n                    if ( lblAddControlId != null )\n                    {\n                            AddLocation_Click( this, new EventArgs() );\n                    }\n                    else\n                    {\n                        // rowIndex is determined by the numeric suffix of the control id after the Grid, subtract 2 (one for the header, and another to convert from 0 to 1 based index)\n                        int rowIndex = subTargetList.First().AsNumeric().AsInteger() - 2;\n                        RowEventArgs rowEventArgs = new RowEventArgs( rowIndex, this.Locations.OrderBy( l => l.Order ).ThenBy( l => l.FullNamePath ).ToList()[rowIndex].LocationId );\n                        DeleteLocation_Click( this, rowEventArgs );\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// \n        /// </summary>\n        [Serializable]\n        public class LocationGridItem\n        {\n            /// <summary>\n            /// Gets or sets the location unique identifier.\n            /// </summary>\n            /// <value>\n            /// The location unique identifier.\n            /// </value>\n            [DataMember]\n            public int LocationId { get; set; }\n\n            /// <summary>\n            /// Gets or sets the name.\n            /// </summary>\n            /// <value>\n            /// The name.\n            /// </value>\n            [DataMember]\n            public string Name { get; set; }\n\n            /// <summary>\n            /// Gets or sets the name in the format ParentLocation1 > ParentLocation0 > Name\n            /// </summary>\n            /// <value>\n            /// The full name path.\n            /// </value>\n            [DataMember]\n            public string FullNamePath { get; set; }\n\n            /// <summary>\n            /// Gets or sets the parent location identifier.\n            /// </summary>\n            /// <value>\n            /// The parent location identifier.\n            /// </value>\n            [DataMember]\n            public int? ParentLocationId { get; set; }\n\n            /// <summary>\n            /// Gets or sets the order.\n            /// </summary>\n            /// <value>\n            /// The order.\n            /// </value>\n            [DataMember]\n            public int? Order { get; set; }\n\n        }\n\n        /// <summary>\n        /// Gets or sets the locations.\n        /// </summary>\n        /// <value>\n        /// The locations.\n        /// </value>\n        public List<LocationGridItem> Locations\n        {\n            get\n            {\n                return ViewState[\"Locations\"] as List<LocationGridItem>;\n            }\n\n            set\n            {\n                ViewState[\"Locations\"] = value;\n            }\n        }\n\n        /// <summary>\n        /// Gets the group unique identifier.\n        /// </summary>\n        /// <value>\n        /// The group unique identifier.\n        /// </value>\n        public Guid GroupGuid\n        {\n            get\n            {\n                EnsureChildControls();\n                return new Guid( _hfGroupGuid.Value );\n            }\n        }\n\n        /// <summary>\n        /// Gets the group type unique identifier.\n        /// </summary>\n        /// <value>\n        /// The group type unique identifier.\n        /// </value>\n        public int GroupTypeId\n        {\n            get\n            {\n                EnsureChildControls();\n                return _hfGroupTypeId.ValueAsInt();\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the group.\n        /// </summary>\n        /// <param name=\"group\">The group.</param>\n        /// <value>\n        /// The group.\n        /// </value>\n        public void GetGroupValues( Group group )\n        {\n            group.Name = _tbGroupName.Text;\n            group.IsActive = _cbIsActive.Checked;\n            Rock.Attribute.Helper.GetEditValues( _phGroupAttributes, group );\n        }\n\n        /// <summary>\n        /// Sets the group.\n        /// </summary>\n        /// <param name=\"value\">The value.</param>\n        /// <param name=\"rockContext\">The rock context.</param>\n        public void SetGroup( Group value, RockContext rockContext )\n        {\n            EnsureChildControls();\n\n            //// NOTE:  A Group that was added will have an Id since it hasn't been saved to the database. \n            //// So, we'll use Guid to uniquely identify in this Control since that'll work in both Saved and Unsaved cases.\n            //// If it is saved, we do need the Id so that Attributes will work\n\n            if ( value != null )\n            {\n                _hfGroupGuid.Value = value.Guid.ToString();\n                _hfGroupId.Value = value.Id.ToString();\n                _hfGroupTypeId.Value = value.GroupTypeId.ToString();\n                _tbGroupName.Text = value.Name;\n                _cbIsActive.Checked = value.IsActive;\n\n                CreateGroupAttributeControls( value, rockContext );\n            }\n        }\n\n        /// <summary>\n        /// Called by the ASP.NET page framework to notify server controls that use composition-based implementation to create any child controls they contain in preparation for posting back or rendering.\n        /// </summary>\n        protected override void CreateChildControls()\n        {\n            Controls.Clear();\n\n            _hfGroupGuid = new HiddenField();\n            _hfGroupGuid.ID = this.ID + \"_hfGroupGuid\";\n\n            _hfGroupId = new HiddenField();\n            _hfGroupId.ID = this.ID + \"_hfGroupId\";\n\n            _hfGroupTypeId = new HiddenField();\n            _hfGroupTypeId.ID = this.ID + \"_hfGroupTypeId\";\n\n            _lblGroupName = new Literal();\n            _lblGroupName.ID = this.ID + \"_lblGroupName\";\n\n            _tbGroupName = new DataTextBox();\n            _tbGroupName.ID = this.ID + \"_tbGroupName\";\n            _tbGroupName.Label = \"Check-in Group Name\";\n\n            _cbIsActive = new RockCheckBox();\n            _cbIsActive.ID = this.ID + \"_cbIsActive\";\n            _cbIsActive.Text = \"Active\";\n\n            // set label when they exit the edit field\n            _tbGroupName.Attributes[\"onblur\"] = string.Format( \"javascript: $('#{0}').text($(this).val());\", _lblGroupName.ID );\n            _tbGroupName.SourceTypeName = \"Rock.Model.Group, Rock\";\n            _tbGroupName.PropertyName = \"Name\";\n\n            _phGroupAttributes = new PlaceHolder();\n            _phGroupAttributes.ID = this.ID + \"_phGroupAttributes\";\n\n            Controls.Add( _hfGroupGuid );\n            Controls.Add( _hfGroupId );\n            Controls.Add( _hfGroupTypeId );\n            Controls.Add( _lblGroupName );\n            Controls.Add( _tbGroupName );\n            Controls.Add( _cbIsActive );\n            Controls.Add( _phGroupAttributes );\n\n            // Locations Grid\n            CreateLocationsGrid();\n        }\n\n        /// <summary>\n        /// Creates the locations grid.\n        /// </summary>\n        private void CreateLocationsGrid()\n        {\n            _gLocations = new Grid();\n\n            _gLocations.ID = this.ID + \"_gLocations\";\n\n            _gLocations.DisplayType = GridDisplayType.Light;\n            _gLocations.ShowActionRow = true;\n            _gLocations.RowItemText = \"Location\";\n            _gLocations.Actions.ShowAdd = true;\n\n            //// Handle AddClick manually in OnLoad()\n            _gLocations.Actions.AddClick += AddLocation_Click;\n            _gLocations.GridReorder += gLocations_Reorder;\n\n            var reorderField = new ReorderField();\n            _gLocations.Columns.Add( reorderField );\n            _gLocations.ShowHeader = false;\n            _gLocations.DataKeyNames = new string[] { \"LocationId\" };\n            _gLocations.Columns.Add( new BoundField { DataField = \"FullNamePath\", HeaderText = \"Name\" } );\n\n            DeleteField deleteField = new DeleteField();\n\n            //// handle manually in OnLoad()\n            deleteField.Click += DeleteLocation_Click;\n\n            _gLocations.Columns.Add( deleteField );\n\n            Controls.Add( _gLocations );\n        }\n\n        /// <summary>\n        /// Writes the <see cref=\"T:System.Web.UI.WebControls.CompositeControl\" /> content to the specified <see cref=\"T:System.Web.UI.HtmlTextWriter\" /> object, for display on the client.\n        /// </summary>\n        /// <param name=\"writer\">An <see cref=\"T:System.Web.UI.HtmlTextWriter\" /> that represents the output stream to render HTML content on the client.</param>\n        public override void RenderControl( HtmlTextWriter writer )\n        {\n            if ( this.Visible )\n            {\n                _hfGroupGuid.RenderControl( writer );\n                _hfGroupId.RenderControl( writer );\n                _hfGroupTypeId.RenderControl( writer );\n\n                writer.AddAttribute( HtmlTextWriterAttribute.Style, \"margin-top:0;\" );\n                writer.RenderBeginTag( HtmlTextWriterTag.H3 );\n                _lblGroupName.Text = _tbGroupName.Text;\n                _lblGroupName.RenderControl( writer );\n                writer.RenderEndTag();\n\n                _tbGroupName.RenderControl( writer );\n                _cbIsActive.RenderBaseControl( writer );\n                _phGroupAttributes.RenderControl( writer );\n\n                writer.WriteLine( \"<h3>Locations</h3>\" );\n                if ( this.Locations != null )\n                {\n                    _gLocations.DataSource = this.Locations.OrderBy( l => l.Order ).ThenBy( l => l.FullNamePath ).ToList();\n                    _gLocations.DataBind();\n                }\n                _gLocations.RenderControl( writer );\n            }\n        }\n\n        /// <summary>\n        /// Creates the group attribute controls.\n        /// </summary>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"rockContext\">The rock context.</param>\n        public void CreateGroupAttributeControls( Group group, RockContext rockContext )\n        {\n            EnsureChildControls();\n\n            _phGroupAttributes.Controls.Clear();\n\n            if ( group != null )\n            {\n                if ( group.Attributes == null )\n                {\n                    group.LoadAttributes( rockContext );\n                }\n                Rock.Attribute.Helper.AddEditControls( group, _phGroupAttributes, true, this.ValidationGroup );\n            }\n        }\n\n        /// <summary>\n        /// Handles the Reorder event of the gLocations control.\n        /// </summary>\n        /// <param name=\"sender\">The source of the event.</param>\n        /// <param name=\"e\">The <see cref=\"GridReorderEventArgs\"/> instance containing the event data.</param>\n        protected void gLocations_Reorder( object sender, GridReorderEventArgs e )\n        {\n            if ( ReorderLocationClick != null )\n            {\n                var eventArg = new CheckinGroupEventArg( GroupGuid, e.DataKey, e.OldIndex, e.NewIndex );\n                ReorderLocationClick( this, eventArg );\n            }\n        }\n\n        /// <summary>\n        /// Handles the Click event of the DeleteLocation control.\n        /// </summary>\n        /// <param name=\"sender\">The source of the event.</param>\n        /// <param name=\"e\">The <see cref=\"RowEventArgs\"/> instance containing the event data.</param>\n        protected void DeleteLocation_Click( object sender, RowEventArgs e )\n        {\n            if ( DeleteLocationClick != null )\n            {\n                DeleteLocationClick( sender, e );\n            }\n        }\n\n        /// <summary>\n        /// Handles the Click event of the AddLocation control.\n        /// </summary>\n        /// <param name=\"sender\">The source of the event.</param>\n        /// <param name=\"e\">The <see cref=\"EventArgs\"/> instance containing the event data.</param>\n        protected void AddLocation_Click( object sender, EventArgs e )\n        {\n            if ( AddLocationClick != null )\n            {\n                AddLocationClick( sender, e );\n            }\n        }\n\n        /// <summary>\n        /// Occurs when [reorder field click].\n        /// </summary>\n        public event EventHandler<CheckinGroupEventArg> ReorderLocationClick;\n\n        /// <summary>\n        /// Occurs when [delete location click].\n        /// </summary>\n        public event EventHandler<RowEventArgs> DeleteLocationClick;\n\n        /// <summary>\n        /// Occurs when [add location click].\n        /// </summary>\n        public event EventHandler AddLocationClick;\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\n    public class TrueTypeInterpreter\n    {\n        Typeface _currentTypeFace;\n        SharpFontInterpreter _interpreter;\n        public void SetTypeFace(Typeface typeface)\n        {\n            _currentTypeFace = typeface;\n            Tables.MaxProfile maximumProfile = _currentTypeFace.MaxProfile;\n            _interpreter = new SharpFontInterpreter(\n                maximumProfile.MaxStackElements,\n                maximumProfile.MaxStorage,\n                maximumProfile.MaxFunctionDefs,\n                maximumProfile.MaxInstructionDefs,\n                maximumProfile.MaxTwilightPoints);\n            // the fpgm table optionally contains a program to run at initialization time \n            if (_currentTypeFace.FpgmProgramBuffer != null)\n            {\n                _interpreter.InitializeFunctionDefs(_currentTypeFace.FpgmProgramBuffer);\n            }\n        }\n\n\n        public GlyphPointF[] HintGlyph(ushort glyphIndex, float glyphSizeInPixel)\n        {\n\n            Glyph glyph = _currentTypeFace.GetGlyphByIndex(glyphIndex);\n            //-------------------------------------------\n            //1. start with original points/contours from glyph \n            int horizontalAdv = _currentTypeFace.GetHAdvanceWidthFromGlyphIndex(glyphIndex);\n            int hFrontSideBearing = _currentTypeFace.GetHFrontSideBearingFromGlyphIndex(glyphIndex);\n\n            return HintGlyph(horizontalAdv,\n                hFrontSideBearing,\n                glyph.MinX,\n                glyph.MaxY,\n                glyph.GlyphPoints,\n                glyph.EndPoints,\n                glyph.GlyphInstructions,\n                glyphSizeInPixel);\n\n        }\n        public GlyphPointF[] HintGlyph(\n            int horizontalAdv,\n            int hFrontSideBearing,\n            int minX,\n            int maxY,\n            GlyphPointF[] glyphPoints,\n            ushort[] contourEndPoints,\n            byte[] instructions,\n            float glyphSizeInPixel)\n        {\n\n            //get glyph for its matrix\n\n            //TODO: review here again\n\n            int verticalAdv = 0;\n            int vFrontSideBearing = 0;\n            var pp1 = new GlyphPointF((minX - hFrontSideBearing), 0, true);\n            var pp2 = new GlyphPointF(pp1.X + horizontalAdv, 0, true);\n            var pp3 = new GlyphPointF(0, maxY + vFrontSideBearing, true);\n            var pp4 = new GlyphPointF(0, pp3.Y - verticalAdv, true);\n            //-------------------------\n\n            //2. use a clone version extend org with 4 elems\n            int orgLen = glyphPoints.Length;\n            GlyphPointF[] newGlyphPoints = Utils.CloneArray(glyphPoints, 4);\n            // add phantom points; these are used to define the extents of the glyph,\n            // and can be modified by hinting instructions\n            newGlyphPoints[orgLen] = pp1;\n            newGlyphPoints[orgLen + 1] = pp2;\n            newGlyphPoints[orgLen + 2] = pp3;\n            newGlyphPoints[orgLen + 3] = pp4;\n\n            //3. scale all point to target pixel size\n            float pxScale = _currentTypeFace.CalculateScaleToPixel(glyphSizeInPixel);\n            for (int i = orgLen + 3; i >= 0; --i)\n            {\n                newGlyphPoints[i].ApplyScale(pxScale);\n            }\n\n            //----------------------------------------------\n            //test : agg's vertical hint\n            //apply large scale on horizontal axis only \n            //translate and then scale back\n            float agg_x_scale = 1000;\n            //\n            if (UseVerticalHinting)\n            {\n                ApplyScaleOnlyOnXAxis(newGlyphPoints, agg_x_scale);\n            }\n\n            //4.  \n            _interpreter.SetControlValueTable(_currentTypeFace.ControlValues,\n                pxScale,\n                glyphSizeInPixel,\n                _currentTypeFace.PrepProgramBuffer);\n            //--------------------------------------------------\n            //5. hint\n            _interpreter.HintGlyph(newGlyphPoints, contourEndPoints, instructions);\n\n            //6. scale back\n            if (UseVerticalHinting)\n            {\n                ApplyScaleOnlyOnXAxis(newGlyphPoints, 1f / agg_x_scale);\n            }\n            return newGlyphPoints;\n\n        }\n\n        public bool UseVerticalHinting { get; set; }\n\n        static void ApplyScaleOnlyOnXAxis(GlyphPointF[] glyphPoints, float xscale)\n        {\n            //TODO: review performance here\n            for (int i = glyphPoints.Length - 1; i >= 0; --i)\n            {\n                glyphPoints[i].ApplyScaleOnlyOnXAxis(xscale);\n            }\n\n        }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "\t/// <summary>\n\t/// Class DeserializeDictionary.\n\t/// </summary>\n\t/// <typeparam name=\"TSerializer\">The type of the t serializer.</typeparam>\n\tinternal static class DeserializeDictionary<TSerializer>\n        where TSerializer : ITypeSerializer\n    {\n\t\t/// <summary>\n\t\t/// The serializer\n\t\t/// </summary>\n\t\tprivate static readonly ITypeSerializer Serializer = JsWriter.GetTypeSerializer<TSerializer>();\n\n\t\t/// <summary>\n\t\t/// The key index\n\t\t/// </summary>\n\t\tconst int KeyIndex = 0;\n\t\t/// <summary>\n\t\t/// The value index\n\t\t/// </summary>\n\t\tconst int ValueIndex = 1;\n\n\t\t/// <summary>\n\t\t/// Gets the parse method.\n\t\t/// </summary>\n\t\t/// <param name=\"type\">The type.</param>\n\t\t/// <returns>ParseStringDelegate.</returns>\n\t\t/// <exception cref=\"System.ArgumentException\"></exception>\n\t\tpublic static ParseStringDelegate GetParseMethod(Type type)\n        {\n            var mapInterface = type.GetTypeWithGenericInterfaceOf(typeof(IDictionary<,>));\n            if (mapInterface == null)\n            {\n#if !SILVERLIGHT\n                if (type == typeof(Hashtable))\n                {\n                    return ParseHashtable;\n                }\n#endif\n                if (type == typeof(IDictionary))\n                {\n                    return GetParseMethod(typeof(Dictionary<object, object>));\n                }\n                throw new ArgumentException(string.Format(\"Type {0} is not of type IDictionary<,>\", type.FullName));\n            }\n\n            //optimized access for regularly used types\n            if (type == typeof(Dictionary<string, string>))\n            {\n                return ParseStringDictionary;\n            }\n            if (type == typeof(JsonObject))\n            {\n                return ParseJsonObject;\n            }\n\n            var dictionaryArgs = mapInterface.GenericTypeArguments();\n            var keyTypeParseMethod = Serializer.GetParseFn(dictionaryArgs[KeyIndex]);\n            if (keyTypeParseMethod == null) return null;\n\n            var valueTypeParseMethod = Serializer.GetParseFn(dictionaryArgs[ValueIndex]);\n            if (valueTypeParseMethod == null) return null;\n\n            var createMapType = type.HasAnyTypeDefinitionsOf(typeof(Dictionary<,>), typeof(IDictionary<,>))\n                ? null : type;\n\n            return value => ParseDictionaryType(value, createMapType, dictionaryArgs, keyTypeParseMethod, valueTypeParseMethod);\n        }\n\n\t\t/// <summary>\n\t\t/// Parses the json object.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>JsonObject.</returns>\n\t\tpublic static JsonObject ParseJsonObject(string value)\n        {\n            var index = VerifyAndGetStartIndex(value, typeof(JsonObject));\n\n            var result = new JsonObject();\n\n            if (JsonTypeSerializer.IsEmptyMap(value, index)) return result;\n\n            var valueLength = value.Length;\n            while (index < valueLength)\n            {\n                var keyValue = Serializer.EatMapKey(value, ref index);\n                Serializer.EatMapKeySeperator(value, ref index);\n                var elementValue = Serializer.EatValue(value, ref index);\n                if (keyValue == null) continue;\n\n                var mapKey = keyValue;\n                var mapValue = elementValue;\n\n                result[mapKey] = mapValue;\n\n                Serializer.EatItemSeperatorOrMapEndChar(value, ref index);\n            }\n\n            return result;\n        }\n\n#if !SILVERLIGHT\n\t\t/// <summary>\n\t\t/// Parses the hashtable.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>Hashtable.</returns>\n\t\tpublic static Hashtable ParseHashtable(string value)\n        {\n            var index = VerifyAndGetStartIndex(value, typeof(Hashtable));\n\n            var result = new Hashtable();\n\n            if (JsonTypeSerializer.IsEmptyMap(value, index)) return result;\n\n            var valueLength = value.Length;\n            while (index < valueLength)\n            {\n                var keyValue = Serializer.EatMapKey(value, ref index);\n                Serializer.EatMapKeySeperator(value, ref index);\n                var elementValue = Serializer.EatValue(value, ref index);\n                if (keyValue == null) continue;\n\n                var mapKey = keyValue;\n                var mapValue = elementValue;\n\n                result[mapKey] = mapValue;\n\n                Serializer.EatItemSeperatorOrMapEndChar(value, ref index);\n            }\n\n            return result;\n        }\n#endif\n\n\t\t/// <summary>\n\t\t/// Parses the string dictionary.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>Dictionary&lt;System.String, System.String&gt;.</returns>\n\t\tpublic static Dictionary<string, string> ParseStringDictionary(string value)\n        {\n            var index = VerifyAndGetStartIndex(value, typeof(Dictionary<string, string>));\n\n            var result = new Dictionary<string, string>();\n\n            if (JsonTypeSerializer.IsEmptyMap(value, index)) return result;\n\n            var valueLength = value.Length;\n            while (index < valueLength)\n            {\n                var keyValue = Serializer.EatMapKey(value, ref index);\n                Serializer.EatMapKeySeperator(value, ref index);\n                var elementValue = Serializer.EatValue(value, ref index);\n                if (keyValue == null) continue;\n\n                var mapKey = Serializer.UnescapeString(keyValue);\n                var mapValue = Serializer.UnescapeString(elementValue);\n\n                result[mapKey] = mapValue;\n\n                Serializer.EatItemSeperatorOrMapEndChar(value, ref index);\n            }\n\n            return result;\n        }\n\n\t\t/// <summary>\n\t\t/// Parses the dictionary.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"TKey\">The type of the t key.</typeparam>\n\t\t/// <typeparam name=\"TValue\">The type of the t value.</typeparam>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"createMapType\">Type of the create map.</param>\n\t\t/// <param name=\"parseKeyFn\">The parse key function.</param>\n\t\t/// <param name=\"parseValueFn\">The parse value function.</param>\n\t\t/// <returns>IDictionary&lt;TKey, TValue&gt;.</returns>\n\t\tpublic static IDictionary<TKey, TValue> ParseDictionary<TKey, TValue>(\n            string value, Type createMapType,\n            ParseStringDelegate parseKeyFn, ParseStringDelegate parseValueFn)\n        {\n            if (value == null) return null;\n\n            var tryToParseItemsAsDictionaries =\n                JsConfig.ConvertObjectTypesIntoStringDictionary && typeof(TValue) == typeof(object);\n            var tryToParseItemsAsPrimitiveTypes =\n                JsConfig.TryToParsePrimitiveTypeValues && typeof(TValue) == typeof(object);\n\n            var index = VerifyAndGetStartIndex(value, createMapType);\n\n            var to = (createMapType == null)\n                ? new Dictionary<TKey, TValue>()\n                : (IDictionary<TKey, TValue>)createMapType.CreateInstance();\n\n            if (JsonTypeSerializer.IsEmptyMap(value, index)) return to;\n\n            var valueLength = value.Length;\n            while (index < valueLength)\n            {\n                var keyValue = Serializer.EatMapKey(value, ref index);\n                Serializer.EatMapKeySeperator(value, ref index);\n                var elementStartIndex = index;\n                var elementValue = Serializer.EatTypeValue(value, ref index);\n                if (keyValue == null) continue;\n\n                TKey mapKey = (TKey)parseKeyFn(keyValue);\n\n                if (tryToParseItemsAsDictionaries)\n                {\n                    Serializer.EatWhitespace(value, ref elementStartIndex);\n                    if (elementStartIndex < valueLength && value[elementStartIndex] == JsWriter.MapStartChar)\n                    {\n                        var tmpMap = ParseDictionary<TKey, TValue>(elementValue, createMapType, parseKeyFn, parseValueFn);\n                        if (tmpMap != null && tmpMap.Count > 0)\n                        {\n                            to[mapKey] = (TValue)tmpMap;\n                        }\n                    }\n                    else if (elementStartIndex < valueLength && value[elementStartIndex] == JsWriter.ListStartChar)\n                    {\n                        to[mapKey] = (TValue)DeserializeList<List<object>, TSerializer>.Parse(elementValue);\n                    }\n                    else\n                    {\n                        to[mapKey] = (TValue)(tryToParseItemsAsPrimitiveTypes && elementStartIndex < valueLength\n                                        ? DeserializeType<TSerializer>.ParsePrimitive(elementValue, value[elementStartIndex])\n                                        : parseValueFn(elementValue));\n                    }\n                }\n                else\n                {\n                    if (tryToParseItemsAsPrimitiveTypes && elementStartIndex < valueLength)\n                    {\n                        Serializer.EatWhitespace(value, ref elementStartIndex);\n                        to[mapKey] = (TValue)DeserializeType<TSerializer>.ParsePrimitive(elementValue, value[elementStartIndex]);\n                    }\n                    else\n                    {\n                        to[mapKey] = (TValue)parseValueFn(elementValue);\n                    }\n                }\n\n                Serializer.EatItemSeperatorOrMapEndChar(value, ref index);\n            }\n\n            return to;\n        }\n\n\t\t/// <summary>\n\t\t/// Verifies the start index of the and get.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"createMapType\">Type of the create map.</param>\n\t\t/// <returns>System.Int32.</returns>\n\t\tprivate static int VerifyAndGetStartIndex(string value, Type createMapType)\n        {\n            var index = 0;\n            if (!Serializer.EatMapStartChar(value, ref index))\n            {\n                //Don't throw ex because some KeyValueDataContractDeserializer don't have '{}'\n                Tracer.Instance.WriteDebug(\"WARN: Map definitions should start with a '{0}', expecting serialized type '{1}', got string starting with: {2}\",\n                    JsWriter.MapStartChar, createMapType != null ? createMapType.Name : \"Dictionary<,>\", value.Substring(0, value.Length < 50 ? value.Length : 50));\n            }\n            return index;\n        }\n\n\t\t/// <summary>\n\t\t/// The parse delegate cache\n\t\t/// </summary>\n\t\tprivate static Dictionary<string, ParseDictionaryDelegate> ParseDelegateCache\n            = new Dictionary<string, ParseDictionaryDelegate>();\n\n\t\t/// <summary>\n\t\t/// Delegate ParseDictionaryDelegate\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"createMapType\">Type of the create map.</param>\n\t\t/// <param name=\"keyParseFn\">The key parse function.</param>\n\t\t/// <param name=\"valueParseFn\">The value parse function.</param>\n\t\t/// <returns>System.Object.</returns>\n\t\tprivate delegate object ParseDictionaryDelegate(string value, Type createMapType,\n            ParseStringDelegate keyParseFn, ParseStringDelegate valueParseFn);\n\n\t\t/// <summary>\n\t\t/// Parses the type of the dictionary.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"createMapType\">Type of the create map.</param>\n\t\t/// <param name=\"argTypes\">The argument types.</param>\n\t\t/// <param name=\"keyParseFn\">The key parse function.</param>\n\t\t/// <param name=\"valueParseFn\">The value parse function.</param>\n\t\t/// <returns>System.Object.</returns>\n\t\tpublic static object ParseDictionaryType(string value, Type createMapType, Type[] argTypes,\n            ParseStringDelegate keyParseFn, ParseStringDelegate valueParseFn)\n        {\n\n            ParseDictionaryDelegate parseDelegate;\n            var key = GetTypesKey(argTypes);\n            if (ParseDelegateCache.TryGetValue(key, out parseDelegate))\n                return parseDelegate(value, createMapType, keyParseFn, valueParseFn);\n\n            var mi = typeof(DeserializeDictionary<TSerializer>).GetPublicStaticMethod(\"ParseDictionary\");\n            var genericMi = mi.MakeGenericMethod(argTypes);\n            parseDelegate = (ParseDictionaryDelegate)genericMi.MakeDelegate(typeof(ParseDictionaryDelegate));\n\n            Dictionary<string, ParseDictionaryDelegate> snapshot, newCache;\n            do\n            {\n                snapshot = ParseDelegateCache;\n                newCache = new Dictionary<string, ParseDictionaryDelegate>(ParseDelegateCache);\n                newCache[key] = parseDelegate;\n\n            } while (!ReferenceEquals(\n                Interlocked.CompareExchange(ref ParseDelegateCache, newCache, snapshot), snapshot));\n\n            return parseDelegate(value, createMapType, keyParseFn, valueParseFn);\n        }\n\n\t\t/// <summary>\n\t\t/// Gets the types key.\n\t\t/// </summary>\n\t\t/// <param name=\"types\">The types.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tprivate static string GetTypesKey(params Type[] types)\n        {\n            var sb = new StringBuilder(256);\n            foreach (var type in types)\n            {\n                if (sb.Length > 0) sb.Append(\">\");\n\n                sb.Append(type.FullName);\n            }\n            return sb.ToString();\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\tpublic class EDBFileWatchParser\n\t{\n\t\tprivate static readonly ILog _log = LogManager.GetLogger(typeof(EDBFileWatchParser));\n\n\t\tprivate readonly EnvironmentWatchElement _environmentWatchElement;\n\n\t\tpublic EDBFileWatchParser(EnvironmentWatchElement environmentWatchElement)\n\t\t{\n\t\t\t_environmentWatchElement = environmentWatchElement;\n\t\t}\n\n\t\tpublic List<FileWatchElement> ToFileWatchCollection()\n\t\t{\n\t\t\tvar environmentDataXml = LoadEDBXml();\n\n\t\t\tvar serversFiltered = environmentDataXml.Descendants(\"Servers\").Descendants(\"Server\").Where(\n\t\t\t\tserver =>\n\t\t\t\t{\n\t\t\t\t\tvar serverName = server.Element(\"Name\").Value;\n\t\t\t\t\tvar networkArea = server.Element(\"NetworkArea\").Value;\n\n\t\t\t\t\treturn serverName.RegExMatches(_environmentWatchElement.ServerNames) &&\n\t\t\t\t\t\t!serverName.RegExMatches(_environmentWatchElement.ServerNamesNotMatch) &&\n\t\t\t\t\t\tnetworkArea.RegExMatches(_environmentWatchElement.NetworkAreas) &&\n\t\t\t\t\t\t!networkArea.RegExMatches(_environmentWatchElement.NetworkAreasNotMatch);\n\t\t\t\t}).ToArray();\n\n\t\t\tvar watches = new List<FileWatchElement>();\n\t\t\tforeach (var serverNode in serversFiltered)\n\t\t\t{\n\t\t\t\tvar serverName = serverNode.Element(\"Name\").Value;\n\t\t\t\tvar serverNetworkArea = serverNode.Element(\"NetworkArea\").Value;\n\n\t\t\t\tforeach (var serviceNode in serverNode.Descendants(\"Services\").Descendants(\"Entity\"))\n\t\t\t\t{\n\t\t\t\t\tvar serviceName = serviceNode.Element(\"Name\").Value;\n\n\t\t\t\t\tif (!serviceName.RegExMatches(_environmentWatchElement.ServiceNames) ||\n\t\t\t\t\t\t\tserviceName.RegExMatches(_environmentWatchElement.ServiceNamesNotMatch))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tvar fields = new FieldCollection\n\t\t\t\t\t{\n\t\t\t\t\t\tnew FieldElement { Key = \"host\", Value = serverName },\n\t\t\t\t\t\tnew FieldElement { Key = \"service\", Value = serviceName },\n\t\t\t\t\t};\n\n\t\t\t\t\tforeach (FieldElement field in _environmentWatchElement.Fields)\n\t\t\t\t\t{\n\t\t\t\t\t\tfields.Add(field);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar serviceLogFile = (string)serviceNode.Elements(\"LogPath\").FirstOrDefault();\n\t\t\t\t\tvar serviceLogType = (string)serviceNode.Elements(\"LogPathType\").FirstOrDefault();\n\t\t\t\t\tvar serviceLogFile1 = (string)serviceNode.Elements(\"LogPath1\").FirstOrDefault();\n\t\t\t\t\tvar serviceLogType1 = (string)serviceNode.Elements(\"LogPath1Type\").FirstOrDefault();\n\t\t\t\t\tvar serviceLogFile2 = (string)serviceNode.Elements(\"LogPath2\").FirstOrDefault();\n\t\t\t\t\tvar serviceLogType2 = (string)serviceNode.Elements(\"LogPath2Type\").FirstOrDefault();\n\n\t\t\t\t\tAddFileWatchElementForLogFile(serviceLogFile, serviceLogType, watches, fields, serverNetworkArea, serverName,\n\t\t\t\t\t\tserviceName);\n\t\t\t\t\tAddFileWatchElementForLogFile(serviceLogFile1, serviceLogType1, watches, fields, serverNetworkArea, serverName,\n\t\t\t\t\t\tserviceName);\n\t\t\t\t\tAddFileWatchElementForLogFile(serviceLogFile2, serviceLogType2, watches, fields, serverNetworkArea, serverName,\n\t\t\t\t\t\tserviceName);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn watches;\n\t\t}\n\n\t\tprivate void AddFileWatchElementForLogFile(string logFile, string logType, ICollection<FileWatchElement> watches,\n\t\t\tFieldCollection fields, string serverNetworkArea, string serverName, string serviceName)\n\t\t{\n\t\t\t//Don't ship logs without a type or with an empty type\n\t\t\tif (!string.IsNullOrEmpty(logType) && !string.IsNullOrWhiteSpace(logType))\n\t\t\t{\n\t\t\t\tvar newWatch = new FileWatchElement\n\t\t\t\t{\n\t\t\t\t\tFiles = logFile,\n\t\t\t\t\tType = logType,\n\t\t\t\t\tFields = fields\n\t\t\t\t};\n\n\t\t\t\tvar overrideConfig = FindOverride(serviceName);\n\t\t\t\tif (overrideConfig != null)\n\t\t\t\t{\n\t\t\t\t\tnewWatch.CloseWhenIdle = overrideConfig.CloseWhenIdle;\n\t\t\t\t\tif (overrideConfig.CustomNxlogConfig != null)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewWatch.CustomNxlogConfig = new CustomNxlogConfig\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tValue = overrideConfig.CustomNxlogConfig.Value\n\t\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tnewWatch.SourceTailer = overrideConfig.SourceTailer;\n\t\t\t\t\tnewWatch.MultilineRule = overrideConfig.MultilineRule;\n\n\t\t\t\t\tforeach (FieldElement overrideField in overrideConfig.Fields)\n\t\t\t\t\t{\n\t\t\t\t\t\tnewWatch.Fields.Remove(overrideField.Key);\n\t\t\t\t\t\tnewWatch.Fields.Add(new FieldElement { Key = overrideField.Key, Value = overrideField.Value });\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\twatches.Add(newWatch);\n\n\t\t\t\t_log.DebugFormat(\n\t\t\t\t\t\"Added file watch from EDB: {0} ({1}) => Matched NetworkArea:{2} ~= {3}, ServerName:{4} ~= {5}, ServiceName:{6} ~= {7}\",\n\t\t\t\t\tlogFile, logType,\n\t\t\t\t\tserverNetworkArea, _environmentWatchElement.NetworkAreas,\n\t\t\t\t\tserverName, _environmentWatchElement.ServerNames,\n\t\t\t\t\tserviceName, _environmentWatchElement.ServiceNames);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!string.IsNullOrEmpty(logFile))\n\t\t\t\t{\n\t\t\t\t\t_log.DebugFormat(\n\t\t\t\t\t\t\"Ignored file watch from EDB because it has an empty type: {0} ({1})\",\n\t\t\t\t\t\tlogFile, logType);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate XDocument LoadEDBXml()\n\t\t{\n\t\t\tXDocument environmentDataXml;\n\t\t\tvar path = _environmentWatchElement.DataFile.Replace('\\\\', Path.DirectorySeparatorChar);\n\t\t\t//Use StreamReader to autodetect file encoding - http://stackoverflow.com/a/4569093/13238\n\t\t\tusing (var sr = new StreamReader(path, true))\n\t\t\t{\n\t\t\t\tenvironmentDataXml = XDocument.Load(sr);\n\t\t\t}\n\t\t\treturn environmentDataXml;\n\t\t}\n\n\t\tpublic IEnumerable<EDBEnvironment> GenerateLogsearchEnvironmentDiagram()\n\t\t{\n\t\t\tvar environmentDataXml = LoadEDBXml();\n\n\t\t\t/* NB Note how we force LINQ evaluation for each query by calling ToArray().  \n\t\t\t * Without this data seems to get duplicated.\n\t\t\t */\n\n\t\t\tvar networkAreas = (from server in environmentDataXml.Descendants(\"Servers\").Descendants(\"Server\")\n\t\t\t\t\t\t\t\tselect new\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tName = server.Element(\"NetworkArea\").Value\n\t\t\t\t\t\t\t\t}\n\t\t\t\t).Distinct().ToArray();\n\n\t\t\tvar servers = (from server in environmentDataXml.Descendants(\"Servers\").Descendants(\"Server\")\n\t\t\t\t\t\t\tselect new EdbServer\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName = server.Element(\"Name\").Value,\n\t\t\t\t\t\t\t\tDescription = (string)server.Elements(\"Description\").FirstOrDefault(),\n\t\t\t\t\t\t\t\tTags = (string)server.Elements(\"Tags\").FirstOrDefault(),\n\t\t\t\t\t\t\t\tDomain = server.Element(\"Domain\").Value,\n\t\t\t\t\t\t\t\tEnvironment = server.Element(\"Environment\").Value,\n\t\t\t\t\t\t\t\tNetworkArea = server.Element(\"NetworkArea\").Value,\n\t\t\t\t\t\t\t\tServices = (from service in server.Descendants(\"Services\").Descendants(\"Entity\")\n\t\t\t\t\t\t\t\t\t\t\t\tselect service).ToList()\n\t\t\t\t\t\t\t}).Distinct().ToArray();\n\n\t\t\tvar environmentHierarchy = new List<EDBEnvironment>\n\t\t\t{\n\t\t\t\tnew EDBEnvironment\n\t\t\t\t{\n\t\t\t\t\tName = environmentDataXml.Element(\"Environment\").Element(\"Name\").Value,\n\t\t\t\t\tServerGroups = (from serverGroup in networkAreas\n\t\t\t\t\t\tselect new EDBServerGroup\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tName = serverGroup.Name,\n\t\t\t\t\t\t\tServers = (from server in servers\n\t\t\t\t\t\t\t\twhere server.NetworkArea == serverGroup.Name\n\t\t\t\t\t\t\t\tselect server).ToList(),\n\t\t\t\t\t\t}).ToList()\n\t\t\t\t}\n\t\t\t};\n\n\t\t\treturn environmentHierarchy.ToArray();\n\t\t}\n\n\t\tOverrideConfig FindOverride(string serviceName)\n\t\t{\n\t\t\tvar overrides = _environmentWatchElement.OverrideConfigs;\n\n\t\t\tforeach (var overrideConfig in overrides)\n\t\t\t{\n\t\t\t\tvar regex = new Regex(overrideConfig.ForServiceNames);\n\t\t\t\tif (regex.Match(serviceName).Success)\n\t\t\t\t\treturn overrideConfig;\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\t}\n", "label": "FeatureEnvy"}
{"text": "\n    internal partial class Lexer : AbstractLexer\n    {\n        private const int TriviaListInitialCapacity = 8;\n\n        private readonly CSharpParseOptions _options;\n\n        private LexerMode _mode;\n        private readonly StringBuilder _builder;\n        private char[] _identBuffer;\n        private int _identLen;\n        private DirectiveStack _directives;\n        private readonly LexerCache _cache;\n        private readonly bool _allowPreprocessorDirectives;\n\n        internal struct TokenInfo\n        {\n            // scanned values\n            internal SyntaxKind Kind;\n            internal SyntaxKind ContextualKind;\n            internal string Text;\n            internal SpecialType ValueKind;\n            internal bool RequiresTextForXmlEntity;\n            internal bool HasIdentifierEscapeSequence;\n            internal string StringValue;\n            internal char CharValue;\n            internal int IntValue;\n            internal uint UintValue;\n            internal long LongValue;\n            internal ulong UlongValue;\n            internal float FloatValue;\n            internal double DoubleValue;\n            internal decimal DecimalValue;\n            internal bool IsVerbatim;\n        }\n\n        public Lexer(SourceText text, CSharpParseOptions options, bool allowPreprocessorDirectives = true)\n            : base(text)\n        {\n            Debug.Assert(options != null);\n\n            _options = options;\n            _builder = new StringBuilder();\n            _identBuffer = new char[32];\n            _cache = new LexerCache();\n            _createQuickTokenFunction = this.CreateQuickToken;\n            _allowPreprocessorDirectives = allowPreprocessorDirectives;\n        }\n\n        public override void Dispose()\n        {\n            _cache.Free();\n\n            if (_xmlParser != null)\n            {\n                _xmlParser.Dispose();\n            }\n\n            base.Dispose();\n        }\n\n        public bool SuppressDocumentationCommentParse\n        {\n            get { return _options.DocumentationMode < DocumentationMode.Parse; }\n        }\n\n        public CSharpParseOptions Options\n        {\n            get { return _options; }\n        }\n\n        public DirectiveStack Directives\n        {\n            get { return _directives; }\n        }\n\n        public void Reset(int position, DirectiveStack directives)\n        {\n            this.TextWindow.Reset(position);\n            _directives = directives;\n        }\n\n        private static LexerMode ModeOf(LexerMode mode)\n        {\n            return mode & LexerMode.MaskLexMode;\n        }\n\n        private bool ModeIs(LexerMode mode)\n        {\n            return ModeOf(_mode) == mode;\n        }\n\n        private static XmlDocCommentLocation LocationOf(LexerMode mode)\n        {\n            return (XmlDocCommentLocation)((int)(mode & LexerMode.MaskXmlDocCommentLocation) >> 16);\n        }\n\n        private bool LocationIs(XmlDocCommentLocation location)\n        {\n            return LocationOf(_mode) == location;\n        }\n\n        private void MutateLocation(XmlDocCommentLocation location)\n        {\n            _mode &= ~LexerMode.MaskXmlDocCommentLocation;\n            _mode |= (LexerMode)((int)location << 16);\n        }\n\n        private static XmlDocCommentStyle StyleOf(LexerMode mode)\n        {\n            return (XmlDocCommentStyle)((int)(mode & LexerMode.MaskXmlDocCommentStyle) >> 20);\n        }\n\n        private bool StyleIs(XmlDocCommentStyle style)\n        {\n            return StyleOf(_mode) == style;\n        }\n\n        private bool InDocumentationComment\n        {\n            get\n            {\n                switch (ModeOf(_mode))\n                {\n                    case LexerMode.XmlDocComment:\n                    case LexerMode.XmlElementTag:\n                    case LexerMode.XmlAttributeTextQuote:\n                    case LexerMode.XmlAttributeTextDoubleQuote:\n                    case LexerMode.XmlCrefQuote:\n                    case LexerMode.XmlCrefDoubleQuote:\n                    case LexerMode.XmlNameQuote:\n                    case LexerMode.XmlNameDoubleQuote:\n                    case LexerMode.XmlCDataSectionText:\n                    case LexerMode.XmlCommentText:\n                    case LexerMode.XmlProcessingInstructionText:\n                    case LexerMode.XmlCharacter:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        public SyntaxToken Lex(ref LexerMode mode)\n        {\n            var result = Lex(mode);\n            mode = _mode;\n            return result;\n        }\n\n#if DEBUG\n        internal static int TokensLexed;\n#endif\n\n        public SyntaxToken Lex(LexerMode mode)\n        {\n#if DEBUG\n            TokensLexed++;\n#endif\n            _mode = mode;\n            switch (_mode)\n            {\n                case LexerMode.Syntax:\n                case LexerMode.DebuggerSyntax:\n                    return this.QuickScanSyntaxToken() ?? this.LexSyntaxToken();\n                case LexerMode.Directive:\n                    return this.LexDirectiveToken();\n            }\n\n            switch (ModeOf(_mode))\n            {\n                case LexerMode.XmlDocComment:\n                    return this.LexXmlToken();\n                case LexerMode.XmlElementTag:\n                    return this.LexXmlElementTagToken();\n                case LexerMode.XmlAttributeTextQuote:\n                case LexerMode.XmlAttributeTextDoubleQuote:\n                    return this.LexXmlAttributeTextToken();\n                case LexerMode.XmlCDataSectionText:\n                    return this.LexXmlCDataSectionTextToken();\n                case LexerMode.XmlCommentText:\n                    return this.LexXmlCommentTextToken();\n                case LexerMode.XmlProcessingInstructionText:\n                    return this.LexXmlProcessingInstructionTextToken();\n                case LexerMode.XmlCrefQuote:\n                case LexerMode.XmlCrefDoubleQuote:\n                    return this.LexXmlCrefOrNameToken();\n                case LexerMode.XmlNameQuote:\n                case LexerMode.XmlNameDoubleQuote:\n                    // Same lexing as a cref attribute, just treat the identifiers a little differently.\n                    return this.LexXmlCrefOrNameToken();\n                case LexerMode.XmlCharacter:\n                    return this.LexXmlCharacter();\n            }\n\n            Debug.Assert(false, \"Unknown LexMode passed to Lexer.Lex\");\n            return this.LexSyntaxToken();\n        }\n\n        private SyntaxListBuilder _leadingTriviaCache = new SyntaxListBuilder(10);\n        private SyntaxListBuilder _trailingTriviaCache = new SyntaxListBuilder(10);\n\n        private static int GetFullWidth(SyntaxListBuilder builder)\n        {\n            int width = 0;\n\n            if (builder != null)\n            {\n                for (int i = 0; i < builder.Count; i++)\n                {\n                    width += builder[i].FullWidth;\n                }\n            }\n\n            return width;\n        }\n\n        private SyntaxToken LexSyntaxToken()\n        {\n            _leadingTriviaCache.Clear();\n            this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache);\n            var leading = _leadingTriviaCache;\n\n            var tokenInfo = default(TokenInfo);\n\n            this.Start();\n            this.ScanSyntaxToken(ref tokenInfo);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            _trailingTriviaCache.Clear();\n            this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache);\n            var trailing = _trailingTriviaCache;\n\n            return Create(ref tokenInfo, leading, trailing, errors);\n        }\n\n        internal SyntaxTriviaList LexSyntaxLeadingTrivia()\n        {\n            _leadingTriviaCache.Clear();\n            this.LexSyntaxTrivia(afterFirstToken: TextWindow.Position > 0, isTrailing: false, triviaList: ref _leadingTriviaCache);\n            return new SyntaxTriviaList(default(Microsoft.CodeAnalysis.SyntaxToken), SyntaxList.List(_leadingTriviaCache), 0, 0);\n        }\n\n        internal SyntaxTriviaList LexSyntaxTrailingTrivia()\n        {\n            _trailingTriviaCache.Clear();\n            this.LexSyntaxTrivia(afterFirstToken: true, isTrailing: true, triviaList: ref _trailingTriviaCache);\n            return new SyntaxTriviaList(default(Microsoft.CodeAnalysis.SyntaxToken), SyntaxList.List(_trailingTriviaCache), 0, 0);\n        }\n\n        private SyntaxToken Create(ref TokenInfo info, SyntaxListBuilder leading, SyntaxListBuilder trailing, SyntaxDiagnosticInfo[] errors)\n        {\n            Debug.Assert(info.Kind != SyntaxKind.IdentifierToken || info.StringValue != null);\n\n            var leadingNode = SyntaxList.List(leading);\n            var trailingNode = SyntaxList.List(trailing);\n\n            SyntaxToken token;\n            if (info.RequiresTextForXmlEntity)\n            {\n                token = SyntaxFactory.Token(leadingNode, info.Kind, info.Text, info.StringValue, trailingNode);\n            }\n            else\n            {\n                switch (info.Kind)\n                {\n                    case SyntaxKind.IdentifierToken:\n                        token = SyntaxFactory.Identifier(info.ContextualKind, leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.NumericLiteralToken:\n                        switch (info.ValueKind)\n                        {\n                            case SpecialType.System_Int32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.IntValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt32:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UintValue, trailingNode);\n                                break;\n                            case SpecialType.System_Int64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.LongValue, trailingNode);\n                                break;\n                            case SpecialType.System_UInt64:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.UlongValue, trailingNode);\n                                break;\n                            case SpecialType.System_Single:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.FloatValue, trailingNode);\n                                break;\n                            case SpecialType.System_Double:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DoubleValue, trailingNode);\n                                break;\n                            case SpecialType.System_Decimal:\n                                token = SyntaxFactory.Literal(leadingNode, info.Text, info.DecimalValue, trailingNode);\n                                break;\n                            default:\n                                throw ExceptionUtilities.UnexpectedValue(info.ValueKind);\n                        }\n\n                        break;\n                    case SyntaxKind.InterpolatedStringToken:\n                        // we do not record a separate \"value\" for an interpolated string token, as it must be rescanned during parsing.\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.Text, trailingNode);\n                        break;\n                    case SyntaxKind.StringLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.Kind, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.CharacterLiteralToken:\n                        token = SyntaxFactory.Literal(leadingNode, info.Text, info.CharValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralNewLineToken:\n                        token = SyntaxFactory.XmlTextNewLine(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlTextLiteralToken:\n                        token = SyntaxFactory.XmlTextLiteral(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.XmlEntityLiteralToken:\n                        token = SyntaxFactory.XmlEntity(leadingNode, info.Text, info.StringValue, trailingNode);\n                        break;\n                    case SyntaxKind.EndOfDocumentationCommentToken:\n                    case SyntaxKind.EndOfFileToken:\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                    case SyntaxKind.None:\n                        token = SyntaxFactory.BadToken(leadingNode, info.Text, trailingNode);\n                        break;\n\n                    default:\n                        Debug.Assert(SyntaxFacts.IsPunctuationOrKeyword(info.Kind));\n                        token = SyntaxFactory.Token(leadingNode, info.Kind, trailingNode);\n                        break;\n                }\n            }\n\n            if (errors != null && (_options.DocumentationMode >= DocumentationMode.Diagnose || !InDocumentationComment))\n            {\n                token = token.WithDiagnosticsGreen(errors);\n            }\n\n            return token;\n        }\n\n        private void ScanSyntaxToken(ref TokenInfo info)\n        {\n            // Initialize for new token scan\n            info.Kind = SyntaxKind.None;\n            info.ContextualKind = SyntaxKind.None;\n            info.Text = null;\n            char character;\n            char surrogateCharacter = SlidingTextWindow.InvalidCharacter;\n            bool isEscaped = false;\n\n            // Start scanning the token\n            character = TextWindow.PeekChar();\n            switch (character)\n            {\n                case '\\\"':\n                case '\\'':\n                    this.ScanStringLiteral(ref info);\n                    break;\n\n                case '/':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.SlashEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.SlashToken;\n                    }\n\n                    break;\n\n                case '.':\n                    if (!this.ScanNumericLiteral(ref info))\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.DotToken;\n                    }\n\n                    break;\n\n                case ',':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.CommaToken;\n                    break;\n\n                case ':':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == ':')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.ColonColonToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.ColonToken;\n                    }\n\n                    break;\n\n                case ';':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.SemicolonToken;\n                    break;\n\n                case '~':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.TildeToken;\n                    break;\n\n                case '!':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.ExclamationEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.ExclamationToken;\n                    }\n\n                    break;\n\n                case '=':\n                    TextWindow.AdvanceChar();\n                    if ((character = TextWindow.PeekChar()) == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.EqualsEqualsToken;\n                    }\n                    else if (character == '>')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.EqualsGreaterThanToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.EqualsToken;\n                    }\n\n                    break;\n\n                case '*':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.AsteriskEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.AsteriskToken;\n                    }\n\n                    break;\n\n                case '(':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.OpenParenToken;\n                    break;\n\n                case ')':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.CloseParenToken;\n                    break;\n\n                case '{':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.OpenBraceToken;\n                    break;\n\n                case '}':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.CloseBraceToken;\n                    break;\n\n                case '[':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.OpenBracketToken;\n                    break;\n\n                case ']':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.CloseBracketToken;\n                    break;\n\n                case '?':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '?')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.QuestionQuestionToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.QuestionToken;\n                    }\n\n                    break;\n\n                case '+':\n                    TextWindow.AdvanceChar();\n                    if ((character = TextWindow.PeekChar()) == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.PlusEqualsToken;\n                    }\n                    else if (character == '+')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.PlusPlusToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.PlusToken;\n                    }\n\n                    break;\n\n                case '-':\n                    TextWindow.AdvanceChar();\n                    if ((character = TextWindow.PeekChar()) == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.MinusEqualsToken;\n                    }\n                    else if (character == '-')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.MinusMinusToken;\n                    }\n                    else if (character == '>')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.MinusGreaterThanToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.MinusToken;\n                    }\n\n                    break;\n\n                case '%':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.PercentEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.PercentToken;\n                    }\n\n                    break;\n\n                case '&':\n                    TextWindow.AdvanceChar();\n                    if ((character = TextWindow.PeekChar()) == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.AmpersandEqualsToken;\n                    }\n                    else if (TextWindow.PeekChar() == '&')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.AmpersandAmpersandToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.AmpersandToken;\n                    }\n\n                    break;\n\n                case '^':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.CaretEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.CaretToken;\n                    }\n\n                    break;\n\n                case '|':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.BarEqualsToken;\n                    }\n                    else if (TextWindow.PeekChar() == '|')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.BarBarToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.BarToken;\n                    }\n\n                    break;\n\n                case '<':\n                    if (this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')\n                    {\n                        // For \"<>f_AnonymousType\", which is an identifier in DebuggerSyntax mode\n                        goto case 'a';\n                    }\n\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.LessThanEqualsToken;\n                    }\n                    else if (TextWindow.PeekChar() == '<')\n                    {\n                        if (this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')\n                        {\n                            // For \"GenericOf<<>f__AnonymousType>\"\n                            info.Kind = SyntaxKind.LessThanToken;\n                            break;\n                        }\n\n                        TextWindow.AdvanceChar();\n                        if (TextWindow.PeekChar() == '=')\n                        {\n                            TextWindow.AdvanceChar();\n                            info.Kind = SyntaxKind.LessThanLessThanEqualsToken;\n                        }\n                        else\n                        {\n                            info.Kind = SyntaxKind.LessThanLessThanToken;\n                        }\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.LessThanToken;\n                    }\n\n                    break;\n\n                case '>':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.GreaterThanEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.GreaterThanToken;\n                    }\n\n                    break;\n\n                case '@':\n                    if (TextWindow.PeekChar(1) == '\"')\n                    {\n                        this.ScanVerbatimStringLiteral(ref info);\n                    }\n                    else if (!this.ScanIdentifierOrKeyword(ref info))\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Text = TextWindow.GetText(intern: true);\n                        this.AddError(ErrorCode.ERR_ExpectedVerbatimLiteral);\n                    }\n\n                    break;\n\n                case '$':\n                    if (TextWindow.PeekChar(1) == '\"')\n                    {\n                        this.ScanInterpolatedStringLiteral(false, ref info);\n                        CheckFeatureAvailability(MessageID.IDS_FeatureInterpolatedStrings);\n                        break;\n                    }\n                    else if (TextWindow.PeekChar(1) == '@' && TextWindow.PeekChar(2) == '\"')\n                    {\n                        this.ScanInterpolatedStringLiteral(true, ref info);\n                        CheckFeatureAvailability(MessageID.IDS_FeatureInterpolatedStrings);\n                        break;\n                    }\n                    else if (this.ModeIs(LexerMode.DebuggerSyntax))\n                    {\n                        goto case 'a';\n                    }\n\n                    goto default;\n\n                // All the 'common' identifier characters are represented directly in\n                // these switch cases for optimal perf.  Calling IsIdentifierChar() functions is relatively\n                // expensive.\n                case 'a':\n                case 'b':\n                case 'c':\n                case 'd':\n                case 'e':\n                case 'f':\n                case 'g':\n                case 'h':\n                case 'i':\n                case 'j':\n                case 'k':\n                case 'l':\n                case 'm':\n                case 'n':\n                case 'o':\n                case 'p':\n                case 'q':\n                case 'r':\n                case 's':\n                case 't':\n                case 'u':\n                case 'v':\n                case 'w':\n                case 'x':\n                case 'y':\n                case 'z':\n                case 'A':\n                case 'B':\n                case 'C':\n                case 'D':\n                case 'E':\n                case 'F':\n                case 'G':\n                case 'H':\n                case 'I':\n                case 'J':\n                case 'K':\n                case 'L':\n                case 'M':\n                case 'N':\n                case 'O':\n                case 'P':\n                case 'Q':\n                case 'R':\n                case 'S':\n                case 'T':\n                case 'U':\n                case 'V':\n                case 'W':\n                case 'X':\n                case 'Y':\n                case 'Z':\n                case '_':\n                    this.ScanIdentifierOrKeyword(ref info);\n                    break;\n\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                    this.ScanNumericLiteral(ref info);\n                    break;\n\n                case '\\\\':\n                    {\n                        // Could be unicode escape. Try that.\n                        character = TextWindow.PeekCharOrUnicodeEscape(out surrogateCharacter);\n\n                        isEscaped = true;\n                        if (SyntaxFacts.IsIdentifierStartCharacter(character))\n                        {\n                            goto case 'a';\n                        }\n\n                        goto default;\n                    }\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n\n                    if (_directives.HasUnfinishedIf())\n                    {\n                        this.AddError(ErrorCode.ERR_EndifDirectiveExpected);\n                    }\n\n                    if (_directives.HasUnfinishedRegion())\n                    {\n                        this.AddError(ErrorCode.ERR_EndRegionDirectiveExpected);\n                    }\n\n                    info.Kind = SyntaxKind.EndOfFileToken;\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsIdentifierStartCharacter(character))\n                    {\n                        goto case 'a';\n                    }\n\n                    if (isEscaped)\n                    {\n                        SyntaxDiagnosticInfo error;\n                        TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter, out error);\n                        AddError(error);\n                    }\n                    else\n                    {\n                        TextWindow.AdvanceChar();\n                    }\n\n                    info.Text = TextWindow.GetText(intern: true);\n\n                    this.AddError(ErrorCode.ERR_UnexpectedCharacter, info.Text);\n                    break;\n            }\n        }\n\n        private void CheckFeatureAvailability(MessageID feature)\n        {\n            LanguageVersion availableVersion = this.Options.LanguageVersion;\n            var requiredVersion = feature.RequiredVersion();\n            if (availableVersion >= requiredVersion) return;\n            var featureName = feature.Localize();\n            this.AddError(availableVersion.GetErrorCode(), featureName, requiredVersion.Localize());\n        }\n\n        private bool ScanInteger()\n        {\n            int start = TextWindow.Position;\n            char ch;\n            while ((ch = TextWindow.PeekChar()) >= '0' && ch <= '9')\n            {\n                TextWindow.AdvanceChar();\n            }\n\n            return start < TextWindow.Position;\n        }\n\n        private bool ScanNumericLiteral(ref TokenInfo info)\n        {\n            int start = TextWindow.Position;\n            char ch;\n            bool isHex = false;\n            bool hasDecimal = false;\n            bool hasExponent = false;\n            info.Text = null;\n            info.ValueKind = SpecialType.None;\n            _builder.Clear();\n            bool hasUSuffix = false;\n            bool hasLSuffix = false;\n\n            ch = TextWindow.PeekChar();\n            if (ch == '0' && ((ch = TextWindow.PeekChar(1)) == 'x' || ch == 'X'))\n            {\n                TextWindow.AdvanceChar(2);\n                isHex = true;\n            }\n\n            if (isHex)\n            {\n                // It's OK if it has no digits after the '0x' -- we'll catch it in ScanNumericLiteral\n                // and give a proper error then.\n                while (SyntaxFacts.IsHexDigit(ch = TextWindow.PeekChar()))\n                {\n                    _builder.Append(ch);\n                    TextWindow.AdvanceChar();\n                }\n\n                if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                {\n                    TextWindow.AdvanceChar();\n                    hasUSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                }\n            }\n            else\n            {\n                while ((ch = TextWindow.PeekChar()) >= '0' && ch <= '9')\n                {\n                    _builder.Append(ch);\n                    TextWindow.AdvanceChar();\n                }\n\n                if (this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar() == '#')\n                {\n                    // Previously, in DebuggerSyntax mode, \"123#\" was a valid identifier.\n                    TextWindow.AdvanceChar();\n                    info.StringValue = info.Text = TextWindow.GetText(intern: true);\n                    info.Kind = SyntaxKind.IdentifierToken;\n                    this.AddError(MakeError(ErrorCode.ERR_LegacyObjectIdSyntax));\n                    return true;\n                }\n\n                if ((ch = TextWindow.PeekChar()) == '.')\n                {\n                    var ch2 = TextWindow.PeekChar(1);\n                    if (ch2 >= '0' && ch2 <= '9')\n                    {\n                        hasDecimal = true;\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n\n                        while ((ch = TextWindow.PeekChar()) >= '0' && ch <= '9')\n                        {\n                            _builder.Append(ch);\n                            TextWindow.AdvanceChar();\n                        }\n                    }\n                    else if (_builder.Length == 0)\n                    {\n                        // we only have the dot so far.. (no preceding number or following number)\n                        info.Kind = SyntaxKind.DotToken;\n                        TextWindow.Reset(start);\n                        return false;\n                    }\n                }\n\n                if ((ch = TextWindow.PeekChar()) == 'E' || ch == 'e')\n                {\n                    _builder.Append(ch);\n                    TextWindow.AdvanceChar();\n                    hasExponent = true;\n                    if ((ch = TextWindow.PeekChar()) == '-' || ch == '+')\n                    {\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n                    }\n\n                    while ((ch = TextWindow.PeekChar()) >= '0' && ch <= '9')\n                    {\n                        _builder.Append(ch);\n                        TextWindow.AdvanceChar();\n                    }\n                }\n\n                if (hasExponent || hasDecimal)\n                {\n                    if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Single;\n                    }\n                    else if (ch == 'D' || ch == 'd')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Double;\n                    }\n                    else if (ch == 'm' || ch == 'M')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.ValueKind = SpecialType.System_Decimal;\n                    }\n                    else\n                    {\n                        info.ValueKind = SpecialType.System_Double;\n                    }\n                }\n                else if ((ch = TextWindow.PeekChar()) == 'f' || ch == 'F')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Single;\n                }\n                else if (ch == 'D' || ch == 'd')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Double;\n                }\n                else if (ch == 'm' || ch == 'M')\n                {\n                    TextWindow.AdvanceChar();\n                    info.ValueKind = SpecialType.System_Decimal;\n                }\n                else if (ch == 'L' || ch == 'l')\n                {\n                    if (ch == 'l')\n                    {\n                        this.AddError(TextWindow.Position, 1, ErrorCode.WRN_LowercaseEllSuffix);\n                    }\n\n                    TextWindow.AdvanceChar();\n                    hasLSuffix = true;\n                    if ((ch = TextWindow.PeekChar()) == 'u' || ch == 'U')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasUSuffix = true;\n                    }\n                }\n                else if (ch == 'u' || ch == 'U')\n                {\n                    hasUSuffix = true;\n                    TextWindow.AdvanceChar();\n                    if ((ch = TextWindow.PeekChar()) == 'L' || ch == 'l')\n                    {\n                        TextWindow.AdvanceChar();\n                        hasLSuffix = true;\n                    }\n                }\n            }\n\n            info.Kind = SyntaxKind.NumericLiteralToken;\n            info.Text = TextWindow.GetText(true);\n            Debug.Assert(info.Text != null);\n            var valueText = TextWindow.Intern(_builder);\n            ulong val;\n            switch (info.ValueKind)\n            {\n                case SpecialType.System_Single:\n                    info.FloatValue = this.GetValueSingle(valueText);\n                    break;\n                case SpecialType.System_Double:\n                    info.DoubleValue = this.GetValueDouble(valueText);\n                    break;\n                case SpecialType.System_Decimal:\n                    info.DecimalValue = this.GetValueDecimal(valueText, start, TextWindow.Position);\n                    break;\n                default:\n                    if (string.IsNullOrEmpty(valueText))\n                    {\n                        this.AddError(MakeError(ErrorCode.ERR_InvalidNumber));\n                        val = 0; //safe default\n                    }\n                    else\n                    {\n                        val = this.GetValueUInt64(valueText, isHex);\n                    }\n\n                    // 2.4.4.2 Integer literals\n                    // ...\n                    // The type of an integer literal is determined as follows:\n\n                    // * If the literal has no suffix, it has the first of these types in which its value can be represented: int, uint, long, ulong.\n                    if (!hasUSuffix && !hasLSuffix)\n                    {\n                        if (val <= Int32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int32;\n                            info.IntValue = (int)val;\n                        }\n                        else if (val <= UInt32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_UInt32;\n                            info.UintValue = (uint)val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 2147483648.\n                        }\n                        else if (val <= Int64.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int64;\n                            info.LongValue = (long)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 9223372036854775808\n                        }\n                    }\n                    else if (hasUSuffix && !hasLSuffix)\n                    {\n                        // * If the literal is suffixed by U or u, it has the first of these types in which its value can be represented: uint, ulong.\n                        if (val <= UInt32.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_UInt32;\n                            info.UintValue = (uint)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n                        }\n                    }\n\n                    // * If the literal is suffixed by L or l, it has the first of these types in which its value can be represented: long, ulong.\n                    else if (!hasUSuffix & hasLSuffix)\n                    {\n                        if (val <= Int64.MaxValue)\n                        {\n                            info.ValueKind = SpecialType.System_Int64;\n                            info.LongValue = (long)val;\n                        }\n                        else\n                        {\n                            info.ValueKind = SpecialType.System_UInt64;\n                            info.UlongValue = val;\n\n                            // TODO: See below, it may be desirable to mark this token\n                            // as special for folding if its value is 9223372036854775808\n                        }\n                    }\n\n                    // * If the literal is suffixed by UL, Ul, uL, ul, LU, Lu, lU, or lu, it is of type ulong.\n                    else\n                    {\n                        Debug.Assert(hasUSuffix && hasLSuffix);\n                        info.ValueKind = SpecialType.System_UInt64;\n                        info.UlongValue = val;\n                    }\n\n                    break;\n\n                    // Note, the following portion of the spec is not implemented here. It is implemented\n                    // in the unary minus analysis.\n\n                    // * When a decimal-integer-literal with the value 2147483648 (231) and no integer-type-suffix appears\n                    //   as the token immediately following a unary minus operator token (\u00a77.7.2), the result is a constant\n                    //   of type int with the value \u22122147483648 (\u2212231). In all other situations, such a decimal-integer-\n                    //   literal is of type uint.\n                    // * When a decimal-integer-literal with the value 9223372036854775808 (263) and no integer-type-suffix\n                    //   or the integer-type-suffix L or l appears as the token immediately following a unary minus operator\n                    //   token (\u00a77.7.2), the result is a constant of type long with the value \u22129223372036854775808 (\u2212263).\n                    //   In all other situations, such a decimal-integer-literal is of type ulong.\n            }\n\n            return true;\n        }\n\n        //used in directives\n        private int GetValueInt32(string text, bool isHex)\n        {\n            int result;\n            if (!Int32.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            }\n\n            return result;\n        }\n\n        //used for all non-directive integer literals (cast to desired type afterward)\n        private ulong GetValueUInt64(string text, bool isHex)\n        {\n            ulong result;\n            if (!UInt64.TryParse(text, isHex ? NumberStyles.AllowHexSpecifier : NumberStyles.None, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_IntOverflow));\n            }\n\n            return result;\n        }\n\n        private double GetValueDouble(string text)\n        {\n            double result;\n            if (!Double.TryParse(text, NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_FloatOverflow, \"double\"));\n            }\n\n            return result;\n        }\n\n        private float GetValueSingle(string text)\n        {\n            float result;\n            if (!Single.TryParse(text, NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(MakeError(ErrorCode.ERR_FloatOverflow, \"float\"));\n            }\n\n            return result;\n        }\n\n        private decimal GetValueDecimal(string text, int start, int end)\n        {\n            // Use decimal.TryParse to parse value. Note: the behavior of\n            // decimal.TryParse differs from Dev11 in several cases:\n            //\n            // 1. [-]0eNm where N > 0\n            //     The native compiler ignores sign and scale and treats such cases\n            //     as 0e0m. decimal.TryParse fails so these cases are compile errors.\n            //     [Bug #568475]\n            // 2. 1e-Nm where N >= 1000\n            //     The native compiler reports CS0594 \"Floating-point constant is\n            //     outside the range of type 'decimal'\". decimal.TryParse allows\n            //     N >> 1000 but treats decimals with very small exponents as 0.\n            //     [No bug.]\n            // 3. Decimals with significant digits below 1e-49\n            //     The native compiler considers digits below 1e-49 when rounding.\n            //     decimal.TryParse ignores digits below 1e-49 when rounding. This\n            //     last difference is perhaps the most significant since existing code\n            //     will continue to compile but constant values may be rounded differently.\n            //     (Note that the native compiler does not round in all cases either since\n            //     the native compiler chops the string at 50 significant digits. For example\n            //     \".100000000000000000000000000050000000000000000000001m\" is not\n            //     rounded up to 0.1000000000000000000000000001.)\n            //     [Bug #568494]\n\n            decimal result;\n            if (!decimal.TryParse(text, NumberStyles.AllowDecimalPoint | NumberStyles.AllowExponent, CultureInfo.InvariantCulture, out result))\n            {\n                //we've already lexed the literal, so the error must be from overflow\n                this.AddError(this.MakeError(start, end - start, ErrorCode.ERR_FloatOverflow, \"decimal\"));\n            }\n\n            return result;\n        }\n\n        private void ResetIdentBuffer()\n        {\n            _identLen = 0;\n        }\n\n        private void AddIdentChar(char ch)\n        {\n            if (_identLen >= _identBuffer.Length)\n            {\n                this.GrowIdentBuffer();\n            }\n\n            _identBuffer[_identLen++] = ch;\n        }\n\n        private void GrowIdentBuffer()\n        {\n            var tmp = new char[_identBuffer.Length * 2];\n            Array.Copy(_identBuffer, tmp, _identBuffer.Length);\n            _identBuffer = tmp;\n        }\n\n        private bool ScanIdentifier(ref TokenInfo info)\n        {\n            return\n                ScanIdentifier_FastPath(ref info) ||\n                (InXmlCrefOrNameAttributeValue ? ScanIdentifier_CrefSlowPath(ref info) : ScanIdentifier_SlowPath(ref info));\n        }\n\n        // Implements a faster identifier lexer for the common case in the \n        // language where:\n        //\n        //   a) identifiers are not verbatim\n        //   b) identifiers don't contain unicode characters\n        //   c) identifiers don't contain unicode escapes\n        //\n        // Given that nearly all identifiers will contain [_a-zA-Z0-9] and will\n        // be terminated by a small set of known characters (like dot, comma, \n        // etc.), we can sit in a tight loop looking for this pattern and only\n        // falling back to the slower (but correct) path if we see something we\n        // can't handle.\n        //\n        // Note: this function also only works if the identifier (and terminator)\n        // can be found in the current sliding window of chars we have from our\n        // source text.  With this constraint we can avoid the costly overhead \n        // incurred with peek/advance/next.  Because of this we can also avoid\n        // the unnecessary stores/reads from identBuffer and all other instance\n        // state while lexing.  Instead we just keep track of our start, end,\n        // and max positions and use those for quick checks internally.\n        //\n        // Note: it is critical that this method must only be called from a \n        // codepath that checked for IsIdentifierStartChar or '@' first. \n        private bool ScanIdentifier_FastPath(ref TokenInfo info)\n        {\n            if ((_mode & LexerMode.MaskLexMode) == LexerMode.DebuggerSyntax)\n            {\n                // Debugger syntax is wonky.  Can't use the fast path for it.\n                return false;\n            }\n\n            var currentOffset = TextWindow.Offset;\n            var characterWindow = TextWindow.CharacterWindow;\n            var characterWindowCount = TextWindow.CharacterWindowCount;\n\n            var startOffset = currentOffset;\n\n            while (true)\n            {\n                if (currentOffset == characterWindowCount)\n                {\n                    // no more contiguous characters.  Fall back to slow path\n                    return false;\n                }\n\n                switch (characterWindow[currentOffset])\n                {\n                    case '&':\n                        // CONSIDER: This method is performance critical, so\n                        // it might be safer to kick out at the top (as for\n                        // LexerMode.DebuggerSyntax).\n\n                        // If we're in a cref, this could be the start of an\n                        // xml entity that belongs in the identifier.\n                        if (InXmlCrefOrNameAttributeValue)\n                        {\n                            // Fall back on the slow path.\n                            return false;\n                        }\n\n                        // Otherwise, end the identifier.\n                        goto case '\\0';\n                    case '\\0':\n                    case ' ':\n                    case '\\r':\n                    case '\\n':\n                    case '\\t':\n                    case '!':\n                    case '%':\n                    case '(':\n                    case ')':\n                    case '*':\n                    case '+':\n                    case ',':\n                    case '-':\n                    case '.':\n                    case '/':\n                    case ':':\n                    case ';':\n                    case '<':\n                    case '=':\n                    case '>':\n                    case '?':\n                    case '[':\n                    case ']':\n                    case '^':\n                    case '{':\n                    case '|':\n                    case '}':\n                    case '~':\n                    case '\"':\n                    case '\\'':\n                        // All of the following characters are not valid in an \n                        // identifier.  If we see any of them, then we know we're\n                        // done.\n                        var length = currentOffset - startOffset;\n                        TextWindow.AdvanceChar(length);\n                        info.Text = info.StringValue = TextWindow.Intern(characterWindow, startOffset, length);\n                        info.IsVerbatim = false;\n                        return true;\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        if (currentOffset == startOffset)\n                        {\n                            return false;\n                        }\n                        else\n                        {\n                            goto case 'A';\n                        }\n                    case 'A':\n                    case 'B':\n                    case 'C':\n                    case 'D':\n                    case 'E':\n                    case 'F':\n                    case 'G':\n                    case 'H':\n                    case 'I':\n                    case 'J':\n                    case 'K':\n                    case 'L':\n                    case 'M':\n                    case 'N':\n                    case 'O':\n                    case 'P':\n                    case 'Q':\n                    case 'R':\n                    case 'S':\n                    case 'T':\n                    case 'U':\n                    case 'V':\n                    case 'W':\n                    case 'X':\n                    case 'Y':\n                    case 'Z':\n                    case '_':\n                    case 'a':\n                    case 'b':\n                    case 'c':\n                    case 'd':\n                    case 'e':\n                    case 'f':\n                    case 'g':\n                    case 'h':\n                    case 'i':\n                    case 'j':\n                    case 'k':\n                    case 'l':\n                    case 'm':\n                    case 'n':\n                    case 'o':\n                    case 'p':\n                    case 'q':\n                    case 'r':\n                    case 's':\n                    case 't':\n                    case 'u':\n                    case 'v':\n                    case 'w':\n                    case 'x':\n                    case 'y':\n                    case 'z':\n                        // All of these characters are valid inside an identifier.\n                        // consume it and keep processing.\n                        currentOffset++;\n                        continue;\n\n                    // case '@':  verbatim identifiers are handled in the slow path\n                    // case '\\\\': unicode escapes are handled in the slow path\n                    default:\n                        // Any other character is something we cannot handle.  i.e.\n                        // unicode chars or an escape.  Just break out and move to\n                        // the slow path.\n                        return false;\n                }\n            }\n        }\n\n        private bool ScanIdentifier_SlowPath(ref TokenInfo info)\n        {\n            int start = TextWindow.Position;\n            this.ResetIdentBuffer();\n\n            info.IsVerbatim = TextWindow.PeekChar() == '@';\n            if (info.IsVerbatim)\n            {\n                TextWindow.AdvanceChar();\n            }\n\n            bool isObjectAddress = false;\n\n            while (true)\n            {\n                char surrogateCharacter = SlidingTextWindow.InvalidCharacter;\n                bool isEscaped = false;\n                char ch = TextWindow.PeekChar();\n            top:\n                switch (ch)\n                {\n                    case '\\\\':\n                        if (!isEscaped && TextWindow.IsUnicodeEscape())\n                        {\n                            // ^^^^^^^ otherwise \\u005Cu1234 looks just like \\u1234! (i.e. escape within escape)\n                            info.HasIdentifierEscapeSequence = true;\n                            isEscaped = true;\n                            ch = TextWindow.PeekUnicodeEscape(out surrogateCharacter);\n                            goto top;\n                        }\n\n                        goto default;\n                    case '$':\n                        if (!this.ModeIs(LexerMode.DebuggerSyntax) || _identLen > 0)\n                        {\n                            goto LoopExit;\n                        }\n\n                        break;\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        goto LoopExit;\n                    case '_':\n                    case 'A':\n                    case 'B':\n                    case 'C':\n                    case 'D':\n                    case 'E':\n                    case 'F':\n                    case 'G':\n                    case 'H':\n                    case 'I':\n                    case 'J':\n                    case 'K':\n                    case 'L':\n                    case 'M':\n                    case 'N':\n                    case 'O':\n                    case 'P':\n                    case 'Q':\n                    case 'R':\n                    case 'S':\n                    case 'T':\n                    case 'U':\n                    case 'V':\n                    case 'W':\n                    case 'X':\n                    case 'Y':\n                    case 'Z':\n                    case 'a':\n                    case 'b':\n                    case 'c':\n                    case 'd':\n                    case 'e':\n                    case 'f':\n                    case 'g':\n                    case 'h':\n                    case 'i':\n                    case 'j':\n                    case 'k':\n                    case 'l':\n                    case 'm':\n                    case 'n':\n                    case 'o':\n                    case 'p':\n                    case 'q':\n                    case 'r':\n                    case 's':\n                    case 't':\n                    case 'u':\n                    case 'v':\n                    case 'w':\n                    case 'x':\n                    case 'y':\n                    case 'z':\n                        {\n                            // Again, these are the 'common' identifier characters...\n                            break;\n                        }\n\n                    case '0':\n                        {\n                            if (_identLen == 0)\n                            {\n                                // Debugger syntax allows @0x[hexdigit]+ for object address identifiers.\n                                if (info.IsVerbatim &&\n                                    this.ModeIs(LexerMode.DebuggerSyntax) &&\n                                    (char.ToLower(TextWindow.PeekChar(1)) == 'x'))\n                                {\n                                    isObjectAddress = true;\n                                }\n                                else\n                                {\n                                    goto LoopExit;\n                                }\n                            }\n\n                            // Again, these are the 'common' identifier characters...\n                            break;\n                        }\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        {\n                            if (_identLen == 0)\n                            {\n                                goto LoopExit;\n                            }\n\n                            // Again, these are the 'common' identifier characters...\n                            break;\n                        }\n\n                    case ' ':\n                    case '\\t':\n                    case '.':\n                    case ';':\n                    case '(':\n                    case ')':\n                    case ',':\n                        // ...and these are the 'common' stop characters.\n                        goto LoopExit;\n                    case '<':\n                        if (_identLen == 0 && this.ModeIs(LexerMode.DebuggerSyntax) && TextWindow.PeekChar(1) == '>')\n                        {\n                            // In DebuggerSyntax mode, identifiers are allowed to begin with <>.\n                            TextWindow.AdvanceChar(2);\n                            this.AddIdentChar('<');\n                            this.AddIdentChar('>');\n                            continue;\n                        }\n\n                        goto LoopExit;\n                    default:\n                        {\n                            // This is the 'expensive' call\n                            if (_identLen == 0 && ch > 127 && SyntaxFacts.IsIdentifierStartCharacter(ch))\n                            {\n                                break;\n                            }\n                            else if (_identLen > 0 && ch > 127 && SyntaxFacts.IsIdentifierPartCharacter(ch))\n                            {\n                                //// BUG 424819 : Handle identifier chars > 0xFFFF via surrogate pairs\n                                if (SyntaxFacts.IsFormattingChar(ch))\n                                {\n                                    if (isEscaped)\n                                    {\n                                        SyntaxDiagnosticInfo error;\n                                        TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter, out error);\n                                        AddError(error);\n                                    }\n                                    else\n                                    {\n                                        TextWindow.AdvanceChar();\n                                    }\n\n                                    continue; // Ignore formatting characters\n                                }\n\n                                break;\n                            }\n                            else\n                            {\n                                // Not a valid identifier character, so bail.\n                                goto LoopExit;\n                            }\n                        }\n                }\n\n                if (isEscaped)\n                {\n                    SyntaxDiagnosticInfo error;\n                    TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter, out error);\n                    AddError(error);\n                }\n                else\n                {\n                    TextWindow.AdvanceChar();\n                }\n\n                this.AddIdentChar(ch);\n                if (surrogateCharacter != SlidingTextWindow.InvalidCharacter)\n                {\n                    this.AddIdentChar(surrogateCharacter);\n                }\n            }\n\n        LoopExit:\n            var width = TextWindow.Width; // exact size of input characters\n            if (_identLen > 0)\n            {\n                info.Text = TextWindow.GetInternedText();\n\n                // id buffer is identical to width in input\n                if (_identLen == width)\n                {\n                    info.StringValue = info.Text;\n                }\n                else\n                {\n                    info.StringValue = TextWindow.Intern(_identBuffer, 0, _identLen);\n                }\n\n                if (isObjectAddress)\n                {\n                    // @0x[hexdigit]+\n                    const int objectAddressOffset = 2;\n                    Debug.Assert(string.Equals(info.Text.Substring(0, objectAddressOffset + 1), \"@0x\", StringComparison.OrdinalIgnoreCase));\n                    var valueText = TextWindow.Intern(_identBuffer, objectAddressOffset, _identLen - objectAddressOffset);\n                    // Verify valid hex value.\n                    if ((valueText.Length == 0) || !valueText.All(IsValidHexDigit))\n                    {\n                        goto Fail;\n                    }\n                    // Parse hex value to check for overflow.\n                    this.GetValueUInt64(valueText, isHex: true);\n                }\n\n                return true;\n            }\n\n        Fail:\n            info.Text = null;\n            info.StringValue = null;\n            TextWindow.Reset(start);\n            return false;\n        }\n\n        private static bool IsValidHexDigit(char c)\n        {\n            if ((c >= '0') && (c <= '9'))\n            {\n                return true;\n            }\n            c = char.ToLower(c);\n            return (c >= 'a') && (c <= 'f');\n        }\n\n        /// <summary>\n        /// This method is essentially the same as ScanIdentifier_SlowPath,\n        /// except that it can handle XML entities.  Since ScanIdentifier\n        /// is hot code and since this method does extra work, it seem\n        /// worthwhile to separate it from the common case.\n        /// </summary>\n        /// <param name=\"info\"></param>\n        /// <returns></returns>\n        private bool ScanIdentifier_CrefSlowPath(ref TokenInfo info)\n        {\n            Debug.Assert(InXmlCrefOrNameAttributeValue);\n\n            int start = TextWindow.Position;\n            this.ResetIdentBuffer();\n\n            if (AdvanceIfMatches('@'))\n            {\n                // In xml name attribute values, the '@' is part of the value text of the identifier\n                // (to match dev11).\n                if (InXmlNameAttributeValue)\n                {\n                    AddIdentChar('@');\n                }\n                else\n                {\n                    info.IsVerbatim = true;\n                }\n            }\n\n            while (true)\n            {\n                int beforeConsumed = TextWindow.Position;\n                char consumedChar;\n                char consumedSurrogate;\n\n                if (TextWindow.PeekChar() == '&')\n                {\n                    if (!TextWindow.TryScanXmlEntity(out consumedChar, out consumedSurrogate))\n                    {\n                        // If it's not a valid entity, then it's not part of the identifier.\n                        TextWindow.Reset(beforeConsumed);\n                        goto LoopExit;\n                    }\n                }\n                else\n                {\n                    consumedChar = TextWindow.NextChar();\n                    consumedSurrogate = SlidingTextWindow.InvalidCharacter;\n                }\n\n                // NOTE: If the surrogate is non-zero, then consumedChar won't match\n                // any of the cases below (UTF-16 guarantees that members of surrogate\n                // pairs aren't separately valid).\n\n                bool isEscaped = false;\n            top:\n                switch (consumedChar)\n                {\n                    case '\\\\':\n                        // NOTE: For completeness, we should allow xml entities in unicode escape\n                        // sequences (DevDiv #16321).  Since it is not currently a priority, we will\n                        // try to make the interim behavior sensible: we will only attempt to scan\n                        // a unicode escape if NONE of the characters are XML entities (including\n                        // the backslash, which we have already consumed).\n                        // When we're ready to implement this behavior, we can drop the position\n                        // check and use AdvanceIfMatches instead of PeekChar.\n                        if (!isEscaped && (TextWindow.Position == beforeConsumed + 1) &&\n                            (TextWindow.PeekChar() == 'u' || TextWindow.PeekChar() == 'U'))\n                        {\n                            Debug.Assert(consumedSurrogate == SlidingTextWindow.InvalidCharacter, \"Since consumedChar == '\\\\'\");\n\n                            info.HasIdentifierEscapeSequence = true;\n\n                            TextWindow.Reset(beforeConsumed);\n                            // ^^^^^^^ otherwise \\u005Cu1234 looks just like \\u1234! (i.e. escape within escape)\n                            isEscaped = true;\n                            SyntaxDiagnosticInfo error;\n                            consumedChar = TextWindow.NextUnicodeEscape(out consumedSurrogate, out error);\n                            AddCrefError(error);\n                            goto top;\n                        }\n\n                        goto default;\n\n                    case '_':\n                    case 'A':\n                    case 'B':\n                    case 'C':\n                    case 'D':\n                    case 'E':\n                    case 'F':\n                    case 'G':\n                    case 'H':\n                    case 'I':\n                    case 'J':\n                    case 'K':\n                    case 'L':\n                    case 'M':\n                    case 'N':\n                    case 'O':\n                    case 'P':\n                    case 'Q':\n                    case 'R':\n                    case 'S':\n                    case 'T':\n                    case 'U':\n                    case 'V':\n                    case 'W':\n                    case 'X':\n                    case 'Y':\n                    case 'Z':\n                    case 'a':\n                    case 'b':\n                    case 'c':\n                    case 'd':\n                    case 'e':\n                    case 'f':\n                    case 'g':\n                    case 'h':\n                    case 'i':\n                    case 'j':\n                    case 'k':\n                    case 'l':\n                    case 'm':\n                    case 'n':\n                    case 'o':\n                    case 'p':\n                    case 'q':\n                    case 'r':\n                    case 's':\n                    case 't':\n                    case 'u':\n                    case 'v':\n                    case 'w':\n                    case 'x':\n                    case 'y':\n                    case 'z':\n                        {\n                            // Again, these are the 'common' identifier characters...\n                            break;\n                        }\n\n                    case '0':\n                    case '1':\n                    case '2':\n                    case '3':\n                    case '4':\n                    case '5':\n                    case '6':\n                    case '7':\n                    case '8':\n                    case '9':\n                        {\n                            if (_identLen == 0)\n                            {\n                                TextWindow.Reset(beforeConsumed);\n                                goto LoopExit;\n                            }\n\n                            // Again, these are the 'common' identifier characters...\n                            break;\n                        }\n\n                    case ' ':\n                    case '$':\n                    case '\\t':\n                    case '.':\n                    case ';':\n                    case '(':\n                    case ')':\n                    case ',':\n                    case '<':\n                        // ...and these are the 'common' stop characters.\n                        TextWindow.Reset(beforeConsumed);\n                        goto LoopExit;\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        TextWindow.Reset(beforeConsumed);\n                        goto LoopExit;\n                    default:\n                        {\n                            // This is the 'expensive' call\n                            if (_identLen == 0 && consumedChar > 127 && SyntaxFacts.IsIdentifierStartCharacter(consumedChar))\n                            {\n                                break;\n                            }\n                            else if (_identLen > 0 && consumedChar > 127 && SyntaxFacts.IsIdentifierPartCharacter(consumedChar))\n                            {\n                                //// BUG 424819 : Handle identifier chars > 0xFFFF via surrogate pairs\n                                if (SyntaxFacts.IsFormattingChar(consumedChar))\n                                {\n                                    continue; // Ignore formatting characters\n                                }\n\n                                break;\n                            }\n                            else\n                            {\n                                // Not a valid identifier character, so bail.\n                                TextWindow.Reset(beforeConsumed);\n                                goto LoopExit;\n                            }\n                        }\n                }\n\n                this.AddIdentChar(consumedChar);\n                if (consumedSurrogate != SlidingTextWindow.InvalidCharacter)\n                {\n                    this.AddIdentChar(consumedSurrogate);\n                }\n            }\n\n        LoopExit:\n            if (_identLen > 0)\n            {\n                // NOTE: If we don't intern the string value, then we won't get a hit\n                // in the keyword dictionary!  (It searches for a key using identity.)\n                // The text does not have to be interned (and probalbly shouldn't be\n                // if it contains entities (else-case).\n\n                var width = TextWindow.Width; // exact size of input characters\n\n                // id buffer is identical to width in input\n                if (_identLen == width)\n                {\n                    info.StringValue = TextWindow.GetInternedText();\n                    info.Text = info.StringValue;\n                }\n                else\n                {\n                    info.StringValue = TextWindow.Intern(_identBuffer, 0, _identLen);\n                    info.Text = TextWindow.GetText(intern: false);\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Text = null;\n                info.StringValue = null;\n                TextWindow.Reset(start);\n                return false;\n            }\n        }\n\n        private bool ScanIdentifierOrKeyword(ref TokenInfo info)\n        {\n            info.ContextualKind = SyntaxKind.None;\n\n            if (this.ScanIdentifier(ref info))\n            {\n                // check to see if it is an actual keyword\n                if (!info.IsVerbatim && !info.HasIdentifierEscapeSequence)\n                {\n                    if (this.ModeIs(LexerMode.Directive))\n                    {\n                        SyntaxKind keywordKind = SyntaxFacts.GetPreprocessorKeywordKind(info.Text);\n                        if (SyntaxFacts.IsPreprocessorContextualKeyword(keywordKind))\n                        {\n                            // Let the parser decide which instances are actually keywords.\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                        }\n                    }\n                    else\n                    {\n                        if (!_cache.TryGetKeywordKind(info.Text, out info.Kind))\n                        {\n                            info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                        else if (SyntaxFacts.IsContextualKeyword(info.Kind))\n                        {\n                            info.ContextualKind = info.Kind;\n                            info.Kind = SyntaxKind.IdentifierToken;\n                        }\n                    }\n\n                    if (info.Kind == SyntaxKind.None)\n                    {\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                }\n\n                return true;\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                return false;\n            }\n        }\n\n        private void LexSyntaxTrivia(bool afterFirstToken, bool isTrailing, ref SyntaxListBuilder triviaList)\n        {\n            bool onlyWhitespaceOnLine = !isTrailing;\n\n            while (true)\n            {\n                this.Start();\n                char ch = TextWindow.PeekChar();\n                if (ch == ' ')\n                {\n                    this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                    continue;\n                }\n                else if (ch > 127)\n                {\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        ch = ' ';\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        ch = '\\n';\n                    }\n                }\n\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                    case '\\u001A':\n                        this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n                        break;\n                    case '/':\n                        if ((ch = TextWindow.PeekChar(1)) == '/')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.SingleLine), ref triviaList);\n                                break;\n                            }\n\n                            // normal single line comment\n                            this.ScanToEndOfLine();\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n                        else if (ch == '*')\n                        {\n                            if (!this.SuppressDocumentationCommentParse && TextWindow.PeekChar(2) == '*' &&\n                                TextWindow.PeekChar(3) != '*' && TextWindow.PeekChar(3) != '/')\n                            {\n                                // Doc comments should never be in trailing trivia.\n                                // Stop processing so that it will be leading trivia on the next token.\n                                if (isTrailing)\n                                {\n                                    return;\n                                }\n\n                                this.AddTrivia(this.LexXmlDocComment(XmlDocCommentStyle.Delimited), ref triviaList);\n                                break;\n                            }\n\n                            bool isTerminated;\n                            this.ScanMultiLineComment(out isTerminated);\n                            if (!isTerminated)\n                            {\n                                // The comment didn't end.  Report an error at the start point.\n                                this.AddError(ErrorCode.ERR_OpenEndedComment);\n                            }\n\n                            var text = TextWindow.GetText(false);\n                            this.AddTrivia(SyntaxFactory.Comment(text), ref triviaList);\n                            onlyWhitespaceOnLine = false;\n                            break;\n                        }\n\n                        // not trivia\n                        return;\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref triviaList);\n                        if (isTrailing)\n                        {\n                            return;\n                        }\n\n                        onlyWhitespaceOnLine = true;\n                        break;\n                    case '#':\n                        if (_allowPreprocessorDirectives)\n                        {\n                            this.LexDirectiveAndExcludedTrivia(afterFirstToken, isTrailing || !onlyWhitespaceOnLine, ref triviaList);\n                            break;\n                        }\n                        else\n                        {\n                            return;\n                        }\n                    default:\n                        return;\n                }\n            }\n        }\n\n        private void AddTrivia(CSharpSyntaxNode trivia, ref SyntaxListBuilder list)\n        {\n            if (this.HasErrors)\n            {\n                trivia = trivia.WithDiagnosticsGreen(this.GetErrors(leadingTriviaWidth: 0));\n            }\n\n            if (list == null)\n            {\n                list = new SyntaxListBuilder(TriviaListInitialCapacity);\n            }\n\n            list.Add(trivia);\n        }\n\n        private bool ScanMultiLineComment(out bool isTerminated)\n        {\n            if (TextWindow.PeekChar() == '/' && TextWindow.PeekChar(1) == '*')\n            {\n                TextWindow.AdvanceChar(2);\n\n                char ch;\n                while (true)\n                {\n                    if ((ch = TextWindow.PeekChar()) == SlidingTextWindow.InvalidCharacter && TextWindow.IsReallyAtEnd())\n                    {\n                        isTerminated = false;\n                        break;\n                    }\n                    else if (ch == '*' && TextWindow.PeekChar(1) == '/')\n                    {\n                        TextWindow.AdvanceChar(2);\n                        isTerminated = true;\n                        break;\n                    }\n                    else\n                    {\n                        TextWindow.AdvanceChar();\n                    }\n                }\n\n                return true;\n            }\n            else\n            {\n                isTerminated = false;\n                return false;\n            }\n        }\n\n        private void ScanToEndOfLine()\n        {\n            char ch;\n            while (!SyntaxFacts.IsNewLine(ch = TextWindow.PeekChar()) &&\n                (ch != SlidingTextWindow.InvalidCharacter || !TextWindow.IsReallyAtEnd()))\n            {\n                TextWindow.AdvanceChar();\n            }\n        }\n\n        /// <summary>\n        /// Scans a new-line sequence (either a single new-line character or a CR-LF combo).\n        /// </summary>\n        /// <returns>A trivia node with the new-line text</returns>\n        private CSharpSyntaxNode ScanEndOfLine()\n        {\n            char ch;\n            switch (ch = TextWindow.PeekChar())\n            {\n                case '\\r':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '\\n')\n                    {\n                        TextWindow.AdvanceChar();\n                        return SyntaxFactory.CarriageReturnLineFeed;\n                    }\n\n                    return SyntaxFactory.CarriageReturn;\n                case '\\n':\n                    TextWindow.AdvanceChar();\n                    return SyntaxFactory.LineFeed;\n                default:\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        TextWindow.AdvanceChar();\n                        return SyntaxFactory.EndOfLine(ch.ToString());\n                    }\n\n                    return null;\n            }\n        }\n\n        /// <summary>\n        /// Scans all of the whitespace (not new-lines) into a trivia node until it runs out.\n        /// </summary>\n        /// <returns>A trivia node with the whitespace text</returns>\n        private SyntaxTrivia ScanWhitespace()\n        {\n            if (_createWhitespaceTriviaFunction == null)\n            {\n                _createWhitespaceTriviaFunction = this.CreateWhitespaceTrivia;\n            }\n\n            int hashCode = Hash.FnvOffsetBias;  // FNV base\n            bool onlySpaces = true;\n\n        top:\n            char ch = TextWindow.PeekChar();\n\n            switch (ch)\n            {\n                case '\\t':       // Horizontal tab\n                case '\\v':       // Vertical Tab\n                case '\\f':       // Form-feed\n                case '\\u001A':\n                    onlySpaces = false;\n                    goto case ' ';\n\n                case ' ':\n                    TextWindow.AdvanceChar();\n                    hashCode = Hash.CombineFNVHash(hashCode, ch);\n                    goto top;\n\n                case '\\r':      // Carriage Return\n                case '\\n':      // Line-feed\n                    break;\n\n                default:\n                    if (ch > 127 && SyntaxFacts.IsWhitespace(ch))\n                    {\n                        goto case '\\t';\n                    }\n\n                    break;\n            }\n\n            if (TextWindow.Width == 1 && onlySpaces)\n            {\n                return SyntaxFactory.Space;\n            }\n            else\n            {\n                var width = TextWindow.Width;\n\n                if (width < MaxCachedTokenSize)\n                {\n                    return _cache.LookupTrivia(\n                        TextWindow.CharacterWindow,\n                        TextWindow.LexemeRelativeStart,\n                        width,\n                        hashCode,\n                        _createWhitespaceTriviaFunction);\n                }\n                else\n                {\n                    return _createWhitespaceTriviaFunction();\n                }\n            }\n        }\n\n        private Func<SyntaxTrivia> _createWhitespaceTriviaFunction;\n\n        private SyntaxTrivia CreateWhitespaceTrivia()\n        {\n            return SyntaxFactory.Whitespace(TextWindow.GetText(intern: true));\n        }\n\n        private void LexDirectiveAndExcludedTrivia(\n            bool afterFirstToken,\n            bool afterNonWhitespaceOnLine,\n            ref SyntaxListBuilder triviaList)\n        {\n            var directive = this.LexSingleDirective(true, true, afterFirstToken, afterNonWhitespaceOnLine, ref triviaList);\n\n            // also lex excluded stuff            \n            var branching = directive as BranchingDirectiveTriviaSyntax;\n            if (branching != null && !branching.BranchTaken)\n            {\n                this.LexExcludedDirectivesAndTrivia(true, ref triviaList);\n            }\n        }\n\n        private void LexExcludedDirectivesAndTrivia(bool endIsActive, ref SyntaxListBuilder triviaList)\n        {\n            while (true)\n            {\n                bool hasFollowingDirective;\n                var text = this.LexDisabledText(out hasFollowingDirective);\n                if (text != null)\n                {\n                    this.AddTrivia(text, ref triviaList);\n                }\n\n                if (!hasFollowingDirective)\n                {\n                    break;\n                }\n\n                var directive = this.LexSingleDirective(false, endIsActive, false, false, ref triviaList);\n                var branching = directive as BranchingDirectiveTriviaSyntax;\n                if (directive.Kind == SyntaxKind.EndIfDirectiveTrivia || (branching != null && branching.BranchTaken))\n                {\n                    break;\n                }\n                else if (directive.Kind == SyntaxKind.IfDirectiveTrivia)\n                {\n                    this.LexExcludedDirectivesAndTrivia(false, ref triviaList);\n                }\n            }\n        }\n\n        private CSharpSyntaxNode LexSingleDirective(\n            bool isActive,\n            bool endIsActive,\n            bool afterFirstToken,\n            bool afterNonWhitespaceOnLine,\n            ref SyntaxListBuilder triviaList)\n        {\n            if (SyntaxFacts.IsWhitespace(TextWindow.PeekChar()))\n            {\n                this.Start();\n                this.AddTrivia(this.ScanWhitespace(), ref triviaList);\n            }\n\n            CSharpSyntaxNode directive;\n            var saveMode = _mode;\n\n            using (var dp = new DirectiveParser(this, _directives))\n            {\n                directive = dp.ParseDirective(isActive, endIsActive, afterFirstToken, afterNonWhitespaceOnLine);\n            }\n\n            this.AddTrivia(directive, ref triviaList);\n            _directives = directive.ApplyDirectives(_directives);\n            _mode = saveMode;\n            return directive;\n        }\n\n        // consume text up to the next directive\n        private CSharpSyntaxNode LexDisabledText(out bool followedByDirective)\n        {\n            this.Start();\n\n            int lastLineStart = TextWindow.Position;\n            int lines = 0;\n            bool allWhitespace = true;\n\n            while (true)\n            {\n                char ch = TextWindow.PeekChar();\n                switch (ch)\n                {\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        followedByDirective = false;\n                        return TextWindow.Width > 0 ? SyntaxFactory.DisabledText(TextWindow.GetText(false)) : null;\n                    case '#':\n                        if (!_allowPreprocessorDirectives) goto default;\n                        followedByDirective = true;\n                        if (lastLineStart < TextWindow.Position && !allWhitespace)\n                        {\n                            goto default;\n                        }\n\n                        TextWindow.Reset(lastLineStart);  // reset so directive parser can consume the starting whitespace on this line\n                        return TextWindow.Width > 0 ? SyntaxFactory.DisabledText(TextWindow.GetText(false)) : null;\n                    case '\\r':\n                    case '\\n':\n                        this.ScanEndOfLine();\n                        lastLineStart = TextWindow.Position;\n                        allWhitespace = true;\n                        lines++;\n                        break;\n                    default:\n                        if (SyntaxFacts.IsNewLine(ch))\n                        {\n                            goto case '\\n';\n                        }\n\n                        allWhitespace = allWhitespace && SyntaxFacts.IsWhitespace(ch);\n                        TextWindow.AdvanceChar();\n                        break;\n                }\n            }\n        }\n\n        private SyntaxToken LexDirectiveToken()\n        {\n            this.Start();\n            TokenInfo info = default(TokenInfo);\n            this.ScanDirectiveToken(ref info);\n            var errors = this.GetErrors(leadingTriviaWidth: 0);\n            var trailing = this.LexDirectiveTrailingTrivia(info.Kind == SyntaxKind.EndOfDirectiveToken);\n            return Create(ref info, null, trailing, errors);\n        }\n\n        private bool ScanDirectiveToken(ref TokenInfo info)\n        {\n            char character;\n            char surrogateCharacter;\n            bool isEscaped = false;\n\n            switch (character = TextWindow.PeekChar())\n            {\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n                    // don't consume end characters here\n                    info.Kind = SyntaxKind.EndOfDirectiveToken;\n                    break;\n\n                case '\\r':\n                case '\\n':\n                    // don't consume end characters here\n                    info.Kind = SyntaxKind.EndOfDirectiveToken;\n                    break;\n\n                case '#':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.HashToken;\n                    break;\n\n                case '(':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.OpenParenToken;\n                    break;\n\n                case ')':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.CloseParenToken;\n                    break;\n\n                case ',':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.CommaToken;\n                    break;\n\n                case '!':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.ExclamationEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.ExclamationToken;\n                    }\n\n                    break;\n\n                case '=':\n                    TextWindow.AdvanceChar();\n                    if (TextWindow.PeekChar() == '=')\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.EqualsEqualsToken;\n                    }\n                    else\n                    {\n                        info.Kind = SyntaxKind.EqualsToken;\n                    }\n\n                    break;\n\n                case '&':\n                    if (TextWindow.PeekChar(1) == '&')\n                    {\n                        TextWindow.AdvanceChar(2);\n                        info.Kind = SyntaxKind.AmpersandAmpersandToken;\n                        break;\n                    }\n\n                    goto default;\n\n                case '|':\n                    if (TextWindow.PeekChar(1) == '|')\n                    {\n                        TextWindow.AdvanceChar(2);\n                        info.Kind = SyntaxKind.BarBarToken;\n                        break;\n                    }\n\n                    goto default;\n\n                case '0':\n                case '1':\n                case '2':\n                case '3':\n                case '4':\n                case '5':\n                case '6':\n                case '7':\n                case '8':\n                case '9':\n                    this.ScanInteger();\n                    info.Kind = SyntaxKind.NumericLiteralToken;\n                    info.Text = TextWindow.GetText(true);\n                    info.ValueKind = SpecialType.System_Int32;\n                    info.IntValue = this.GetValueInt32(info.Text, false);\n                    break;\n\n                case '\\\"':\n                    this.ScanStringLiteral(ref info, false);\n                    break;\n\n                case '\\\\':\n                    {\n                        // Could be unicode escape. Try that.\n                        character = TextWindow.PeekCharOrUnicodeEscape(out surrogateCharacter);\n                        isEscaped = true;\n                        if (SyntaxFacts.IsIdentifierStartCharacter(character))\n                        {\n                            this.ScanIdentifierOrKeyword(ref info);\n                            break;\n                        }\n\n                        goto default;\n                    }\n\n                default:\n                    if (!isEscaped && SyntaxFacts.IsNewLine(character))\n                    {\n                        goto case '\\n';\n                    }\n\n                    if (SyntaxFacts.IsIdentifierStartCharacter(character))\n                    {\n                        this.ScanIdentifierOrKeyword(ref info);\n                    }\n                    else\n                    {\n                        // unknown single character\n                        if (isEscaped)\n                        {\n                            SyntaxDiagnosticInfo error;\n                            TextWindow.NextCharOrUnicodeEscape(out surrogateCharacter, out error);\n                            AddError(error);\n                        }\n                        else\n                        {\n                            TextWindow.AdvanceChar();\n                        }\n\n                        info.Kind = SyntaxKind.None;\n                        info.Text = TextWindow.GetText(true);\n                    }\n\n                    break;\n            }\n\n            Debug.Assert(info.Kind != SyntaxKind.None || info.Text != null);\n            return info.Kind != SyntaxKind.None;\n        }\n\n        private SyntaxListBuilder LexDirectiveTrailingTrivia(bool includeEndOfLine)\n        {\n            SyntaxListBuilder trivia = null;\n\n            CSharpSyntaxNode tr;\n            while (true)\n            {\n                var pos = TextWindow.Position;\n                tr = this.LexDirectiveTrivia();\n                if (tr == null)\n                {\n                    break;\n                }\n                else if (tr.Kind == SyntaxKind.EndOfLineTrivia)\n                {\n                    if (includeEndOfLine)\n                    {\n                        AddTrivia(tr, ref trivia);\n                    }\n                    else\n                    {\n                        // don't consume end of line...\n                        TextWindow.Reset(pos);\n                    }\n\n                    break;\n                }\n                else\n                {\n                    AddTrivia(tr, ref trivia);\n                }\n            }\n\n            return trivia;\n        }\n\n        private CSharpSyntaxNode LexDirectiveTrivia()\n        {\n            CSharpSyntaxNode trivia = null;\n\n            this.Start();\n            char ch = TextWindow.PeekChar();\n            switch (ch)\n            {\n                case '/':\n                    if (TextWindow.PeekChar(1) == '/')\n                    {\n                        // normal single line comment\n                        this.ScanToEndOfLine();\n                        var text = TextWindow.GetText(false);\n                        trivia = SyntaxFactory.Comment(text);\n                    }\n\n                    break;\n                case '\\r':\n                case '\\n':\n                    trivia = this.ScanEndOfLine();\n                    break;\n                case ' ':\n                case '\\t':       // Horizontal tab\n                case '\\v':       // Vertical Tab\n                case '\\f':       // Form-feed\n                    trivia = this.ScanWhitespace();\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsWhitespace(ch))\n                    {\n                        goto case ' ';\n                    }\n\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        goto case '\\n';\n                    }\n\n                    break;\n            }\n\n            return trivia;\n        }\n\n        private DocumentationCommentParser _xmlParser;\n\n        private CSharpSyntaxNode LexXmlDocComment(XmlDocCommentStyle style)\n        {\n            var saveMode = _mode;\n            bool isTerminated;\n\n            var mode = style == XmlDocCommentStyle.SingleLine\n                    ? LexerMode.XmlDocCommentStyleSingleLine\n                    : LexerMode.XmlDocCommentStyleDelimited;\n            if (_xmlParser == null)\n            {\n                _xmlParser = new DocumentationCommentParser(this, mode);\n            }\n            else\n            {\n                _xmlParser.ReInitialize(mode);\n            }\n\n            var docComment = _xmlParser.ParseDocumentationComment(out isTerminated);\n\n            // We better have finished with the whole comment. There should be error\n            // code in the implementation of ParseXmlDocComment that ensures this.\n            Debug.Assert(this.LocationIs(XmlDocCommentLocation.End) || TextWindow.PeekChar() == SlidingTextWindow.InvalidCharacter);\n\n            _mode = saveMode;\n\n            if (!isTerminated)\n            {\n                // The comment didn't end.  Report an error at the start point.\n                // NOTE: report this error even if the DocumentationMode is less than diagnose - the comment\n                // would be malformed as a non-doc comment as well.\n                this.AddError(TextWindow.LexemeStartPosition, TextWindow.Width, ErrorCode.ERR_OpenEndedComment);\n            }\n\n            return docComment;\n        }\n\n        /// <summary>\n        /// Lexer entry point for LexMode.XmlDocComment\n        /// </summary>\n        private SyntaxToken LexXmlToken()\n        {\n            TokenInfo xmlTokenInfo = default(TokenInfo);\n\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTrivia(ref leading);\n\n            this.Start();\n            this.ScanXmlToken(ref xmlTokenInfo);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            return Create(ref xmlTokenInfo, leading, null, errors);\n        }\n\n        private bool ScanXmlToken(ref TokenInfo info)\n        {\n            char ch;\n\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            switch (ch = TextWindow.PeekChar())\n            {\n                case '&':\n                    this.ScanXmlEntity(ref info);\n                    info.Kind = SyntaxKind.XmlEntityLiteralToken;\n                    break;\n\n                case '<':\n                    this.ScanXmlTagStart(ref info);\n                    break;\n\n                case '\\r':\n                case '\\n':\n                    this.ScanEndOfLine();\n                    info.StringValue = info.Text = TextWindow.GetText(false);\n                    info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;\n                    this.MutateLocation(XmlDocCommentLocation.Exterior);\n                    break;\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n\n                    info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        goto case '\\n';\n                    }\n\n                    this.ScanXmlText(ref info);\n                    info.Kind = SyntaxKind.XmlTextLiteralToken;\n                    break;\n            }\n\n            Debug.Assert(info.Kind != SyntaxKind.None || info.Text != null);\n            return info.Kind != SyntaxKind.None;\n        }\n\n        private void ScanXmlTagStart(ref TokenInfo info)\n        {\n            Debug.Assert(TextWindow.PeekChar() == '<');\n\n            if (TextWindow.PeekChar(1) == '!')\n            {\n                if (TextWindow.PeekChar(2) == '-'\n                    && TextWindow.PeekChar(3) == '-')\n                {\n                    TextWindow.AdvanceChar(4);\n                    info.Kind = SyntaxKind.XmlCommentStartToken;\n                }\n                else if (TextWindow.PeekChar(2) == '['\n                    && TextWindow.PeekChar(3) == 'C'\n                    && TextWindow.PeekChar(4) == 'D'\n                    && TextWindow.PeekChar(5) == 'A'\n                    && TextWindow.PeekChar(6) == 'T'\n                    && TextWindow.PeekChar(7) == 'A'\n                    && TextWindow.PeekChar(8) == '[')\n                {\n                    TextWindow.AdvanceChar(9);\n                    info.Kind = SyntaxKind.XmlCDataStartToken;\n                }\n                else\n                {\n                    // TODO: Take the < by itself, I guess?\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.LessThanToken;\n                }\n            }\n            else if (TextWindow.PeekChar(1) == '/')\n            {\n                TextWindow.AdvanceChar(2);\n                info.Kind = SyntaxKind.LessThanSlashToken;\n            }\n            else if (TextWindow.PeekChar(1) == '?')\n            {\n                TextWindow.AdvanceChar(2);\n                info.Kind = SyntaxKind.XmlProcessingInstructionStartToken;\n            }\n            else\n            {\n                TextWindow.AdvanceChar();\n                info.Kind = SyntaxKind.LessThanToken;\n            }\n        }\n\n        private void ScanXmlEntity(ref TokenInfo info)\n        {\n            info.StringValue = null;\n\n            Debug.Assert(TextWindow.PeekChar() == '&');\n            TextWindow.AdvanceChar();\n            _builder.Clear();\n            XmlParseErrorCode? error = null;\n            object[] errorArgs = null;\n\n            char ch;\n            if (IsXmlNameStartChar(ch = TextWindow.PeekChar()))\n            {\n                while (IsXmlNameChar(ch = TextWindow.PeekChar()))\n                {\n                    // Important bit of information here: none of \\0, \\r, \\n, and crucially for\n                    // delimited comments, * are considered Xml name characters. Also, since\n                    // entities appear in xml text and attribute text, it's relevant here that\n                    // none of <, /, >, ', \", =, are Xml name characters. Note that - and ] are\n                    // irrelevant--entities do not appear in comments or cdata.\n\n                    TextWindow.AdvanceChar();\n                    _builder.Append(ch);\n                }\n\n                switch (_builder.ToString())\n                {\n                    case \"lt\":\n                        info.StringValue = \"<\";\n                        break;\n                    case \"gt\":\n                        info.StringValue = \">\";\n                        break;\n                    case \"amp\":\n                        info.StringValue = \"&\";\n                        break;\n                    case \"apos\":\n                        info.StringValue = \"'\";\n                        break;\n                    case \"quot\":\n                        info.StringValue = \"\\\"\";\n                        break;\n                    default:\n                        error = XmlParseErrorCode.XML_RefUndefinedEntity_1;\n                        errorArgs = new[] { _builder.ToString() };\n                        break;\n                }\n            }\n            else if (ch == '#')\n            {\n                TextWindow.AdvanceChar();\n                bool isHex = TextWindow.PeekChar() == 'x';\n                uint charValue = 0;\n\n                if (isHex)\n                {\n                    TextWindow.AdvanceChar(); // x\n                    while (SyntaxFacts.IsHexDigit(ch = TextWindow.PeekChar()))\n                    {\n                        TextWindow.AdvanceChar();\n\n                        // disallow overflow\n                        if (charValue <= 0x7FFFFFF)\n                        {\n                            charValue = (charValue << 4) + (uint)SyntaxFacts.HexValue(ch);\n                        }\n                    }\n                }\n                else\n                {\n                    while (SyntaxFacts.IsDecDigit(ch = TextWindow.PeekChar()))\n                    {\n                        TextWindow.AdvanceChar();\n\n                        // disallow overflow\n                        if (charValue <= 0x7FFFFFF)\n                        {\n                            charValue = (charValue << 3) + (charValue << 1) + (uint)SyntaxFacts.DecValue(ch);\n                        }\n                    }\n                }\n\n                if (TextWindow.PeekChar() != ';')\n                {\n                    error = XmlParseErrorCode.XML_InvalidCharEntity;\n                }\n\n                if (MatchesProductionForXmlChar(charValue))\n                {\n                    char lowSurrogate;\n                    char highSurrogate = SlidingTextWindow.GetCharsFromUtf32(charValue, out lowSurrogate);\n\n                    _builder.Append(highSurrogate);\n                    if (lowSurrogate != SlidingTextWindow.InvalidCharacter)\n                    {\n                        _builder.Append(lowSurrogate);\n                    }\n\n                    info.StringValue = _builder.ToString();\n                }\n                else\n                {\n                    if (error == null)\n                    {\n                        error = XmlParseErrorCode.XML_InvalidUnicodeChar;\n                    }\n                }\n            }\n            else\n            {\n                if (SyntaxFacts.IsWhitespace(ch) || SyntaxFacts.IsNewLine(ch))\n                {\n                    if (error == null)\n                    {\n                        error = XmlParseErrorCode.XML_InvalidWhitespace;\n                    }\n                }\n                else\n                {\n                    if (error == null)\n                    {\n                        error = XmlParseErrorCode.XML_InvalidToken;\n                        errorArgs = new[] { ch.ToString() };\n                    }\n                }\n            }\n\n            ch = TextWindow.PeekChar();\n            if (ch == ';')\n            {\n                TextWindow.AdvanceChar();\n            }\n            else\n            {\n                if (error == null)\n                {\n                    error = XmlParseErrorCode.XML_InvalidToken;\n                    errorArgs = new[] { ch.ToString() };\n                }\n            }\n\n            // If we don't have a value computed from above, then we don't recognize the entity, in which\n            // case we will simply use the text.\n\n            info.Text = TextWindow.GetText(true);\n            if (info.StringValue == null)\n            {\n                info.StringValue = info.Text;\n            }\n\n            if (error != null)\n            {\n                this.AddError(error.Value, errorArgs ?? SpecializedCollections.EmptyArray<object>());\n            }\n        }\n\n        private static bool MatchesProductionForXmlChar(uint charValue)\n        {\n            // Char ::= #x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF] /* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */\n\n            return\n                charValue == 0x9 ||\n                charValue == 0xA ||\n                charValue == 0xD ||\n                (charValue >= 0x20 && charValue <= 0xD7FF) ||\n                (charValue >= 0xE000 && charValue <= 0xFFFD) ||\n                (charValue >= 0x10000 && charValue <= 0x10FFFF);\n        }\n\n        private void ScanXmlText(ref TokenInfo info)\n        {\n            // Collect \"]]>\" strings into their own XmlText.\n            if (TextWindow.PeekChar() == ']' && TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')\n            {\n                TextWindow.AdvanceChar(3);\n                info.StringValue = info.Text = TextWindow.GetText(false);\n                this.AddError(XmlParseErrorCode.XML_CDataEndTagNotAllowed);\n                return;\n            }\n\n            while (true)\n            {\n                var ch = TextWindow.PeekChar();\n                switch (ch)\n                {\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n                    case '&':\n                    case '<':\n                    case '\\r':\n                    case '\\n':\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case '*':\n                        if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')\n                        {\n                            // we're at the end of the comment, but don't lex it yet.\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    case ']':\n                        if (TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')\n                        {\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    default:\n                        if (SyntaxFacts.IsNewLine(ch))\n                        {\n                            goto case '\\n';\n                        }\n\n                        TextWindow.AdvanceChar();\n                        break;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Lexer entry point for LexMode.XmlElementTag\n        /// </summary>\n        private SyntaxToken LexXmlElementTagToken()\n        {\n            TokenInfo tagInfo = default(TokenInfo);\n\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTriviaWithWhitespace(ref leading);\n\n            this.Start();\n            this.ScanXmlElementTagToken(ref tagInfo);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            // PERF: De-dupe common XML element tags\n            if (errors == null && tagInfo.ContextualKind == SyntaxKind.None && tagInfo.Kind == SyntaxKind.IdentifierToken)\n            {\n                SyntaxToken token = DocumentationCommentXmlTokens.LookupToken(tagInfo.Text, leading);\n                if (token != null)\n                {\n                    return token;\n                }\n            }\n\n            return Create(ref tagInfo, leading, null, errors);\n        }\n\n        private bool ScanXmlElementTagToken(ref TokenInfo info)\n        {\n            char ch;\n\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            switch (ch = TextWindow.PeekChar())\n            {\n                case '<':\n                    this.ScanXmlTagStart(ref info);\n                    break;\n\n                case '>':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.GreaterThanToken;\n                    break;\n\n                case '/':\n                    if (TextWindow.PeekChar(1) == '>')\n                    {\n                        TextWindow.AdvanceChar(2);\n                        info.Kind = SyntaxKind.SlashGreaterThanToken;\n                        break;\n                    }\n\n                    goto default;\n\n                case '\"':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.DoubleQuoteToken;\n                    break;\n\n                case '\\'':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.SingleQuoteToken;\n                    break;\n\n                case '=':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.EqualsToken;\n                    break;\n\n                case ':':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.ColonToken;\n                    break;\n\n                case '\\r':\n                case '\\n':\n                    // Assert?\n                    break;\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n\n                    info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                    break;\n\n                case '*':\n                    if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')\n                    {\n                        // Assert? We should have gotten this in the leading trivia.\n                        Debug.Assert(false, \"Should have picked up leading indentationTrivia, but didn't.\");\n                        break;\n                    }\n\n                    goto default;\n\n                default:\n                    if (IsXmlNameStartChar(ch))\n                    {\n                        this.ScanXmlName(ref info);\n                        info.StringValue = info.Text;\n                        info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                    else if (SyntaxFacts.IsWhitespace(ch) || SyntaxFacts.IsNewLine(ch))\n                    {\n                        // whitespace! needed to do a better job with trivia\n                        Debug.Assert(false, \"Should have picked up leading indentationTrivia, but didn't.\");\n                    }\n                    else\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.None;\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                    }\n\n                    break;\n            }\n\n            Debug.Assert(info.Kind != SyntaxKind.None || info.Text != null);\n            return info.Kind != SyntaxKind.None;\n        }\n\n        private void ScanXmlName(ref TokenInfo info)\n        {\n            int start = TextWindow.Position;\n\n            while (true)\n            {\n                char ch = TextWindow.PeekChar();\n\n                // Important bit of information here: none of \\0, \\r, \\n, and crucially for\n                // delimited comments, * are considered Xml name characters.\n                if (ch != ':' && IsXmlNameChar(ch))\n                {\n                    // Although ':' is a name char, we don't include it in ScanXmlName\n                    // since it is its own token. This enables the parser to add structure\n                    // to colon-separated names.\n\n                    // TODO: Could put a big switch here for common cases\n                    // if this is a perf bottleneck.\n                    TextWindow.AdvanceChar();\n                }\n                else\n                {\n                    break;\n                }\n            }\n\n            info.Text = TextWindow.GetText(start, TextWindow.Position - start, intern: true);\n        }\n\n        /// <summary>\n        /// Determines whether this Unicode character can start a XMLName.\n        /// </summary>\n        /// <param name=\"ch\">The Unicode character.</param>\n        private static bool IsXmlNameStartChar(char ch)\n        {\n            // TODO: which is the right one?\n            return XmlCharType.IsStartNCNameCharXml4e(ch);\n            // return XmlCharType.IsStartNameSingleChar(ch);\n        }\n\n        /// <summary>\n        /// Determines if this Unicode character can be part of an XML Name.\n        /// </summary>\n        /// <param name=\"ch\">The Unicode character.</param>\n        private static bool IsXmlNameChar(char ch)\n        {\n            // TODO: which is the right one?\n            return XmlCharType.IsNCNameCharXml4e(ch);\n            //return XmlCharType.IsNameSingleChar(ch);\n        }\n\n        // TODO: There is a lot of duplication between attribute text, CDATA text, and comment text.\n        // It would be nice to factor them together.\n\n        /// <summary>\n        /// Lexer entry point for LexMode.XmlAttributeText\n        /// </summary>\n        private SyntaxToken LexXmlAttributeTextToken()\n        {\n            TokenInfo info = default(TokenInfo);\n\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTrivia(ref leading);\n\n            this.Start();\n            this.ScanXmlAttributeTextToken(ref info);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            return Create(ref info, leading, null, errors);\n        }\n\n        private bool ScanXmlAttributeTextToken(ref TokenInfo info)\n        {\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            char ch;\n            switch (ch = TextWindow.PeekChar())\n            {\n                case '\"':\n                    if (this.ModeIs(LexerMode.XmlAttributeTextDoubleQuote))\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.DoubleQuoteToken;\n                        break;\n                    }\n\n                    goto default;\n\n                case '\\'':\n                    if (this.ModeIs(LexerMode.XmlAttributeTextQuote))\n                    {\n                        TextWindow.AdvanceChar();\n                        info.Kind = SyntaxKind.SingleQuoteToken;\n                        break;\n                    }\n\n                    goto default;\n\n                case '&':\n                    this.ScanXmlEntity(ref info);\n                    info.Kind = SyntaxKind.XmlEntityLiteralToken;\n                    break;\n\n                case '<':\n                    TextWindow.AdvanceChar();\n                    info.Kind = SyntaxKind.LessThanToken;\n                    break;\n\n                case '\\r':\n                case '\\n':\n                    this.ScanEndOfLine();\n                    info.StringValue = info.Text = TextWindow.GetText(false);\n                    info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;\n                    this.MutateLocation(XmlDocCommentLocation.Exterior);\n                    break;\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n\n                    info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        goto case '\\n';\n                    }\n\n                    this.ScanXmlAttributeText(ref info);\n                    info.Kind = SyntaxKind.XmlTextLiteralToken;\n                    break;\n            }\n\n            Debug.Assert(info.Kind != SyntaxKind.None || info.Text != null);\n            return info.Kind != SyntaxKind.None;\n        }\n\n        private void ScanXmlAttributeText(ref TokenInfo info)\n        {\n            while (true)\n            {\n                var ch = TextWindow.PeekChar();\n                switch (ch)\n                {\n                    case '\"':\n                        if (this.ModeIs(LexerMode.XmlAttributeTextDoubleQuote))\n                        {\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    case '\\'':\n                        if (this.ModeIs(LexerMode.XmlAttributeTextQuote))\n                        {\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    case '&':\n                    case '<':\n                    case '\\r':\n                    case '\\n':\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case '*':\n                        if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')\n                        {\n                            // we're at the end of the comment, but don't lex it yet.\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    default:\n                        if (SyntaxFacts.IsNewLine(ch))\n                        {\n                            goto case '\\n';\n                        }\n\n                        TextWindow.AdvanceChar();\n                        break;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Lexer entry point for LexerMode.XmlCharacter.\n        /// </summary>\n        private SyntaxToken LexXmlCharacter()\n        {\n            TokenInfo info = default(TokenInfo);\n\n            //TODO: Dev11 allows C# comments and newlines in cref trivia (DevDiv #530523).\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTriviaWithWhitespace(ref leading);\n\n            this.Start();\n            this.ScanXmlCharacter(ref info);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            return Create(ref info, leading, null, errors);\n        }\n\n        /// <summary>\n        /// Scan a single XML character (or entity).  Assumes that leading trivia has already\n        /// been consumed.\n        /// </summary>\n        private bool ScanXmlCharacter(ref TokenInfo info)\n        {\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            switch (TextWindow.PeekChar())\n            {\n                case '&':\n                    this.ScanXmlEntity(ref info);\n                    info.Kind = SyntaxKind.XmlEntityLiteralToken;\n                    break;\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n                    info.Kind = SyntaxKind.EndOfFileToken;\n                    break;\n                default:\n                    info.Kind = SyntaxKind.XmlTextLiteralToken;\n                    info.Text = info.StringValue = TextWindow.NextChar().ToString();\n                    break;\n            }\n\n            return true;\n        }\n\n        /// <summary>\n        /// Lexer entry point for LexerMode.XmlCrefQuote, LexerMode.XmlCrefDoubleQuote, \n        /// LexerMode.XmlNameQuote, and LexerMode.XmlNameDoubleQuote.\n        /// </summary>\n        private SyntaxToken LexXmlCrefOrNameToken()\n        {\n            TokenInfo info = default(TokenInfo);\n\n            //TODO: Dev11 allows C# comments and newlines in cref trivia (DevDiv #530523).\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTriviaWithWhitespace(ref leading);\n\n            this.Start();\n            this.ScanXmlCrefToken(ref info);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            return Create(ref info, leading, null, errors);\n        }\n\n        /// <summary>\n        /// Scan a single cref attribute token.  Assumes that leading trivia has already\n        /// been consumed.\n        /// </summary>\n        /// <remarks>\n        /// Within this method, characters that are not XML meta-characters can be seamlessly\n        /// replaced with the corresponding XML entities.\n        /// </remarks>\n        private bool ScanXmlCrefToken(ref TokenInfo info)\n        {\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            int beforeConsumed = TextWindow.Position;\n            char consumedChar = TextWindow.NextChar();\n            char consumedSurrogate = SlidingTextWindow.InvalidCharacter;\n\n            // This first switch is for special characters.  If we see the corresponding\n            // XML entities, we DO NOT want to take these actions.\n            switch (consumedChar)\n            {\n                case '\"':\n                    if (this.ModeIs(LexerMode.XmlCrefDoubleQuote) || this.ModeIs(LexerMode.XmlNameDoubleQuote))\n                    {\n                        info.Kind = SyntaxKind.DoubleQuoteToken;\n                        return true;\n                    }\n\n                    break;\n\n                case '\\'':\n                    if (this.ModeIs(LexerMode.XmlCrefQuote) || this.ModeIs(LexerMode.XmlNameQuote))\n                    {\n                        info.Kind = SyntaxKind.SingleQuoteToken;\n                        return true;\n                    }\n\n                    break;\n\n                case '<':\n                    info.Text = TextWindow.GetText(intern: false);\n                    this.AddError(XmlParseErrorCode.XML_LessThanInAttributeValue, info.Text); //ErrorCode.WRN_XMLParseError\n                    return true;\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n\n                    info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                    return true;\n\n                case '\\r':\n                case '\\n':\n                    TextWindow.Reset(beforeConsumed);\n                    this.ScanEndOfLine();\n                    info.StringValue = info.Text = TextWindow.GetText(intern: false);\n                    info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;\n                    this.MutateLocation(XmlDocCommentLocation.Exterior);\n                    break;\n\n                case '&':\n                    TextWindow.Reset(beforeConsumed);\n                    if (!TextWindow.TryScanXmlEntity(out consumedChar, out consumedSurrogate))\n                    {\n                        TextWindow.Reset(beforeConsumed);\n                        this.ScanXmlEntity(ref info);\n                        info.Kind = SyntaxKind.XmlEntityLiteralToken;\n                        return true;\n                    }\n\n                    // TryScanXmlEntity advances even when it returns false.\n                    break;\n\n                case '{':\n                    consumedChar = '<';\n                    break;\n\n                case '}':\n                    consumedChar = '>';\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsNewLine(consumedChar))\n                    {\n                        goto case '\\n';\n                    }\n\n                    break;\n            }\n\n            Debug.Assert(TextWindow.Position > beforeConsumed, \"First character or entity has been consumed.\");\n\n            // NOTE: None of these cases will be matched if the surrogate is non-zero (UTF-16 rules)\n            // so we don't need to check for that explicitly.\n\n            // NOTE: there's a lot of overlap between this switch and the one in\n            // ScanSyntaxToken, but we probably don't want to share code because\n            // ScanSyntaxToken is really hot code and this switch does some extra\n            // work.\n            switch (consumedChar)\n            {\n                //// Single-Character Punctuation/Operators ////\n                case '(':\n                    info.Kind = SyntaxKind.OpenParenToken;\n                    break;\n                case ')':\n                    info.Kind = SyntaxKind.CloseParenToken;\n                    break;\n                case '[':\n                    info.Kind = SyntaxKind.OpenBracketToken;\n                    break;\n                case ']':\n                    info.Kind = SyntaxKind.CloseBracketToken;\n                    break;\n                case ',':\n                    info.Kind = SyntaxKind.CommaToken;\n                    break;\n                case '.':\n                    info.Kind = SyntaxKind.DotToken;\n                    break;\n                case '?':\n                    info.Kind = SyntaxKind.QuestionToken;\n                    break;\n                case '&':\n                    info.Kind = SyntaxKind.AmpersandToken;\n                    break;\n                case '*':\n                    info.Kind = SyntaxKind.AsteriskToken;\n                    break;\n                case '|':\n                    info.Kind = SyntaxKind.BarToken;\n                    break;\n                case '^':\n                    info.Kind = SyntaxKind.CaretToken;\n                    break;\n                case '%':\n                    info.Kind = SyntaxKind.PercentToken;\n                    break;\n                case '/':\n                    info.Kind = SyntaxKind.SlashToken;\n                    break;\n                case '~':\n                    info.Kind = SyntaxKind.TildeToken;\n                    break;\n\n                // NOTE: Special case - convert curly brackets into angle brackets.\n                case '{':\n                    info.Kind = SyntaxKind.LessThanToken;\n                    break;\n                case '}':\n                    info.Kind = SyntaxKind.GreaterThanToken;\n                    break;\n\n                //// Multi-Character Punctuation/Operators ////\n                case ':':\n                    if (AdvanceIfMatches(':')) info.Kind = SyntaxKind.ColonColonToken;\n                    else info.Kind = SyntaxKind.ColonToken;\n                    break;\n                case '=':\n                    if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.EqualsEqualsToken;\n                    else info.Kind = SyntaxKind.EqualsToken;\n                    break;\n                case '!':\n                    if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.ExclamationEqualsToken;\n                    else info.Kind = SyntaxKind.ExclamationToken;\n                    break;\n                case '>':\n                    if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.GreaterThanEqualsToken;\n                    // GreaterThanGreaterThanToken is synthesized in the parser since it is ambiguous (with closing nested type parameter lists)\n                    // else if (AdvanceIfMatches('>')) info.Kind = SyntaxKind.GreaterThanGreaterThanToken;\n                    else info.Kind = SyntaxKind.GreaterThanToken;\n                    break;\n                case '<':\n                    if (AdvanceIfMatches('=')) info.Kind = SyntaxKind.LessThanEqualsToken;\n                    else if (AdvanceIfMatches('<')) info.Kind = SyntaxKind.LessThanLessThanToken;\n                    else info.Kind = SyntaxKind.LessThanToken;\n                    break;\n                case '+':\n                    if (AdvanceIfMatches('+')) info.Kind = SyntaxKind.PlusPlusToken;\n                    else info.Kind = SyntaxKind.PlusToken;\n                    break;\n                case '-':\n                    if (AdvanceIfMatches('-')) info.Kind = SyntaxKind.MinusMinusToken;\n                    else info.Kind = SyntaxKind.MinusToken;\n                    break;\n            }\n\n            if (info.Kind != SyntaxKind.None)\n            {\n                Debug.Assert(info.Text == null, \"Haven't tried to set it yet.\");\n                Debug.Assert(info.StringValue == null, \"Haven't tried to set it yet.\");\n\n                string valueText = SyntaxFacts.GetText(info.Kind);\n                string actualText = TextWindow.GetText(intern: false);\n                if (!string.IsNullOrEmpty(valueText) && actualText != valueText)\n                {\n                    info.RequiresTextForXmlEntity = true;\n                    info.Text = actualText;\n                    info.StringValue = valueText;\n                }\n            }\n            else\n            {\n                // If we didn't match any of the above cases, then we either have an\n                // identifier or an unexpected character.\n\n                TextWindow.Reset(beforeConsumed);\n\n                if (this.ScanIdentifier(ref info) && info.Text.Length > 0)\n                {\n                    // ACASEY:  All valid identifier characters should be valid in XML attribute values,\n                    // but I don't want to add an assert because XML character classification is expensive.\n                    // check to see if it is an actual keyword\n                    // NOTE: name attribute values don't respect keywords - everything is an identifier.\n                    SyntaxKind keywordKind;\n                    if (!InXmlNameAttributeValue && !info.IsVerbatim && !info.HasIdentifierEscapeSequence && _cache.TryGetKeywordKind(info.StringValue, out keywordKind))\n                    {\n                        if (SyntaxFacts.IsContextualKeyword(keywordKind))\n                        {\n                            info.Kind = SyntaxKind.IdentifierToken;\n                            info.ContextualKind = keywordKind;\n                            // Don't need to set any special flags to store the original text of an identifier.\n                        }\n                        else\n                        {\n                            info.Kind = keywordKind;\n                            info.RequiresTextForXmlEntity = info.Text != info.StringValue;\n                        }\n                    }\n                    else\n                    {\n                        info.ContextualKind = info.Kind = SyntaxKind.IdentifierToken;\n                    }\n                }\n                else\n                {\n                    if (consumedChar == '@')\n                    {\n                        // Saw '@', but it wasn't followed by an identifier (otherwise ScanIdentifier would have succeeded).\n                        if (TextWindow.PeekChar() == '@')\n                        {\n                            TextWindow.NextChar();\n                            info.Text = TextWindow.GetText(intern: true);\n                            info.StringValue = \"\"; // Can't be null for an identifier.\n                        }\n                        else\n                        {\n                            this.ScanXmlEntity(ref info);\n                        }\n                        info.Kind = SyntaxKind.IdentifierToken;\n                        this.AddError(ErrorCode.ERR_ExpectedVerbatimLiteral);\n                    }\n                    else if (TextWindow.PeekChar() == '&')\n                    {\n                        this.ScanXmlEntity(ref info);\n                        info.Kind = SyntaxKind.XmlEntityLiteralToken;\n                        this.AddCrefError(ErrorCode.ERR_UnexpectedCharacter, info.Text);\n                    }\n                    else\n                    {\n                        char bad = TextWindow.NextChar();\n                        info.Text = TextWindow.GetText(intern: false);\n\n                        // If it's valid in XML, then it was unexpected in cref mode.\n                        // Otherwise, it's just bad XML.\n                        if (MatchesProductionForXmlChar((uint)bad))\n                        {\n                            this.AddCrefError(ErrorCode.ERR_UnexpectedCharacter, info.Text);\n                        }\n                        else\n                        {\n                            this.AddError(XmlParseErrorCode.XML_InvalidUnicodeChar);\n                        }\n                    }\n                }\n            }\n\n            Debug.Assert(info.Kind != SyntaxKind.None || info.Text != null);\n            return info.Kind != SyntaxKind.None;\n        }\n\n        /// <summary>\n        /// Given a character, advance the input if either the character or the\n        /// corresponding XML entity appears next in the text window.\n        /// </summary>\n        /// <param name=\"ch\"></param>\n        /// <returns></returns>\n        private bool AdvanceIfMatches(char ch)\n        {\n            char peekCh = TextWindow.PeekChar();\n            if ((peekCh == ch) ||\n                (peekCh == '{' && ch == '<') ||\n                (peekCh == '}' && ch == '>'))\n            {\n                TextWindow.AdvanceChar();\n                return true;\n            }\n\n            if (peekCh == '&')\n            {\n                int pos = TextWindow.Position;\n\n                char nextChar;\n                char nextSurrogate;\n                if (TextWindow.TryScanXmlEntity(out nextChar, out nextSurrogate)\n                    && nextChar == ch && nextSurrogate == SlidingTextWindow.InvalidCharacter)\n                {\n                    return true;\n                }\n\n                TextWindow.Reset(pos);\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Convenience property for determining whether we are currently lexing the\n        /// value of a cref or name attribute.\n        /// </summary>\n        private bool InXmlCrefOrNameAttributeValue\n        {\n            get\n            {\n                switch (_mode & LexerMode.MaskLexMode)\n                {\n                    case LexerMode.XmlCrefQuote:\n                    case LexerMode.XmlCrefDoubleQuote:\n                    case LexerMode.XmlNameQuote:\n                    case LexerMode.XmlNameDoubleQuote:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Convenience property for determining whether we are currently lexing the\n        /// value of a name attribute.\n        /// </summary>\n        private bool InXmlNameAttributeValue\n        {\n            get\n            {\n                switch (_mode & LexerMode.MaskLexMode)\n                {\n                    case LexerMode.XmlNameQuote:\n                    case LexerMode.XmlNameDoubleQuote:\n                        return true;\n                    default:\n                        return false;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Diagnostics that occur within cref attributes need to be\n        /// wrapped with ErrorCode.WRN_ErrorOverride.\n        /// </summary>\n        private void AddCrefError(ErrorCode code, params object[] args)\n        {\n            this.AddCrefError(MakeError(code, args));\n        }\n\n        /// <summary>\n        /// Diagnostics that occur within cref attributes need to be\n        /// wrapped with ErrorCode.WRN_ErrorOverride.\n        /// </summary>\n        private void AddCrefError(DiagnosticInfo info)\n        {\n            if (info != null)\n            {\n                this.AddError(ErrorCode.WRN_ErrorOverride, info, info.Code);\n            }\n        }\n\n        /// <summary>\n        /// Lexer entry point for LexMode.XmlCDataSectionText\n        /// </summary>\n        private SyntaxToken LexXmlCDataSectionTextToken()\n        {\n            TokenInfo info = default(TokenInfo);\n\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTrivia(ref leading);\n\n            this.Start();\n            this.ScanXmlCDataSectionTextToken(ref info);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            return Create(ref info, leading, null, errors);\n        }\n\n        private bool ScanXmlCDataSectionTextToken(ref TokenInfo info)\n        {\n            char ch;\n\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            switch (ch = TextWindow.PeekChar())\n            {\n                case ']':\n                    if (TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')\n                    {\n                        TextWindow.AdvanceChar(3);\n                        info.Kind = SyntaxKind.XmlCDataEndToken;\n                        break;\n                    }\n\n                    goto default;\n\n                case '\\r':\n                case '\\n':\n                    this.ScanEndOfLine();\n                    info.StringValue = info.Text = TextWindow.GetText(false);\n                    info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;\n                    this.MutateLocation(XmlDocCommentLocation.Exterior);\n                    break;\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n\n                    info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        goto case '\\n';\n                    }\n\n                    this.ScanXmlCDataSectionText(ref info);\n                    info.Kind = SyntaxKind.XmlTextLiteralToken;\n                    break;\n            }\n\n            return true;\n        }\n\n        private void ScanXmlCDataSectionText(ref TokenInfo info)\n        {\n            while (true)\n            {\n                var ch = TextWindow.PeekChar();\n                switch (ch)\n                {\n                    case ']':\n                        if (TextWindow.PeekChar(1) == ']' && TextWindow.PeekChar(2) == '>')\n                        {\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    case '\\r':\n                    case '\\n':\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case '*':\n                        if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')\n                        {\n                            // we're at the end of the comment, but don't lex it yet.\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    default:\n                        if (SyntaxFacts.IsNewLine(ch))\n                        {\n                            goto case '\\n';\n                        }\n\n                        TextWindow.AdvanceChar();\n                        break;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Lexer entry point for LexMode.XmlCommentText\n        /// </summary>\n        private SyntaxToken LexXmlCommentTextToken()\n        {\n            TokenInfo info = default(TokenInfo);\n\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTrivia(ref leading);\n\n            this.Start();\n            this.ScanXmlCommentTextToken(ref info);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            return Create(ref info, leading, null, errors);\n        }\n\n        private bool ScanXmlCommentTextToken(ref TokenInfo info)\n        {\n            char ch;\n\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            switch (ch = TextWindow.PeekChar())\n            {\n                case '-':\n                    if (TextWindow.PeekChar(1) == '-')\n                    {\n                        if (TextWindow.PeekChar(2) == '>')\n                        {\n                            TextWindow.AdvanceChar(3);\n                            info.Kind = SyntaxKind.XmlCommentEndToken;\n                            break;\n                        }\n                        else\n                        {\n                            TextWindow.AdvanceChar(2);\n                            info.Kind = SyntaxKind.MinusMinusToken;\n                            break;\n                        }\n                    }\n\n                    goto default;\n\n                case '\\r':\n                case '\\n':\n                    this.ScanEndOfLine();\n                    info.StringValue = info.Text = TextWindow.GetText(false);\n                    info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;\n                    this.MutateLocation(XmlDocCommentLocation.Exterior);\n                    break;\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n                    info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        goto case '\\n';\n                    }\n\n                    this.ScanXmlCommentText(ref info);\n                    info.Kind = SyntaxKind.XmlTextLiteralToken;\n                    break;\n            }\n\n            return true;\n        }\n\n        private void ScanXmlCommentText(ref TokenInfo info)\n        {\n            while (true)\n            {\n                var ch = TextWindow.PeekChar();\n                switch (ch)\n                {\n                    case '-':\n                        if (TextWindow.PeekChar(1) == '-')\n                        {\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    case '\\r':\n                    case '\\n':\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case '*':\n                        if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')\n                        {\n                            // we're at the end of the comment, but don't lex it yet.\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    default:\n                        if (SyntaxFacts.IsNewLine(ch))\n                        {\n                            goto case '\\n';\n                        }\n\n                        TextWindow.AdvanceChar();\n                        break;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Lexer entry point for LexMode.XmlProcessingInstructionText\n        /// </summary>\n        private SyntaxToken LexXmlProcessingInstructionTextToken()\n        {\n            TokenInfo info = default(TokenInfo);\n\n            SyntaxListBuilder leading = null;\n            this.LexXmlDocCommentLeadingTrivia(ref leading);\n\n            this.Start();\n            this.ScanXmlProcessingInstructionTextToken(ref info);\n            var errors = this.GetErrors(GetFullWidth(leading));\n\n            return Create(ref info, leading, null, errors);\n        }\n\n        // CONSIDER: This could easily be merged with ScanXmlCDataSectionTextToken\n        private bool ScanXmlProcessingInstructionTextToken(ref TokenInfo info)\n        {\n            char ch;\n\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Start));\n            Debug.Assert(!this.LocationIs(XmlDocCommentLocation.Exterior));\n\n            if (this.LocationIs(XmlDocCommentLocation.End))\n            {\n                info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                return true;\n            }\n\n            switch (ch = TextWindow.PeekChar())\n            {\n                case '?':\n                    if (TextWindow.PeekChar(1) == '>')\n                    {\n                        TextWindow.AdvanceChar(2);\n                        info.Kind = SyntaxKind.XmlProcessingInstructionEndToken;\n                        break;\n                    }\n\n                    goto default;\n\n                case '\\r':\n                case '\\n':\n                    this.ScanEndOfLine();\n                    info.StringValue = info.Text = TextWindow.GetText(false);\n                    info.Kind = SyntaxKind.XmlTextLiteralNewLineToken;\n                    this.MutateLocation(XmlDocCommentLocation.Exterior);\n                    break;\n\n                case SlidingTextWindow.InvalidCharacter:\n                    if (!TextWindow.IsReallyAtEnd())\n                    {\n                        goto default;\n                    }\n\n                    info.Kind = SyntaxKind.EndOfDocumentationCommentToken;\n                    break;\n\n                default:\n                    if (SyntaxFacts.IsNewLine(ch))\n                    {\n                        goto case '\\n';\n                    }\n\n                    this.ScanXmlProcessingInstructionText(ref info);\n                    info.Kind = SyntaxKind.XmlTextLiteralToken;\n                    break;\n            }\n\n            return true;\n        }\n\n        // CONSIDER: This could easily be merged with ScanXmlCDataSectionText\n        private void ScanXmlProcessingInstructionText(ref TokenInfo info)\n        {\n            while (true)\n            {\n                var ch = TextWindow.PeekChar();\n                switch (ch)\n                {\n                    case '?':\n                        if (TextWindow.PeekChar(1) == '>')\n                        {\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    case '\\r':\n                    case '\\n':\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case SlidingTextWindow.InvalidCharacter:\n                        if (!TextWindow.IsReallyAtEnd())\n                        {\n                            goto default;\n                        }\n\n                        info.StringValue = info.Text = TextWindow.GetText(false);\n                        return;\n\n                    case '*':\n                        if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')\n                        {\n                            // we're at the end of the comment, but don't lex it yet.\n                            info.StringValue = info.Text = TextWindow.GetText(false);\n                            return;\n                        }\n\n                        goto default;\n\n                    default:\n                        if (SyntaxFacts.IsNewLine(ch))\n                        {\n                            goto case '\\n';\n                        }\n\n                        TextWindow.AdvanceChar();\n                        break;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Collects XML doc comment exterior trivia, and therefore is a no op unless we are in the Start or Exterior of an XML doc comment.\n        /// </summary>\n        /// <param name=\"trivia\">List in which to collect the trivia</param>\n        private void LexXmlDocCommentLeadingTrivia(ref SyntaxListBuilder trivia)\n        {\n            var start = TextWindow.Position;\n            this.Start();\n\n            if (this.LocationIs(XmlDocCommentLocation.Start) && this.StyleIs(XmlDocCommentStyle.Delimited))\n            {\n                // Read the /** that begins an XML doc comment. Since these are recognized only\n                // when the trailing character is not a '*', we wind up in the interior of the\n                // doc comment at the end.\n\n                if (TextWindow.PeekChar() == '/'\n                    && TextWindow.PeekChar(1) == '*'\n                    && TextWindow.PeekChar(2) == '*'\n                    && TextWindow.PeekChar(3) != '*')\n                {\n                    TextWindow.AdvanceChar(3);\n                    var text = TextWindow.GetText(true);\n                    this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text), ref trivia);\n                    this.MutateLocation(XmlDocCommentLocation.Interior);\n                    return;\n                }\n            }\n            else if (this.LocationIs(XmlDocCommentLocation.Start) || this.LocationIs(XmlDocCommentLocation.Exterior))\n            {\n                // We're in the exterior of an XML doc comment and need to eat the beginnings of\n                // lines, for single line and delimited comments. We chew up white space until\n                // a non-whitespace character, and then make the right decision depending on\n                // what kind of comment we're in.\n\n                while (true)\n                {\n                    char ch = TextWindow.PeekChar();\n                    switch (ch)\n                    {\n                        case ' ':\n                        case '\\t':\n                        case '\\v':\n                        case '\\f':\n                            TextWindow.AdvanceChar();\n                            break;\n\n                        case '/':\n                            if (this.StyleIs(XmlDocCommentStyle.SingleLine) && TextWindow.PeekChar(1) == '/' && TextWindow.PeekChar(2) == '/' && TextWindow.PeekChar(3) != '/')\n                            {\n                                TextWindow.AdvanceChar(3);\n                                var text = TextWindow.GetText(true);\n                                this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text), ref trivia);\n                                this.MutateLocation(XmlDocCommentLocation.Interior);\n                                return;\n                            }\n\n                            goto default;\n\n                        case '*':\n                            if (this.StyleIs(XmlDocCommentStyle.Delimited))\n                            {\n                                while (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) != '/')\n                                {\n                                    TextWindow.AdvanceChar();\n                                }\n\n                                var text = TextWindow.GetText(true);\n                                if (!String.IsNullOrEmpty(text))\n                                {\n                                    this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text), ref trivia);\n                                }\n\n                                // This setup ensures that on the final line of a comment, if we have\n                                // the string \"  */\", the \"*/\" part is separated from the whitespace\n                                // and therefore recognizable as the end of the comment.\n\n                                if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')\n                                {\n                                    TextWindow.AdvanceChar(2);\n                                    this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(\"*/\"), ref trivia);\n                                    this.MutateLocation(XmlDocCommentLocation.End);\n                                }\n                                else\n                                {\n                                    this.MutateLocation(XmlDocCommentLocation.Interior);\n                                }\n\n                                return;\n                            }\n\n                            goto default;\n\n                        default:\n                            if (SyntaxFacts.IsWhitespace(ch))\n                            {\n                                goto case ' ';\n                            }\n\n                            // so here we have something else. if this is a single-line xml\n                            // doc comment, that means we're on a line that's no longer a doc\n                            // comment, so we need to rewind. if we're in a delimited doc comment,\n                            // then that means we hit pay dirt and we're back into xml text.\n\n                            if (this.StyleIs(XmlDocCommentStyle.SingleLine))\n                            {\n                                TextWindow.Reset(start);\n                                this.MutateLocation(XmlDocCommentLocation.End);\n                            }\n                            else // XmlDocCommentStyle.Delimited\n                            {\n                                Debug.Assert(this.StyleIs(XmlDocCommentStyle.Delimited));\n\n                                var text = TextWindow.GetText(true);\n                                if (!String.IsNullOrEmpty(text))\n                                    this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text), ref trivia);\n                                this.MutateLocation(XmlDocCommentLocation.Interior);\n                            }\n\n                            return;\n                    }\n                }\n            }\n            else if (!this.LocationIs(XmlDocCommentLocation.End) && this.StyleIs(XmlDocCommentStyle.Delimited))\n            {\n                if (TextWindow.PeekChar() == '*' && TextWindow.PeekChar(1) == '/')\n                {\n                    TextWindow.AdvanceChar(2);\n                    var text = TextWindow.GetText(true);\n                    this.AddTrivia(SyntaxFactory.DocumentationCommentExteriorTrivia(text), ref trivia);\n                    this.MutateLocation(XmlDocCommentLocation.End);\n                }\n            }\n        }\n\n        private void LexXmlDocCommentLeadingTriviaWithWhitespace(ref SyntaxListBuilder trivia)\n        {\n            while (true)\n            {\n                this.LexXmlDocCommentLeadingTrivia(ref trivia);\n\n                char ch = TextWindow.PeekChar();\n                if (this.LocationIs(XmlDocCommentLocation.Interior)\n                    && (SyntaxFacts.IsWhitespace(ch) || SyntaxFacts.IsNewLine(ch)))\n                {\n                    this.LexXmlWhitespaceAndNewLineTrivia(ref trivia);\n                }\n                else\n                {\n                    break;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Collects whitespace and new line trivia for XML doc comments. Does not see XML doc comment exterior trivia, and is a no op unless we are in the interior.\n        /// </summary>\n        /// <param name=\"trivia\">List in which to collect the trivia</param>\n        private void LexXmlWhitespaceAndNewLineTrivia(ref SyntaxListBuilder trivia)\n        {\n            this.Start();\n            if (this.LocationIs(XmlDocCommentLocation.Interior))\n            {\n                char ch = TextWindow.PeekChar();\n                switch (ch)\n                {\n                    case ' ':\n                    case '\\t':       // Horizontal tab\n                    case '\\v':       // Vertical Tab\n                    case '\\f':       // Form-feed\n                        this.AddTrivia(this.ScanWhitespace(), ref trivia);\n                        break;\n\n                    case '\\r':\n                    case '\\n':\n                        this.AddTrivia(this.ScanEndOfLine(), ref trivia);\n                        this.MutateLocation(XmlDocCommentLocation.Exterior);\n                        return;\n\n                    case '*':\n                        if (this.StyleIs(XmlDocCommentStyle.Delimited) && TextWindow.PeekChar(1) == '/')\n                        {\n                            // we're at the end of the comment, but don't add as trivia here.\n                            return;\n                        }\n\n                        goto default;\n\n                    default:\n                        if (SyntaxFacts.IsWhitespace(ch))\n                        {\n                            goto case ' ';\n                        }\n\n                        if (SyntaxFacts.IsNewLine(ch))\n                        {\n                            goto case '\\n';\n                        }\n\n                        return;\n                }\n            }\n        }\n    }\n    internal partial class Lexer\n    {\n        private void ScanStringLiteral(ref TokenInfo info, bool allowEscapes = true)\n        {\n            var quoteCharacter = TextWindow.PeekChar();\n            if (quoteCharacter == '\\'' || quoteCharacter == '\"')\n            {\n                TextWindow.AdvanceChar();\n                _builder.Length = 0;\n                while (true)\n                {\n                    char ch = TextWindow.PeekChar();\n                    if (ch == '\\\\' && allowEscapes)\n                    {\n                        // normal string & char constants can have escapes\n                        char c2;\n                        ch = this.ScanEscapeSequence(out c2);\n                        _builder.Append(ch);\n                        if (c2 != SlidingTextWindow.InvalidCharacter)\n                        {\n                            _builder.Append(c2);\n                        }\n                    }\n                    else if (ch == quoteCharacter)\n                    {\n                        TextWindow.AdvanceChar();\n                        break;\n                    }\n                    else if (SyntaxFacts.IsNewLine(ch) ||\n                            (ch == SlidingTextWindow.InvalidCharacter && TextWindow.IsReallyAtEnd()))\n                    {\n                        //String and character literals can contain any Unicode character. They are not limited\n                        //to valid UTF-16 characters. So if we get the SlidingTextWindow's sentinel value,\n                        //double check that it was not real user-code contents. This will be rare.\n                        Debug.Assert(TextWindow.Width > 0);\n                        this.AddError(ErrorCode.ERR_NewlineInConst);\n                        break;\n                    }\n                    else\n                    {\n                        TextWindow.AdvanceChar();\n                        _builder.Append(ch);\n                    }\n                }\n\n                info.Text = TextWindow.GetText(true);\n                if (quoteCharacter == '\\'')\n                {\n                    info.Kind = SyntaxKind.CharacterLiteralToken;\n                    if (_builder.Length != 1)\n                    {\n                        this.AddError((_builder.Length != 0) ? ErrorCode.ERR_TooManyCharsInConst : ErrorCode.ERR_EmptyCharConst);\n                    }\n\n                    if (_builder.Length > 0)\n                    {\n                        info.StringValue = TextWindow.Intern(_builder);\n                        info.CharValue = info.StringValue[0];\n                    }\n                    else\n                    {\n                        info.StringValue = string.Empty;\n                        info.CharValue = SlidingTextWindow.InvalidCharacter;\n                    }\n                }\n                else\n                {\n                    info.Kind = SyntaxKind.StringLiteralToken;\n                    if (_builder.Length > 0)\n                    {\n                        info.StringValue = TextWindow.Intern(_builder);\n                    }\n                    else\n                    {\n                        info.StringValue = string.Empty;\n                    }\n                }\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                info.Text = null;\n            }\n        }\n\n        private char ScanEscapeSequence(out char surrogateCharacter)\n        {\n            var start = TextWindow.Position;\n            surrogateCharacter = SlidingTextWindow.InvalidCharacter;\n            char ch = TextWindow.NextChar();\n            Debug.Assert(ch == '\\\\');\n\n            ch = TextWindow.NextChar();\n            switch (ch)\n            {\n                // escaped characters that translate to themselves\n                case '\\'':\n                case '\"':\n                case '\\\\':\n                    break;\n                // translate escapes as per C# spec 2.4.4.4\n                case '0':\n                    ch = '\\u0000';\n                    break;\n                case 'a':\n                    ch = '\\u0007';\n                    break;\n                case 'b':\n                    ch = '\\u0008';\n                    break;\n                case 'f':\n                    ch = '\\u000c';\n                    break;\n                case 'n':\n                    ch = '\\u000a';\n                    break;\n                case 'r':\n                    ch = '\\u000d';\n                    break;\n                case 't':\n                    ch = '\\u0009';\n                    break;\n                case 'v':\n                    ch = '\\u000b';\n                    break;\n                case 'x':\n                case 'u':\n                case 'U':\n                    TextWindow.Reset(start);\n                    SyntaxDiagnosticInfo error;\n                    ch = TextWindow.NextUnicodeEscape(surrogateCharacter: out surrogateCharacter, info: out error);\n                    AddError(error);\n                    break;\n                default:\n                    this.AddError(start, TextWindow.Position - start, ErrorCode.ERR_IllegalEscape);\n                    break;\n            }\n\n            return ch;\n        }\n\n        private void ScanVerbatimStringLiteral(ref TokenInfo info, bool allowNewlines = true)\n        {\n            _builder.Length = 0;\n\n            if (TextWindow.PeekChar() == '@' && TextWindow.PeekChar(1) == '\"')\n            {\n                TextWindow.AdvanceChar(2);\n                bool done = false;\n                char ch;\n                _builder.Length = 0;\n                while (!done)\n                {\n                    switch (ch = TextWindow.PeekChar())\n                    {\n                        case '\"':\n                            TextWindow.AdvanceChar();\n                            if (TextWindow.PeekChar() == '\"')\n                            {\n                                // Doubled quote -- skip & put the single quote in the string\n                                TextWindow.AdvanceChar();\n                                _builder.Append(ch);\n                            }\n                            else\n                            {\n                                done = true;\n                            }\n\n                            break;\n\n                        case SlidingTextWindow.InvalidCharacter:\n                            if (!TextWindow.IsReallyAtEnd())\n                            {\n                                goto default;\n                            }\n\n                            // Reached the end of the source without finding the end-quote.  Give\n                            // an error back at the starting point.\n                            this.AddError(ErrorCode.ERR_UnterminatedStringLit);\n                            done = true;\n                            break;\n\n                        default:\n                            if (!allowNewlines && SyntaxFacts.IsNewLine(ch))\n                            {\n                                this.AddError(ErrorCode.ERR_UnterminatedStringLit);\n                                done = true;\n                                break;\n                            }\n\n                            TextWindow.AdvanceChar();\n                            _builder.Append(ch);\n                            break;\n                    }\n                }\n\n                info.Kind = SyntaxKind.StringLiteralToken;\n                info.Text = TextWindow.GetText(false);\n                info.StringValue = _builder.ToString();\n            }\n            else\n            {\n                info.Kind = SyntaxKind.None;\n                info.Text = null;\n                info.StringValue = null;\n            }\n        }\n\n        private void ScanInterpolatedStringLiteral(bool isVerbatim, ref TokenInfo info)\n        {\n            // We have a string of the form\n            //                $\" ... \"\n            // or, if isVerbatim is true, of the form\n            //                $@\" ... \"\n            // Where the contents contains zero or more sequences\n            //                { STUFF }\n            // where these curly braces delimit STUFF in expression \"holes\".\n            // In order to properly find the closing quote of the whole string,\n            // we need to locate the closing brace of each hole, as strings\n            // may appear in expressions in the holes. So we\n            // need to match up any braces that appear between them.\n            // But in order to do that, we also need to match up any\n            // /**/ comments, ' characters quotes, () parens\n            // [] brackets, and \"\" strings, including interpolated holes in the latter.\n\n            SyntaxDiagnosticInfo error = null;\n            bool closeQuoteMissing;\n            ScanInterpolatedStringLiteralTop(null, isVerbatim, ref info, ref error, out closeQuoteMissing);\n            this.AddError(error);\n        }\n\n        internal void ScanInterpolatedStringLiteralTop(ArrayBuilder<Interpolation> interpolations, bool isVerbatim, ref TokenInfo info, ref SyntaxDiagnosticInfo error, out bool closeQuoteMissing)\n        {\n            var subScanner = new InterpolatedStringScanner(this, isVerbatim);\n            subScanner.ScanInterpolatedStringLiteralTop(interpolations, ref info, out closeQuoteMissing);\n            error = subScanner.error;\n            info.Text = TextWindow.GetText(false);\n        }\n\n        internal struct Interpolation\n        {\n            public readonly int OpenBracePosition;\n            public readonly int ColonPosition;\n            public readonly int CloseBracePosition;\n            public readonly bool CloseBraceMissing;\n            public bool ColonMissing => ColonPosition <= 0;\n            public bool HasColon => ColonPosition > 0;\n            public int LastPosition => CloseBraceMissing ? CloseBracePosition - 1 : CloseBracePosition;\n            public int FormatEndPosition => CloseBracePosition - 1;\n            public Interpolation(int openBracePosition, int colonPosition, int closeBracePosition, bool closeBraceMissing)\n            {\n                this.OpenBracePosition = openBracePosition;\n                this.ColonPosition = colonPosition;\n                this.CloseBracePosition = closeBracePosition;\n                this.CloseBraceMissing = closeBraceMissing;\n            }\n        }\n\n        /// <summary>\n        /// Turn a (parsed) interpolated string nonterminal into an interpolated string token.\n        /// </summary>\n        /// <param name=\"interpolatedString\"></param>\n        static internal SyntaxToken RescanInterpolatedString(InterpolatedStringExpressionSyntax interpolatedString)\n        {\n            var text = interpolatedString.ToString();\n            var kind = SyntaxKind.InterpolatedStringToken;\n            // TODO: scan the contents (perhaps using ScanInterpolatedStringLiteralContents) to reconstruct any lexical\n            // errors such as // inside an expression hole\n            return SyntaxFactory.Literal(\n                interpolatedString.GetFirstToken().GetLeadingTrivia(),\n                text,\n                kind,\n                text,\n                interpolatedString.GetLastToken().GetTrailingTrivia());\n        }\n\n        private class InterpolatedStringScanner\n        {\n            public Lexer lexer;\n            public bool isVerbatim;\n            public bool allowNewlines;\n            public SyntaxDiagnosticInfo error;\n            public InterpolatedStringScanner(\n                Lexer lexer,\n                bool isVerbatim)\n            {\n                this.lexer = lexer;\n                this.isVerbatim = isVerbatim;\n                this.allowNewlines = isVerbatim;\n            }\n\n            private bool IsAtEnd()\n            {\n                return IsAtEnd(isVerbatim && allowNewlines);\n            }\n\n            private bool IsAtEnd(bool allowNewline)\n            {\n                char ch = lexer.TextWindow.PeekChar();\n                return\n                    !allowNewline && SyntaxFacts.IsNewLine(ch) ||\n                    (ch == SlidingTextWindow.InvalidCharacter && lexer.TextWindow.IsReallyAtEnd());\n            }\n\n            internal void ScanInterpolatedStringLiteralTop(ArrayBuilder<Interpolation> interpolations, ref TokenInfo info, out bool closeQuoteMissing)\n            {\n                Debug.Assert(lexer.TextWindow.PeekChar() == '$');\n                lexer.TextWindow.AdvanceChar(); // $\n                if (isVerbatim)\n                {\n                    Debug.Assert(lexer.TextWindow.PeekChar() == '@');\n                    lexer.TextWindow.AdvanceChar(); // @\n                }\n\n                Debug.Assert(lexer.TextWindow.PeekChar() == '\"');\n                lexer.TextWindow.AdvanceChar(); // \"\n                ScanInterpolatedStringLiteralContents(interpolations);\n                if (lexer.TextWindow.PeekChar() != '\"')\n                {\n                    Debug.Assert(IsAtEnd());\n                    if (error == null)\n                    {\n                        int position = IsAtEnd(true) ? lexer.TextWindow.Position - 1 : lexer.TextWindow.Position;\n                        error = lexer.MakeError(position, 1, isVerbatim ? ErrorCode.ERR_UnterminatedStringLit : ErrorCode.ERR_NewlineInConst);\n                    }\n\n                    closeQuoteMissing = true;\n                }\n                else\n                {\n                    // found the closing quote\n                    lexer.TextWindow.AdvanceChar(); // \"\n                    closeQuoteMissing = false;\n                }\n\n                info.Kind = SyntaxKind.InterpolatedStringToken;\n            }\n\n            private void ScanInterpolatedStringLiteralContents(ArrayBuilder<Interpolation> interpolations)\n            {\n                while (true)\n                {\n                    if (IsAtEnd())\n                    {\n                        // error: end of line before end of string\n                        return;\n                    }\n\n                    switch (lexer.TextWindow.PeekChar())\n                    {\n                        case '\"':\n                            if (isVerbatim && lexer.TextWindow.PeekChar(1) == '\"')\n                            {\n                                lexer.TextWindow.AdvanceChar(); // \"\n                                lexer.TextWindow.AdvanceChar(); // \"\n                                continue;\n                            }\n                            // found the end of the string\n                            return;\n                        case '}':\n                            var pos = lexer.TextWindow.Position;\n                            lexer.TextWindow.AdvanceChar(); // }\n                            // ensure any } characters are doubled up\n                            if (lexer.TextWindow.PeekChar() == '}')\n                            {\n                                lexer.TextWindow.AdvanceChar(); // }\n                            }\n                            else if (error == null)\n                            {\n                                error = lexer.MakeError(pos, 1, ErrorCode.ERR_UnescapedCurly, \"}\");\n                            }\n                            continue;\n                        case '{':\n                            if (lexer.TextWindow.PeekChar(1) == '{')\n                            {\n                                lexer.TextWindow.AdvanceChar();\n                                lexer.TextWindow.AdvanceChar();\n                            }\n                            else\n                            {\n                                int openBracePosition = lexer.TextWindow.Position;\n                                lexer.TextWindow.AdvanceChar();\n                                int colonPosition = 0;\n                                ScanInterpolatedStringLiteralHoleBalancedText('}', true, ref colonPosition);\n                                int closeBracePosition = lexer.TextWindow.Position;\n                                bool closeBraceMissing = false;\n                                if (lexer.TextWindow.PeekChar() == '}')\n                                {\n                                    lexer.TextWindow.AdvanceChar();\n                                }\n                                else\n                                {\n                                    closeBraceMissing = true;\n                                    if (error == null)\n                                    {\n                                        error = lexer.MakeError(openBracePosition - 1, 2, ErrorCode.ERR_UnclosedExpressionHole);\n                                    }\n                                }\n\n                                interpolations?.Add(new Interpolation(openBracePosition, colonPosition, closeBracePosition, closeBraceMissing));\n                            }\n                            continue;\n                        case '\\\\':\n                            if (isVerbatim)\n                            {\n                                goto default;\n                            }\n\n                            var escapeStart = lexer.TextWindow.Position;\n                            char c2;\n                            char ch = lexer.ScanEscapeSequence(out c2);\n                            if ((ch == '{' || ch == '}') && error == null)\n                            {\n                                error = lexer.MakeError(escapeStart, lexer.TextWindow.Position - escapeStart, ErrorCode.ERR_EscapedCurly, ch);\n                            }\n\n                            continue;\n                        default:\n                            // found some other character in the string portion\n                            lexer.TextWindow.AdvanceChar();\n                            continue;\n                    }\n                }\n            }\n\n            private void ScanFormatSpecifier()\n            {\n                Debug.Assert(lexer.TextWindow.PeekChar() == ':');\n                lexer.TextWindow.AdvanceChar();\n                while (true)\n                {\n                    char ch = lexer.TextWindow.PeekChar();\n                    if (ch == '\\\\' && !isVerbatim)\n                    {\n                        // normal string & char constants can have escapes\n                        var pos = lexer.TextWindow.Position;\n                        char c2;\n                        ch = lexer.ScanEscapeSequence(out c2);\n                        if ((ch == '{' || ch == '}') && error == null)\n                        {\n                            error = lexer.MakeError(pos, 1, ErrorCode.ERR_EscapedCurly, ch);\n                        }\n                    }\n                    else if (ch == '\"')\n                    {\n                        if (isVerbatim && lexer.TextWindow.PeekChar(1) == '\"')\n                        {\n                            lexer.TextWindow.AdvanceChar();\n                            lexer.TextWindow.AdvanceChar();\n                        }\n                        else\n                        {\n                            return; // premature end of string! let caller complain about unclosed interpolation\n                        }\n                    }\n                    else if (ch == '{')\n                    {\n                        var pos = lexer.TextWindow.Position;\n                        lexer.TextWindow.AdvanceChar();\n                        // ensure any { characters are doubled up\n                        if (lexer.TextWindow.PeekChar() == '{')\n                        {\n                            lexer.TextWindow.AdvanceChar(); // {\n                        }\n                        else if (error == null)\n                        {\n                            error = lexer.MakeError(pos, 1, ErrorCode.ERR_UnescapedCurly, \"{\");\n                        }\n                    }\n                    else if (ch == '}')\n                    {\n                        if (lexer.TextWindow.PeekChar(1) == '}')\n                        {\n                            lexer.TextWindow.AdvanceChar();\n                            lexer.TextWindow.AdvanceChar();\n                        }\n                        else\n                        {\n                            return; // end of interpolation\n                        }\n                    }\n                    else if (IsAtEnd())\n                    {\n                        return; // premature end; let caller complain\n                    }\n                    else\n                    {\n                        lexer.TextWindow.AdvanceChar();\n                    }\n                }\n            }\n\n            /// <summary>\n            /// Scan past the hole inside an interpolated string literal, leaving the current character on the '}' (if any)\n            /// </summary>\n            private void ScanInterpolatedStringLiteralHoleBalancedText(char endingChar, bool isHole, ref int colonPosition)\n            {\n                while (true)\n                {\n                    if (IsAtEnd())\n                    {\n                        // the caller will complain\n                        return;\n                    }\n\n                    char ch = lexer.TextWindow.PeekChar();\n                    switch (ch)\n                    {\n                        case '#':\n                            // preprocessor directives not allowed.\n                            if (error == null)\n                            {\n                                error = lexer.MakeError(lexer.TextWindow.Position, 1, ErrorCode.ERR_SyntaxError, endingChar.ToString());\n                            }\n\n                            lexer.TextWindow.AdvanceChar();\n                            continue;\n                        case '$':\n                            if (lexer.TextWindow.PeekChar(1) == '\"' || lexer.TextWindow.PeekChar(1) == '@' && lexer.TextWindow.PeekChar(2) == '\"')\n                            {\n                                bool isVerbatimSubstring = lexer.TextWindow.PeekChar(1) == '@';\n                                var interpolations = default(ArrayBuilder<Interpolation>);\n                                var info = default(TokenInfo);\n                                bool wasVerbatim = this.isVerbatim;\n                                bool wasAllowNewlines = this.allowNewlines;\n                                try\n                                {\n                                    this.isVerbatim = isVerbatimSubstring;\n                                    this.allowNewlines &= isVerbatim;\n                                    bool closeQuoteMissing;\n                                    ScanInterpolatedStringLiteralTop(interpolations, ref info, out closeQuoteMissing);\n                                }\n                                finally\n                                {\n                                    this.isVerbatim = wasVerbatim;\n                                    this.allowNewlines = wasAllowNewlines;\n                                }\n                                continue;\n                            }\n\n                            goto default;\n                        case ':':\n                            // the first colon not nested within matching delimiters is the start of the format string\n                            if (isHole)\n                            {\n                                Debug.Assert(colonPosition == 0);\n                                colonPosition = lexer.TextWindow.Position;\n                                ScanFormatSpecifier();\n                                return;\n                            }\n\n                            goto default;\n                        case '}':\n                        case ')':\n                        case ']':\n                            if (ch == endingChar)\n                            {\n                                return;\n                            }\n\n                            if (error == null)\n                            {\n                                error = lexer.MakeError(lexer.TextWindow.Position, 1, ErrorCode.ERR_SyntaxError, endingChar.ToString());\n                            }\n\n                            goto default;\n                        case '\"':\n                        case '\\'':\n                            // handle string or character literal inside an expression hole.\n                            ScanInterpolatedStringLiteralNestedString(ch);\n                            continue;\n                        case '@':\n                            if (lexer.TextWindow.PeekChar(1) == '\"')\n                            {\n                                // check for verbatim string inside an expression hole.\n                                ScanInterpolatedStringLiteralNestedVerbatimString();\n                                continue;\n                            }\n\n                            goto default;\n                        case '/':\n                            switch (lexer.TextWindow.PeekChar(1))\n                            {\n                                case '/':\n                                    if (isVerbatim && allowNewlines)\n                                    {\n                                        lexer.TextWindow.AdvanceChar(); // skip /\n                                        lexer.TextWindow.AdvanceChar(); // skip /\n                                        while (!IsAtEnd(false))\n                                        {\n                                            lexer.TextWindow.AdvanceChar(); // skip // comment character\n                                        }\n                                    }\n                                    else\n                                    {\n                                        // error: single-line comment not allowed in an interpolated string\n                                        if (error == null)\n                                        {\n                                            error = lexer.MakeError(lexer.TextWindow.Position, 2, ErrorCode.ERR_SingleLineCommentInExpressionHole);\n                                        }\n\n                                        lexer.TextWindow.AdvanceChar();\n                                        lexer.TextWindow.AdvanceChar();\n                                    }\n                                    continue;\n                                case '*':\n                                    // check for and scan /* comment */\n                                    ScanInterpolatedStringLiteralNestedComment();\n                                    continue;\n                                default:\n                                    lexer.TextWindow.AdvanceChar();\n                                    continue;\n                            }\n                        case '{':\n                            // TODO: after the colon this has no special meaning.\n                            ScanInterpolatedStringLiteralHoleBracketed('{', '}');\n                            continue;\n                        case '(':\n                            // TODO: after the colon this has no special meaning.\n                            ScanInterpolatedStringLiteralHoleBracketed('(', ')');\n                            continue;\n                        case '[':\n                            // TODO: after the colon this has no special meaning.\n                            ScanInterpolatedStringLiteralHoleBracketed('[', ']');\n                            continue;\n                        default:\n                            // part of code in the expression hole\n                            lexer.TextWindow.AdvanceChar();\n                            continue;\n                    }\n                }\n            }\n\n            private void ScanInterpolatedStringLiteralNestedComment()\n            {\n                Debug.Assert(lexer.TextWindow.PeekChar() == '/');\n                lexer.TextWindow.AdvanceChar();\n                Debug.Assert(lexer.TextWindow.PeekChar() == '*');\n                lexer.TextWindow.AdvanceChar();\n                while (true)\n                {\n                    if (IsAtEnd())\n                    {\n                        return; // let the caller complain about the unterminated quote\n                    }\n\n                    var ch = lexer.TextWindow.PeekChar();\n                    lexer.TextWindow.AdvanceChar();\n                    if (ch == '*' && lexer.TextWindow.PeekChar() == '/')\n                    {\n                        lexer.TextWindow.AdvanceChar(); // skip */\n                        return;\n                    }\n                }\n            }\n\n            private void ScanInterpolatedStringLiteralNestedString(char quote)\n            {\n                var discarded = default(TokenInfo);\n                lexer.ScanStringLiteral(ref discarded, true);\n            }\n\n            private void ScanInterpolatedStringLiteralNestedVerbatimString()\n            {\n                var discarded = default(TokenInfo);\n                lexer.ScanVerbatimStringLiteral(ref discarded, allowNewlines: allowNewlines);\n            }\n\n            private void ScanInterpolatedStringLiteralHoleBracketed(char start, char end)\n            {\n                Debug.Assert(start == lexer.TextWindow.PeekChar());\n                lexer.TextWindow.AdvanceChar();\n                int colon = 0;\n                ScanInterpolatedStringLiteralHoleBalancedText(end, false, ref colon);\n                if (lexer.TextWindow.PeekChar() == end)\n                {\n                    lexer.TextWindow.AdvanceChar();\n                }\n                else\n                {\n                    // an error was given by the caller\n                }\n            }\n        }\n    }\n    internal partial class Lexer\n    {\n        // Maximum size of tokens/trivia that we cache and use in quick scanner.\n        // From what I see in our own codebase, tokens longer then 40-50 chars are \n        // not very common. \n        // So it seems reasonable to limit the sizes to some round number like 42.\n        private const int MaxCachedTokenSize = 42;\n\n        private enum QuickScanState : byte\n        {\n            Initial,\n            FollowingWhite,\n            FollowingCR,\n            Ident,\n            Number,\n            Punctuation,\n            Dot,\n            CompoundPunctStart,\n            DoneAfterNext,\n            Done,\n            Bad\n        }\n\n        private enum CharFlags : byte\n        {\n            White,      // simple whitespace (space/tab)\n            CR,         // carriage return\n            LF,         // line feed\n            Letter,     // letter\n            Digit,      // digit 0-9\n            Punct,      // some simple punctuation (parens, braces, comma, equals, question)\n            Dot,        // dot is different from other punctuation when foillowed by a digit (Ex: .9 )\n            CompoundPunctStart, // may be a part of compound punctuation. will be used only if followed by (not white) && (not punct)\n            Slash,      // /\n            Complex,    // complex - causes scanning to abort\n            EndOfFile,  // legal type character (except !, which is contextually dictionary lookup\n        }\n\n        // PERF: Use byte instead of QuickScanState so the compiler can use array literal initialization.\n        //       The most natural type choice, Enum arrays, are not blittable due to a CLR limitation.\n        private static readonly byte[,] s_stateTransitions = new byte[,]\n        {\n            // Initial\n            {\n                (byte)QuickScanState.Initial,             // White\n                (byte)QuickScanState.Initial,             // CR\n                (byte)QuickScanState.Initial,             // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Punctuation,         // Punct\n                (byte)QuickScanState.Dot,                 // Dot\n                (byte)QuickScanState.CompoundPunctStart,  // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Bad,                 // EndOfFile\n            },\n\n            // Following White\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Following CR\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Identifier\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Ident,               // Letter\n                (byte)QuickScanState.Ident,               // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Number\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Bad,                 // Letter (might be 'e' or 'x' or suffix)\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Bad,                 // Dot (Number is followed by a dot - too complex for us to handle here).\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Dot\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Number,              // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Compound Punctuation\n            {\n                (byte)QuickScanState.FollowingWhite,      // White\n                (byte)QuickScanState.FollowingCR,         // CR\n                (byte)QuickScanState.DoneAfterNext,       // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Bad,                 // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Bad,                 // Compound\n                (byte)QuickScanState.Bad,                 // Slash\n                (byte)QuickScanState.Bad,                 // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n\n            // Done after next\n            {\n                (byte)QuickScanState.Done,                // White\n                (byte)QuickScanState.Done,                // CR\n                (byte)QuickScanState.Done,                // LF\n                (byte)QuickScanState.Done,                // Letter\n                (byte)QuickScanState.Done,                // Digit\n                (byte)QuickScanState.Done,                // Punct\n                (byte)QuickScanState.Done,                // Dot\n                (byte)QuickScanState.Done,                // Compound\n                (byte)QuickScanState.Done,                // Slash\n                (byte)QuickScanState.Done,                // Complex\n                (byte)QuickScanState.Done,                // EndOfFile\n            },\n        };\n\n        private SyntaxToken QuickScanSyntaxToken()\n        {\n            this.Start();\n            var state = QuickScanState.Initial;\n            int i = TextWindow.Offset;\n            int n = TextWindow.CharacterWindowCount;\n            n = Math.Min(n, i + MaxCachedTokenSize);\n\n            int hashCode = Hash.FnvOffsetBias;\n\n            //localize frequently accessed fields\n            var charWindow = TextWindow.CharacterWindow;\n            var charPropLength = s_charProperties.Length;\n\n            for (; i < n; i++)\n            {\n                char c = charWindow[i];\n                int uc = unchecked((int)c);\n\n                var flags = uc < charPropLength ? (CharFlags)s_charProperties[uc] : CharFlags.Complex;\n\n                state = (QuickScanState)s_stateTransitions[(int)state, (int)flags];\n                if (state == QuickScanState.Done || state == QuickScanState.Bad)\n                {\n                    goto exitWhile;\n                }\n\n                hashCode = unchecked((hashCode ^ uc) * Hash.FnvPrime);\n            }\n\n            state = QuickScanState.Bad; // ran out of characters in window\n        exitWhile:\n\n            TextWindow.AdvanceChar(i - TextWindow.Offset);\n            Debug.Assert(state == QuickScanState.Bad || state == QuickScanState.Done);\n\n            if (state == QuickScanState.Done)\n            {\n                // this is a good token!\n                var token = _cache.LookupToken(\n                    TextWindow.CharacterWindow,\n                    TextWindow.LexemeRelativeStart,\n                    i - TextWindow.LexemeRelativeStart,\n                    hashCode,\n                    _createQuickTokenFunction);\n                return token;\n            }\n            else\n            {\n                TextWindow.Reset(TextWindow.LexemeStartPosition);\n                return null;\n            }\n        }\n\n        private Func<SyntaxToken> _createQuickTokenFunction;\n\n        private SyntaxToken CreateQuickToken()\n        {\n#if DEBUG\n            var quickWidth = TextWindow.Width;\n#endif\n            TextWindow.Reset(TextWindow.LexemeStartPosition);\n            var token = this.LexSyntaxToken();\n#if DEBUG\n            Debug.Assert(quickWidth == token.FullWidth);\n#endif\n            return token;\n        }\n\n        // The following table classifies the first 0x180 Unicode characters. \n        // # is marked complex as it may start directives.\n        // PERF: Use byte instead of CharFlags so the compiler can use array literal initialization.\n        //       The most natural type choice, Enum arrays, are not blittable due to a CLR limitation.\n        private static readonly byte[] s_charProperties = new[]\n        {\n            // 0 .. 31\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.White,   // TAB\n            (byte)CharFlags.LF,      // LF\n            (byte)CharFlags.White,   // VT\n            (byte)CharFlags.White,   // FF\n            (byte)CharFlags.CR,      // CR\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 32 .. 63\n            (byte)CharFlags.White,    // SPC\n            (byte)CharFlags.CompoundPunctStart,    // !\n            (byte)CharFlags.Complex,  // \"\n            (byte)CharFlags.Complex,  // #\n            (byte)CharFlags.Complex,  // $\n            (byte)CharFlags.CompoundPunctStart, // %\n            (byte)CharFlags.CompoundPunctStart, // &\n            (byte)CharFlags.Complex,  // '\n            (byte)CharFlags.Punct,    // (\n            (byte)CharFlags.Punct,    // )\n            (byte)CharFlags.CompoundPunctStart, // *\n            (byte)CharFlags.CompoundPunctStart, // +\n            (byte)CharFlags.Punct,    // ,\n            (byte)CharFlags.CompoundPunctStart, // -\n            (byte)CharFlags.Dot,      // .\n            (byte)CharFlags.Slash,    // /\n            (byte)CharFlags.Digit,    // 0\n            (byte)CharFlags.Digit,    // 1\n            (byte)CharFlags.Digit,    // 2\n            (byte)CharFlags.Digit,    // 3\n            (byte)CharFlags.Digit,    // 4\n            (byte)CharFlags.Digit,    // 5\n            (byte)CharFlags.Digit,    // 6\n            (byte)CharFlags.Digit,    // 7\n            (byte)CharFlags.Digit,    // 8\n            (byte)CharFlags.Digit,    // 9\n            (byte)CharFlags.CompoundPunctStart,  // :\n            (byte)CharFlags.Punct,    // ;\n            (byte)CharFlags.CompoundPunctStart,  // <\n            (byte)CharFlags.CompoundPunctStart,  // =\n            (byte)CharFlags.CompoundPunctStart,  // >\n            (byte)CharFlags.CompoundPunctStart,  // ?\n\n            // 64 .. 95\n            (byte)CharFlags.Complex,  // @\n            (byte)CharFlags.Letter,   // A\n            (byte)CharFlags.Letter,   // B\n            (byte)CharFlags.Letter,   // C\n            (byte)CharFlags.Letter,   // D\n            (byte)CharFlags.Letter,   // E\n            (byte)CharFlags.Letter,   // F\n            (byte)CharFlags.Letter,   // G\n            (byte)CharFlags.Letter,   // H\n            (byte)CharFlags.Letter,   // I\n            (byte)CharFlags.Letter,   // J\n            (byte)CharFlags.Letter,   // K\n            (byte)CharFlags.Letter,   // L\n            (byte)CharFlags.Letter,   // M\n            (byte)CharFlags.Letter,   // N\n            (byte)CharFlags.Letter,   // O\n            (byte)CharFlags.Letter,   // P\n            (byte)CharFlags.Letter,   // Q\n            (byte)CharFlags.Letter,   // R\n            (byte)CharFlags.Letter,   // S\n            (byte)CharFlags.Letter,   // T\n            (byte)CharFlags.Letter,   // U\n            (byte)CharFlags.Letter,   // V\n            (byte)CharFlags.Letter,   // W\n            (byte)CharFlags.Letter,   // X\n            (byte)CharFlags.Letter,   // Y\n            (byte)CharFlags.Letter,   // Z\n            (byte)CharFlags.Punct,    // [\n            (byte)CharFlags.Complex,  // \\\n            (byte)CharFlags.Punct,    // ]\n            (byte)CharFlags.CompoundPunctStart,    // ^\n            (byte)CharFlags.Letter,   // _\n\n            // 96 .. 127\n            (byte)CharFlags.Complex,  // `\n            (byte)CharFlags.Letter,   // a\n            (byte)CharFlags.Letter,   // b\n            (byte)CharFlags.Letter,   // c\n            (byte)CharFlags.Letter,   // d\n            (byte)CharFlags.Letter,   // e\n            (byte)CharFlags.Letter,   // f\n            (byte)CharFlags.Letter,   // g\n            (byte)CharFlags.Letter,   // h\n            (byte)CharFlags.Letter,   // i\n            (byte)CharFlags.Letter,   // j\n            (byte)CharFlags.Letter,   // k\n            (byte)CharFlags.Letter,   // l\n            (byte)CharFlags.Letter,   // m\n            (byte)CharFlags.Letter,   // n\n            (byte)CharFlags.Letter,   // o\n            (byte)CharFlags.Letter,   // p\n            (byte)CharFlags.Letter,   // q\n            (byte)CharFlags.Letter,   // r\n            (byte)CharFlags.Letter,   // s\n            (byte)CharFlags.Letter,   // t\n            (byte)CharFlags.Letter,   // u\n            (byte)CharFlags.Letter,   // v\n            (byte)CharFlags.Letter,   // w\n            (byte)CharFlags.Letter,   // x\n            (byte)CharFlags.Letter,   // y\n            (byte)CharFlags.Letter,   // z\n            (byte)CharFlags.Punct,    // {\n            (byte)CharFlags.CompoundPunctStart,  // |\n            (byte)CharFlags.Punct,    // }\n            (byte)CharFlags.CompoundPunctStart,    // ~\n            (byte)CharFlags.Complex,\n\n            // 128 .. 159\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 160 .. 191\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n            (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Letter, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex, (byte)CharFlags.Complex,\n\n            // 192 .. \n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Complex,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter,\n            (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter, (byte)CharFlags.Letter\n        };\n    }\n", "label": "FeatureEnvy"}
{"text": "        internal sealed class GlobalSuppressMessageCodeAction : CodeAction\n        {\n            private readonly AbstractSuppressionCodeFixProvider _fixer;\n            private readonly string _title;\n            private readonly ISymbol _targetSymbol;\n            private readonly Document _document;\n            private readonly Diagnostic _diagnostic;\n\n            public GlobalSuppressMessageCodeAction(AbstractSuppressionCodeFixProvider fixer, ISymbol targetSymbol, Document document, Diagnostic diagnostic)\n            {\n                _fixer = fixer;\n\n                _targetSymbol = targetSymbol;\n                _document = document;\n                _diagnostic = diagnostic;\n\n                _title = FeaturesResources.SuppressWithGlobalSuppressMessage;\n            }\n\n            protected override async Task<IEnumerable<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken)\n            {\n                var changedSuppressionDocument = await GetChangedSuppressionDocumentAsync(cancellationToken).ConfigureAwait(false);\n                return new CodeActionOperation[]\n                {\n                    new ApplyChangesOperation(changedSuppressionDocument.Project.Solution),\n                    new OpenDocumentOperation(changedSuppressionDocument.Id, activateIfAlreadyOpen: true),\n                    new NavigationOperation(changedSuppressionDocument.Id, position: 0)\n                };\n            }\n\n            public override string Title\n            {\n                get\n                {\n                    return _title;\n                }\n            }\n\n            private async Task<Document> GetChangedSuppressionDocumentAsync(CancellationToken cancellationToken)\n            {\n                var suppressionsDoc = await GetOrCreateSuppressionsDocumentAsync(_document, cancellationToken).ConfigureAwait(false);\n                var suppressionsRoot = await suppressionsDoc.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);\n                var newSuppressionsRoot = _fixer.AddGlobalSuppressMessageAttribute(suppressionsRoot, _targetSymbol, _diagnostic);\n                return suppressionsDoc.WithSyntaxRoot(newSuppressionsRoot);\n            }\n\n            private async Task<Document> GetOrCreateSuppressionsDocumentAsync(Document document, CancellationToken c)\n            {\n                int index = 1;\n                var suppressionsFileName = s_globalSuppressionsFileName + _fixer.DefaultFileExtension;\n                if (document.Name == suppressionsFileName)\n                {\n                    index++;\n                    suppressionsFileName = s_globalSuppressionsFileName + index.ToString() + _fixer.DefaultFileExtension;\n                }\n\n                Document suppressionsDoc = null;\n                while (suppressionsDoc == null)\n                {\n                    var hasDocWithSuppressionsName = false;\n                    foreach (var d in document.Project.Documents)\n                    {\n                        if (d.Name == suppressionsFileName)\n                        {\n                            // Existing global suppressions file, see if this file only has global assembly attributes.\n                            hasDocWithSuppressionsName = true;\n\n                            var t = await d.GetSyntaxTreeAsync(c).ConfigureAwait(false);\n                            var r = await t.GetRootAsync(c).ConfigureAwait(false);\n                            if (r.ChildNodes().All(n => _fixer.IsAttributeListWithAssemblyAttributes(n)))\n                            {\n                                suppressionsDoc = d;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (suppressionsDoc == null)\n                    {\n                        if (hasDocWithSuppressionsName)\n                        {\n                            index++;\n                            suppressionsFileName = s_globalSuppressionsFileName + index.ToString() + _fixer.DefaultFileExtension;\n                        }\n                        else\n                        {\n                            // Create an empty global suppressions file.\n                            suppressionsDoc = document.Project.AddDocument(suppressionsFileName, string.Empty);\n                        }\n                    }\n                }\n\n                return suppressionsDoc;\n            }\n        }\n", "label": "FeatureEnvy"}
{"text": "\n\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public partial class blockContact_args : TBase\n    {\n      private int _reqSeq;\n      private string _id;\n\n      public int ReqSeq\n      {\n        get\n        {\n          return _reqSeq;\n        }\n        set\n        {\n          __isset.reqSeq = true;\n          this._reqSeq = value;\n        }\n      }\n\n      public string Id\n      {\n        get\n        {\n          return _id;\n        }\n        set\n        {\n          __isset.id = true;\n          this._id = value;\n        }\n      }\n\n\n      public Isset __isset;\n      #if !SILVERLIGHT\n      [Serializable]\n      #endif\n      public struct Isset {\n        public bool reqSeq;\n        public bool id;\n      }\n\n      public blockContact_args() {\n      }\n\n      public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 1:\n              if (field.Type == TType.I32) {\n                ReqSeq = iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 2:\n              if (field.Type == TType.String) {\n                Id = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }\n\n      public void Write(TProtocol oprot) {\n        TStruct struc = new TStruct(\"blockContact_args\");\n        oprot.WriteStructBegin(struc);\n        TField field = new TField();\n        if (__isset.reqSeq) {\n          field.Name = \"reqSeq\";\n          field.Type = TType.I32;\n          field.ID = 1;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32(ReqSeq);\n          oprot.WriteFieldEnd();\n        }\n        if (Id != null && __isset.id) {\n          field.Name = \"id\";\n          field.Type = TType.String;\n          field.ID = 2;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(Id);\n          oprot.WriteFieldEnd();\n        }\n        oprot.WriteFieldStop();\n        oprot.WriteStructEnd();\n      }\n\n      public override string ToString() {\n        StringBuilder sb = new StringBuilder(\"blockContact_args(\");\n        sb.Append(\"ReqSeq: \");\n        sb.Append(ReqSeq);\n        sb.Append(\",Id: \");\n        sb.Append(Id);\n        sb.Append(\")\");\n        return sb.ToString();\n      }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class RedisProvider : IRedisProvider\n    {\n        public bool IsConnected { get { return Client.IsConnected; } }\n\n        public RedisClient Client { get; private set; }\n        \n        // private readonly Version _requiredMinimumVersion = new Version(2, 6);\n\n        private readonly IRedisProviderConfig _config;\n\n        private readonly ILogger _logger;\n\n        public RedisProvider(IPoolConfig poolConfig, IRedisProviderConfig config)\n        {\n            _logger = Log.ForContext<RedisProvider>().ForContext(\"Component\", poolConfig.Coin.Name);\n\n            _config = config;\n\n            Initialize();\n        }\n\n        private void Initialize()\n        {\n            try\n            {\n\n                Client = new RedisClient(_config.Host, _config.Port, _config.Password, \"version=2.6\");\n\n                // select the database\n                Client.Select(_config.DatabaseId);\n\n                /*\n                // check the version\n                var version = GetVersion();\n                if (version < _requiredMinimumVersion)\n                    throw new Exception(string.Format(\"You are using redis version {0}, minimum required version is 2.6\", version));\n                \n                _logger.Information(\"Redis storage initialized: {0:l}:{1}, v{2:l}.\", _config.Host, _config.Port, version);\n                */\n\n                _logger.Information(\"Redis storage initialized: {0:l}:{1}.\", _config.Host, _config.Port);\n            }\n            catch (Exception e)\n            {\n                _logger.Error(e,\"Redis storage initialization failed: {0:l}:{1}\", _config.Host, _config.Port);\n            }\n        }\n\n        /*\n        private Version GetVersion()\n        {\n            Version version = null;\n\n            try\n            {\n                var info = Client.Info(\"server\");\n\n                var parts = info.Split(new[] { Environment.NewLine }, StringSplitOptions.None);\n\n                foreach (var part in parts)\n                {\n                    var data = part.Split(':');\n\n                    if (data[0] != \"redis_version\")\n                        continue;\n\n                    version = new Version(data[1]);\n                }\n            }\n            catch (Exception e)\n            {\n                _logger.Error(\"An exception occured while getting version info: {0:l}\", e.Message);\n            }\n\n            return version;\n        }\n        */\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public partial class registerWithSnsId_args : TBase\n    {\n      private SnsIdType _snsIdType;\n      private string _snsAccessToken;\n      private string _region;\n      private string _udidHash;\n      private DeviceInfo _deviceInfo;\n      private string _mid;\n\n      /// <summary>\n      /// \n      /// <seealso cref=\"SnsIdType\"/>\n      /// </summary>\n      public SnsIdType SnsIdType\n      {\n        get\n        {\n          return _snsIdType;\n        }\n        set\n        {\n          __isset.snsIdType = true;\n          this._snsIdType = value;\n        }\n      }\n\n      public string SnsAccessToken\n      {\n        get\n        {\n          return _snsAccessToken;\n        }\n        set\n        {\n          __isset.snsAccessToken = true;\n          this._snsAccessToken = value;\n        }\n      }\n\n      public string Region\n      {\n        get\n        {\n          return _region;\n        }\n        set\n        {\n          __isset.region = true;\n          this._region = value;\n        }\n      }\n\n      public string UdidHash\n      {\n        get\n        {\n          return _udidHash;\n        }\n        set\n        {\n          __isset.udidHash = true;\n          this._udidHash = value;\n        }\n      }\n\n      public DeviceInfo DeviceInfo\n      {\n        get\n        {\n          return _deviceInfo;\n        }\n        set\n        {\n          __isset.deviceInfo = true;\n          this._deviceInfo = value;\n        }\n      }\n\n      public string Mid\n      {\n        get\n        {\n          return _mid;\n        }\n        set\n        {\n          __isset.mid = true;\n          this._mid = value;\n        }\n      }\n\n\n      public Isset __isset;\n      #if !SILVERLIGHT\n      [Serializable]\n      #endif\n      public struct Isset {\n        public bool snsIdType;\n        public bool snsAccessToken;\n        public bool region;\n        public bool udidHash;\n        public bool deviceInfo;\n        public bool mid;\n      }\n\n      public registerWithSnsId_args() {\n      }\n\n      public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 2:\n              if (field.Type == TType.I32) {\n                SnsIdType = (SnsIdType)iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 3:\n              if (field.Type == TType.String) {\n                SnsAccessToken = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 4:\n              if (field.Type == TType.String) {\n                Region = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 5:\n              if (field.Type == TType.String) {\n                UdidHash = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 6:\n              if (field.Type == TType.Struct) {\n                DeviceInfo = new DeviceInfo();\n                DeviceInfo.Read(iprot);\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 7:\n              if (field.Type == TType.String) {\n                Mid = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }\n\n      public void Write(TProtocol oprot) {\n        TStruct struc = new TStruct(\"registerWithSnsId_args\");\n        oprot.WriteStructBegin(struc);\n        TField field = new TField();\n        if (__isset.snsIdType) {\n          field.Name = \"snsIdType\";\n          field.Type = TType.I32;\n          field.ID = 2;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32((int)SnsIdType);\n          oprot.WriteFieldEnd();\n        }\n        if (SnsAccessToken != null && __isset.snsAccessToken) {\n          field.Name = \"snsAccessToken\";\n          field.Type = TType.String;\n          field.ID = 3;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(SnsAccessToken);\n          oprot.WriteFieldEnd();\n        }\n        if (Region != null && __isset.region) {\n          field.Name = \"region\";\n          field.Type = TType.String;\n          field.ID = 4;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(Region);\n          oprot.WriteFieldEnd();\n        }\n        if (UdidHash != null && __isset.udidHash) {\n          field.Name = \"udidHash\";\n          field.Type = TType.String;\n          field.ID = 5;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(UdidHash);\n          oprot.WriteFieldEnd();\n        }\n        if (DeviceInfo != null && __isset.deviceInfo) {\n          field.Name = \"deviceInfo\";\n          field.Type = TType.Struct;\n          field.ID = 6;\n          oprot.WriteFieldBegin(field);\n          DeviceInfo.Write(oprot);\n          oprot.WriteFieldEnd();\n        }\n        if (Mid != null && __isset.mid) {\n          field.Name = \"mid\";\n          field.Type = TType.String;\n          field.ID = 7;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(Mid);\n          oprot.WriteFieldEnd();\n        }\n        oprot.WriteFieldStop();\n        oprot.WriteStructEnd();\n      }\n\n      public override string ToString() {\n        StringBuilder sb = new StringBuilder(\"registerWithSnsId_args(\");\n        sb.Append(\"SnsIdType: \");\n        sb.Append(SnsIdType);\n        sb.Append(\",SnsAccessToken: \");\n        sb.Append(SnsAccessToken);\n        sb.Append(\",Region: \");\n        sb.Append(Region);\n        sb.Append(\",UdidHash: \");\n        sb.Append(UdidHash);\n        sb.Append(\",DeviceInfo: \");\n        sb.Append(DeviceInfo== null ? \"<null>\" : DeviceInfo.ToString());\n        sb.Append(\",Mid: \");\n        sb.Append(Mid);\n        sb.Append(\")\");\n        return sb.ToString();\n      }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "\n    internal abstract class AppInstaller<T> : IPackageInstaller where T : IApplication\n    {\n        private static ILogger logger = Logger.GetLogger(\"WinAppDriver\");\n\n        private T app;\n\n        private IDriverContext context;\n\n        private IUtils utils;\n\n        private bool prepared = false;\n\n        public AppInstaller(IDriverContext context, T app, IUtils utils)\n        {\n            this.context = context;\n            this.app = app;\n            this.utils = utils;\n        }\n\n        private string CurrentFile\n        {\n            get\n            {\n                return Path.Combine(this.context.GetAppWorkingDir(this.app), \"Current.txt\");\n            }\n        }\n\n        private string PackageDir\n        {\n            get\n            {\n                return Path.Combine(this.context.GetAppWorkingDir(this.app), \"InstallationPackage\");\n            }\n        }\n\n        private string PackageInfoFile\n        {\n            get\n            {\n                return Path.Combine(this.PackageDir, \"Info.txt\");\n            }\n        }\n\n        public bool IsBuildChanged()\n        {\n            string currentChecksum;\n            if (!this.TryReadCurrent(out currentChecksum))\n            {\n                logger.Info(\n                    \"Build changed, because current build (checksum) is unknown; app = [{0}]\",\n                    this.app.DriverAppID);\n                return true;\n            }\n\n            string cachedChecksum;\n            string package = this.PrepareInstallationPackage(out cachedChecksum);\n            bool changed = currentChecksum != cachedChecksum;\n\n            logger.Info(\n                \"Build changed? {0}; app = [{1}], current checksum = [{2}], cached checksum = [{3}]\",\n                changed, this.app.DriverAppID, currentChecksum, cachedChecksum);\n            return changed;\n        }\n\n        public void Install()\n        {\n            string checksum;\n            string package = this.PrepareInstallationPackage(out checksum);\n\n            this.InstallImpl(package, checksum);\n            this.UpdateCurrent(checksum);\n            System.Threading.Thread.Sleep(5000); // TODO avoid timing issue, esp. for store apps\n        }\n\n        protected internal abstract void InstallImpl(string package, string checksum);\n\n        protected internal void UpdateCurrent(string checksum)\n        {\n            string path = this.CurrentFile;\n            checksum = checksum.ToLower();\n            logger.Debug(\"Update current build (checksum); app = [{0}], checksum = [{1}]\", this.app.DriverAppID, checksum);\n\n            File.WriteAllText(path, checksum);\n        }\n\n        private bool TryReadCurrent(out string checksum)\n        {\n            string path = this.CurrentFile;\n            logger.Debug(\"Current file: [{0}]; app = [{1}]\", path, this.app.DriverAppID);\n\n            if (!File.Exists(path))\n            {\n                logger.Debug(\"Current file does not exist.\");\n                checksum = null;\n                return false;\n            }\n\n            checksum = File.ReadAllText(path);\n            logger.Debug(\"Current build (checksum): [{0}]\", checksum);\n            return true;\n        }\n\n        private string PrepareInstallationPackage(out string checksum)\n        {\n            string baseDir = this.PackageDir;\n            var caps = this.app.Capabilities;\n            logger.Debug(\n                \"Prepare installation package; app = [{0}], base dir = [{1}], caps.App = [{2}], caps.AppChecksum = [{3}]\",\n                this.app.DriverAppID, baseDir, caps.App, caps.AppChecksum);\n\n            string filename;\n            string fullpath;\n            bool cached = this.TryReadCachedPackageInfo(out filename, out checksum);\n            if (this.prepared && cached)\n            {\n                fullpath = Path.Combine(baseDir, filename);\n                logger.Debug(\n                    \"Alread prepared; path = [{0}], checksum = [{1}]\", fullpath, checksum);\n                return fullpath;\n            }\n\n            // Quick comparison\n            if (caps.AppChecksum != null && cached)\n            {\n                logger.Debug(\"Checksum matching (case-insensitive); caps.AppChecksum = [{0}], cached checksum = [{1}]\", caps.AppChecksum, checksum);\n                fullpath = Path.Combine(baseDir, filename);\n                if (checksum == caps.AppChecksum.ToLower())\n                {\n                    logger.Info(\n                        \"The cached installation package of app '{0}' ({1}) can be reused, because of matched checksums.\",\n                        this.app.DriverAppID, fullpath);\n\n                    this.prepared = true;\n                    return fullpath;\n                }\n                else\n                {\n                    logger.Info(\n                        \"The cached installation package of app '{0}' ({1}) can not be reused, because of unmatched checksums.\",\n                        this.app.DriverAppID, fullpath);\n                }\n            }\n\n            // Download the installation package\n            logger.Info(\n                \"Start downloading installation pacakge of app '{0}' from {1}.\",\n                this.app.DriverAppID, caps.App);\n            string downloaded = this.utils.GetAppFileFromWeb(caps.App, caps.AppChecksum);\n            filename = Path.GetFileName(downloaded); // TODO Preserve original filename, and replace invalid characters\n            checksum = caps.AppChecksum != null ? caps.AppChecksum.ToLower() : this.utils.GetFileMD5(downloaded);\n            logger.Info(\"Installation package downloaded: {0} ({1}).\", downloaded, checksum);\n\n            // Discard cached installation package\n            if (Directory.Exists(baseDir))\n            {\n                Directory.Delete(baseDir, true);\n            }\n\n            Directory.CreateDirectory(baseDir);\n\n            // Update cached package information.\n            fullpath = Path.Combine(baseDir, filename);\n            logger.Info(\"Cache the installation package: {0}.\", fullpath);\n            File.Move(downloaded, fullpath);\n            this.WriteCachedPackageInfo(filename, checksum);\n\n            this.prepared = true;\n            return fullpath;\n        }\n\n        private bool TryReadCachedPackageInfo(out string filename, out string checksum)\n        {\n            string path = this.PackageInfoFile;\n            logger.Debug(\"Cached package info file: [{0}]; app = [{1}]\", path, this.app.DriverAppID);\n            if (!File.Exists(path))\n            {\n                logger.Debug(\"Cached package info file does not exist.\");\n                filename = null;\n                checksum = null;\n                return false;\n            }\n\n            string[] lines = File.ReadAllLines(path, Encoding.UTF8);\n            filename = lines[0];\n            checksum = lines[1];\n\n            logger.Debug(\"Cached package info: filename = [{0}], checksum = [{1}]\", filename, checksum);\n            return true;\n        }\n\n        private void WriteCachedPackageInfo(string filename, string checksum)\n        {\n            string path = this.PackageInfoFile;\n            string[] lines = { filename, checksum };\n            logger.Debug(\n                \"Write cached package info; app = [{0}], path = [{1}], filename = [{2}], checksum = [{3}]\",\n                this.app.DriverAppID, path, filename, checksum);\n\n            File.WriteAllLines(path, lines, Encoding.UTF8);\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class PullToRefreshScrollViewRenderer : ScrollViewRenderer\n    {\n        private FormsUIRefreshControl _refreshControl;\n\n        protected override void OnElementChanged(VisualElementChangedEventArgs e)\n        {\n            base.OnElementChanged(e);\n\n            if (_refreshControl != null)\n                return;\n\n            var pullToRefreshScrollView = (PullToRefreshScrollView)Element;\n\n\t\t\tif (pullToRefreshScrollView != null)\n\t\t\t{\n\t            pullToRefreshScrollView.PropertyChanged += OnElementPropertyChanged;\n\n\t            _refreshControl = new FormsUIRefreshControl\n\t            {\n\t                RefreshCommand = pullToRefreshScrollView.RefreshCommand,\n\t                Message = pullToRefreshScrollView.Message\n\t            };\n\n\t            AlwaysBounceVertical = true;\n\n\t            AddSubview(_refreshControl);\n\t\t\t}\n        }\n\n        private void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e)\n        {\n            var pullToRefreshScrollView = Element as PullToRefreshScrollView;\n            if (pullToRefreshScrollView == null)\n                return;\n\n            if (e.PropertyName == PullToRefreshScrollView.IsRefreshingProperty.PropertyName)\n                _refreshControl.IsRefreshing = pullToRefreshScrollView.IsRefreshing;\n\n            if (e.PropertyName == PullToRefreshScrollView.MessageProperty.PropertyName)\n                _refreshControl.Message = pullToRefreshScrollView.Message;\n\n            if (e.PropertyName == PullToRefreshScrollView.RefreshCommandProperty.PropertyName)\n                _refreshControl.RefreshCommand = pullToRefreshScrollView.RefreshCommand;\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Vector clock\n    /// </summary>\n    public class VectorClock : IEquatable<VectorClock>\n    {\n        /// <summary>\n        /// The result of comparing two times\n        ///     either t1 is before t2, \n        ///     t1 is after t2, \n        ///     or t1 happens concurrently to t2\n        /// </summary>\n        public enum Occured\n        {\n            /// <summary>\n            /// Event occurred before\n            /// </summary>\n            Before = -1,\n\n            /// <summary>\n            /// Event occurred after\n            /// </summary>\n            After = 1,\n\n            /// <summary>\n            /// Event occurred independantly\n            /// </summary>\n            Concurrently = 0\n        }\n        private const int MaxVersions = Int16.MaxValue;\n        public readonly Lst<ClockEntry> Versions;\n        public static readonly VectorClock Empty = new VectorClock();\n\n        /// <summary>\n        /// Ctor\n        /// </summary>\n        VectorClock() : this(List.empty<ClockEntry>())\n        {\n        }\n\n        /// <summary>\n        /// Ctor\n        /// </summary>\n        VectorClock(Lst<ClockEntry> versions)\n        {\n            Versions = versions;\n        }\n\n        /// <summary>\n        /// Increment the version info associated with the given node\n        /// </summary>\n        /// <param name=\"nodeId\">Node to increment</param>\n        public VectorClock Incr(int nodeId)\n        {\n            // stop on the index greater or equal to the node\n            int index = 0;\n            bool found = false;\n            var versions = Versions;\n\n            foreach(var version in versions)\n            {\n                if (version.NodeId == nodeId)\n                {\n                    found = true;\n                    break;\n                }\n                else if (version.NodeId > nodeId)\n                {\n                    break;\n                }\n                index++;\n            }\n\n            if (found)\n            {\n                versions = versions.SetItem(index, versions[index].Incr());\n            }\n            else if (index < versions.Count - 1)\n            {\n                versions = versions.Insert(index, new ClockEntry(nodeId, 1));\n            }\n            else\n            {\n                // we don't already have a version for this, so add it\n                if (versions.Count > MaxVersions) throw new ArgumentOutOfRangeException(\"Vector clock is full\");\n                versions.Add(new ClockEntry(nodeId, 1));\n            }\n            return new VectorClock(versions);\n        }\n\n        /// <summary>\n        /// ToString\n        /// </summary>\n        public override string ToString()\n        {\n            var builder = new StringBuilder();\n            builder.Append(\"version(\");\n\n            if (Versions.Count > 0)\n            {\n                for (int i = 0; i < Versions.Count - 1; i++)\n                {\n                    builder.Append(Versions[i]);\n                    builder.Append(\", \");\n                }\n                builder.Append(Versions[Versions.Count - 1]);\n            }\n            builder.Append(\")\");\n            return builder.ToString();\n        }\n\n        /// <summary>\n        /// Merge clocks\n        /// </summary>\n        public VectorClock Merge(VectorClock clock)\n        {\n            int i = 0;\n            int j = 0;\n\n            var versions = Versions.ToArray();\n            var clockVersions = clock.Versions.ToArray();\n            var newClockVersions = List.empty<ClockEntry>();\n\n            while (i < versions.Count && j < clockVersions.Count)\n            {\n                var v1 = versions[i];\n                var v2 = clockVersions[j];\n\n                if (v1.NodeId == v2.NodeId)\n                {\n                    var nc = new ClockEntry(v1.NodeId, (int)Math.Max(v1.Version, v2.Version));\n                    newClockVersions = newClockVersions.Add(nc);\n\n                    i++;\n                    j++;\n                }\n                else if (v1.NodeId < v2.NodeId)\n                {\n                    newClockVersions = newClockVersions.Add(v1);\n                    i++;\n                }\n                else\n                {\n                    newClockVersions = newClockVersions.Add(v2);\n                    j++;\n                }\n            }\n\n            // Okay now there may be leftovers on one or the other list remaining\n            for (int k = i; k < versions.Count; k++)\n            {\n                newClockVersions = newClockVersions.Add(versions[k]);\n            }\n            for (int k = j; k < clockVersions.Count; k++)\n            {\n                newClockVersions = newClockVersions.Add(clockVersions[k]);\n            }\n            return new VectorClock(newClockVersions);\n        }\n\n        /// <summary>\n        /// <para>\n        /// Is this reflexive, antisymetic, and transitive? Compare two VectorClocks,\n        /// the outcomes will be one of the following: \n        /// </para>\n        /// <para>\n        ///     * Clock 1 is /before/ clock 2\n        ///         if there exists an i such that c1(i) &lt;= c(2) and there does not \n        ///         exist a j such that c1(j) > c2(j). \n        /// </para>\n        /// <para>\n        ///     * Clock 1 is /concurrent/ to clock 2 if there exists an i, j such that \n        ///         c1(i) &lt; c2(i) and c1(j) > c2(j)\n        /// </para>\n        /// <para>\n        ///     * Clock 1 is /after/ clock 2  otherwise\n        /// </para>\n        /// </summary>\n        /// <param name=\"v1\">The first VectorClock</param>\n        /// <param name=\"v2\">The second VectorClock</param>\n        /// <returns>Whether the change occured before, after or concurrently</returns>\n        public static Occured Compare(VectorClock v1, VectorClock v2)\n        {\n            if (v1 == null || v2 == null)\n                throw new ArgumentException(\"Can't compare null vector clocks!\");\n\n            // We do two checks: v1 <= v2 and v2 <= v1 if both are true then\n            bool v1Bigger = false;\n            bool v2Bigger = false;\n            int p1 = 0;\n            int p2 = 0;\n\n            while (p1 < v1.Versions.Count && p2 < v2.Versions.Count)\n            {\n                ClockEntry ver1 = v1.Versions[p1];\n                ClockEntry ver2 = v2.Versions[p2];\n\n                if (ver1.NodeId == ver2.NodeId)\n                {\n                    if (ver1.Version > ver2.Version)\n                        v1Bigger = true;\n                    else if (ver2.Version > ver1.Version)\n                        v2Bigger = true;\n                    p1++;\n                    p2++;\n                }\n                else if (ver1.NodeId > ver2.NodeId)\n                {\n                    // since ver1 is bigger that means it is missing a version that ver2 has\n                    v2Bigger = true;\n                    p2++;\n                }\n                else\n                {\n                    // this means ver2 is bigger which means it is missing a version ver1 has\n                    v1Bigger = true;\n                    p1++;\n                }\n            }\n\n            // Check for left overs\n            if (p1 < v1.Versions.Count)\n            {\n                v1Bigger = true;\n            }\n            else if (p2 < v2.Versions.Count)\n            {\n                v2Bigger = true;\n            }\n\n            // This is the case where they are equal, return BEFORE arbitrarily\n            if (!v1Bigger && !v2Bigger)\n            {\n                return Occured.Before;\n            }\n            // This is the case where v1 is a successor clock to v2\n            else if (v1Bigger && !v2Bigger)\n            {\n                return Occured.After;\n            }\n            // This is the case where v2 is a successor clock to v1\n            else if (!v1Bigger && v2Bigger)\n            {\n                return Occured.Before;\n            }\n            // This is the case where both clocks are parallel to one another\n            else\n            {\n                return Occured.Concurrently;\n            }\n        }\n\n        /// <summary>\n        /// Equality test\n        /// </summary>\n        /// <param name=\"obj\"></param>\n        /// <returns></returns>\n        public override bool Equals(object obj) =>\n            obj is VectorClock\n                ? Equals((VectorClock)obj)\n                : false;\n\n        public bool Equals(VectorClock rhs)\n        {\n            if (ReferenceEquals(this, rhs)) return true;\n            if (ReferenceEquals(rhs, null)) return false;\n            if (Versions.Count != rhs.Versions.Count) return false;\n            if (Versions.Zip(rhs.Versions, (x, y) => x == y).Exists(x => !x)) return false;\n            return true;\n        }\n\n        public override int GetHashCode() =>\n            Versions.Fold(13, (s, x) => s * Math.Max(1, x.GetHashCode()));\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\t\t#endregion\n\n\t\t#region -- class LuaTableHashValueCollection --------------------------------------\n\n\t\t///////////////////////////////////////////////////////////////////////////////\n\t\t/// <summary></summary>\n\t\tpublic class LuaTableHashValueCollection : ICollection<object>\n\t\t{\n\t\t\tprivate LuaTable t;\n\n\t\t\tinternal LuaTableHashValueCollection(LuaTable t)\n\t\t\t{\n\t\t\t\tthis.t = t;\n\t\t\t} // ctor\n\n\t\t\t/// <summary></summary>\n\t\t\t/// <param name=\"value\"></param>\n\t\t\t/// <returns></returns>\n\t\t\tpublic bool Contains(object value)\n\t\t\t{\n\t\t\t\tfor (var i = 0; i < t.arrayList.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (t.arrayList[i] != null && comparerObject.Equals(t.arrayList[i], value))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = hiddenMemberCount; i < t.classDefinition.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tif (comparerObject.Equals(t.GetClassMemberValue(i, t.entries[i].key, true), value))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tfor (var i = t.classDefinition.Count; i < t.entries.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (t.entries[i].hashCode != -1 && comparerObject.Equals(t.entries[i].value, value))\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\treturn false;\n\t\t\t} // func Contains\n\n\t\t\t/// <summary></summary>\n\t\t\t/// <param name=\"array\"></param>\n\t\t\t/// <param name=\"arrayIndex\"></param>\n\t\t\tpublic void CopyTo(object[] array, int arrayIndex)\n\t\t\t{\n\t\t\t\tif (arrayIndex < 0 || arrayIndex + Count > array.Length)\n\t\t\t\t\tthrow new ArgumentOutOfRangeException();\n\n\t\t\t\tfor (var i = 0; i < t.arrayList.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (t.arrayList[i] != null)\n\t\t\t\t\t\tarray[arrayIndex++] = t.arrayList[i];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = hiddenMemberCount; i < t.classDefinition.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tarray[arrayIndex++] = t.GetClassMemberValue(i, t.entries[i].key, true);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = t.classDefinition.Count; i < t.entries.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (t.entries[i].hashCode != -1)\n\t\t\t\t\t\tarray[arrayIndex++] = t.entries[i].value;\n\t\t\t\t}\n\t\t\t} // proc CopyTo\n\n\t\t\t/// <summary></summary>\n\t\t\t/// <returns></returns>\n\t\t\tpublic IEnumerator<object> GetEnumerator()\n\t\t\t{\n\t\t\t\tvar version = t.version;\n\n\t\t\t\tfor (var i = 0; i < t.arrayList.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (version != t.version)\n\t\t\t\t\t\tthrow new InvalidOperationException(\"table changed\");\n\n\t\t\t\t\tif (t.arrayList[i] != null)\n\t\t\t\t\t\tyield return t.arrayList[i];\n\t\t\t\t}\n\n\t\t\t\tfor (var i = hiddenMemberCount; i < t.classDefinition.Count; i++)\n\t\t\t\t{\n\t\t\t\t\tif (version != t.version)\n\t\t\t\t\t\tthrow new InvalidOperationException(\"table changed\");\n\n\t\t\t\t\tyield return t.GetClassMemberValue(i, t.entries[i].key, true);\n\t\t\t\t}\n\n\t\t\t\tfor (var i = t.classDefinition.Count; i < t.entries.Length; i++)\n\t\t\t\t{\n\t\t\t\t\tif (version != t.version)\n\t\t\t\t\t\tthrow new InvalidOperationException(\"table changed\");\n\n\t\t\t\t\tif (t.entries[i].hashCode != -1)\n\t\t\t\t\t\tyield return t.entries[i].value;\n\t\t\t\t}\n\t\t\t} // func GetEnumerator\n\n\t\t\tIEnumerator IEnumerable.GetEnumerator()\n\t\t\t\t=> GetEnumerator();\n\n\t\t\tvoid ICollection<object>.Add(object item) { throw new NotSupportedException(); }\n\t\t\tbool ICollection<object>.Remove(object item) { throw new NotSupportedException(); }\n\t\t\tvoid ICollection<object>.Clear() { throw new NotSupportedException(); }\n\n\t\t\t/// <summary></summary>\n\t\t\tpublic int Count => t.count - hiddenMemberCount;\n\t\t\t/// <summary>Always true</summary>\n\t\t\tpublic bool IsReadOnly => true;\n\t\t} // class LuaTableHashValueCollection\n", "label": "FeatureEnvy"}
{"text": "    internal class ClusterFit : ColourFit {\n        const int MaxIterations = 8;\n\n        #region Fields\n        private int _IterationCount;\n        private Vector3 _Principle;\n        private byte[] _Order = new byte[16 * MaxIterations];\n        private Vector4[] _PointsWeight = new Vector4[16];\n        private Vector4 _XSumWSum;\n        private Vector4 _Metric;\n        private Vector4 _BestError;\n        #endregion\n\n        #region Constructor\n        protected ClusterFit(ColourSet colours, SquishOptions flags) : base(colours, flags) {\n            // Set the iteration count.\n            this._IterationCount = flags.HasFlag(SquishOptions.ColourIterativeClusterFit) ? MaxIterations : 1;\n\n            // Initialise the best error.\n            this._BestError = new Vector4(float.MaxValue);\n\n            // Initialize the metric\n            var perceptual = flags.HasFlag(SquishOptions.ColourMetricPerceptual);\n            if (perceptual)\n                this._Metric = new Vector4(0.2126f, 0.7152f, 0.0722f, 0.0f);\n            else\n                this._Metric = new Vector4(1.0f);\n\n            // Get the covariance matrix.\n            var covariance = Sym3x3.ComputeWeightedCovariance(colours.Count, colours.Points, colours.Weights);\n\n            // Compute the principle component\n            this._Principle = Sym3x3.ComputePrincipledComponent(covariance);\n        }\n        #endregion\n\n        #region Methods\n        protected bool ConstructOrdering(Vector3 axis, int iteration) {\n            // Build the list of dot products.\n            var dps = new float[16];\n            var ordOff = 16 * iteration;\n            for (int i = 0; i < _Colours.Count; ++i) {\n                dps[i] = Vector3.Dot(_Colours.Points[i], axis);\n                this._Order[ordOff + i] = (byte)i;\n            }\n\n            // Stable sort using them.\n            for (int i = 0; i < _Colours.Count; ++i) {\n                for (int j = i; j > 0 && dps[j] < dps[j - 1]; --j) {\n                    var _dps = dps[j];\n                    var _order = _Order[ordOff + j];\n\n                    dps[j] = dps[j - 1];\n                    dps[j - 1] = _dps;\n                    _Order[ordOff + j] = _Order[ordOff + j - 1];\n                    _Order[ordOff + j - 1] = _order;\n                }\n            }\n\n            // Check this ordering is unique\n            for (int it = 0; it < iteration; ++it) {\n                var prevOff = 16 * it;\n                var same = true;\n                for (int i = 0; i < _Colours.Count; ++i) {\n                    if (_Order[ordOff + i] != _Order[prevOff + i]) {\n                        same = false;\n                        break;\n                    }\n                }\n                if (same)\n                    return false;\n            }\n\n            // Copy the ordering and weight all the points\n            this._XSumWSum = new Vector4(0f);\n            for (int i = 0; i < _Colours.Count; ++i) {\n                var j = _Order[ordOff + i];\n                var p = new Vector4(_Colours.Points[j].X, _Colours.Points[j].Y, _Colours.Points[j].Z, 1f);\n                var w = new Vector4(_Colours.Weights[j]);\n                var x = p * w;\n                this._PointsWeight[i] = x;\n                this._XSumWSum += x;\n            }\n            return true;\n        }\n\n        protected override void Compress3(byte[] block) {\n           // Declare variables\n            var count = _Colours.Count;\n            var zero = new Vector4(0f);\n            var half = new Vector4(.5f);\n            var one = new Vector4(1f);\n            var two = new Vector4(2f);\n            var half_half2 = new Vector4(.5f, .5f, .5f, .25f);\n            var grid = new Vector4(31f, 63f, 31f, 0f);\n            var gridrcp = new Vector4(1f / 31f, 1f / 63f, 1f / 31f, 0f);\n\n            // Prepare the ordering using the principle axis.\n            ConstructOrdering(_Principle, 0);\n\n            // Check all possible clusters and iterate on the total order.\n            var bestStart = zero;\n            var bestEnd = zero;\n            var bestError = this._BestError;\n            var bestIndices = new byte[16];\n            var bestIteration = 0;\n            int besti = 0, bestj = 0;\n\n            // Loop over iterations (we avoid the case that all points in first or last cluster)\n            for (int iterationIndex = 0; ; ) {\n                throw new NotImplementedException();\n            }\n        }\n        protected override void Compress4(byte[] block) {\n            throw new NotImplementedException();\n        }\n        #endregion\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class TilesetLoader\n    {\n        private static readonly Logger logger = LogManager.GetCurrentClassLogger();\n\n        private Tileset tileset;\n\n        public TilesetLoader (ref Tileset tilesetToLoad)\n        {\n            tileset = tilesetToLoad;\n        }\n\n        public Result Load(string path)\n        {\n            var returnResult = new Result(\"Loading tileset from '{0}'\".Format2(path), false);\n            logger.Info(\"Loading tileset from '{0}'\".Format2(path));\n\n            tileset.Directory = path;\n\n            Bitmap bitmap = null;\n            var SplitPath = new sSplitPath(path);\n            var slashPath = PathUtil.EndWithPathSeperator(path);\n            var result = new SimpleResult();\n\n            if ( SplitPath.FileTitle != \"\" )\n            {\n                tileset.Name = SplitPath.FileTitle;\n            }\n            else if ( SplitPath.PartCount >= 2 )\n            {\n                tileset.Name = SplitPath.Parts[SplitPath.PartCount - 2];\n            }\n\n            var ttpFileName = Path.ChangeExtension(tileset.Name, \".ttp\");\n\n            result = loadTileType(Path.Combine(slashPath, ttpFileName));\n\n            if ( !result.Success )\n            {\n                returnResult.ProblemAdd(\"Loading tile types: \" + result.Problem);\n                return returnResult;\n            }\n\n            var redTotal = 0;\n            var greenTotal = 0;\n            var blueTotal = 0;\n            var tileNum = 0;\n            var strTile = \"\";\n            var AverageColour = new float[4];\n            var x = 0;\n            var y = 0;\n            var Pixel = new Color();\n\n            var graphicPath = \"\";\n\n            //tile count has been set by the ttp file\n\n            for ( tileNum = 0; tileNum < tileset.Tiles.Count; tileNum++ )\n            {\n                var tile = tileset.Tiles[tileNum];\n\n                strTile = \"tile-\" + App.MinDigits(tileNum, 2) + \".png\";\n\n                //-------- 128 --------\n\n                var tileDir = Path.Combine(tileset.Name + \"-128\", strTile);\n                graphicPath = Path.Combine(slashPath, tileDir);\n\n\n                result = BitmapUtil.LoadBitmap(graphicPath, ref bitmap);\n                if ( !result.Success )\n                {\n                    tileset.Tiles.RemoveRange (tileNum, tileset.Tiles.Count - tileNum);\n                    //ignore and exit, since not all tile types have a corresponding tile graphic\n                    return returnResult;\n                }\n\n                if ( bitmap.Width != 128 | bitmap.Height != 128 )\n                {\n                    returnResult.WarningAdd (string.Format (\"Tile graphic {0} from tileset {1} is not 128x128.\", graphicPath, tileset.Name));\n                    return returnResult;\n                }\n\n                if ( App.SettingsManager.Mipmaps )\n                {\n                    tile.GlTextureNum = BitmapUtil.CreateGLTexture (bitmap, 0, 0,\n                                                                              TextureMagFilter.Nearest, \n                                                                              TextureMinFilter.LinearMipmapLinear);\n                }\n                else\n                {\n                    tile.GlTextureNum = BitmapUtil.CreateGLTexture (bitmap, 0, 0, \n                                                                              TextureMagFilter.Nearest, \n                                                                              TextureMinFilter.Nearest);\n                }\n\n                if ( App.SettingsManager.Mipmaps )\n                {\n                    if ( App.SettingsManager.MipmapsHardware )\n                    {\n                        GL.Enable(EnableCap.Texture2D);\n                        GL.GenerateMipmap(GenerateMipmapTarget.Texture2D);\n                        GL.Disable(EnableCap.Texture2D);\n                    }\n                    else\n                    {\n                        var MipmapResult = default(Result);\n                        MipmapResult = generateMipMaps(slashPath, strTile, \n                                                       tileset.Tiles[tileNum].GlTextureNum, tileNum);\n                        returnResult.Add(MipmapResult);\n                        if ( MipmapResult.HasProblems )\n                        {\n                            return returnResult;\n                        }\n                    }\n                    GL.GetTexImage(TextureTarget.Texture2D, 7, PixelFormat.Rgba, PixelType.Float, AverageColour);\n                    tile.AverageColour.Red = AverageColour[0];\n                    tile.AverageColour.Green = AverageColour[1];\n                    tile.AverageColour.Blue = AverageColour[2];\n                }\n                else\n                {\n                    redTotal = 0;\n                    greenTotal = 0;\n                    blueTotal = 0;\n                    for ( y = 0; y <= bitmap.Height - 1; y++ )\n                    {\n                        for ( x = 0; x <= bitmap.Width - 1; x++ )\n                        {\n                            Pixel = bitmap.GetPixel(x, y);\n                            redTotal += Pixel.R;\n                            greenTotal += Pixel.G;\n                            blueTotal += Pixel.B;\n                        }\n                    }\n                    tile.AverageColour.Red = (float)(redTotal / 4177920.0D);\n                    tile.AverageColour.Green = (float)(greenTotal / 4177920.0D);\n                    tile.AverageColour.Blue = (float)(blueTotal / 4177920.0D);\n                }\n\n                tileset.Tiles[tileNum] = tile;\n\n                bitmap.Dispose();\n            }\n\n            return returnResult;\n        }\n\n        private SimpleResult loadTileType(string path)\n        {\n            var returnResult = new SimpleResult();\n\n            try\n            {\n                using (var file = new BinaryReader(new FileStream(path, FileMode.Open))) {\n                    returnResult = readTileType(file);\n                }\n            }\n            catch ( Exception ex )\n            {\n                returnResult.Problem = ex.Message;\n                return returnResult;\n            }\n            return returnResult;\n        }\n\n        private SimpleResult readTileType(BinaryReader file)\n        {\n            var returnResult = new SimpleResult();\n            returnResult.Success = false;\n            returnResult.Problem = \"\";\n\n            UInt32 uintTemp = 0;\n            var i = 0;\n            UInt16 ushortTemp = 0;\n            var strTemp = \"\";\n\n            try\n            {\n                strTemp = IOUtil.ReadOldTextOfLength(file, 4);\n                if ( strTemp != \"ttyp\" )\n                {\n                    returnResult.Problem = \"Bad identifier.\";\n                    return returnResult;\n                }\n\n                uintTemp = file.ReadUInt32();\n                if ( !(uintTemp == 8U) )\n                {\n                    returnResult.Problem = \"Unknown version.\";\n                    return returnResult;\n                }\n\n                uintTemp = file.ReadUInt32();\n                tileset.TileCount = Convert.ToInt32(uintTemp);\n                // tileset.Tiles = new Tile[tileset.TileCount];\n\n                for ( i = 0; i < Math.Min((Int32)uintTemp,tileset.TileCount); i++ )\n                {\n                    var tile = new Tile();\n                    ushortTemp = file.ReadUInt16();\n                    if ( ushortTemp > App.TileTypes.Count )\n                    {\n                        returnResult.Problem = \"Unknown tile type.\";\n                        return returnResult;\n                    }\n                    tile.DefaultType = (byte)ushortTemp;\n                    tileset.Tiles.Add(tile);\n                }\n            }\n            catch ( Exception ex )\n            {\n                returnResult.Problem = ex.Message;\n                return returnResult;\n            }\n\n            returnResult.Success = true;\n            return returnResult;\n        }\n\n        private Result generateMipMaps(string slashPath, string strTile, int textureNum, int tileNum)\n        {\n            var returnResult = new Result(\"Generating mipmaps\", false);\n            logger.Info(\"Generating mipmaps\");\n            var graphicPath = \"\";\n            var pixX = 0;\n            var pixY = 0;\n            Color pixelColorA;\n            Color pixelColorB;\n            Color pixelColorC;\n            Color pixelColorD;\n            var x1 = 0;\n            var y1 = 0;\n            var x2 = 0;\n            var y2 = 0;\n            var red = 0;\n            var green = 0;\n            var blue = 0;\n            Bitmap bitmap = null;\n\n            //-------- 64 --------\n\n            graphicPath = string.Format (\"{0}{1}-64{2}{3}\", slashPath, tileset.Name, Path.DirectorySeparatorChar, strTile);\n\n            var result = BitmapUtil.LoadBitmap(graphicPath, ref bitmap);\n            if ( !result.Success )\n            {\n                returnResult.WarningAdd(\"Unable to load tile graphic: \" + result.Problem);\n                return returnResult;\n            }\n\n            if ( bitmap.Width != 64 | bitmap.Height != 64 )\n            {\n                returnResult.WarningAdd (string.Format (\"Tile graphic {0} from tileset {1} is not 64x64.\", graphicPath, tileset.Name));\n                return returnResult;\n            }\n\n            BitmapUtil.CreateGLTexture (bitmap, 1, textureNum);\n\n            //-------- 32 --------\n\n            graphicPath = string.Format (\"{0}{1}-32{2}{3}\", slashPath, tileset.Name, Path.DirectorySeparatorChar, strTile);\n\n            result = BitmapUtil.LoadBitmap(graphicPath, ref bitmap);\n            if ( !result.Success )\n            {\n                returnResult.WarningAdd (string.Format (\"Unable to load tile graphic: {0}\", result.Problem));\n                return returnResult;\n            }\n\n            if ( bitmap.Width != 32 | bitmap.Height != 32 )\n            {\n                returnResult.WarningAdd (string.Format (\"Tile graphic {0} from tileset {1} is not 32x32.\", graphicPath, tileset.Name));\n                return returnResult;\n            }\n\n            BitmapUtil.CreateGLTexture (bitmap, 2, textureNum);\n\n            //-------- 16 --------\n\n            graphicPath = string.Format (\"{0}{1}-16{2}{3}\", slashPath, tileset.Name, Path.DirectorySeparatorChar, strTile);\n\n            result = BitmapUtil.LoadBitmap(graphicPath, ref bitmap);\n            if ( !result.Success )\n            {\n                returnResult.WarningAdd(\"Unable to load tile graphic: \" + result.Problem);\n                return returnResult;\n            }\n\n            if ( bitmap.Width != 16 | bitmap.Height != 16 )\n            {\n                returnResult.WarningAdd (string.Format (\"Tile graphic {0} from tileset {1} is not 16x16.\", graphicPath, tileset.Name));\n                return returnResult;\n            }\n\n            BitmapUtil.CreateGLTexture (bitmap, 3, textureNum);\n\n            //-------- 8 --------\n\n            var bitmap8 = new Bitmap(8, 8, System.Drawing.Imaging.PixelFormat.Format32bppArgb);\n            for ( pixY = 0; pixY <= 7; pixY++ )\n            {\n                y1 = pixY * 2;\n                y2 = y1 + 1;\n                for ( pixX = 0; pixX <= 7; pixX++ )\n                {\n                    x1 = pixX * 2;\n                    x2 = x1 + 1;\n                    pixelColorA = bitmap.GetPixel(x1, y1);\n                    pixelColorB = bitmap.GetPixel(x2, y1);\n                    pixelColorC = bitmap.GetPixel(x1, y2);\n                    pixelColorD = bitmap.GetPixel(x2, y2);\n                    red = Convert.ToInt32(((pixelColorA.R) + pixelColorB.R + pixelColorC.R + pixelColorD.R) / 4.0F);\n                    green = Convert.ToInt32(((pixelColorA.G) + pixelColorB.G + pixelColorC.G + pixelColorD.G) / 4.0F);\n                    blue = Convert.ToInt32(((pixelColorA.B) + pixelColorB.B + pixelColorC.B + pixelColorD.B) / 4.0F);\n                    bitmap8.SetPixel(pixX, pixY, ColorTranslator.FromOle(ColorUtil.OsRgb(red, green, blue)));\n                }\n            }\n\n            BitmapUtil.CreateGLTexture (bitmap8, 4, textureNum);\n\n            //-------- 4 --------\n\n            bitmap = bitmap8;\n            var bitmap4 = new Bitmap(4, 4, System.Drawing.Imaging.PixelFormat.Format32bppArgb);\n            for ( pixY = 0; pixY <= 3; pixY++ )\n            {\n                y1 = pixY * 2;\n                y2 = y1 + 1;\n                for ( pixX = 0; pixX <= 3; pixX++ )\n                {\n                    x1 = pixX * 2;\n                    x2 = x1 + 1;\n                    pixelColorA = bitmap.GetPixel(x1, y1);\n                    pixelColorB = bitmap.GetPixel(x2, y1);\n                    pixelColorC = bitmap.GetPixel(x1, y2);\n                    pixelColorD = bitmap.GetPixel(x2, y2);\n                    red = Convert.ToInt32(((pixelColorA.R) + pixelColorB.R + pixelColorC.R + pixelColorD.R) / 4.0F);\n                    green = Convert.ToInt32(((pixelColorA.G) + pixelColorB.G + pixelColorC.G + pixelColorD.G) / 4.0F);\n                    blue = Convert.ToInt32(((pixelColorA.B) + pixelColorB.B + pixelColorC.B + pixelColorD.B) / 4.0F);\n                    bitmap4.SetPixel(pixX, pixY, ColorTranslator.FromOle(ColorUtil.OsRgb(red, green, blue)));\n                }\n            }\n\n            BitmapUtil.CreateGLTexture (bitmap4, 5, textureNum);\n\n            //-------- 2 --------\n\n            bitmap = bitmap4;\n            var bitmap2 = new Bitmap(2, 2, System.Drawing.Imaging.PixelFormat.Format32bppArgb);\n            for ( pixY = 0; pixY <= 1; pixY++ )\n            {\n                y1 = pixY * 2;\n                y2 = y1 + 1;\n                for ( pixX = 0; pixX <= 1; pixX++ )\n                {\n                    x1 = pixX * 2;\n                    x2 = x1 + 1;\n                    pixelColorA = bitmap.GetPixel(x1, y1);\n                    pixelColorB = bitmap.GetPixel(x2, y1);\n                    pixelColorC = bitmap.GetPixel(x1, y2);\n                    pixelColorD = bitmap.GetPixel(x2, y2);\n                    red = Convert.ToInt32(((pixelColorA.R) + pixelColorB.R + pixelColorC.R + pixelColorD.R) / 4.0F);\n                    green = Convert.ToInt32(((pixelColorA.G) + pixelColorB.G + pixelColorC.G + pixelColorD.G) / 4.0F);\n                    blue = Convert.ToInt32(((pixelColorA.B) + pixelColorB.B + pixelColorC.B + pixelColorD.B) / 4.0F);\n                    bitmap2.SetPixel(pixX, pixY, ColorTranslator.FromOle(ColorUtil.OsRgb(red, green, blue)));\n                }\n            }\n\n            BitmapUtil.CreateGLTexture (bitmap2, 6, textureNum);\n\n            //-------- 1 --------\n\n            bitmap = bitmap2;\n            var bitmap1 = new Bitmap(1, 1, System.Drawing.Imaging.PixelFormat.Format32bppArgb);\n            pixX = 0;\n            pixY = 0;\n            y1 = pixY * 2;\n            y2 = y1 + 1;\n            x1 = pixX * 2;\n            x2 = x1 + 1;\n            pixelColorA = bitmap.GetPixel(x1, y1);\n            pixelColorB = bitmap.GetPixel(x2, y1);\n            pixelColorC = bitmap.GetPixel(x1, y2);\n            pixelColorD = bitmap.GetPixel(x2, y2);\n            red = Convert.ToInt32(((pixelColorA.R) + pixelColorB.R + pixelColorC.R + pixelColorD.R) / 4.0F);\n            green = Convert.ToInt32(((pixelColorA.G) + pixelColorB.G + pixelColorC.G + pixelColorD.G) / 4.0F);\n            blue = Convert.ToInt32(((pixelColorA.B) + pixelColorB.B + pixelColorC.B + pixelColorD.B) / 4.0F);\n            bitmap1.SetPixel(pixX, pixY, ColorTranslator.FromOle(ColorUtil.OsRgb(red, green, blue)));\n\n            BitmapUtil.CreateGLTexture (bitmap1, 7, textureNum);\n\n            return returnResult;\n        }    \n    }\n", "label": "FeatureEnvy"}
{"text": "\n    /// <summary>\n    /// Controller for handling minified/combined responses\n    /// </summary>    \n    [AddCompressionHeader(Order = 0)]\n    [AddExpiryHeaders(Order = 1)]\n    [CheckNotModified(Order = 2)]\n    [CompositeFileCacheFilter(Order = 3)]        \n    public class SmidgeController : Controller\n    {\n        private readonly FileSystemHelper _fileSystemHelper;\n        private readonly IBundleManager _bundleManager;\n        private readonly IBundleFileSetGenerator _fileSetGenerator;\n        private readonly PreProcessPipelineFactory _processorFactory;\n        private readonly PreProcessManager _preProcessManager;\n        private readonly ILogger _logger;\n        \n        /// <summary>\n        /// Constructor\n        /// </summary>\n        /// <param name=\"fileSystemHelper\"></param>\n        /// <param name=\"bundleManager\"></param>\n        /// <param name=\"fileSetGenerator\"></param>\n        /// <param name=\"processorFactory\"></param>\n        /// <param name=\"preProcessManager\"></param>\n        /// <param name=\"logger\"></param>\n        public SmidgeController(\n            FileSystemHelper fileSystemHelper, \n            IBundleManager bundleManager,\n            IBundleFileSetGenerator fileSetGenerator,\n            PreProcessPipelineFactory processorFactory,\n            PreProcessManager preProcessManager,\n            ILogger<SmidgeController> logger)\n        {\n            if (fileSystemHelper == null) throw new ArgumentNullException(nameof(fileSystemHelper));\n            if (bundleManager == null) throw new ArgumentNullException(nameof(bundleManager));\n            if (fileSetGenerator == null) throw new ArgumentNullException(nameof(fileSetGenerator));\n            if (processorFactory == null) throw new ArgumentNullException(nameof(processorFactory));\n            if (preProcessManager == null) throw new ArgumentNullException(nameof(preProcessManager));\n            _fileSystemHelper = fileSystemHelper;\n            _bundleManager = bundleManager;\n            _fileSetGenerator = fileSetGenerator;\n            _processorFactory = processorFactory;\n            _preProcessManager = preProcessManager;\n            _logger = logger;\n        }\n\n        /// <summary>\n        /// Handles requests for named bundles\n        /// </summary>\n        /// <param name=\"bundle\">The bundle model</param>\n        /// <returns></returns>       \n        public async Task<IActionResult> Bundle(\n            [FromServices]BundleRequestModel bundle)\n        {\n            if (!_bundleManager.TryGetValue(bundle.FileKey, out Bundle foundBundle))\n            {\n                return NotFound();\n            }\n\n            var bundleOptions = foundBundle.GetBundleOptions(_bundleManager, bundle.Debug);\n            \n            //now we need to determine if this bundle has already been created\n            var compositeFilePath = new FileInfo(_fileSystemHelper.GetCurrentCompositeFilePath(bundle.CacheBuster, bundle.Compression, bundle.FileKey));\n            if (compositeFilePath.Exists)\n            {\n                _logger.LogDebug($\"Returning bundle '{bundle.FileKey}' from cache\");\n\n                //this is already processed, return it\n                return File(compositeFilePath.OpenRead(), bundle.Mime);\n            }\n\n            //the bundle doesn't exist so we'll go get the files, process them and create the bundle\n            //TODO: We should probably lock here right?! we don't want multiple threads trying to do this at the same time, we'll need a dictionary of locks to do this effectively\n\n            //get the files for the bundle\n            var files = _fileSetGenerator.GetOrderedFileSet(foundBundle,\n                    _processorFactory.CreateDefault(\n                        //the file type in the bundle will always be the same\n                        foundBundle.Files[0].DependencyType))\n                .ToArray();\n\n            if (files.Length == 0)\n            {\n                return NotFound();\n            }\n            \n            using (var bundleContext = new BundleContext(bundle, compositeFilePath))\n            {\n                var watch = new Stopwatch();\n                watch.Start();\n                _logger.LogDebug($\"Processing bundle '{bundle.FileKey}', debug? {bundle.Debug} ...\");\n\n                //we need to do the minify on the original files\n                foreach (var file in files)\n                {\n                    await _preProcessManager.ProcessAndCacheFileAsync(file, bundleOptions, bundleContext);\n                }\n\n                //Get each file path to it's hashed location since that is what the pre-processed file will be saved as\n                Lazy<IFileInfo> fi;\n                var filePaths = files.Select(\n                    x => _fileSystemHelper.GetCacheFilePath(x, bundleOptions.FileWatchOptions.Enabled, Path.GetExtension(x.FilePath), bundle.CacheBuster, out fi));\n\n                using (var resultStream = await GetCombinedStreamAsync(filePaths, bundleContext))\n                {\n                    //compress the response (if enabled)\n                    var compressedStream = await Compressor.CompressAsync(\n                        //do not compress anything if it's not enabled in the bundle options\n                        bundleOptions.CompressResult ? bundle.Compression : CompressionType.none,\n                        resultStream);\n\n                    //save the resulting compressed file, if compression is not enabled it will just save the non compressed format\n                    // this persisted file will be used in the CheckNotModifiedAttribute which will short circuit the request and return\n                    // the raw file if it exists for further requests to this path\n                    await CacheCompositeFileAsync(compositeFilePath, compressedStream);\n\n                    _logger.LogDebug($\"Processed bundle '{bundle.FileKey}' in {watch.ElapsedMilliseconds}ms\");\n\n                    //return the stream\n                    return File(compressedStream, bundle.Mime);\n                }\n            }\n        }\n\n        /// <summary>\n        /// Handles requests for composite files (non-named bundles)\n        /// </summary>\n        /// <param name=\"file\"></param>\n        /// <returns></returns>\n        public async Task<IActionResult> Composite(\n             [FromServices]CompositeFileModel file)\n        {\n            if (!file.ParsedPath.Names.Any())\n            {\n                return NotFound();\n            }\n\n            var compositeFilePath = new FileInfo(_fileSystemHelper.GetCurrentCompositeFilePath(file.CacheBuster, file.Compression, file.FileKey));\n\n            if (compositeFilePath.Exists)\n            {\n                //this is already processed, return it\n                return File(compositeFilePath.OpenRead(), file.Mime);\n            }\n            \n            using (var bundleContext = new BundleContext(file, compositeFilePath))\n            {\n                var filePaths = file.ParsedPath.Names.Select(filePath =>\n                    Path.Combine(\n                        _fileSystemHelper.CurrentCacheFolder,\n                        file.ParsedPath.Version,\n                        filePath + file.Extension));\n\n                using (var resultStream = await GetCombinedStreamAsync(filePaths, bundleContext))\n                {\n                    var compressedStream = await Compressor.CompressAsync(file.Compression, resultStream);\n\n                    await CacheCompositeFileAsync(compositeFilePath, compressedStream);\n\n                    return File(compressedStream, file.Mime);\n                }\n            }\n        }\n\n        private static async Task CacheCompositeFileAsync(FileInfo compositeFilePath, Stream compositeStream)\n        {\n            //ensure it exists\n            compositeFilePath.Directory.Create();            \n            compositeStream.Position = 0;            \n            using (var fs = compositeFilePath.Create())\n            {\n                await compositeStream.CopyToAsync(fs);\n            }\n            compositeStream.Position = 0;\n        }\n\n        /// <summary>\n        /// Combines files into a single stream\n        /// </summary>\n        /// <param name=\"filePaths\"></param>\n        /// <param name=\"bundleContext\"></param>\n        /// <returns></returns>\n        private async Task<Stream> GetCombinedStreamAsync(IEnumerable<string> filePaths, BundleContext bundleContext)\n        {\n            //TODO: Here we need to be able to prepend/append based on a \"BundleContext\" (or similar)\n\n            List<Stream> inputs = null;\n            try\n            {\n                inputs = filePaths.Where(System.IO.File.Exists)\n                    .Select(System.IO.File.OpenRead)\n                    .Cast<Stream>()\n                    .ToList();\n\n                var delimeter = bundleContext.BundleRequest.Extension == \".js\" ? \";\" : \"\\n\";\n                var combined = await bundleContext.GetCombinedStreamAsync(inputs, delimeter);\n                return combined;\n            }\n            finally\n            {\n                if (inputs != null)\n                {\n                    foreach (var input in inputs)\n                    {\n                        input.Dispose();\n                    }\n                }\n            }\n        }\n\n        \n    }\n", "label": "FeatureEnvy"}
{"text": "\n  #if !SILVERLIGHT\n  [Serializable]\n  #endif\n  public partial class ContactReport : TBase\n  {\n    private string _mid;\n    private bool _exists;\n    private Contact _contact;\n\n    public string Mid\n    {\n      get\n      {\n        return _mid;\n      }\n      set\n      {\n        __isset.mid = true;\n        this._mid = value;\n      }\n    }\n\n    public bool Exists\n    {\n      get\n      {\n        return _exists;\n      }\n      set\n      {\n        __isset.exists = true;\n        this._exists = value;\n      }\n    }\n\n    public Contact Contact\n    {\n      get\n      {\n        return _contact;\n      }\n      set\n      {\n        __isset.contact = true;\n        this._contact = value;\n      }\n    }\n\n\n    public Isset __isset;\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public struct Isset {\n      public bool mid;\n      public bool exists;\n      public bool contact;\n    }\n\n    public ContactReport() {\n    }\n\n    public void Read (TProtocol iprot)\n    {\n      TField field;\n      iprot.ReadStructBegin();\n      while (true)\n      {\n        field = iprot.ReadFieldBegin();\n        if (field.Type == TType.Stop) { \n          break;\n        }\n        switch (field.ID)\n        {\n          case 1:\n            if (field.Type == TType.String) {\n              Mid = iprot.ReadString();\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          case 2:\n            if (field.Type == TType.Bool) {\n              Exists = iprot.ReadBool();\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          case 3:\n            if (field.Type == TType.Struct) {\n              Contact = new Contact();\n              Contact.Read(iprot);\n            } else { \n              TProtocolUtil.Skip(iprot, field.Type);\n            }\n            break;\n          default: \n            TProtocolUtil.Skip(iprot, field.Type);\n            break;\n        }\n        iprot.ReadFieldEnd();\n      }\n      iprot.ReadStructEnd();\n    }\n\n    public void Write(TProtocol oprot) {\n      TStruct struc = new TStruct(\"ContactReport\");\n      oprot.WriteStructBegin(struc);\n      TField field = new TField();\n      if (Mid != null && __isset.mid) {\n        field.Name = \"mid\";\n        field.Type = TType.String;\n        field.ID = 1;\n        oprot.WriteFieldBegin(field);\n        oprot.WriteString(Mid);\n        oprot.WriteFieldEnd();\n      }\n      if (__isset.exists) {\n        field.Name = \"exists\";\n        field.Type = TType.Bool;\n        field.ID = 2;\n        oprot.WriteFieldBegin(field);\n        oprot.WriteBool(Exists);\n        oprot.WriteFieldEnd();\n      }\n      if (Contact != null && __isset.contact) {\n        field.Name = \"contact\";\n        field.Type = TType.Struct;\n        field.ID = 3;\n        oprot.WriteFieldBegin(field);\n        Contact.Write(oprot);\n        oprot.WriteFieldEnd();\n      }\n      oprot.WriteFieldStop();\n      oprot.WriteStructEnd();\n    }\n\n    public override string ToString() {\n      StringBuilder sb = new StringBuilder(\"ContactReport(\");\n      sb.Append(\"Mid: \");\n      sb.Append(Mid);\n      sb.Append(\",Exists: \");\n      sb.Append(Exists);\n      sb.Append(\",Contact: \");\n      sb.Append(Contact== null ? \"<null>\" : Contact.ToString());\n      sb.Append(\")\");\n      return sb.ToString();\n    }\n\n  }\n", "label": "FeatureEnvy"}
{"text": "\n    public class Channel : BasicChannel\n    {\n        private readonly InterlockedBoolean initialized = new InterlockedBoolean();\n        \n        private readonly InterlockedBoolean disposed = new InterlockedBoolean();\n\n        private readonly BehaviorSubject<BridgedChannel> bridgedChannelsSubject = new BehaviorSubject<BridgedChannel>(null);\n\n        private string bridgedUUID;\n\n        protected internal Channel(OutboundSocket outboundSocket) : this(outboundSocket.ChannelData, outboundSocket)\n        {\n        }\n\n        protected internal Channel(ChannelEvent eventMessage, EventSocket eventSocket) : base(eventMessage, eventSocket)\n        {\n            LingerTime = 10;\n        }\n\n        internal static async Task<Channel> Create(OutboundSocket outboundSocket)\n        {\n            var channel = new Channel(outboundSocket);\n            \n            channel.ExitOnHangup = true;\n\n            await outboundSocket.Linger().ConfigureAwait(false);\n\n\n            await outboundSocket.SubscribeEvents(\n               EventName.ChannelProgress,\n               EventName.ChannelBridge,\n               EventName.ChannelUnbridge,\n               EventName.ChannelAnswer,\n               EventName.ChannelHangup,\n               EventName.ChannelHangupComplete,\n               EventName.Dtmf).ConfigureAwait(false); //subscribe to minimum events\n\n            await outboundSocket.Filter(HeaderNames.UniqueId, outboundSocket.ChannelData.UUID).ConfigureAwait(false); //filter for our unique id (in case using full socket mode)\n            await outboundSocket.Filter(HeaderNames.OtherLegUniqueId, outboundSocket.ChannelData.UUID).ConfigureAwait(false); //filter for channels bridging to our unique id\n            await outboundSocket.Filter(HeaderNames.ChannelCallUniqueId, outboundSocket.ChannelData.UUID).ConfigureAwait(false); //filter for channels bridging to our unique id\n\n            channel.InitializeSubscriptions();\n            return channel;\n        }\n\n        ~Channel()\n        {\n            Dispose(false);\n        }\n        public IObservable<ChannelEvent> Events { get { return Socket.ChannelEvents.Where(x => x.UUID == UUID).AsObservable(); } }\n\n        public IObservable<BridgedChannel> BridgedChannels { get { return bridgedChannelsSubject.Where(x => x != null).AsObservable(); } }\n\n        public BridgedChannel OtherLeg => bridgedChannelsSubject.Value;\n\n        public bool ExitOnHangup { get; set; }\n\n        public int LingerTime { get; set; }\n\n        public async Task BridgeTo(string destination, BridgeOptions options, Action<EventMessage> onProgress = null)\n        {\n            if (!IsAnswered && !IsPreAnswered)\n            {\n                return;\n            }\n\n            Log.Debug(() => \"Channel {0} is attempting a bridge to {1}\".Fmt(UUID, destination));\n\n            if (string.IsNullOrEmpty(options.UUID))\n            {\n                options.UUID = Guid.NewGuid().ToString();\n            }\n\n            var subscriptions = new CompositeDisposable();\n\n            if (onProgress != null)\n            {\n                subscriptions.Add(\n                    eventSocket.ChannelEvents.Where(x => x.UUID == options.UUID && x.EventName == EventName.ChannelProgress)\n                        .Take(1)\n                        .Subscribe(onProgress));\n            }\n\n            var bridgedChannel = this.BridgedChannels.FirstAsync(x => x.UUID == options.UUID);\n            var result = await eventSocket.Bridge(UUID, destination, options).ConfigureAwait(false);\n\n            Log.Debug(() => \"Channel {0} bridge complete {1} {2}\".Fmt(UUID, result.Success, result.ResponseText));\n            subscriptions.Dispose();\n\n            if (result.Success)\n            {\n                //wait for this.OtherLeg to be set before completing\n                await bridgedChannel;\n            }\n        }\n\n        public Task Execute(string application, string args)\n        {\n            return eventSocket.ExecuteApplication(UUID, application, args);\n        }\n\n        public Task Execute(string uuid, string application, string args)\n        {\n            return eventSocket.ExecuteApplication(uuid, application, args);\n        }\n\n        public Task HoldToggle()\n        {\n            return RunIfAnswered(() => eventSocket.SendApi(\"uuid_hold toggle \" + UUID));\n        }\n\n        public Task HoldOn()\n        {\n            return RunIfAnswered(() => eventSocket.SendApi(\"uuid_hold \" + UUID));\n        }\n\n        public Task HoldOff()\n        {\n            return RunIfAnswered(() => eventSocket.SendApi(\"uuid_hold off \" + UUID));\n        }\n\n        public Task Park()\n        {\n            return RunIfAnswered(() => eventSocket.ExecuteApplication(UUID, \"park\"));\n        }\n\n        public Task RingReady()\n        {\n            return eventSocket.ExecuteApplication(UUID, \"ring_ready\");\n        }\n\n        public Task Answer()\n        {\n            return eventSocket.ExecuteApplication(UUID, \"answer\");\n        }\n\n        public Task EnableHeartBeat(int intervalSeconds = 60)\n        {\n            return RunIfAnswered(\n                async () =>\n                {\n                    await eventSocket.SubscribeEvents(EventName.SessionHeartbeat).ConfigureAwait(false);\n                    await eventSocket.ExecuteApplication(UUID, \"enable_heartbeat\", intervalSeconds.ToString()).ConfigureAwait(false);\n                }, true);\n        }\n\n        public Task PreAnswer()\n        {\n            return eventSocket.ExecuteApplication(UUID, \"pre_answer\");\n        }\n\n        public Task Sleep(int milliseconds)\n        {\n            return eventSocket.ExecuteApplication(UUID, \"sleep\", milliseconds.ToString());\n        }\n\n        public new void Dispose()\n        {\n            Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        protected virtual void Dispose(bool disposing)\n        {\n            if (disposed != null && !disposed.EnsureCalledOnce())\n            {\n                if (disposing)\n                {\n                    if (!Disposables.IsDisposed)\n                    {\n                        Disposables.Dispose();\n                    }\n\n                    OtherLeg?.Dispose();\n                    bridgedChannelsSubject.Dispose();\n                }\n\n                if (eventSocket != null && eventSocket is OutboundSocket)\n                {\n                    // todo: should we close the socket associated with the channel here?\n                    eventSocket.Dispose();\n                }\n\n                eventSocket = null;\n\n                Log.Debug(() => \"Channel Disposed.\");\n            }\n\n            base.Dispose(disposing);\n        }\n        \n        private void InitializeSubscriptions()\n        {\n            if (initialized.EnsureCalledOnce())\n            {\n                Log.Warn(() => \"Channel already initialized\");\n                return;\n            }\n\n            Disposables.Add(\n                    eventSocket.ChannelEvents.Where(x => x.UUID == UUID \n                                            && x.EventName == EventName.ChannelBridge\n                                            && x.OtherLegUUID != bridgedUUID)\n                    .Subscribe(\n                        async x =>\n                        {\n                            Log.Info(() => \"Channel [{0}] Bridged to [{1}] CHANNEL_BRIDGE\".Fmt(UUID, x.GetHeader(HeaderNames.OtherLegUniqueId)));\n\n                            var apiResponse = await eventSocket.Api(\"uuid_dump\", x.OtherLegUUID);\n\n                            if (apiResponse.Success && apiResponse.BodyText != \"+OK\")\n                            {\n                                var eventMessage = new ChannelEvent(apiResponse);\n                                bridgedChannelsSubject.OnNext(new BridgedChannel(eventMessage, eventSocket));\n                            }\n                            else\n                            {\n                                Log.Error(() => \"Unable to get CHANNEL_DATA info from 'api uuid_dump {0}' - received '{1}'.\".Fmt(x.OtherLegUUID, apiResponse.BodyText));\n                            }\n                        }));\n\n            Disposables.Add(\n                eventSocket.ChannelEvents.Where(x => \n                                    x.UUID == UUID \n                                    && x.EventName == EventName.ChannelUnbridge\n                                    && x.GetVariable(\"bridge_hangup_cause\") != null)\n                           .Subscribe(\n                               x =>\n                               {\n                                   /* side effects:\n                                    * the att_xfer application is evil\n                                    * if after speaking to C, B presses '#' to cancel,\n                                    * the A channel fires an unbridge event, even though it is still bridged to B\n                                    * in this case, bridge_hangup_cause will be empty so we'll ignore those events\n                                    * however, this may break if this channel has had any completed bridges before this. */\n\n                                   Log.Info(\n                                       () =>\n                                           \"Channel [{0}] Unbridged from [{1}] {2}\".Fmt(\n                                               UUID,\n                                               x.GetVariable(\"last_bridge_to\"),\n                                               x.GetVariable(\"bridge_hangup_cause\")));\n\n                                   bridgedChannelsSubject.OnNext(null); //clears out OtherLeg\n                               }));\n\n            Disposables.Add(BridgedChannels.Subscribe(\n                async b =>\n                {\n                    if (bridgedUUID != null && bridgedUUID != b.UUID)\n                    {\n                        await eventSocket.FilterDelete(HeaderNames.UniqueId, bridgedUUID).ConfigureAwait(false);\n                        await eventSocket.FilterDelete(HeaderNames.OtherLegUniqueId, bridgedUUID).ConfigureAwait(false);\n                        await eventSocket.FilterDelete(HeaderNames.ChannelCallUniqueId, bridgedUUID).ConfigureAwait(false);\n                    }\n\n                    bridgedUUID = b.UUID;\n\n                    await eventSocket.Filter(HeaderNames.UniqueId, bridgedUUID).ConfigureAwait(false); \n                    await eventSocket.Filter(HeaderNames.OtherLegUniqueId, bridgedUUID).ConfigureAwait(false);\n                    await eventSocket.Filter(HeaderNames.ChannelCallUniqueId, bridgedUUID).ConfigureAwait(false);\n\n                    Log.Trace(() => \"Channel [{0}] setting OtherLeg to [{1}]\".Fmt(UUID, b.UUID));\n                }));\n\n            Disposables.Add(\n                eventSocket.ChannelEvents.Where(\n                    x =>\n                    x.EventName == EventName.ChannelBridge\n                    && x.UUID != UUID\n                    && x.GetHeader(HeaderNames.OtherLegUniqueId) == UUID\n                    && x.UUID != bridgedUUID)\n                    .Subscribe(\n                        x =>\n                        {\n                            //there is another channel out there that has bridged to us but we didn't get the CHANNEL_BRIDGE event on this channel\n                            Log.Info(() => \"Channel [{0}] bridged to [{1}]] on CHANNEL_BRIDGE received on other channel\".Fmt(UUID, x.UUID));\n                            bridgedChannelsSubject.OnNext(new BridgedChannel(x, eventSocket));\n                        }));\n\n\n            if (eventSocket is OutboundSocket)\n            {\n                Disposables.Add(\n                    eventSocket.ChannelEvents.Where(x => x.UUID == UUID && x.EventName == EventName.ChannelHangupComplete)\n                               .Subscribe(\n                                   async e =>\n                                   {\n                                       if (ExitOnHangup)\n                                       {\n                                           //give event subscribers time to complete\n                                           if (LingerTime > 0)\n                                           {\n                                               Log.Debug(() => \"Channel[{0}] will exit in {1} seconds...\".Fmt(UUID, LingerTime));\n                                               await Task.Delay(LingerTime * 1000);\n                                           }\n\n                                           if (eventSocket != null)\n                                           {\n                                               Log.Info(() => \"Channel [{0}] exiting\".Fmt(UUID));\n                                               await eventSocket.Exit().ConfigureAwait(false);\n                                           }\n\n                                           Dispose();\n                                       }\n                                   }));\n            }\n\n            Log.Trace(() => \"Channel [{0}] subscriptions initialized\".Fmt(UUID));\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\n    #if !SILVERLIGHT\n    [Serializable]\n    #endif\n    public partial class buyMustbuyProduct_args : TBase\n    {\n      private string _receiverMid;\n      private string _productId;\n      private int _messageTemplate;\n      private string _language;\n      private string _country;\n      private long _packageId;\n      private string _serialNumber;\n\n      public string ReceiverMid\n      {\n        get\n        {\n          return _receiverMid;\n        }\n        set\n        {\n          __isset.receiverMid = true;\n          this._receiverMid = value;\n        }\n      }\n\n      public string ProductId\n      {\n        get\n        {\n          return _productId;\n        }\n        set\n        {\n          __isset.productId = true;\n          this._productId = value;\n        }\n      }\n\n      public int MessageTemplate\n      {\n        get\n        {\n          return _messageTemplate;\n        }\n        set\n        {\n          __isset.messageTemplate = true;\n          this._messageTemplate = value;\n        }\n      }\n\n      public string Language\n      {\n        get\n        {\n          return _language;\n        }\n        set\n        {\n          __isset.language = true;\n          this._language = value;\n        }\n      }\n\n      public string Country\n      {\n        get\n        {\n          return _country;\n        }\n        set\n        {\n          __isset.country = true;\n          this._country = value;\n        }\n      }\n\n      public long PackageId\n      {\n        get\n        {\n          return _packageId;\n        }\n        set\n        {\n          __isset.packageId = true;\n          this._packageId = value;\n        }\n      }\n\n      public string SerialNumber\n      {\n        get\n        {\n          return _serialNumber;\n        }\n        set\n        {\n          __isset.serialNumber = true;\n          this._serialNumber = value;\n        }\n      }\n\n\n      public Isset __isset;\n      #if !SILVERLIGHT\n      [Serializable]\n      #endif\n      public struct Isset {\n        public bool receiverMid;\n        public bool productId;\n        public bool messageTemplate;\n        public bool language;\n        public bool country;\n        public bool packageId;\n        public bool serialNumber;\n      }\n\n      public buyMustbuyProduct_args() {\n      }\n\n      public void Read (TProtocol iprot)\n      {\n        TField field;\n        iprot.ReadStructBegin();\n        while (true)\n        {\n          field = iprot.ReadFieldBegin();\n          if (field.Type == TType.Stop) { \n            break;\n          }\n          switch (field.ID)\n          {\n            case 2:\n              if (field.Type == TType.String) {\n                ReceiverMid = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 3:\n              if (field.Type == TType.String) {\n                ProductId = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 4:\n              if (field.Type == TType.I32) {\n                MessageTemplate = iprot.ReadI32();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 5:\n              if (field.Type == TType.String) {\n                Language = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 6:\n              if (field.Type == TType.String) {\n                Country = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 7:\n              if (field.Type == TType.I64) {\n                PackageId = iprot.ReadI64();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            case 8:\n              if (field.Type == TType.String) {\n                SerialNumber = iprot.ReadString();\n              } else { \n                TProtocolUtil.Skip(iprot, field.Type);\n              }\n              break;\n            default: \n              TProtocolUtil.Skip(iprot, field.Type);\n              break;\n          }\n          iprot.ReadFieldEnd();\n        }\n        iprot.ReadStructEnd();\n      }\n\n      public void Write(TProtocol oprot) {\n        TStruct struc = new TStruct(\"buyMustbuyProduct_args\");\n        oprot.WriteStructBegin(struc);\n        TField field = new TField();\n        if (ReceiverMid != null && __isset.receiverMid) {\n          field.Name = \"receiverMid\";\n          field.Type = TType.String;\n          field.ID = 2;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(ReceiverMid);\n          oprot.WriteFieldEnd();\n        }\n        if (ProductId != null && __isset.productId) {\n          field.Name = \"productId\";\n          field.Type = TType.String;\n          field.ID = 3;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(ProductId);\n          oprot.WriteFieldEnd();\n        }\n        if (__isset.messageTemplate) {\n          field.Name = \"messageTemplate\";\n          field.Type = TType.I32;\n          field.ID = 4;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI32(MessageTemplate);\n          oprot.WriteFieldEnd();\n        }\n        if (Language != null && __isset.language) {\n          field.Name = \"language\";\n          field.Type = TType.String;\n          field.ID = 5;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(Language);\n          oprot.WriteFieldEnd();\n        }\n        if (Country != null && __isset.country) {\n          field.Name = \"country\";\n          field.Type = TType.String;\n          field.ID = 6;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(Country);\n          oprot.WriteFieldEnd();\n        }\n        if (__isset.packageId) {\n          field.Name = \"packageId\";\n          field.Type = TType.I64;\n          field.ID = 7;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteI64(PackageId);\n          oprot.WriteFieldEnd();\n        }\n        if (SerialNumber != null && __isset.serialNumber) {\n          field.Name = \"serialNumber\";\n          field.Type = TType.String;\n          field.ID = 8;\n          oprot.WriteFieldBegin(field);\n          oprot.WriteString(SerialNumber);\n          oprot.WriteFieldEnd();\n        }\n        oprot.WriteFieldStop();\n        oprot.WriteStructEnd();\n      }\n\n      public override string ToString() {\n        StringBuilder sb = new StringBuilder(\"buyMustbuyProduct_args(\");\n        sb.Append(\"ReceiverMid: \");\n        sb.Append(ReceiverMid);\n        sb.Append(\",ProductId: \");\n        sb.Append(ProductId);\n        sb.Append(\",MessageTemplate: \");\n        sb.Append(MessageTemplate);\n        sb.Append(\",Language: \");\n        sb.Append(Language);\n        sb.Append(\",Country: \");\n        sb.Append(Country);\n        sb.Append(\",PackageId: \");\n        sb.Append(PackageId);\n        sb.Append(\",SerialNumber: \");\n        sb.Append(SerialNumber);\n        sb.Append(\")\");\n        return sb.ToString();\n      }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "\n\t/// <summary>\n\t/// \u5efa\u9020\u306e\u30ec\u30b3\u30fc\u30c9\u3067\u3059\u3002\n\t/// </summary>\n\t[DebuggerDisplay(\"{Record.Count} Records\")]\n\tpublic class DevelopmentRecord : RecordBase\n\t{\n\n\t\t[DebuggerDisplay(\"[{EquipmentID}] : {EquipmentName}\")]\n\t\tpublic sealed class DevelopmentElement : RecordElementBase\n\t\t{\n\n\t\t\t/// <summary>\n\t\t\t/// \u958b\u767a\u3057\u305f\u88c5\u5099\u306eID\n\t\t\t/// </summary>\n\t\t\tpublic int EquipmentID { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u958b\u767a\u3057\u305f\u88c5\u5099\u306e\u540d\u524d\n\t\t\t/// </summary>\n\t\t\tpublic string EquipmentName { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u958b\u767a\u65e5\u6642\n\t\t\t/// </summary>\n\t\t\tpublic DateTime Date { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u6295\u5165\u71c3\u6599\n\t\t\t/// </summary>\n\t\t\tpublic int Fuel { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u6295\u5165\u5f3e\u85ac\n\t\t\t/// </summary>\n\t\t\tpublic int Ammo { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u6295\u5165\u92fc\u6750\n\t\t\t/// </summary>\n\t\t\tpublic int Steel { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u6295\u5165\u30dc\u30fc\u30ad\u30b5\u30a4\u30c8\n\t\t\t/// </summary>\n\t\t\tpublic int Bauxite { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u65d7\u8266\u306e\u8266\u8239ID\n\t\t\t/// </summary>\n\t\t\tpublic int FlagshipID { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u65d7\u8266\u306e\u8266\u540d\n\t\t\t/// </summary>\n\t\t\tpublic string FlagshipName { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u65d7\u8266\u306e\u8266\u7a2e\n\t\t\t/// </summary>\n\t\t\tpublic int FlagshipType { get; set; }\n\n\t\t\t/// <summary>\n\t\t\t/// \u53f8\u4ee4\u90e8Lv.\n\t\t\t/// </summary>\n\t\t\tpublic int HQLevel { get; set; }\n\n\n\n\t\t\tpublic DevelopmentElement()\n\t\t\t{\n\t\t\t\tEquipmentID = -1;\n\t\t\t\tDate = DateTime.Now;\n\t\t\t}\n\n\t\t\tpublic DevelopmentElement(string line)\n\t\t\t\t: this()\n\t\t\t{\n\t\t\t\tLoadLine(line);\n\t\t\t}\n\n\t\t\tpublic DevelopmentElement(int equipmentID, int fuel, int ammo, int steel, int bauxite, int flagshipID, int hqLevel)\n\t\t\t{\n\t\t\t\tEquipmentID = equipmentID;\n\t\t\t\tFuel = fuel;\n\t\t\t\tAmmo = ammo;\n\t\t\t\tSteel = steel;\n\t\t\t\tBauxite = bauxite;\n\t\t\t\tFlagshipID = flagshipID;\n\t\t\t\tHQLevel = hqLevel;\n\n\t\t\t\tSetSubParameters();\n\t\t\t}\n\n\n\t\t\tpublic override void LoadLine(string line)\n\t\t\t{\n\n\t\t\t\tstring[] elem = CsvHelper.ParseCsvLine(line).ToArray();\n\t\t\t\tif (elem.Length < 11) throw new ArgumentException(\"\u8981\u7d20\u6570\u304c\u5c11\u306a\u3059\u304e\u307e\u3059\u3002\");\n\n\t\t\t\tEquipmentID = int.Parse(elem[0]);\n\t\t\t\tEquipmentName = elem[1];\n\t\t\t\tDate = DateTimeHelper.CSVStringToTime(elem[2]);\n\t\t\t\tFuel = int.Parse(elem[3]);\n\t\t\t\tAmmo = int.Parse(elem[4]);\n\t\t\t\tSteel = int.Parse(elem[5]);\n\t\t\t\tBauxite = int.Parse(elem[6]);\n\t\t\t\tFlagshipID = int.Parse(elem[7]);\n\t\t\t\tFlagshipName = elem[8];\n\t\t\t\tFlagshipType = int.Parse(elem[9]);\n\t\t\t\tHQLevel = int.Parse(elem[10]);\n\n\t\t\t}\n\n\t\t\tpublic override string SaveLine()\n\t\t\t{\n\n\t\t\t\treturn string.Join(\",\",\n\t\t\t\t\tEquipmentID,\n\t\t\t\t\tCsvHelper.EscapeCsvCell(EquipmentName),\n\t\t\t\t\tDateTimeHelper.TimeToCSVString(Date),\n\t\t\t\t\tFuel,\n\t\t\t\t\tAmmo,\n\t\t\t\t\tSteel,\n\t\t\t\t\tBauxite,\n\t\t\t\t\tFlagshipID,\n\t\t\t\t\tCsvHelper.EscapeCsvCell(FlagshipName),\n\t\t\t\t\tFlagshipType,\n\t\t\t\t\tHQLevel);\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// \u8266\u540d\u306a\u3069\u306e\u30d1\u30e9\u30e1\u30fc\u30bf\u3092\u73fe\u5728\u306eID\u3092\u3082\u3068\u306b\u8a2d\u5b9a\u3057\u307e\u3059\u3002\n\t\t\t/// </summary>\n\t\t\tpublic void SetSubParameters()\n\t\t\t{\n\t\t\t\tvar eq = KCDatabase.Instance.MasterEquipments[EquipmentID];\n\t\t\t\tvar flagship = KCDatabase.Instance.MasterShips[FlagshipID];\n\n\t\t\t\tEquipmentName = EquipmentID == -1 ? \"(\u5931\u6557)\" :\n\t\t\t\t\teq?.Name ?? \"???\";\n\t\t\t\tFlagshipName = flagship?.NameWithClass ?? \"???\";\n\t\t\t\tFlagshipType = (int?)flagship?.ShipType ?? -1;\n\t\t\t}\n\t\t}\n\n\n\n\t\tpublic List<DevelopmentElement> Record { get; private set; }\n\t\tprivate DevelopmentElement tempElement;\n\t\tprivate int LastSavedCount;\n\n\n\t\tpublic DevelopmentRecord()\n\t\t{\n\t\t\tRecord = new List<DevelopmentElement>();\n\t\t\ttempElement = null;\n\n\t\t}\n\n\t\tpublic override void RegisterEvents()\n\t\t{\n\t\t\tAPIObserver ao = APIObserver.Instance;\n\n\t\t\tao.APIList[\"api_req_kousyou/createitem\"].RequestReceived += DevelopmentStart;\n\t\t\tao.APIList[\"api_req_kousyou/createitem\"].ResponseReceived += DevelopmentEnd;\n\t\t}\n\n\n\t\tpublic DevelopmentElement this[int i]\n\t\t{\n\t\t\tget { return Record[i]; }\n\t\t\tset { Record[i] = value; }\n\t\t}\n\n\n\t\tprivate void DevelopmentStart(string apiname, dynamic data)\n\t\t{\n\n\t\t\ttempElement = new DevelopmentElement\n\t\t\t{\n\t\t\t\tFuel = int.Parse(data[\"api_item1\"]),\n\t\t\t\tAmmo = int.Parse(data[\"api_item2\"]),\n\t\t\t\tSteel = int.Parse(data[\"api_item3\"]),\n\t\t\t\tBauxite = int.Parse(data[\"api_item4\"])\n\t\t\t};\n\n\t\t}\n\n\t\tprivate void DevelopmentEnd(string apiname, dynamic data)\n\t\t{\n\n\t\t\tif (tempElement == null) return;\n\n\t\t\tif ((int)data.api_create_flag == 0)\n\t\t\t{\n\t\t\t\ttempElement.EquipmentID = -1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttempElement.EquipmentID = (int)data.api_slot_item.api_slotitem_id;\n\t\t\t}\n\n\t\t\tShipData flagship = KCDatabase.Instance.Fleet[1].MembersInstance[0];\n\t\t\ttempElement.FlagshipID = flagship.ShipID;\n\t\t\ttempElement.HQLevel = KCDatabase.Instance.Admiral.Level;\n\n\t\t\ttempElement.SetSubParameters();\n\n\t\t\tRecord.Add(tempElement);\n\n\t\t\ttempElement = null;\n\t\t}\n\n\n\n\t\tprotected override void LoadLine(string line)\n\t\t{\n\t\t\tRecord.Add(new DevelopmentElement(line));\n\t\t}\n\n\t\tprotected override string SaveLinesAll()\n\t\t{\n\t\t\tvar sb = new StringBuilder();\n\t\t\tforeach (var elem in Record.OrderBy(r => r.Date))\n\t\t\t{\n\t\t\t\tsb.AppendLine(elem.SaveLine());\n\t\t\t}\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\tprotected override string SaveLinesPartial()\n\t\t{\n\t\t\tvar sb = new StringBuilder();\n\t\t\tforeach (var elem in Record.Skip(LastSavedCount).OrderBy(r => r.Date))\n\t\t\t{\n\t\t\t\tsb.AppendLine(elem.SaveLine());\n\t\t\t}\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\tprotected override void UpdateLastSavedIndex()\n\t\t{\n\t\t\tLastSavedCount = Record.Count;\n\t\t}\n\n\t\tpublic override bool NeedToSave => LastSavedCount < Record.Count;\n\n\t\tpublic override bool SupportsPartialSave => true;\n\n\t\tprotected override void ClearRecord()\n\t\t{\n\t\t\tRecord.Clear();\n\t\t\tLastSavedCount = 0;\n\t\t}\n\n\n\t\tpublic override string RecordHeader => \"\u88c5\u5099ID,\u88c5\u5099\u540d,\u958b\u767a\u65e5\u6642,\u71c3\u6599,\u5f3e\u85ac,\u92fc\u6750,\u30dc\u30fc\u30ad,\u65d7\u8266ID,\u65d7\u8266\u540d,\u65d7\u8266\u8266\u7a2e,\u53f8\u4ee4\u90e8Lv\";\n\n\t\tpublic override string FileName => \"DevelopmentRecord.csv\";\n\t}\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Interaction logic for Preferences.xaml\n    /// </summary>\n    public partial class Preferences : Window\n    {\n        Settings local;\n\n        public Theme[] theme_list = new Theme[] \n        {\n            Theme.Aero,\n            Theme.Aero2,\n            Theme.Classic,\n            Theme.Luna,\n            Theme.Royale\n        };\n\n        public string[] TrayIconBehaviorsReadable = new string[] \n        { \n            \"Show/Hide ByteFlood\",\n            \"Show context menu\",\n            \"Do nothing\"\n        };\n\n        public TrayIconBehavior[] TrayIconBehaviors = (TrayIconBehavior[])Enum.GetValues(typeof(TrayIconBehavior));\n\n        public string[] WindowBehaviorsReadable = new string[]\n        {\n            \"Minimize to tray\",\n            \"Minimize to taskbar\",\n            \"Exit\"\n        };\n\n        public WindowBehavior[] WindowBehaviors = (WindowBehavior[])Enum.GetValues(typeof(WindowBehavior));\n\n        public ComboBox[] TrayIconComboBoxes;\n        public ComboBox[] WindowComboBoxes;\n\n        public string[] EncryptionTypesReadable = new string[]\n        {\n            \"Forced\",\n            \"Preferred\",\n            \"Doesn't matter\"\n        };\n\n        public Preferences()\n        {\n            InitializeComponent();\n        }\n\n        private void Window_Loaded(object sender, RoutedEventArgs e)\n        {\n            local = (Settings)Utility.CloneObject(App.Settings);\n            this.DataContext = local;\n            this.themeCombox.ItemsSource = theme_list;\n            this.themeCombox.SelectedItem = local.Theme;\n            TrayIconComboBoxes = new ComboBox[] { tcb, tdcb, trcb };\n            WindowComboBoxes = new ComboBox[] { mb, cb };\n            Utility.SetItemsSource<ComboBox>(TrayIconComboBoxes, TrayIconBehaviorsReadable);\n            Utility.SetItemsSource<ComboBox>(WindowComboBoxes, WindowBehaviorsReadable);\n            enctype.ItemsSource = EncryptionTypesReadable;\n            LoadNetworkInterfaces();\n            styleCombox.SelectedIndex = local.ApplicationStyle;\n            styleCombox.SelectionChanged += this.ReloadStyle;\n            LoadLangs();\n        }\n\n        private void LoadNetworkInterfaces()\n        {\n            foreach (var iface in Utility.GetValidNetworkInterfaces())\n            {\n                ComboBoxItem bi = new ComboBoxItem();\n                bi.Content = iface.Name;\n                bi.Tag = iface;\n                interfaces.Items.Add(bi);\n                if (iface.Id == local.NetworkInterfaceID)\n                {\n                    interfaces.SelectedItem = bi;\n                }\n            }\n            if (interfaces.SelectedIndex == -1)\n            {\n                interfaces.SelectedIndex = 0;\n            }\n            interfaces.SelectionChanged += interfaces_SelectionChanged;\n        }\n\n        private void LoadLangs() \n        {\n            string[] langs = Utility.GetAvailableLanguages();\n            this.langCombox.ItemsSource = langs;\n            this.langCombox.SelectedIndex = Array.IndexOf(langs, App.Settings.DefaultLanguage);\n        }\n\n        void interfaces_SelectionChanged(object sender, SelectionChangedEventArgs e)\n        {\n            ComboBoxItem bi = interfaces.SelectedItem as ComboBoxItem;\n            var iface = bi.Tag as System.Net.NetworkInformation.NetworkInterface;\n            local.NetworkInterfaceID = iface.Id;\n            if (iface.OperationalStatus != System.Net.NetworkInformation.OperationalStatus.Up)\n            {\n                iface_error.Visibility = Visibility.Visible;\n            }\n            else\n            {\n                iface_error.Visibility = Visibility.Collapsed;\n            }\n        }\n\n        private void UpdateDataContext(Settings s)\n        {\n            this.DataContext = s;\n            this.themeCombox.SelectedItem = s == null ? Theme.Aero2 : s.Theme;\n        }\n\n        private void SelectDownloadColor(object sender, RoutedEventArgs e)\n        {\n            local.DownloadColor = GetNewColor(local.DownloadColor);\n            downcolor.GetBindingExpression(Button.BackgroundProperty).UpdateTarget();\n        }\n\n        public Color GetNewColor(Color current)\n        {\n            ColorDialog cd = new ColorDialog();\n            cd.Color = current.ToWinFormColor();\n            cd.AllowFullOpen = true;\n            cd.FullOpen = true;\n            cd.SolidColorOnly = true;\n            cd.ShowDialog();\n            return cd.Color.ToWPFColor();\n        }\n\n        private void SelectUploadColor(object sender, RoutedEventArgs e)\n        {\n            local.UploadColor = GetNewColor(local.UploadColor);\n            upcolor.GetBindingExpression(Button.BackgroundProperty).UpdateTarget();\n        }\n\n        private void PickPath(object sender, RoutedEventArgs e)\n        {\n            string new_path = Utility.PromptFolderSelection(\"Choose default download path\", local.DefaultDownloadPath, this);\n            if (new_path != null)\n            {\n                local.DefaultDownloadPath = new_path;\n                downpath.GetBindingExpression(TextBox.TextProperty).UpdateTarget();\n            }\n        }\n\n        private void ImportTorrents(object sender, RoutedEventArgs e)\n        {\n            MainWindow mw = (App.Current.MainWindow as MainWindow);\n            if (!mw.ImportTorrents())\n            {\n                MessageBox.Show(\"resume.dat not found! You either have no torrents or have not installed uTorrent.\", \"Error\", MessageBoxButton.OK, MessageBoxImage.Error);\n            }\n        }\n\n        private void ReloadTheme(object sender, SelectionChangedEventArgs e)\n        {\n            var t = (Theme)themeCombox.SelectedItem;\n            Utility.ReloadTheme(t);\n        }\n\n        private void ChangeDefaultSettings(object sender, RoutedEventArgs e)\n        {\n            var editor = new TorrentPropertiesEditor(local.DefaultTorrentProperties) { Owner = this, Icon = this.Icon };\n            editor.ShowDialog();\n        }\n\n        private void SaveSettings(object sender, RoutedEventArgs e)\n        {\n            local.TrayIconClickBehavior = TrayIconBehaviors[tcb.SelectedIndex];\n            local.TrayIconRightClickBehavior = TrayIconBehaviors[trcb.SelectedIndex];\n            local.TrayIconDoubleClickBehavior = TrayIconBehaviors[tdcb.SelectedIndex];\n            local.MinimizeBehavior = WindowBehaviors[mb.SelectedIndex];\n            local.ExitBehavior = WindowBehaviors[cb.SelectedIndex];\n            local.EncryptionType = (EncryptionTypeEnum)enctype.SelectedIndex;\n\n            MainWindow mw = (App.Current.MainWindow as MainWindow);\n\n            local.Theme = (Theme)themeCombox.SelectedItem;\n\n            if (this.langCombox.SelectedIndex > -1)\n            {\n                string new_choice = this.langCombox.SelectedValue.ToString();\n                if (new_choice != local.DefaultLanguage)\n                {\n                    local.DefaultLanguage = new_choice;\n\n                    if (App.CurrentLanguage != null)\n                    {\n                        App.CurrentLanguage.ReloadLang(local.DefaultLanguage);\n                    }\n                    else\n                    {\n                        App.CurrentLanguage = LanguageEngine.LoadDefault();\n                    }\n                }\n            }\n\n            if (local.CheckForUpdates) \n            {\n                mw.StartAutoUpdater();\n            }\n            else \n            {\n                mw.StopAutoUpdater();\n            }\n\n            if (local.EnableDHT) \n                mw.state.LibtorrentSession.StartDht();\n            else \n                mw.state.LibtorrentSession.StopDht();\n\n            if (local.EnableLSD)\n                mw.state.LibtorrentSession.StartLsd();\n            else\n                mw.state.LibtorrentSession.StopLsd();\n\n            if (local.EnableNAT_PMP)\n                mw.state.LibtorrentSession.StartNatPmp();\n            else\n                mw.state.LibtorrentSession.StopNatPmp();\n\n            if (local.Enable_UPNP)\n                mw.state.LibtorrentSession.StartUpnp();\n            else\n                mw.state.LibtorrentSession.StopUpnp();\n       \n            App.Settings = (Settings)Utility.CloneObject(local);\n\n            this.Close();\n        }\n\n        private void DiscardSettings(object sender, RoutedEventArgs e)\n        {\n            this.Close();\n        }\n\n        private void ResetToDefaultSettings(object sender, RoutedEventArgs e)\n        {\n            local = (Settings)Utility.CloneObject(Settings.DefaultSettings);\n            UpdateDataContext(null);\n            UpdateDataContext(local);\n        }\n\n        private void AssociateFiles(object sender, RoutedEventArgs e)\n        {\n            Utility.FileAssociate();\n            Utility.MagnetAssociate();\n        }\n\n        private void RefreshNetworkInterfaces(object sender, RoutedEventArgs e)\n        {\n            interfaces.SelectionChanged -= interfaces_SelectionChanged;\n            interfaces.Items.Clear();\n            LoadNetworkInterfaces();\n        }\n\n        private void ReloadStyle(object sender, SelectionChangedEventArgs e)\n        {\n            ComboBox s = (sender as ComboBox);\n            if (s != null)\n            {\n                (App.Current.MainWindow as MainWindow).UpdateAppStyle(s.SelectedIndex);\n                local.ApplicationStyle = s.SelectedIndex;\n            }\n        }\n\n    }\n", "label": "FeatureEnvy"}
{"text": "    class Program\n    {\n        public static AriClient ActionClient;\n        public static Bridge SimpleBridge;\n\n        private const string AppName = \"bridge_test\";\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                // Create a message actionClient to receive events on\n                ActionClient = new AriClient(new StasisEndpoint(\"127.0.0.1\", 8088, \"dev\", \"test\"), AppName);\n\n                ActionClient.OnStasisStartEvent += c_OnStasisStartEvent;\n                ActionClient.OnStasisEndEvent += c_OnStasisEndEvent;\n\n                ActionClient.Connect();\n\n                // Create simple bridge\n                SimpleBridge = ActionClient.Bridges.Create(\"mixing\", Guid.NewGuid().ToString(), AppName);\n\n                // subscribe to bridge events\n                ActionClient.Applications.Subscribe(AppName, \"bridge:\" + SimpleBridge.Id);\n\n                // start MOH on bridge\n                ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\");\n\n                var done = false;\n                while (!done)\n                {\n                    var lastKey = Console.ReadKey();\n                    switch(lastKey.KeyChar.ToString())\n                    {\n                        case \"*\":\n                            done = true;\n                            break;\n                        case \"1\":\n                            ActionClient.Bridges.StopMoh(SimpleBridge.Id);\n                            break;\n                        case \"2\":\n                            ActionClient.Bridges.StartMoh(SimpleBridge.Id, \"default\");\n                            break;\n                        case \"3\":\n                            // Mute all channels on bridge\n                            var bridgeMute = ActionClient.Bridges.Get(SimpleBridge.Id);\n                            foreach (var chan in bridgeMute.Channels)\n                                ActionClient.Channels.Mute(chan, \"in\");\n                            break;\n                        case \"4\":\n                            // Unmute all channels on bridge\n                            var bridgeUnmute = ActionClient.Bridges.Get(SimpleBridge.Id);\n                            foreach (var chan in bridgeUnmute.Channels)\n                                ActionClient.Channels.Unmute(chan, \"in\");\n                            break;\n                    }\n                }\n\n                ActionClient.Bridges.Destroy(SimpleBridge.Id);\n                ActionClient.Disconnect();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(ex.ToString());\n                Console.ReadKey();\n            }\n        }\n\n        static void c_OnStasisEndEvent(object sender, AsterNET.ARI.Models.StasisEndEvent e)\n        {\n            // remove from bridge\n            ActionClient.Bridges.RemoveChannel(SimpleBridge.Id, e.Channel.Id);\n\n            // hangup\n            ActionClient.Channels.Hangup(e.Channel.Id, \"normal\");\n        }\n\n        static void c_OnStasisStartEvent(object sender, AsterNET.ARI.Models.StasisStartEvent e)\n        {\n            // answer channel\n            ActionClient.Channels.Answer(e.Channel.Id);\n\n            // add to bridge\n            ActionClient.Bridges.AddChannel(SimpleBridge.Id, e.Channel.Id, \"member\");\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "\n    /// <summary>\n    /// TODO this class is deprecated by virtue of StreamingInputStage. Still used by Reporting, but that can be fixed.\n    /// </summary>\n    internal class InputStage<TRecord> : InputStage, IObserver<IEnumerable<TRecord>>, IObserver<TRecord>\n    {\n        private readonly KeyValuePair<int,InputVertex<TRecord>>[] localVertices;\n\n        internal InputVertex<TRecord> GetInputVertex(int vertexId) \n        {\n            foreach (var vertex in localVertices)\n                if (vertexId == vertex.Key)\n                    return vertex.Value;\n\n            throw new Exception(String.Format(\"Vertex {0} not found in Input {1} on Process {2}\", vertexId, stage.StageId, stage.InternalComputation.Controller.Configuration.ProcessID));\n        }\n\n        public int InputId { get { return this.stage.StageId; } }\n\n        private int currentEpoch;\n\n        private bool completedCalled;\n        public bool Completed { get { return this.completedCalled; } }\n\n        private bool hasActivatedProgressTracker;\n\n        private readonly Stream<TRecord, Epoch> output;\n        public Stream<TRecord, Epoch> Stream { get { return output; } }\n\n        public static implicit operator Stream<TRecord, Epoch>(InputStage<TRecord> stage) { return stage.Stream; }\n\n        public TimeContext<Epoch> Context { get { return this.stage.Context; } }\n        internal InternalComputation InternalComputation { get { return this.stage.InternalComputation; } }\n        public Placement Placement { get { return this.stage.Placement; } }\n\n        private readonly string inputName;\n        public string InputName { get { return this.inputName; } }\n\n        private readonly Stage<InputVertex<TRecord>, Epoch> stage;\n\n        internal InputStage(Placement placement, InternalComputation internalComputation, string inputName)\n        {\n            this.inputName = inputName;\n\n            stage = Foundry.NewStage(new TimeContext<Epoch>(internalComputation.ContextManager.RootContext), (i, v) => new InputVertex<TRecord>(i, v), this.inputName);\n\n            this.output = stage.NewOutput(vertex => vertex.Output);\n\n            stage.Materialize();\n\n            this.localVertices = placement.Where(x => x.ProcessId == internalComputation.Controller.Configuration.ProcessID)\n                                        .Select(x => new KeyValuePair<int, InputVertex<TRecord>>(x.VertexId, stage.GetVertex(x.VertexId) as InputVertex<TRecord>))\n                                        .ToArray();\n\n            this.completedCalled = false;\n            this.hasActivatedProgressTracker = false;\n            this.currentEpoch = 0;\n\n            // results in pointstamps comparisons which assert w/o this.\n            this.InternalComputation.Reachability.UpdateReachabilityPartialOrder(internalComputation);\n            this.InternalComputation.Reachability.DoNotImpersonate(stage.StageId);\n\n            var initialVersion = new Runtime.Progress.Pointstamp(stage.StageId, new int[] { 0 });\n\n            //if (this.Controller.Configuration.Impersonation)\n            //{\n            //    foreach (var version in Reachability.EnumerateImpersonations(initialVersion))\n            //        controller.BroadcastUpdate(version, placement.Count);\n            //}\n            //else\n                \n            internalComputation.ProgressTracker.BroadcastProgressUpdate(initialVersion, placement.Count);\n        }\n\n        private void EnsureProgressTrackerActivated()\n        {\n            if (!this.hasActivatedProgressTracker)\n            {\n                stage.InternalComputation.Activate();\n                this.hasActivatedProgressTracker = true;\n            }\n        }\n\n        public void OnNext()\n        {\n            this.OnNext(new TRecord[] { });\n        }\n\n        public void OnNext(TRecord record)\n        {\n            this.OnNext(new[] { record });\n        }\n\n        public void OnNext(IEnumerable<TRecord> batch)\n        {\n            //Debug.Assert(!this.completedCalled);\n            this.EnsureProgressTrackerActivated();\n\n            var array = batch == null ? new TRecord[] { } : batch.ToArray();\n            lock (this)\n            {\n                var arrayCursor = 0;\n                for (int i = 0; i < this.localVertices.Length; i++)\n                {\n                    var toEat = (array.Length / this.localVertices.Length) + ((i < (array.Length % this.localVertices.Length)) ? 1 : 0);\n                    var chunk = new TRecord[toEat];\n\n                    Array.Copy(array, arrayCursor, chunk, 0, toEat);\n                    arrayCursor += toEat;\n\n                    this.localVertices[i].Value.OnNext(chunk);\n                }\n                ++this.currentEpoch;\n            }\n        }\n\n        public void OnCompleted()\n        {\n            //Debug.Assert(!this.completedCalled);\n            if (!this.completedCalled)\n            {\n                this.EnsureProgressTrackerActivated();\n                this.completedCalled = true;\n                for (int i = 0; i < this.localVertices.Length; i++)\n                    this.localVertices[i].Value.OnCompleted();\n            }\n        }\n\n        public void OnCompleted(TRecord record)\n        {\n            this.OnCompleted(new[] { record });\n        }\n        public void OnCompleted(IEnumerable<TRecord> batch)\n        {\n            if (!this.completedCalled)\n            {\n                this.EnsureProgressTrackerActivated();\n                this.completedCalled = true;\n\n                var array = batch == null ? new TRecord[] { } : batch.ToArray();\n                lock (this)\n                {\n                    ++this.currentEpoch;\n\n                    var arrayCursor = 0;\n                    for (int i = 0; i < this.localVertices.Length; i++)\n                    {\n                        var toEat = (array.Length / this.localVertices.Length) + ((i < (array.Length % this.localVertices.Length)) ? 1 : 0);\n                        var chunk = new TRecord[toEat];\n\n                        Array.Copy(array, arrayCursor, chunk, 0, toEat);\n                        arrayCursor += toEat;\n\n                        this.localVertices[i].Value.OnCompleted(chunk);\n                    }\n                }\n            }\n        }\n\n        public void OnError(Exception error) { throw error; }\n\n        public bool IsCompleted { get { return this.completedCalled; } }\n\n        public int CurrentEpoch { get { return this.currentEpoch; } }\n        public int MaximumValidEpoch { get { return this.currentEpoch - 1; } }\n\n        public void Checkpoint(NaiadWriter writer)\n        {\n            writer.Write(currentEpoch, this.InternalComputation.SerializationFormat.GetSerializer<int>());\n            writer.Write(completedCalled, this.InternalComputation.SerializationFormat.GetSerializer<bool>());\n            writer.Write(hasActivatedProgressTracker, this.InternalComputation.SerializationFormat.GetSerializer<bool>());\n        }\n\n        public void Restore(NaiadReader reader)\n        {\n            this.currentEpoch = reader.Read<int>(this.InternalComputation.SerializationFormat.GetSerializer<int>());\n            this.completedCalled = reader.Read<bool>(this.InternalComputation.SerializationFormat.GetSerializer<bool>());\n            this.hasActivatedProgressTracker = reader.Read<bool>(this.InternalComputation.SerializationFormat.GetSerializer<bool>());\n        }\n\n        public bool Stateful { get { return true; } }\n\n        public override string ToString()\n        {\n            return string.Format(\"{0} (current epoch = {1})\", base.ToString(), this.currentEpoch);\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Summary description for DeflaterOutputStream.\n    /// </summary>\n    [Obsolete(\"Use 'ZInputStream' instead\")]\n    public class ZInflaterInputStream : Stream {\n        protected ZStream z=new ZStream();\n        protected int flushLevel=JZlib.Z_NO_FLUSH;\n        private const int BUFSIZE = 4192;\n        protected byte[] buf=new byte[BUFSIZE];\n        private byte[] buf1=new byte[1];\n\n        protected Stream inp=null;\n        private bool nomoreinput=false;\n\n        public ZInflaterInputStream(Stream inp) : this(inp, false) {\n        }\n    \n        public ZInflaterInputStream(Stream inp, bool nowrap) {\n            this.inp=inp;\n            z.inflateInit(nowrap);\n            z.next_in=buf;\n            z.next_in_index=0;\n            z.avail_in=0;\n        }\n    \n        public override bool CanRead {\n            get {\n                // TODO:  Add DeflaterOutputStream.CanRead getter implementation\n                return true;\n            }\n        }\n    \n        public override bool CanSeek {\n            get {\n                // TODO:  Add DeflaterOutputStream.CanSeek getter implementation\n                return false;\n            }\n        }\n    \n        public override bool CanWrite {\n            get {\n                // TODO:  Add DeflaterOutputStream.CanWrite getter implementation\n                return false;\n            }\n        }\n    \n        public override long Length {\n            get {\n                // TODO:  Add DeflaterOutputStream.Length getter implementation\n                return 0;\n            }\n        }\n    \n        public override long Position {\n            get {\n                // TODO:  Add DeflaterOutputStream.Position getter implementation\n                return 0;\n            }\n            set {\n                // TODO:  Add DeflaterOutputStream.Position setter implementation\n            }\n        }\n    \n        public override void Write(byte[] b, int off, int len) {\n        }\n    \n        public override long Seek(long offset, SeekOrigin origin) {\n            // TODO:  Add DeflaterOutputStream.Seek implementation\n            return 0;\n        }\n    \n        public override void SetLength(long value) {\n            // TODO:  Add DeflaterOutputStream.SetLength implementation\n\n        }\n    \n        public override int Read(byte[] b, int off, int len) {\n            if(len==0)\n                return(0);\n            int err;\n            z.next_out=b;\n            z.next_out_index=off;\n            z.avail_out=len;\n            do {\n                if((z.avail_in==0)&&(!nomoreinput)) { // if buffer is empty and more input is avaiable, refill it\n                    z.next_in_index=0;\n                    z.avail_in=inp.Read(buf, 0, BUFSIZE);//(BUFSIZE<z.avail_out ? BUFSIZE : z.avail_out));\n                    if(z.avail_in<=0) {\n                        z.avail_in=0;\n                        nomoreinput=true;\n                    }\n                }\n                err=z.inflate(flushLevel);\n                if(nomoreinput&&(err==JZlib.Z_BUF_ERROR))\n                    return(0);\n                if(err!=JZlib.Z_OK && err!=JZlib.Z_STREAM_END)\n                    throw new IOException(\"inflating: \"+z.msg);\n                if((nomoreinput||err==JZlib.Z_STREAM_END)&&(z.avail_out==len))\n                    return(0);\n            } \n            while(z.avail_out==len&&err==JZlib.Z_OK);\n            //System.err.print(\"(\"+(len-z.avail_out)+\")\");\n            return(len-z.avail_out);\n        }\n    \n        public override void Flush() {\n            inp.Flush();\n        }\n    \n        public override void WriteByte(byte b) {\n        }\n\n        public override void Close() {\n            inp.Close();\n        }\n    \n        public override int ReadByte() {\n            if(Read(buf1, 0, 1)<=0)\n                return -1;\n            return(buf1[0]&0xFF);\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class DataGridViewLiveOutput : DataGridView\n    {\n        private List<string> idsList = new List<string>();\n        private readonly List<StatusInfo> ListStatus = new List<StatusInfo>();\n        private static SortableBindingList<LiveOutputEntry> _MyObservLiveOutputs;\n\n        private static int _itemssperpage = 50; //nb of items per page\n        private static readonly int _pagecount = 1;\n        private static int _currentpage = 1;\n        private static bool _initialized = false;\n        private static bool _refreshedatleastonetime = false;\n        private static string _statefilter = \"All\";\n        private static SearchObject _searchinname = new SearchObject { SearchType = SearchIn.LiveOutputName, Text = string.Empty };\n        private static string _timefilter = FilterTime.LastWeek;\n        private static TimeRangeValue _timefilterTimeRange = new TimeRangeValue(DateTime.Now.ToLocalTime().AddDays(-7).Date, null);\n        private static BackgroundWorker WorkerRefreshChannels;\n        public string _published = \"Published\";\n        private static readonly Bitmap Streaminglocatorimage = Bitmaps.streaming_locator;\n        private static enumDisplayProgram _anyChannel = enumDisplayProgram.Selected;\n        private AMSClientV3 _client;\n\n        public List<string> LiveEventSourceNames\n        {\n            get => idsList;\n            set => idsList = value;\n        }\n\n        public int ItemsPerPage\n        {\n            get => _itemssperpage;\n            set => _itemssperpage = value;\n        }\n\n\n        public int PageCount => _pagecount;\n        public int CurrentPage => _currentpage;\n\n        public enumDisplayProgram DisplayLiveEvent\n        {\n            get => _anyChannel;\n            set => _anyChannel = value;\n        }\n\n        public string FilterState\n        {\n            get => _statefilter;\n            set => _statefilter = value;\n\n        }\n        public SearchObject SearchInName\n        {\n            get => _searchinname;\n            set => _searchinname = value;\n        }\n        public bool Initialized => _initialized;\n        public string TimeFilter\n        {\n            get => _timefilter;\n            set => _timefilter = value;\n        }\n        public TimeRangeValue TimeFilterTimeRange\n        {\n            get => _timefilterTimeRange;\n            set => _timefilterTimeRange = value;\n        }\n        public int DisplayedCount => _MyObservLiveOutputs != null ? _MyObservLiveOutputs.Count() : 0;\n\n\n\n        public void Init(AMSClientV3 client)\n        {\n            IEnumerable<LiveOutputEntry> programquery;\n            client.RefreshTokenIfNeeded();\n\n            _client = client;\n            _client.RefreshTokenIfNeeded();\n\n            List<LiveEvent> ListEvents = _client.AMSclient.LiveEvents.List(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName).ToList();\n            List<Program.LiveOutputExt> LOList = new List<Program.LiveOutputExt>();\n\n            foreach (LiveEvent le in ListEvents)\n            {\n                List<LiveOutput> plist = _client.AMSclient.LiveOutputs.List(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, le.Name).ToList();\n                plist.ForEach(p => LOList.Add(new Program.LiveOutputExt() { LiveOutputItem = p, LiveEventName = le.Name }));\n            }\n\n            programquery = from c in (LOList.Take(0))\n                               //orderby c.LastModified descending\n                           select new LiveOutputEntry\n                           {\n                               Name = c.LiveOutputItem.Name,\n                               State = c.LiveOutputItem.ResourceState,\n                               Description = c.LiveOutputItem.Description,\n                               ArchiveWindowLength = c.LiveOutputItem.ArchiveWindowLength,\n                               LastModified = c.LiveOutputItem.LastModified != null ? (DateTime?)((DateTime)c.LiveOutputItem.LastModified).ToLocalTime() : null,\n                               Published = null,\n                               LiveEventName = c.LiveEventName\n                           };\n\n            DataGridViewCellStyle cellstyle = new DataGridViewCellStyle()\n            {\n                NullValue = null,\n                Alignment = DataGridViewContentAlignment.MiddleCenter\n            };\n            DataGridViewImageColumn imageCol = new DataGridViewImageColumn()\n            {\n                DefaultCellStyle = cellstyle,\n                Name = _published,\n                DataPropertyName = _published,\n            };\n            Columns.Add(imageCol);\n\n\n            SortableBindingList<LiveOutputEntry> MyObservProgramInPage = new SortableBindingList<LiveOutputEntry>(programquery.Take(0).ToList());\n            DataSource = MyObservProgramInPage;\n            //this.Columns[\"LiveEventName\"].Visible = false;\n            Columns[_published].DisplayIndex = ColumnCount - 3;\n            Columns[_published].DefaultCellStyle.NullValue = null;\n            Columns[_published].HeaderText = _published;\n            Columns[\"LastModified\"].Width = 130;\n            Columns[\"LastModified\"].HeaderText = \"Last modified\";\n            Columns[\"Description\"].Width = 150;\n            Columns[\"ArchiveWindowLength\"].Width = 130;\n            Columns[\"ArchiveWindowLength\"].HeaderText = \"Archive window\";\n            Columns[\"LiveEventName\"].HeaderText = \"Live event name\";\n\n            WorkerRefreshChannels = new BackgroundWorker\n            {\n                WorkerSupportsCancellation = true\n            };\n            WorkerRefreshChannels.DoWork += new System.ComponentModel.DoWorkEventHandler(WorkerRefreshChannels_DoWork);\n\n            _initialized = true;\n        }\n\n\n        public void DisplayPage(int page)\n        {\n            if (!_initialized)\n            {\n                return;\n            }\n\n            if (!_refreshedatleastonetime)\n            {\n                return;\n            }\n\n            if ((page <= _pagecount) && (page > 0))\n            {\n                _currentpage = page;\n                DataSource = new BindingList<LiveOutputEntry>(_MyObservLiveOutputs.Skip(_itemssperpage * (page - 1)).Take(_itemssperpage).ToList());\n            }\n        }\n\n        public void RefreshProgram(string liveeventName, LiveOutput program)\n        {\n            int index = -1;\n\n            if (_MyObservLiveOutputs != null)\n            {\n                foreach (LiveOutputEntry CE in _MyObservLiveOutputs) // let's search for index\n                {\n                    if (CE.Name == program.Name)\n                    {\n                        index = _MyObservLiveOutputs.IndexOf(CE);\n                        break;\n                    }\n                }\n            }\n\n            if (index >= 0) // we found it\n            { // we update the observation collection\n                _client.RefreshTokenIfNeeded();\n\n                program = _client.AMSclient.LiveOutputs.Get(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, liveeventName, program.Name); //refresh\n                if (program != null)\n                {\n                    try // sometimes, index could be wrong id program has been deleted\n                    {\n                        _MyObservLiveOutputs[index].State = program.ResourceState;\n                        _MyObservLiveOutputs[index].Description = program.Description;\n                        _MyObservLiveOutputs[index].ArchiveWindowLength = program.ArchiveWindowLength;\n                        _MyObservLiveOutputs[index].LastModified = program.LastModified != null ? (DateTime?)((DateTime)program.LastModified).ToLocalTime() : null;\n                        Refresh();\n                    }\n                    catch\n                    {\n                    }\n                }\n            }\n        }\n\n        private void WorkerRefreshChannels_DoWork(object sender, DoWorkEventArgs e)\n        {\n            Debug.WriteLine(\"WorkerRefreshChannels_DoWork\");\n            BackgroundWorker worker = sender as BackgroundWorker;\n            LiveOutput liveOutputItem;\n            _client.RefreshTokenIfNeeded();\n\n            foreach (LiveOutputEntry CE in _MyObservLiveOutputs)\n            {\n\n                liveOutputItem = null;\n                try\n                {\n                    liveOutputItem = _client.AMSclient.LiveOutputs.Get(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, CE.LiveEventName, CE.Name);\n                    if (liveOutputItem != null)\n                    {\n                        CE.State = liveOutputItem.ResourceState;\n                        BeginInvoke(new Action(() => Refresh()), null);\n                    }\n                }\n                catch // in some case, we have a timeout on Assets.Where...\n                {\n\n                }\n                if (worker.CancellationPending == true)\n                {\n                    e.Cancel = true;\n                    return;\n                }\n            }\n            BeginInvoke(new Action(() => Refresh()), null);\n        }\n\n        private void RefreshPrograms() // all assets are refreshed\n        {\n            Task.Run(async () => await RefreshLiveOutputsAsync(_currentpage));\n\n        }\n\n        public async Task RefreshLiveOutputsAsync(int pagetodisplay) // all assets are refreshed\n        {\n            if (!_initialized)\n            {\n                return;\n            }\n\n            if (idsList.Count == 0)\n            {\n                return;\n            }\n\n            Debug.WriteLine(\"RefreshPrograms : start\");\n\n            BeginInvoke(new Action(() => FindForm().Cursor = Cursors.WaitCursor));\n\n            await _client.RefreshTokenIfNeededAsync();\n\n            IEnumerable<LiveEvent> ListEvents;\n            if (_anyChannel == enumDisplayProgram.None)\n            {\n                ListEvents = new List<LiveEvent>();\n            }\n            else\n            {\n                ListEvents = (await _client.AMSclient.LiveEvents.ListAsync(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName))\n                    .ToList()\n                    .Where(l => _anyChannel == enumDisplayProgram.Any || (_anyChannel == enumDisplayProgram.Selected && LiveEventSourceNames.Contains(l.Name)));\n            }\n\n\n            List<Program.LiveOutputExt> LOList = new List<Program.LiveOutputExt>();\n\n            foreach (LiveEvent le in ListEvents)\n            {\n                List<LiveOutput> plist = (await _client.AMSclient.LiveOutputs.ListAsync(_client.credentialsEntry.ResourceGroup, _client.credentialsEntry.AccountName, le.Name))\n                    .ToList();\n                plist.ForEach(p => LOList.Add(new Program.LiveOutputExt() { LiveOutputItem = p, LiveEventName = le.Name }));\n            }\n\n            IEnumerable<LiveOutputEntry> programquery = from c in (LOList)\n                                                            //orderby c.LastModified descending\n                                                        select new LiveOutputEntry\n                                                        {\n                                                            Name = c.LiveOutputItem.Name,\n                                                            State = c.LiveOutputItem.ResourceState,\n                                                            Description = c.LiveOutputItem.Description,\n                                                            ArchiveWindowLength = c.LiveOutputItem.ArchiveWindowLength,\n                                                            LastModified = c.LiveOutputItem.LastModified != null ? (DateTime?)((DateTime)c.LiveOutputItem.LastModified).ToLocalTime() : null,\n                                                            Published = DataGridViewAssets.BuildBitmapPublication(c.LiveOutputItem.AssetName, _client).bitmap,\n                                                            LiveEventName = c.LiveEventName\n                                                        };\n\n\n\n            _MyObservLiveOutputs = new SortableBindingList<LiveOutputEntry>(programquery.ToList());\n            BeginInvoke(new Action(() => DataSource = _MyObservLiveOutputs));\n            _refreshedatleastonetime = true;\n\n            BeginInvoke(new Action(() => FindForm().Cursor = Cursors.Default));\n\n            Debug.WriteLine(\"RefreshPrograms : end\");\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    public class CameraDeviceManager : BaseFieldClass\n    {\n        private const string AppName = \"CameraControl\";\n        private const int AppMajorVersionNumber = 1;\n        private const int AppMinorVersionNumber = 0;\n        private bool _connectionInProgress = false;\n        private DeviceDescriptorEnumerator _deviceEnumerator;\n        private EosFramework _framework;\n        private object _locker = new object();\n        private List<DeviceDescription> _deviceDescriptions = new List<DeviceDescription>();\n\n        public ConcurrentDictionary<ICameraDevice, byte[]> LiveViewImage;\n        public ConcurrentDictionary<ICameraDevice, string> LastCapturedImage;\n\n        /// <summary>\n        /// Gets or sets a value indicating whether use experimental drivers.\n        /// Experimental drivers isn't tested and may not implement all camera possibilities \n        /// </summary>\n        /// <value>\n        /// <c>true</c> if [use experimental drivers]; otherwise, <c>false</c>.\n        /// </value>\n        public bool UseExperimentalDrivers { get; set; }\n\n        public bool LoadWiaDevices { get; set; }\n\n        /// <summary>\n        /// Gets or sets the natively supported model dictionary.\n        /// This property is used to find the right driver for connected camera, \n        /// if model not found in this dictionary generic wia driver will used.\n        /// </summary>\n        /// <value>\n        /// The device class.\n        /// </value>\n        public static Dictionary<string, Type> DeviceClass { get; set; }\n        public Dictionary<string, Type> CustomDeviceClass { get; set; }\n\n        public List<IWifiDeviceProvider> WifiDeviceProviders { get; set; }\n\n        private ICameraDevice _selectedCameraDevice;\n\n        /// <summary>\n        /// Gets or sets the default selected camera device. When new camera connected this property set automatically to new device\n        /// </summary>\n        /// <value>\n        /// The selected camera device.\n        /// </value>\n        public ICameraDevice SelectedCameraDevice\n        {\n            get { return _selectedCameraDevice; }\n            set\n            {\n                ICameraDevice device = _selectedCameraDevice;\n                _selectedCameraDevice = value ?? (ConnectedDevices.Count > 0\n                    ? ConnectedDevices[0]\n                    : new NotConnectedCameraDevice());\n\n                CameraSelected?.Invoke(device, _selectedCameraDevice);\n\n                NotifyPropertyChanged(\"SelectedCameraDevice\");\n            }\n        }\n\n        /// <summary>\n        /// If enabled the application will detect the connected webcams\n        /// </summary>\n        /// <value>\n        ///   <c>true</c> if [detect webcams]; otherwise, <c>false</c>.\n        /// </value>\n        public bool DetectWebcams { get; set; }\n\n\n        public bool StartInNewThread { get; set; }\n\n        private AsyncObservableCollection<ICameraDevice> _connectedDevices;\n\n        public AsyncObservableCollection<ICameraDevice> ConnectedDevices\n        {\n            get { return _connectedDevices; }\n            set\n            {\n                _connectedDevices = value;\n                NotifyPropertyChanged(\"ConnectedDevices\");\n            }\n        }\n\n        private void PopulateDeviceClass()\n        {\n            DeviceClass = new Dictionary<string, Type>\n            {\n                {\"D200\", typeof(NikonD40)},\n                {\"D3\", typeof(NikonD90)},\n                {\"D3S\", typeof(NikonD90)},\n                {\"D3X\", typeof(NikonD3X)},\n                {\"D300\", typeof(NikonD300)},\n                {\"D300s\", typeof(NikonD300)},\n                {\"D300S\", typeof(NikonD300)},\n                {\"D3200\", typeof(NikonD3200)},\n                {\"D3300\", typeof(NikonD600Base)},\n                {\"D3400\", typeof(NikonD600Base)},\n                {\"D3500\", typeof(NikonD600Base)},\n                {\"D4\", typeof(NikonD4)},\n                {\"D4s\", typeof(NikonD4)},\n                {\"D4S\", typeof(NikonD4)},\n                {\"D40\", typeof(NikonD40)},\n                {\"D40X\", typeof(NikonD40)},\n                {\"D5\", typeof(NikonD5)},\n                {\"D50\", typeof(NikonD40)},\n                {\"D500\", typeof(NikonD500)},\n                {\"D5600\", typeof(NikonD5200)},\n                {\"D5500\", typeof(NikonD5200)},\n                {\"D5300\", typeof(NikonD5200)},\n                {\"D5200\", typeof(NikonD5200)},\n                {\"D5100\", typeof(NikonD5100)},\n                {\"D5000\", typeof(NikonD90)},\n                {\"D60\", typeof(NikonD60)},\n                {\"D610\", typeof(NikonD600Base)},\n                {\"D600\", typeof(NikonD600)},\n                {\"D70\", typeof(NikonD40)},\n                {\"D70s\", typeof(NikonD40)},\n                {\"D700\", typeof(NikonD700)},\n                {\"D750\", typeof(NikonD750)},\n                {\"D7000\", typeof(NikonD7000)},\n                {\"D7100\", typeof(NikonD7100)},\n                {\"D7200\", typeof(NikonD7100)},\n                {\"D7500\", typeof(NikonD7500)},\n                {\"D80\", typeof(NikonD80)},\n                {\"D800\", typeof(NikonD800)},\n                {\"D800E\", typeof(NikonD800)},\n                {\"D800e\", typeof(NikonD800)},\n                {\"D810\", typeof(NikonD810)},\n                {\"D810A\", typeof(NikonD810)},\n                {\"D810a\", typeof(NikonD810)},\n                {\"D850\", typeof(NikonD850)},\n                {\"D90\", typeof(NikonD90)},\n                {\"V1\", typeof(NikonD5100)},\n                {\"V2\", typeof(NikonD5100)},\n                {\"V3\", typeof(NikonD600Base)},\n                {\"J3\", typeof(NikonD600Base)},\n                {\"J4\", typeof(NikonD600Base)},\n                {\"Df\", typeof(NikonD600Base)},\n                {\"L830\", typeof(NikonL830)},\n                {\"L840\", typeof(NikonL830)},\n                {\"Z 6\", typeof(NikonZ6)},\n                {\"Z 7\", typeof(NikonZ7)},\n                //{\"Canon EOS 5D Mark II\", typeof (CanonSDKBase)},\n                {\"MTP Sim\", typeof(BaseMTPCamera)},\n                //{\"D.*\", typeof (NikonBase)},\n                // for mtp simulator\n                //{\"Test Camera \", typeof (NikonBase)},\n            };\n            //if(UseExperimentalDrivers)\n            //{\n            //  DeviceClass.Add(\"Canon EOS.*\", typeof(CanonSDKBase));\n            //}\n            WifiDeviceProviders.Add(new DDServerProvider());\n            WifiDeviceProviders.Add(new PtpIpProvider());\n            WifiDeviceProviders.Add(new YiCameraProvider());\n            WifiDeviceProviders.Add(new SonyProvider());\n            WifiDeviceProviders.Add(new PanonoProvider());\n            WifiDeviceProviders.Add(new OscProvider());\n            foreach (var type in CustomDeviceClass)\n            {\n                DeviceClass.Add(type.Key, type.Value);\n            }\n        }\n\n        public CameraDeviceManager(string datafolder=null)\n        {\n            UseExperimentalDrivers = true;\n            LoadWiaDevices = true;\n            StartInNewThread = false;\n            DetectWebcams = true;\n            CustomDeviceClass = new Dictionary<string, Type>();\n            SelectedCameraDevice = new NotConnectedCameraDevice();\n            ConnectedDevices = new AsyncObservableCollection<ICameraDevice>();\n            _deviceEnumerator = new DeviceDescriptorEnumerator();\n            LiveViewImage = new ConcurrentDictionary<ICameraDevice, byte[]>();\n            LastCapturedImage = new ConcurrentDictionary<ICameraDevice, string>();\n            WifiDeviceProviders = new List<IWifiDeviceProvider>();\n\n\n            // prevent program crash in something wrong with wia\n            try\n            {\n                WiaDeviceManager = new DeviceManager();\n                WiaDeviceManager.RegisterEvent(Conts.wiaEventDeviceConnected, \"*\");\n                WiaDeviceManager.RegisterEvent(Conts.wiaEventDeviceDisconnected, \"*\");\n                WiaDeviceManager.OnEvent += DeviceManager_OnEvent;\n                Log.Error(\"Wia initialized\");\n            }\n            catch (Exception exception)\n            {\n                Log.Error(\"Error initialize WIA\", exception);\n            }\n            if (datafolder != null && Directory.Exists(datafolder))\n            {\n                try\n                {\n                    var files = Directory.GetFiles(datafolder, \"*.xml\");\n                    foreach (var file in files)\n                    {\n                        var device = DeviceDescription.Load(file);\n                        if (device != null)\n                            _deviceDescriptions.Add(device);\n                    }\n                }\n                catch (Exception)\n                {\n                    Log.Error(\"Error loading custom data\");\n                }\n            }\n        }\n\n        private void InitCanon()\n        {\n            try\n            {\n                if (_framework == null)\n                {\n                    _framework = new EosFramework();\n                    _framework.CameraAdded += _framework_CameraAdded;\n                }\n                AddCanonCameras();\n            }\n            catch (Exception exception)\n            {\n                Log.Error(\"Unable init canon driver\", exception);\n                /* Give specific guidance if the error is a missing DLL */\n                if ((exception.InnerException != null) && (exception.InnerException.Message != null) && (exception.InnerException.Message.Contains(\"EDSDK.dll\")))\n                {\n                    Console.WriteLine(\"\\n**CRITICAL ERROR**\\n\\nCanon EOS camera library, EDSDK.dll is missing\\nInstall it after downloading from Canon's site\\n\");\n                }\n            }\n        }\n\n        private void _framework_CameraAdded(object sender, EventArgs e)\n        {\n            AddCanonCameras();\n        }\n\n        public IEnumerable<EosCamera> GetEosCameras()\n        {\n            using (EosCameraCollection cameras = _framework.GetCameraCollection())\n                return cameras.ToArray();\n        }\n\n        private void AddWebcameras()\n        {\n            try\n            {\n                List<string> monikers = new List<string>();\n                var loaclWebCamsCollection = new FilterInfoCollection(FilterCategory.VideoInputDevice);\n                foreach (Accord.Video.DirectShow.FilterInfo localcamera in loaclWebCamsCollection)\n                {\n                    monikers.Add(localcamera.MonikerString);\n                    bool added = false;\n                    foreach (ICameraDevice device in ConnectedDevices)\n                    {\n                        WebCameraDevice webCamera = device as WebCameraDevice;\n                        if (webCamera != null)\n                        {\n                            if (webCamera.PortName == localcamera.MonikerString)\n                            {\n                                added = true;\n                            }\n                        }\n                    }\n\n                    if (added)\n                        continue;\n\n                    WebCameraDevice camera = new WebCameraDevice();\n                    camera.Init(localcamera.MonikerString);\n                    camera.DeviceName = localcamera.Name;\n                    camera.SerialNumber = localcamera.MonikerString;\n\n                    ConnectedDevices.Add(camera);\n\n                    SelectedCameraDevice = camera;\n\n                    camera.PhotoCaptured += cameraDevice_PhotoCaptured;\n                    camera.CameraDisconnected += cameraDevice_CameraDisconnected;\n\n                    CameraConnected?.Invoke(camera);\n                }\n                //List<WebCameraDevice> devicesToDisconnect = ConnectedDevices.OfType<WebCameraDevice>()\n                //    .Where(webCamera => !monikers.Contains(webCamera.PortName))\n                //    .ToList();\n                //foreach (var webCamera in devicesToDisconnect)\n                //{\n                //    cameraDevice_CameraDisconnected(webCamera, new DisconnectCameraEventArgs() { });\n                //}\n            }\n            catch (Exception ex)\n            {\n                Log.Error(\"Unable to connect to a webcamera\", ex);\n            }\n\n        }\n\n        private void AddCanonCameras()\n        {\n            lock (_locker)\n            {\n                foreach (EosCamera eosCamera in GetEosCameras())\n                {\n                    bool shouldbeadded =\n                        ConnectedDevices.OfType<CanonSDKBase>().All(camera => camera.PortName != eosCamera.PortName);\n\n                    if (shouldbeadded)\n                    {\n                        Log.Debug(\"New canon camera found !\");\n                        CanonSDKBase camera = new CanonSDKBase();\n                        Log.Debug(\"Pas 1\");\n                        DeviceDescriptor descriptor = new DeviceDescriptor {EosCamera = eosCamera};\n                        descriptor.CameraDevice = camera;\n                        Log.Debug(\"Pas 2\");\n                        camera.Init(eosCamera);\n                        Log.Debug(\"Pas 3\");\n                        ConnectedDevices.Add(camera);\n                        Log.Debug(\"Pas 4\");\n                        _deviceEnumerator.Add(descriptor);\n                        Log.Debug(\"Pas 5\");\n                        NewCameraConnected(camera);\n                        Log.Debug(\"New canon camera found done!\");\n                    }\n                }\n                //Thread.Sleep(2500);\n            }\n        }\n\n        private ICameraDevice GetWiaIDevice(IDeviceInfo devInfo)\n        {\n            // if camera already is connected do nothing\n            if (_deviceEnumerator.GetByWiaId(devInfo.DeviceID) != null)\n                return _deviceEnumerator.GetByWiaId(devInfo.DeviceID).CameraDevice;\n            _deviceEnumerator.RemoveDisconnected();\n            DeviceDescriptor descriptor = new DeviceDescriptor {WiaDeviceInfo = devInfo, WiaId = devInfo.DeviceID};\n\n            ICameraDevice cameraDevice = new WiaCameraDevice();\n            bool isConnected = cameraDevice.Init(descriptor);\n\n            descriptor.CameraDevice = cameraDevice;\n            _deviceEnumerator.Add(descriptor);\n            ConnectedDevices.Add(cameraDevice);\n\n            if (isConnected)\n            {\n                NewCameraConnected(cameraDevice);\n            }\n            //ServiceProvider.DeviceManager.SelectedCameraDevice.ReadDeviceProperties(0);\n\n            return SelectedCameraDevice;\n        }\n\n        private void cameraDevice_CameraDisconnected(object sender, DisconnectCameraEventArgs e)\n        {\n            if (e.StillImageDevice != null)\n            {\n                DisconnectCamera(e.StillImageDevice);\n            }\n            if (e.EosCamera != null)\n            {\n                DisconnectCamera(e.EosCamera);\n            }\n            OnCameraDisconnected((ICameraDevice) sender);\n        }\n\n        /// <summary>\n        /// Raise CameraDisconnected event.\n        /// </summary>\n        /// <param name=\"cameraDevice\">The camera device.</param>\n        public void OnCameraDisconnected(ICameraDevice cameraDevice)\n        {\n            if (CameraDisconnected != null)\n                CameraDisconnected(cameraDevice);\n        }\n\n        private void cameraDevice_PhotoCaptured(object sender, PhotoCapturedEventArgs eventArgs)\n        {\n            if (PhotoCaptured != null)\n                PhotoCaptured(sender, eventArgs);\n        }\n\n        public void OnPhotoCaptured(object sender, PhotoCapturedEventArgs eventArgs)\n        {\n            if (PhotoCaptured != null)\n                PhotoCaptured(sender, eventArgs);\n        }\n\n        private void ConnectDevices()\n        {\n            if (_connectionInProgress)\n                return;\n            _connectionInProgress = true;\n            if (PortableDeviceCollection.Instance == null)\n            {\n                PortableDeviceCollection.CreateInstance(AppName, AppMajorVersionNumber, AppMinorVersionNumber);\n                PortableDeviceCollection.Instance.AutoConnectToPortableDevice = false;\n            }\n            _deviceEnumerator.RemoveDisconnected();\n\n            Log.Debug(\"Connection device start\" );\n            try\n            {\n                var devices = PortableDeviceCollection.Instance.Devices;\n                foreach (PortableDevice portableDevice in devices)\n                {\n                    Log.Debug(\"Connection device \" + portableDevice.DeviceId);\n                    //TODO: avoid to load some mass storage in my computer need to find a general solution\n                    if (!portableDevice.DeviceId.StartsWith(\"\\\\\\\\?\\\\usb\") &&\n                        !portableDevice.DeviceId.StartsWith(\"\\\\\\\\?\\\\comp\"))\n                        continue;\n                    // ignore some Canon cameras\n                    if (!SupportedCanonCamera(portableDevice.DeviceId))\n                        continue;\n                    portableDevice.ConnectToDevice(AppName, AppMajorVersionNumber, AppMinorVersionNumber);\n\n                    if (_deviceEnumerator.GetByWpdId(portableDevice.DeviceId) == null &&\n                        GetNativeDriver(portableDevice.Model) != null)\n                    {\n                        ICameraDevice cameraDevice;\n                        DeviceDescriptor descriptor = new DeviceDescriptor {WpdId = portableDevice.DeviceId};\n                        cameraDevice = (ICameraDevice) Activator.CreateInstance(GetNativeDriver(portableDevice.Model));\n                        MtpProtocol device = new MtpProtocol(descriptor.WpdId);\n                        device.ConnectToDevice(AppName, AppMajorVersionNumber, AppMinorVersionNumber);\n\n                        descriptor.StillImageDevice = device;\n\n                        cameraDevice.SerialNumber = StaticHelper.GetSerial(portableDevice.DeviceId);\n                        cameraDevice.Init(descriptor);\n\n                        if (string.IsNullOrWhiteSpace(cameraDevice.SerialNumber))\n                            cameraDevice.SerialNumber = StaticHelper.GetSerial(portableDevice.DeviceId);\n\n                        ConnectedDevices.Add(cameraDevice);\n                        NewCameraConnected(cameraDevice);\n\n                        descriptor.CameraDevice = cameraDevice;\n                        _deviceEnumerator.Add(descriptor);\n                    }\n\n                    if (_deviceEnumerator.GetByWpdId(portableDevice.DeviceId) == null &&\n                        GetNativeDriver(portableDevice.Model) == null)\n                    {\n                        var description = getDeviceDescription(portableDevice.Model);\n                        if (description != null)\n                        {\n                            CustomDevice cameraDevice = new CustomDevice();\n                            DeviceDescriptor descriptor = new DeviceDescriptor {WpdId = portableDevice.DeviceId};\n                            MtpProtocol device = new MtpProtocol(descriptor.WpdId);\n                            device.ConnectToDevice(AppName, AppMajorVersionNumber, AppMinorVersionNumber);\n\n                            descriptor.StillImageDevice = device;\n\n                            cameraDevice.SerialNumber = StaticHelper.GetSerial(portableDevice.DeviceId);\n                            cameraDevice.Init(descriptor, description);\n\n                            ConnectedDevices.Add(cameraDevice);\n                            NewCameraConnected(cameraDevice);\n\n                            descriptor.CameraDevice = cameraDevice;\n                            _deviceEnumerator.Add(descriptor);\n                            break;\n                        }\n\n                    }\n\n                }\n\n            }\n            catch (Exception exception)\n            {\n                Log.Error(\"Unable to connect to cameras \", exception);\n            }\n\n            _connectionInProgress = false;\n        }\n\n        private DeviceDescription getDeviceDescription(string model)\n        {\n            return _deviceDescriptions.FirstOrDefault(description => description.Model == model);\n        }\n\n        public void AddDevice(DeviceDescriptor descriptor)\n        {\n            _deviceEnumerator.RemoveDisconnected();\n            ConnectedDevices.Add(descriptor.CameraDevice);\n            NewCameraConnected(descriptor.CameraDevice);\n            _deviceEnumerator.Add(descriptor);\n        }\n\n        public void ConnectToServer(string s, int type)\n        {\n            if(string.IsNullOrEmpty(s))\n                return;\n            \n            if (type == 0)\n            {\n                int port = 15740;\n                string ip = s;\n                if (s.Contains(\":\"))\n                {\n                    ip = s.Split(':')[0];\n                    int.TryParse(s.Split(':')[1], out port);\n                }\n                ConnectDevicesPtpIp(ip, port);\n            }\n\n            if (type == 1)\n            {\n                int port = 4757;\n                string ip = s;\n                if (s.Contains(\":\"))\n                {\n                    ip = s.Split(':')[0];\n                    int.TryParse(s.Split(':')[1], out port);\n                }\n                ConnectDevicesDDServer(ip, port);\n            }\n        }\n\n        public void ConnectDevicesDDServer(string ip, int port)\n        {\n            if (_connectionInProgress)\n                return;\n            try\n            {\n                _connectionInProgress = true;\n                _deviceEnumerator.RemoveDisconnected();\n                DdClient client = new DdClient();\n                if (!client.Open(ip, port))\n                    throw new Exception(\"No server was found!\");\n                var devices = client.GetDevices();\n                if (devices.Count == 0)\n                    throw new Exception(\"No connected device was found!\");\n\n                client.Connect(devices[0]);\n                DdServerProtocol protocol = new DdServerProtocol(client);\n\n                if (GetNativeDriver(protocol.Model) != null)\n                {\n                    ICameraDevice cameraDevice;\n                    DeviceDescriptor descriptor = new DeviceDescriptor {WpdId = \"ddserver\"};\n                    cameraDevice = (ICameraDevice) Activator.CreateInstance(GetNativeDriver(protocol.Model));\n                    descriptor.StillImageDevice = protocol;\n\n                    //cameraDevice.SerialNumber = StaticHelper.GetSerial(portableDevice.DeviceId);\n                    cameraDevice.Init(descriptor);\n                    ConnectedDevices.Add(cameraDevice);\n                    NewCameraConnected(cameraDevice);\n\n                    descriptor.CameraDevice = cameraDevice;\n                    _deviceEnumerator.Add(descriptor);\n                }\n                else\n                {\n                    throw new Exception(\"Not Supported device \" + protocol.Model);\n                }\n            }\n            finally\n            {\n                _connectionInProgress = false;\n            }\n        }\n\n        public void ConnectDevicesPtpIp(string ip, int port)\n        {\n            if (_connectionInProgress)\n                return;\n            try\n            {\n                _connectionInProgress = true;\n                _deviceEnumerator.RemoveDisconnected();\n\n                PtpIpClient client = new PtpIpClient();\n                if (!client.Open(ip, 15740))\n                    throw new Exception(\"No server was found!\");\n                PtpIpProtocol protocol = new PtpIpProtocol(client);\n                protocol.ExecuteWithNoData(0x1002, 1);\n\n                if (GetNativeDriver(protocol.Model) != null)\n                {\n                    ICameraDevice cameraDevice;\n                    DeviceDescriptor descriptor = new DeviceDescriptor { WpdId = \"ptpip\" };\n                    cameraDevice = (ICameraDevice)Activator.CreateInstance(GetNativeDriver(protocol.Model));\n                    descriptor.StillImageDevice = protocol;\n\n                    //cameraDevice.SerialNumber = StaticHelper.GetSerial(portableDevice.DeviceId);\n                    cameraDevice.Init(descriptor);\n                    ConnectedDevices.Add(cameraDevice);\n                    NewCameraConnected(cameraDevice);\n\n                    descriptor.CameraDevice = cameraDevice;\n                    _deviceEnumerator.Add(descriptor);\n                }\n                else\n                {\n                    throw new Exception(\"Not Supported device \" + protocol.Model);\n                }\n            }\n            finally\n            {\n                _connectionInProgress = false;\n            }\n        }\n\n        private bool SupportedCanonCamera(string id)\n        {\n            // isn't canon the manufacturer \n            if (!id.Contains(\"vid_04a9\"))\n                return true;\n            return false;\n        }\n\n\n        private void NewCameraConnected(ICameraDevice cameraDevice)\n        {\n            const string usbPrefix = \"\\\\\\\\?\\\\usb\";\n\n            StaticHelper.Instance.SystemMessage = \"New Camera is connected ! Driver :\" + cameraDevice.DeviceName;\n            Log.Debug(\"===========Camera is connected==============\");\n\n            if (cameraDevice.PortName != null && cameraDevice.PortName.Substring(0, usbPrefix.Length).Equals(usbPrefix))\n            {\n                string vid = \"\";\n                string pid = \"\";\n                char[] delimiterChars = { '#', '&', '_' };\n\n                string[] words = cameraDevice.PortName.Split(delimiterChars);\n\n                for (int i = 1; i < words.Length - 1; i++)\n                {\n                    if (words[i].Equals(\"pid\"))\n                        pid = words[i + 1];\n                    else if (words[i].Equals(\"vid\"))\n                        vid = words[i + 1];\n                }\n\n                if (!vid.Equals(\"\") && !pid.Equals(\"\"))\n                    Log.Debug(\"USB : VID=\" + vid + \", PID=\" + pid);\n            }\n\n            Log.Debug(\"Driver :\" + cameraDevice.GetType().Name);\n            Log.Debug(\"Name :\" + cameraDevice.DeviceName);\n            Log.Debug(\"Manufacturer :\" + cameraDevice.Manufacturer);\n            if (CameraConnected != null)\n                CameraConnected(cameraDevice);\n            SelectedCameraDevice = cameraDevice;\n            cameraDevice.PhotoCaptured += cameraDevice_PhotoCaptured;\n            cameraDevice.CameraDisconnected += cameraDevice_CameraDisconnected;\n        }\n\n        /// <summary>\n        /// Gets the native driver based on camera model.\n        /// </summary>\n        /// <param name=\"model\">The model name.</param>\n        /// <returns>If the model not supported return null else the driver type</returns>\n        public static Type GetNativeDriver(string model)\n        {\n            if (String.IsNullOrEmpty(model))\n                return null;\n            // first check if driver exist with same driver name\n            if (DeviceClass.ContainsKey(model))\n                return DeviceClass[model];\n            return null;\n            //// in driver not found will check with regex name\n            //return (from keyValuePair in DeviceClass\n            //        let regex = new Regex(keyValuePair.Key)\n            //        where regex.IsMatch(model)\n            //        select keyValuePair.Value).FirstOrDefault();\n        }\n\n        [HandleProcessCorruptedStateExceptions]\n        public void DisconnectCamera(ICameraDevice cameraDevice)\n        {\n\n            cameraDevice.PhotoCaptured -= cameraDevice_PhotoCaptured;\n            cameraDevice.CameraDisconnected -= cameraDevice_CameraDisconnected;\n            ConnectedDevices.Remove(cameraDevice);\n            StaticHelper.Instance.SystemMessage = \"Camera disconnected :\" + cameraDevice.DeviceName;\n            Log.Debug(\"===========Camera disconnected==============\");\n            Log.Debug(\"Name :\" + cameraDevice.DeviceName);\n\n            cameraDevice.Close();\n            OnCameraDisconnected(cameraDevice);\n        }\n\n        private void DisconnectCamera(string wiaId)\n        {\n            DeviceDescriptor descriptor = _deviceEnumerator.GetByWiaId(wiaId);\n            if (descriptor != null)\n            {\n                descriptor.CameraDevice.PhotoCaptured -= cameraDevice_PhotoCaptured;\n                descriptor.CameraDevice.CameraDisconnected -= cameraDevice_CameraDisconnected;\n                ConnectedDevices.Remove(descriptor.CameraDevice);\n                StaticHelper.Instance.SystemMessage = \"Camera disconnected :\" + descriptor.CameraDevice.DeviceName;\n                Log.Debug(\"===========Camera disconnected==============\");\n                Log.Debug(\"Name :\" + descriptor.CameraDevice.DeviceName);\n\n                _deviceEnumerator.Remove(descriptor);\n                descriptor.CameraDevice.Close();\n                var wiaCameraDevice = descriptor.CameraDevice as WiaCameraDevice;\n                if (wiaCameraDevice != null)\n                {\n                    OnCameraDisconnected(wiaCameraDevice);\n                }\n                if (PortableDeviceCollection.Instance != null)\n                    PortableDeviceCollection.Instance.RefreshDevices();\n            }\n        }\n\n        private void DisconnectCamera(ITransferProtocol device)\n        {\n            DeviceDescriptor descriptor = _deviceEnumerator.GetByWpdId(device.DeviceId);\n            if (descriptor != null)\n            {\n                descriptor.CameraDevice.PhotoCaptured -= cameraDevice_PhotoCaptured;\n                descriptor.CameraDevice.CameraDisconnected -= cameraDevice_CameraDisconnected;\n                StaticHelper.Instance.SystemMessage = \"Camera disconnected :\" + descriptor.CameraDevice.DeviceName;\n                Log.Debug(\"===========Camera disconnected==============\");\n                Log.Debug(\"Name :\" + descriptor.CameraDevice.DeviceName);\n                PortableDeviceCollection.Instance.RemoveDevice(device.DeviceId);\n                device.IsConnected = false;\n                ConnectedDevices.Remove(descriptor.CameraDevice);\n                descriptor.CameraDevice.Close();\n                _deviceEnumerator.Remove(descriptor);\n                _deviceEnumerator.RemoveDisconnected();\n            }\n            RemoveDisconnected();\n        }\n\n        private void DisconnectCamera(EosCamera device)\n        {\n            DeviceDescriptor descriptor = _deviceEnumerator.GetByEosCamera(device);\n            if (descriptor != null)\n            {\n                descriptor.CameraDevice.PhotoCaptured -= cameraDevice_PhotoCaptured;\n                descriptor.CameraDevice.CameraDisconnected -= cameraDevice_CameraDisconnected;\n                StaticHelper.Instance.SystemMessage = \"Camera disconnected :\" + descriptor.CameraDevice.DeviceName;\n                Log.Debug(\"===========Camera disconnected==============\");\n                Log.Debug(\"Name :\" + descriptor.CameraDevice.DeviceName);\n                ConnectedDevices.Remove(descriptor.CameraDevice);\n                descriptor.CameraDevice.Close();\n                _deviceEnumerator.Remove(descriptor);\n                _deviceEnumerator.RemoveDisconnected();\n            }\n            RemoveDisconnected();\n        }\n\n        private void RemoveDisconnected()\n        {\n            List<ICameraDevice> removedCameras = ConnectedDevices.Where(device => !device.IsConnected).ToList();\n            foreach (ICameraDevice device in removedCameras)\n            {\n                ConnectedDevices.Remove(device);\n            }\n        }\n\n        private DeviceManager WiaDeviceManager { get; set; }\n\n        /// <summary>\n        /// Gets or sets a value for disabling native drivers.\n        /// </summary>\n        /// <value>\n        /// <c>true</c> all devices are loaded like WIA devices <c>false</c> If native driver are available for connected model the will be loaded that driver else will be loaded WIA driver.\n        /// </value>\n        public bool DisableNativeDrivers { get; set; }\n\n\n        private void DeviceManager_OnEvent(string eventId, string deviceId, string itemId)\n        {\n            //if (!LoadWiaDevices)\n            //    return;\n\n            if (eventId == Conts.wiaEventDeviceConnected)\n            {\n                if (StartInNewThread)\n                {\n                    Thread _thread = new Thread(() => ConnectToCamera(true));\n                    _thread.SetApartmentState(ApartmentState.MTA);\n                    _thread.Start();\n                }\n                else\n                {\n                    ConnectToCamera(true);\n                }\n            }\n            else if (eventId == Conts.wiaEventDeviceDisconnected)\n            {\n                DisconnectCamera(deviceId);\n            }\n        }\n\n\n        public bool ConnectToCamera()\n        {\n            if (UseExperimentalDrivers)\n                InitCanon();\n            return ConnectToCamera(true);\n        }\n\n        public void AddFakeCamera()\n        {\n            FakeCameraDevice device = new FakeCameraDevice();\n            ConnectedDevices.Add(device);\n            NewCameraConnected(device);\n        }\n\n        /// <summary>\n        /// Populate the ConnectedDevices list with connected cameras. This method will be called automatically every time new devices will be connected \n        /// Except Canon cameras that is handled by framework event handler\n        /// </summary>\n        /// <returns></returns>\n        public bool ConnectToCamera(bool retry)\n        {\n            if (DeviceClass == null || DeviceClass.Count == 0)\n                PopulateDeviceClass();\n\n            if(DetectWebcams)\n                AddWebcameras();\n\n            if (!DisableNativeDrivers)\n            {\n                ConnectDevices();\n            }\n            else\n            {\n                Log.Debug(\"Native drivers are disabled !!!!\");\n            }\n            // if canon camera is connected don't use wia driver\n            if (UseExperimentalDrivers && _framework != null && _framework.GetCameraCollection().Count > 0)\n                return true;\n\n            if (!LoadWiaDevices)\n                return true;\n\n            bool ret = false;\n            bool noDriversDetected = ConnectedDevices.Count == 0;\n            int retries = 0;\n            foreach (IDeviceInfo devInfo in new DeviceManager().DeviceInfos)\n            {\n                // Look for CameraDeviceType devices\n                string model = devInfo.Properties[\"Name\"].get_Value();\n                // skip canon cameras \n                //if (!string.IsNullOrEmpty(model) && model.Contains(\"Canon\"))\n                //    continue;\n                if (getDeviceDescription(model) != null)\n                    continue;\n\n                var nativeDriver = GetNativeDriver(model);\n                ret = nativeDriver != null;\n\n                if ((devInfo.Type == WiaDeviceType.CameraDeviceType || devInfo.Type == WiaDeviceType.VideoDeviceType)\n                    && (nativeDriver == null || DisableNativeDrivers || noDriversDetected) && retries < 3)\n                {\n                    do\n                    {\n                        Log.Debug(\"Wia Camera Found: \" + model);\n                        try\n                        {\n                            GetWiaIDevice(devInfo);\n                            retries = 4;\n                            ret = true;\n                        }\n                        catch (Exception exception)\n                        {\n                            Log.Error(\"Unable to connect to the camera\", exception);\n                            retries++;\n                            if (retries < 3)\n                            {\n                                Log.Debug(\"Retrying\");\n                                StaticHelper.Instance.SystemMessage = \"Unable to connect to the camera. Retrying\";\n                            }\n                            else\n                            {\n                                StaticHelper.Instance.SystemMessage =\n                                    \"Unable to connect to the camera. Please reconnect your camera !\";\n                            }\n                            Thread.Sleep(1000);\n                        }\n                    } while (retries < 3);\n                }\n            }\n            return ret;\n        }\n\n        public void CloseAll()\n        {\n            foreach (\n                ICameraDevice connectedDevice in ConnectedDevices.Where(connectedDevice => connectedDevice.IsConnected))\n            {\n                connectedDevice.Close();\n            }\n        }\n\n        public event PhotoCapturedEventHandler PhotoCaptured;\n\n        public delegate void CameraConnectedEventHandler(ICameraDevice cameraDevice);\n\n        /// <summary>\n        /// Occurs when a new camera is connected.\n        /// </summary>\n        public event CameraConnectedEventHandler CameraConnected;\n\n        /// <summary>\n        /// Occurs when a camera disconnected.\n        /// </summary>\n        public event CameraConnectedEventHandler CameraDisconnected;\n\n        public delegate void CameraSelectedEventHandler(ICameraDevice oldcameraDevice, ICameraDevice newcameraDevice);\n\n        /// <summary>\n        /// Occurs when SelectedCameraDevice property changed.\n        /// </summary>\n        public event CameraSelectedEventHandler CameraSelected;\n\n\n        public void SelectNextCamera()\n        {\n            if (ConnectedDevices.Count == 0)\n                return;\n            int idx = 0;\n            for (int i = 0; i < ConnectedDevices.Count; i++)\n            {\n                var device = ConnectedDevices[i];\n                if (device == SelectedCameraDevice)\n                {\n                    idx = i;\n                    break;\n                }\n            }\n            idx++;\n            if (idx < ConnectedDevices.Count)\n                SelectedCameraDevice = ConnectedDevices[idx];\n        }\n\n        public void SelectPrevCamera()\n        {\n            if (ConnectedDevices.Count == 0)\n                return;\n            int idx = 0;\n            for (int i = 0; i < ConnectedDevices.Count; i++)\n            {\n                var device = ConnectedDevices[i];\n                if (device == SelectedCameraDevice)\n                {\n                    idx = i;\n                    break;\n                }\n            }\n            idx--;\n            if (idx >= 0)\n                SelectedCameraDevice = ConnectedDevices[idx];\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    /// <summary>\n    /// Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.\n    /// </summary>\n    public abstract class JsonReader : IDisposable\n    {\n        /// <summary>\n        /// Specifies the state of the reader.\n        /// </summary>\n        protected internal enum State\n        {\n            /// <summary>\n            /// The Read method has not been called.\n            /// </summary>\n            Start,\n\n            /// <summary>\n            /// The end of the file has been reached successfully.\n            /// </summary>\n            Complete,\n\n            /// <summary>\n            /// Reader is at a property.\n            /// </summary>\n            Property,\n\n            /// <summary>\n            /// Reader is at the start of an object.\n            /// </summary>\n            ObjectStart,\n\n            /// <summary>\n            /// Reader is in an object.\n            /// </summary>\n            Object,\n\n            /// <summary>\n            /// Reader is at the start of an array.\n            /// </summary>\n            ArrayStart,\n\n            /// <summary>\n            /// Reader is in an array.\n            /// </summary>\n            Array,\n\n            /// <summary>\n            /// The Close method has been called.\n            /// </summary>\n            Closed,\n\n            /// <summary>\n            /// Reader has just read a value.\n            /// </summary>\n            PostValue,\n\n            /// <summary>\n            /// Reader is at the start of a constructor.\n            /// </summary>\n            ConstructorStart,\n\n            /// <summary>\n            /// Reader in a constructor.\n            /// </summary>\n            Constructor,\n\n            /// <summary>\n            /// An error occurred that prevents the read operation from continuing.\n            /// </summary>\n            Error,\n\n            /// <summary>\n            /// The end of the file has been reached successfully.\n            /// </summary>\n            Finished\n        }\n\n        // current Token data\n        private JsonToken _tokenType;\n        private object _value;\n        internal char _quoteChar;\n        internal State _currentState;\n        internal ReadType _readType;\n        private JsonPosition _currentPosition;\n        private CultureInfo _culture;\n        private DateTimeZoneHandling _dateTimeZoneHandling;\n        private int? _maxDepth;\n        private bool _hasExceededMaxDepth;\n        internal DateParseHandling _dateParseHandling;\n        internal FloatParseHandling _floatParseHandling;\n        private string _dateFormatString;\n        private readonly List<JsonPosition> _stack;\n\n        /// <summary>\n        /// Gets the current reader state.\n        /// </summary>\n        /// <value>The current reader state.</value>\n        protected State CurrentState\n        {\n            get { return _currentState; }\n        }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether the underlying stream or\n        /// <see cref=\"TextReader\"/> should be closed when the reader is closed.\n        /// </summary>\n        /// <value>\n        /// true to close the underlying stream or <see cref=\"TextReader\"/> when\n        /// the reader is closed; otherwise false. The default is true.\n        /// </value>\n        public bool CloseInput { get; set; }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether multiple pieces of JSON content can\n        /// be read from a continuous stream without erroring.\n        /// </summary>\n        /// <value>\n        /// true to support reading multiple pieces of JSON content; otherwise false. The default is false.\n        /// </value>\n        public bool SupportMultipleContent { get; set; }\n\n        /// <summary>\n        /// Gets the quotation mark character used to enclose the value of a string.\n        /// </summary>\n        public virtual char QuoteChar\n        {\n            get { return _quoteChar; }\n            protected internal set { _quoteChar = value; }\n        }\n\n        /// <summary>\n        /// Get or set how <see cref=\"DateTime\"/> time zones are handling when reading JSON.\n        /// </summary>\n        public DateTimeZoneHandling DateTimeZoneHandling\n        {\n            get { return _dateTimeZoneHandling; }\n            set { _dateTimeZoneHandling = value; }\n        }\n\n        /// <summary>\n        /// Get or set how date formatted strings, e.g. \"\\/Date(1198908717056)\\/\" and \"2012-03-21T05:40Z\", are parsed when reading JSON.\n        /// </summary>\n        public DateParseHandling DateParseHandling\n        {\n            get { return _dateParseHandling; }\n            set { _dateParseHandling = value; }\n        }\n\n        /// <summary>\n        /// Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.\n        /// </summary>\n        public FloatParseHandling FloatParseHandling\n        {\n            get { return _floatParseHandling; }\n            set { _floatParseHandling = value; }\n        }\n\n        /// <summary>\n        /// Get or set how custom date formatted strings are parsed when reading JSON.\n        /// </summary>\n        public string DateFormatString\n        {\n            get { return _dateFormatString; }\n            set { _dateFormatString = value; }\n        }\n\n        /// <summary>\n        /// Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref=\"JsonReaderException\"/>.\n        /// </summary>\n        public int? MaxDepth\n        {\n            get { return _maxDepth; }\n            set\n            {\n                if (value <= 0)\n                    throw new ArgumentException(\"Value must be positive.\", \"value\");\n\n                _maxDepth = value;\n            }\n        }\n\n        /// <summary>\n        /// Gets the type of the current JSON token. \n        /// </summary>\n        public virtual JsonToken TokenType\n        {\n            get { return _tokenType; }\n        }\n\n        /// <summary>\n        /// Gets the text value of the current JSON token.\n        /// </summary>\n        public virtual object Value\n        {\n            get { return _value; }\n        }\n\n        /// <summary>\n        /// Gets The Common Language Runtime (CLR) type for the current JSON token.\n        /// </summary>\n        public virtual Type ValueType\n        {\n            get { return (_value != null) ? _value.GetType() : null; }\n        }\n\n        /// <summary>\n        /// Gets the depth of the current token in the JSON document.\n        /// </summary>\n        /// <value>The depth of the current token in the JSON document.</value>\n        public virtual int Depth\n        {\n            get\n            {\n                int depth = _stack.Count;\n                if (IsStartToken(TokenType) || _currentPosition.Type == JsonContainerType.None)\n                    return depth;\n                else\n                    return depth + 1;\n            }\n        }\n\n        /// <summary>\n        /// Gets the path of the current JSON token. \n        /// </summary>\n        public virtual string Path\n        {\n            get\n            {\n                if (_currentPosition.Type == JsonContainerType.None)\n                    return string.Empty;\n\n                bool insideContainer = (_currentState != State.ArrayStart\n                                        && _currentState != State.ConstructorStart\n                                        && _currentState != State.ObjectStart);\n\n                IEnumerable<JsonPosition> positions = (!insideContainer)\n                    ? _stack\n                    : _stack.Concat(new[] { _currentPosition });\n\n                return JsonPosition.BuildPath(positions);\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the culture used when reading JSON. Defaults to <see cref=\"CultureInfo.InvariantCulture\"/>.\n        /// </summary>\n        public CultureInfo Culture\n        {\n            get { return _culture ?? CultureInfo.InvariantCulture; }\n            set { _culture = value; }\n        }\n\n        internal JsonPosition GetPosition(int depth)\n        {\n            if (depth < _stack.Count)\n                return _stack[depth];\n\n            return _currentPosition;\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"JsonReader\"/> class with the specified <see cref=\"TextReader\"/>.\n        /// </summary>\n        protected JsonReader()\n        {\n            _currentState = State.Start;\n            _stack = new List<JsonPosition>(4);\n            _dateTimeZoneHandling = DateTimeZoneHandling.RoundtripKind;\n            _dateParseHandling = DateParseHandling.DateTime;\n            _floatParseHandling = FloatParseHandling.Double;\n\n            CloseInput = true;\n        }\n\n        private void Push(JsonContainerType value)\n        {\n            UpdateScopeWithFinishedValue();\n\n            if (_currentPosition.Type == JsonContainerType.None)\n            {\n                _currentPosition = new JsonPosition(value);\n            }\n            else\n            {\n                _stack.Add(_currentPosition);\n                _currentPosition = new JsonPosition(value);\n\n                // this is a little hacky because Depth increases when first property/value is written but only testing here is faster/simpler\n                if (_maxDepth != null && Depth + 1 > _maxDepth && !_hasExceededMaxDepth)\n                {\n                    _hasExceededMaxDepth = true;\n                    throw JsonReaderException.Create(this, \"The reader's MaxDepth of {0} has been exceeded.\".FormatWith(CultureInfo.InvariantCulture, _maxDepth));\n                }\n            }\n        }\n\n        private JsonContainerType Pop()\n        {\n            JsonPosition oldPosition;\n            if (_stack.Count > 0)\n            {\n                oldPosition = _currentPosition;\n                _currentPosition = _stack[_stack.Count - 1];\n                _stack.RemoveAt(_stack.Count - 1);\n            }\n            else\n            {\n                oldPosition = _currentPosition;\n                _currentPosition = new JsonPosition();\n            }\n\n            if (_maxDepth != null && Depth <= _maxDepth)\n                _hasExceededMaxDepth = false;\n\n            return oldPosition.Type;\n        }\n\n        private JsonContainerType Peek()\n        {\n            return _currentPosition.Type;\n        }\n\n        /// <summary>\n        /// Reads the next JSON token from the stream.\n        /// </summary>\n        /// <returns>true if the next token was read successfully; false if there are no more tokens to read.</returns>\n        public abstract bool Read();\n\n        /// <summary>\n        /// Reads the next JSON token from the stream as a <see cref=\"Nullable{Int32}\"/>.\n        /// </summary>\n        /// <returns>A <see cref=\"Nullable{Int32}\"/>. This method will return <c>null</c> at the end of an array.</returns>\n        public abstract int? ReadAsInt32();\n\n        /// <summary>\n        /// Reads the next JSON token from the stream as a <see cref=\"String\"/>.\n        /// </summary>\n        /// <returns>A <see cref=\"String\"/>. This method will return <c>null</c> at the end of an array.</returns>\n        public abstract string ReadAsString();\n\n        /// <summary>\n        /// Reads the next JSON token from the stream as a <see cref=\"T:Byte[]\"/>.\n        /// </summary>\n        /// <returns>A <see cref=\"T:Byte[]\"/> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>\n        public abstract byte[] ReadAsBytes();\n\n        /// <summary>\n        /// Reads the next JSON token from the stream as a <see cref=\"Nullable{Decimal}\"/>.\n        /// </summary>\n        /// <returns>A <see cref=\"Nullable{Decimal}\"/>. This method will return <c>null</c> at the end of an array.</returns>\n        public abstract decimal? ReadAsDecimal();\n\n        /// <summary>\n        /// Reads the next JSON token from the stream as a <see cref=\"Nullable{DateTime}\"/>.\n        /// </summary>\n        /// <returns>A <see cref=\"String\"/>. This method will return <c>null</c> at the end of an array.</returns>\n        public abstract DateTime? ReadAsDateTime();\n\n#if !NET20\n        /// <summary>\n        /// Reads the next JSON token from the stream as a <see cref=\"Nullable{DateTimeOffset}\"/>.\n        /// </summary>\n        /// <returns>A <see cref=\"Nullable{DateTimeOffset}\"/>. This method will return <c>null</c> at the end of an array.</returns>\n        public abstract DateTimeOffset? ReadAsDateTimeOffset();\n#endif\n\n        internal virtual bool ReadInternal()\n        {\n            throw new NotImplementedException();\n        }\n\n#if !NET20\n        internal DateTimeOffset? ReadAsDateTimeOffsetInternal()\n        {\n            _readType = ReadType.ReadAsDateTimeOffset;\n\n            JsonToken t;\n\n            do\n            {\n                if (!ReadInternal())\n                {\n                    SetToken(JsonToken.None);\n                    return null;\n                }\n                else\n                {\n                    t = TokenType;\n                }\n            } while (t == JsonToken.Comment);\n\n            if (t == JsonToken.Date)\n            {\n                if (Value is DateTime)\n                    SetToken(JsonToken.Date, new DateTimeOffset((DateTime)Value), false);\n\n                return (DateTimeOffset)Value;\n            }\n\n            if (t == JsonToken.Null)\n                return null;\n\n            if (t == JsonToken.String)\n            {\n                string s = (string)Value;\n                if (string.IsNullOrEmpty(s))\n                {\n                    SetToken(JsonToken.Null);\n                    return null;\n                }\n\n                object temp;\n                DateTimeOffset dt;\n                if (DateTimeUtils.TryParseDateTime(s, DateParseHandling.DateTimeOffset, DateTimeZoneHandling, _dateFormatString, Culture, out temp))\n                {\n                    dt = (DateTimeOffset)temp;\n                    SetToken(JsonToken.Date, dt, false);\n                    return dt;\n                }\n\n                if (DateTimeOffset.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))\n                {\n                    SetToken(JsonToken.Date, dt, false);\n                    return dt;\n                }\n                \n                throw JsonReaderException.Create(this, \"Could not convert string to DateTimeOffset: {0}.\".FormatWith(CultureInfo.InvariantCulture, Value));\n            }\n\n            if (t == JsonToken.EndArray)\n                return null;\n\n            throw JsonReaderException.Create(this, \"Error reading date. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\n        }\n#endif\n\n        internal byte[] ReadAsBytesInternal()\n        {\n            _readType = ReadType.ReadAsBytes;\n\n            JsonToken t;\n\n            do\n            {\n                if (!ReadInternal())\n                {\n                    SetToken(JsonToken.None);\n                    return null;\n                }\n                else\n                {\n                    t = TokenType;\n                }\n            } while (t == JsonToken.Comment);\n\n            if (IsWrappedInTypeObject())\n            {\n                byte[] data = ReadAsBytes();\n                ReadInternal();\n                SetToken(JsonToken.Bytes, data, false);\n                return data;\n            }\n\n            // attempt to convert possible base 64 string to bytes\n            if (t == JsonToken.String)\n            {\n                string s = (string)Value;\n\n                byte[] data;\n\n                Guid g;\n                if (s.Length == 0)\n                {\n                    data = new byte[0];\n                }\n                else if (ConvertUtils.TryConvertGuid(s, out g))\n                {\n                    data = g.ToByteArray();\n                }\n                else\n                {\n                    data = Convert.FromBase64String(s);\n                }\n\n                SetToken(JsonToken.Bytes, data, false);\n                return data;\n            }\n\n            if (t == JsonToken.Null)\n                return null;\n\n            if (t == JsonToken.Bytes)\n            {\n                if (ValueType == typeof(Guid))\n                {\n                    byte[] data = ((Guid)Value).ToByteArray();\n                    SetToken(JsonToken.Bytes, data, false);\n                    return data;\n                }\n\n                return (byte[])Value;\n            }\n\n            if (t == JsonToken.StartArray)\n            {\n                List<byte> data = new List<byte>();\n\n                while (ReadInternal())\n                {\n                    t = TokenType;\n                    switch (t)\n                    {\n                        case JsonToken.Integer:\n                            data.Add(Convert.ToByte(Value, CultureInfo.InvariantCulture));\n                            break;\n                        case JsonToken.EndArray:\n                            byte[] d = data.ToArray();\n                            SetToken(JsonToken.Bytes, d, false);\n                            return d;\n                        case JsonToken.Comment:\n                            // skip\n                            break;\n                        default:\n                            throw JsonReaderException.Create(this, \"Unexpected token when reading bytes: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\n                    }\n                }\n\n                throw JsonReaderException.Create(this, \"Unexpected end when reading bytes.\");\n            }\n\n            if (t == JsonToken.EndArray)\n                return null;\n\n            throw JsonReaderException.Create(this, \"Error reading bytes. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\n        }\n\n        internal decimal? ReadAsDecimalInternal()\n        {\n            _readType = ReadType.ReadAsDecimal;\n\n            JsonToken t;\n\n            do\n            {\n                if (!ReadInternal())\n                {\n                    SetToken(JsonToken.None);\n                    return null;\n                }\n                else\n                {\n                    t = TokenType;\n                }\n            } while (t == JsonToken.Comment);\n\n            if (t == JsonToken.Integer || t == JsonToken.Float)\n            {\n                if (!(Value is decimal))\n                    SetToken(JsonToken.Float, Convert.ToDecimal(Value, CultureInfo.InvariantCulture), false);\n\n                return (decimal)Value;\n            }\n\n            if (t == JsonToken.Null)\n                return null;\n\n            if (t == JsonToken.String)\n            {\n                string s = (string)Value;\n                if (string.IsNullOrEmpty(s))\n                {\n                    SetToken(JsonToken.Null);\n                    return null;\n                }\n\n                decimal d;\n                if (decimal.TryParse(s, NumberStyles.Number, Culture, out d))\n                {\n                    SetToken(JsonToken.Float, d, false);\n                    return d;\n                }\n                else\n                {\n                    throw JsonReaderException.Create(this, \"Could not convert string to decimal: {0}.\".FormatWith(CultureInfo.InvariantCulture, Value));\n                }\n            }\n\n            if (t == JsonToken.EndArray)\n                return null;\n\n            throw JsonReaderException.Create(this, \"Error reading decimal. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\n        }\n\n        internal int? ReadAsInt32Internal()\n        {\n            _readType = ReadType.ReadAsInt32;\n\n            JsonToken t;\n\n            do\n            {\n                if (!ReadInternal())\n                {\n                    SetToken(JsonToken.None);\n                    return null;\n                }\n                else\n                {\n                    t = TokenType;\n                }\n            } while (t == JsonToken.Comment);\n\n            if (t == JsonToken.Integer || t == JsonToken.Float)\n            {\n                if (!(Value is int))\n                    SetToken(JsonToken.Integer, Convert.ToInt32(Value, CultureInfo.InvariantCulture), false);\n\n                return (int)Value;\n            }\n\n            if (t == JsonToken.Null)\n                return null;\n\n            int i;\n            if (t == JsonToken.String)\n            {\n                string s = (string)Value;\n                if (string.IsNullOrEmpty(s))\n                {\n                    SetToken(JsonToken.Null);\n                    return null;\n                }\n\n                if (int.TryParse(s, NumberStyles.Integer, Culture, out i))\n                {\n                    SetToken(JsonToken.Integer, i, false);\n                    return i;\n                }\n                else\n                {\n                    throw JsonReaderException.Create(this, \"Could not convert string to integer: {0}.\".FormatWith(CultureInfo.InvariantCulture, Value));\n                }\n            }\n\n            if (t == JsonToken.EndArray)\n                return null;\n\n            throw JsonReaderException.Create(this, \"Error reading integer. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, TokenType));\n        }\n\n        internal string ReadAsStringInternal()\n        {\n            _readType = ReadType.ReadAsString;\n\n            JsonToken t;\n\n            do\n            {\n                if (!ReadInternal())\n                {\n                    SetToken(JsonToken.None);\n                    return null;\n                }\n                else\n                {\n                    t = TokenType;\n                }\n            } while (t == JsonToken.Comment);\n\n            if (t == JsonToken.String)\n                return (string)Value;\n\n            if (t == JsonToken.Null)\n                return null;\n\n            if (IsPrimitiveToken(t))\n            {\n                if (Value != null)\n                {\n                    string s;\n                    if (Value is IFormattable)\n                        s = ((IFormattable)Value).ToString(null, Culture);\n                    else\n                        s = Value.ToString();\n\n                    SetToken(JsonToken.String, s, false);\n                    return s;\n                }\n            }\n\n            if (t == JsonToken.EndArray)\n                return null;\n\n            throw JsonReaderException.Create(this, \"Error reading string. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, t));\n        }\n\n        internal DateTime? ReadAsDateTimeInternal()\n        {\n            _readType = ReadType.ReadAsDateTime;\n\n            do\n            {\n                if (!ReadInternal())\n                {\n                    SetToken(JsonToken.None);\n                    return null;\n                }\n            } while (TokenType == JsonToken.Comment);\n\n            if (TokenType == JsonToken.Date)\n                return (DateTime)Value;\n\n            if (TokenType == JsonToken.Null)\n                return null;\n\n            if (TokenType == JsonToken.String)\n            {\n                string s = (string)Value;\n                if (string.IsNullOrEmpty(s))\n                {\n                    SetToken(JsonToken.Null);\n                    return null;\n                }\n\n                DateTime dt;\n                object temp;\n                if (DateTimeUtils.TryParseDateTime(s, DateParseHandling.DateTime, DateTimeZoneHandling, _dateFormatString, Culture, out temp))\n                {\n                    dt = (DateTime)temp;\n                    dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);\n                    SetToken(JsonToken.Date, dt, false);\n                    return dt;\n                }\n\n                if (DateTime.TryParse(s, Culture, DateTimeStyles.RoundtripKind, out dt))\n                {\n                    dt = DateTimeUtils.EnsureDateTime(dt, DateTimeZoneHandling);\n                    SetToken(JsonToken.Date, dt, false);\n                    return dt;\n                }\n\n                throw JsonReaderException.Create(this, \"Could not convert string to DateTime: {0}.\".FormatWith(CultureInfo.InvariantCulture, Value));\n            }\n\n            if (TokenType == JsonToken.EndArray)\n                return null;\n\n            throw JsonReaderException.Create(this, \"Error reading date. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, TokenType));\n        }\n\n        private bool IsWrappedInTypeObject()\n        {\n            _readType = ReadType.Read;\n\n            if (TokenType == JsonToken.StartObject)\n            {\n                if (!ReadInternal())\n                    throw JsonReaderException.Create(this, \"Unexpected end when reading bytes.\");\n\n                if (Value.ToString() == JsonTypeReflector.TypePropertyName)\n                {\n                    ReadInternal();\n                    if (Value != null && Value.ToString().StartsWith(\"System.Byte[]\", StringComparison.Ordinal))\n                    {\n                        ReadInternal();\n                        if (Value.ToString() == JsonTypeReflector.ValuePropertyName)\n                        {\n                            return true;\n                        }\n                    }\n                }\n\n                throw JsonReaderException.Create(this, \"Error reading bytes. Unexpected token: {0}.\".FormatWith(CultureInfo.InvariantCulture, JsonToken.StartObject));\n            }\n\n            return false;\n        }\n\n        /// <summary>\n        /// Skips the children of the current token.\n        /// </summary>\n        public void Skip()\n        {\n            if (TokenType == JsonToken.PropertyName)\n                Read();\n\n            if (IsStartToken(TokenType))\n            {\n                int depth = Depth;\n\n                while (Read() && (depth < Depth))\n                {\n                }\n            }\n        }\n\n        /// <summary>\n        /// Sets the current token.\n        /// </summary>\n        /// <param name=\"newToken\">The new token.</param>\n        protected void SetToken(JsonToken newToken)\n        {\n            SetToken(newToken, null, true);\n        }\n\n        /// <summary>\n        /// Sets the current token and value.\n        /// </summary>\n        /// <param name=\"newToken\">The new token.</param>\n        /// <param name=\"value\">The value.</param>\n        protected void SetToken(JsonToken newToken, object value)\n        {\n            SetToken(newToken, value, true);\n        }\n\n        internal void SetToken(JsonToken newToken, object value, bool updateIndex)\n        {\n            _tokenType = newToken;\n            _value = value;\n\n            switch (newToken)\n            {\n                case JsonToken.StartObject:\n                    _currentState = State.ObjectStart;\n                    Push(JsonContainerType.Object);\n                    break;\n                case JsonToken.StartArray:\n                    _currentState = State.ArrayStart;\n                    Push(JsonContainerType.Array);\n                    break;\n                case JsonToken.StartConstructor:\n                    _currentState = State.ConstructorStart;\n                    Push(JsonContainerType.Constructor);\n                    break;\n                case JsonToken.EndObject:\n                    ValidateEnd(JsonToken.EndObject);\n                    break;\n                case JsonToken.EndArray:\n                    ValidateEnd(JsonToken.EndArray);\n                    break;\n                case JsonToken.EndConstructor:\n                    ValidateEnd(JsonToken.EndConstructor);\n                    break;\n                case JsonToken.PropertyName:\n                    _currentState = State.Property;\n\n                    _currentPosition.PropertyName = (string)value;\n                    break;\n                case JsonToken.Undefined:\n                case JsonToken.Integer:\n                case JsonToken.Float:\n                case JsonToken.Boolean:\n                case JsonToken.Null:\n                case JsonToken.Date:\n                case JsonToken.String:\n                case JsonToken.Raw:\n                case JsonToken.Bytes:\n                    SetPostValueState(updateIndex);\n                    break;\n            }\n        }\n\n        internal void SetPostValueState(bool updateIndex)\n        {\n            if (Peek() != JsonContainerType.None)\n                _currentState = State.PostValue;\n            else\n                SetFinished();\n\n            if (updateIndex)\n                UpdateScopeWithFinishedValue();\n        }\n\n        private void UpdateScopeWithFinishedValue()\n        {\n            if (_currentPosition.HasIndex)\n                _currentPosition.Position++;\n        }\n\n        private void ValidateEnd(JsonToken endToken)\n        {\n            JsonContainerType currentObject = Pop();\n\n            if (GetTypeForCloseToken(endToken) != currentObject)\n                throw JsonReaderException.Create(this, \"JsonToken {0} is not valid for closing JsonType {1}.\".FormatWith(CultureInfo.InvariantCulture, endToken, currentObject));\n\n            if (Peek() != JsonContainerType.None)\n                _currentState = State.PostValue;\n            else\n                SetFinished();\n        }\n\n        /// <summary>\n        /// Sets the state based on current token type.\n        /// </summary>\n        protected void SetStateBasedOnCurrent()\n        {\n            JsonContainerType currentObject = Peek();\n\n            switch (currentObject)\n            {\n                case JsonContainerType.Object:\n                    _currentState = State.Object;\n                    break;\n                case JsonContainerType.Array:\n                    _currentState = State.Array;\n                    break;\n                case JsonContainerType.Constructor:\n                    _currentState = State.Constructor;\n                    break;\n                case JsonContainerType.None:\n                    SetFinished();\n                    break;\n                default:\n                    throw JsonReaderException.Create(this, \"While setting the reader state back to current object an unexpected JsonType was encountered: {0}\".FormatWith(CultureInfo.InvariantCulture, currentObject));\n            }\n        }\n\n        private void SetFinished()\n        {\n            if (SupportMultipleContent)\n                _currentState = State.Start;\n            else\n                _currentState = State.Finished;\n        }\n\n        internal static bool IsPrimitiveToken(JsonToken token)\n        {\n            switch (token)\n            {\n                case JsonToken.Integer:\n                case JsonToken.Float:\n                case JsonToken.String:\n                case JsonToken.Boolean:\n                case JsonToken.Undefined:\n                case JsonToken.Null:\n                case JsonToken.Date:\n                case JsonToken.Bytes:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        internal static bool IsStartToken(JsonToken token)\n        {\n            switch (token)\n            {\n                case JsonToken.StartObject:\n                case JsonToken.StartArray:\n                case JsonToken.StartConstructor:\n                    return true;\n                default:\n                    return false;\n            }\n        }\n\n        private JsonContainerType GetTypeForCloseToken(JsonToken token)\n        {\n            switch (token)\n            {\n                case JsonToken.EndObject:\n                    return JsonContainerType.Object;\n                case JsonToken.EndArray:\n                    return JsonContainerType.Array;\n                case JsonToken.EndConstructor:\n                    return JsonContainerType.Constructor;\n                default:\n                    throw JsonReaderException.Create(this, \"Not a valid close JsonToken: {0}\".FormatWith(CultureInfo.InvariantCulture, token));\n            }\n        }\n\n        /// <summary>\n        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\n        /// </summary>\n        void IDisposable.Dispose()\n        {\n            Dispose(true);\n        }\n\n        /// <summary>\n        /// Releases unmanaged and - optionally - managed resources\n        /// </summary>\n        /// <param name=\"disposing\"><c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>\n        protected virtual void Dispose(bool disposing)\n        {\n            if (_currentState != State.Closed && disposing)\n                Close();\n        }\n\n        /// <summary>\n        /// Changes the <see cref=\"State\"/> to Closed. \n        /// </summary>\n        public virtual void Close()\n        {\n            _currentState = State.Closed;\n            _tokenType = JsonToken.None;\n            _value = null;\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "    internal class CachedPropertyDictionary : IPropertyDictionary\n    {\n        private Dictionary<PropertyKey, object> _properties;\n        private IPropertyStore _propertyStoreInteface;\n\n        public CachedPropertyDictionary()\n        {\n            ComThread.Assert();\n\n            _properties = new Dictionary<PropertyKey, object>();\n        }\n\n        public AccessMode Mode { get; private set; }\n\n        public int Count => _properties?.Count ?? 0;\n\n        public object this[PropertyKey key]\n        {\n            get\n            {\n                if (_properties.ContainsKey(key))\n                    return _properties[key];\n\n                return null;\n            }\n            set\n            {\n                if (Mode == AccessMode.Read)\n                    return;\n\n                SetValue(key, value);\n            }\n        }\n\n        public bool Contains(PropertyKey key)\n        {\n            return _properties.ContainsKey(key);\n        }\n\n        public void Dispose()\n        {\n            _properties = null;\n            ComThread.BeginInvoke(() => { _propertyStoreInteface = null; });\n        }\n\n        /// <summary>\n        /// Will attempt to load the properties from the MMDevice. If it can't open, or the device is in \n        /// an invalid state it will continue to use it's current internal property cache\n        /// </summary>\n        /// <param name=\"device\"></param>\n        public void TryLoadFrom(IMultimediaDevice device)\n        {\n            var properties = GetProperties(device);\n\n            if (properties.Count > 0)\n                _properties = properties;\n        }\n\n        private Dictionary<PropertyKey, object> GetProperties(IMultimediaDevice device)\n        {\n            var properties = new Dictionary<PropertyKey, object>();\n            //Opening in write mode, can cause exceptions to be thrown when not run as admin.\n            //This tries to open in write mode if available\n            try\n            {\n                device.OpenPropertyStore(StorageAccessMode.ReadWrite, out _propertyStoreInteface);\n                Mode = AccessMode.ReadWrite;\n            }\n            catch\n            {\n                Debug.WriteLine(\"Cannot open property store in write mode\");\n            }\n\n            if (_propertyStoreInteface == null)\n            {\n                Marshal.ThrowExceptionForHR(device.OpenPropertyStore(StorageAccessMode.Read, out _propertyStoreInteface));\n                Mode = AccessMode.Read;\n            }\n            try\n            {\n                uint count;\n                _propertyStoreInteface.GetCount(out count);\n                for (uint i = 0; i < count; i++)\n                {\n                    PropertyKey key;\n                    PropVariant variant;\n                    _propertyStoreInteface.GetAt(i, out key);\n\n                    _propertyStoreInteface.GetValue(ref key, out variant);\n\n                    if (variant.IsSupported())\n                        properties.Add(key, variant.Value);\n                }\n            }\n            catch(Exception)\n            {\n                Debug.WriteLine(\"Cannot get property values\");\n                return new Dictionary<PropertyKey, object>();\n            }\n\n            return properties;\n        }\n\n        /// <summary>\n        ///     Sets property value of the property\n        /// </summary>\n        /// <returns>Property value</returns>\n        public void SetValue(PropertyKey key, object value)\n        {\n            ComThread.Assert();\n\n            if (Mode == AccessMode.Read)\n                return;\n\n            if (!Contains(key))\n                return;\n\n            Marshal.ThrowExceptionForHR(_propertyStoreInteface.SetValue(ref key, ref value));\n            _propertyStoreInteface.Commit();\n        }\n    }\n", "label": "FeatureEnvy"}
{"text": "public bool UpdateBuffers(DeviceContextProxy context, IDeviceResources deviceResources)\n            {\n                if(SpriteCount == 0 || IndexCount == 0 || Sprites == null || Indices == null || Sprites.Length < SpriteCount || Indices.Length < IndexCount)\n                {\n                    return false;\n                }\n                vertextBuffer.UploadDataToBuffer(context, Sprites, SpriteCount);\n                IndexBuffer.UploadDataToBuffer(context, Indices, IndexCount);\n                return true;\n            }", "label": "ComplexConditional"}
{"text": "public SRes LzmaEnc_SetProps(CLzmaEncProps props2)\n            {\n                TR(\"LzmaEnc_SetProps:level\", props2.mLevel);\n                TR(\"LzmaEnc_SetProps:dictSize\", props2.mDictSize);\n                TR(\"LzmaEnc_SetProps:lc\", props2.mLC);\n                TR(\"LzmaEnc_SetProps:lp\", props2.mLP);\n                TR(\"LzmaEnc_SetProps:pb\", props2.mPB);\n                TR(\"LzmaEnc_SetProps:algo\", props2.mAlgo);\n                TR(\"LzmaEnc_SetProps:fb\", props2.mFB);\n                TR(\"LzmaEnc_SetProps:btMode\", props2.mBtMode);\n                TR(\"LzmaEnc_SetProps:numHashBytes\", props2.mNumHashBytes);\n                TR(\"LzmaEnc_SetProps:mc\", props2.mMC);\n                TR(\"LzmaEnc_SetProps:writeEndMark\", props2.mWriteEndMark);\n                TR(\"LzmaEnc_SetProps:numThreads\", props2.mNumThreads);\n\n                CLzmaEncProps props = new CLzmaEncProps(props2);\n                props.LzmaEncProps_Normalize();\n\n                if (props.mLC > LZMA_LC_MAX\n                    || props.mLP > LZMA_LP_MAX\n                    || props.mPB > LZMA_PB_MAX\n                    || props.mDictSize > (1u << kDicLogSizeMaxCompress)\n                    || props.mDictSize > (1u << 30))\n                    return SZ_ERROR_PARAM;\n\n                mDictSize = props.mDictSize;\n\n                uint fb = (uint)props.mFB;\n                if (fb < 5)\n                    fb = 5;\n                if (fb > LZMA_MATCH_LEN_MAX)\n                    fb = LZMA_MATCH_LEN_MAX;\n                mNumFastBytes = fb;\n\n                mLC = props.mLC;\n                mLP = props.mLP;\n                mPB = props.mPB;\n                mFastMode = (props.mAlgo == 0);\n                mMatchFinderBase.mBtMode = (props.mBtMode != 0);\n\n                uint numHashBytes = 4;\n                if (props.mBtMode != 0)\n                {\n                    if (props.mNumHashBytes < 2)\n                        numHashBytes = 2;\n                    else if (props.mNumHashBytes < 4)\n                        numHashBytes = (uint)props.mNumHashBytes;\n                }\n                mMatchFinderBase.mNumHashBytes = numHashBytes;\n\n                mMatchFinderBase.mCutValue = props.mMC;\n\n                mWriteEndMark = (props.mWriteEndMark != 0);\n\n#if !_7ZIP_ST\n                mMultiThread = (props.mNumThreads > 1);\n#endif\n\n                return SZ_OK;\n            }", "label": "ComplexConditional"}
{"text": "public override void OnMovement(Mobile m, Point3D oldLocation)\n        {\n            if (this.TurnedOn && this.IsLockedDown && (!m.Hidden || m.IsPlayer()) && Utility.InRange(m.Location, this.Location, 2) && !Utility.InRange(oldLocation, this.Location, 2))\n                Effects.PlaySound(this.Location, this.Map, m_Sounds[Utility.Random(m_Sounds.Length)]);\n\n            base.OnMovement(m, oldLocation);\n        }", "label": "ComplexConditional"}
{"text": "//\n        // carry out the combo defenses\n        //\n        // If you add a new combo, you must add the code here to define what it actually does when it is activated\n        //\n        public void DoComboDefense(Mobile attacker, Mobile defender, BaseWeapon weapon, int damageGiven, ComboDefense combo)\n\t\t{\n\t\t    if(attacker == null || defender == null || weapon == null || combo == null) return;\n\n\t\t    defender.SendMessage(\"You unleash the combo defense {0}!\",combo.Name);\n\n\t\t    // apply the combo defense\n            switch(combo.DefenseID)\n            {\n                case ComboDefenses.ColdWind:\n                {\n                    // 5 sec paralyze\n                    attacker.FixedEffect( 0x376A, 9, 32 );\n\t\t\t        attacker.PlaySound( 0x204 );\n                    attacker.Freeze( TimeSpan.FromSeconds(5) );\n                    // 7x stam drain\n                    attacker.Stam -= weapon.MaxDamage*7;\n                    break;\n                }\n            }\n\t\t}", "label": "ComplexConditional"}
{"text": "internal DataGridColumn GetLastColumn(bool? isVisible, bool? isFrozen, bool? isReadOnly)\n        {\n            Debug.Assert(ItemsInternal.Count == DisplayIndexMap.Count);\n            int index = DisplayIndexMap.Count - 1;\n            while (index >= 0)\n            {\n                DataGridColumn dataGridColumn = GetColumnAtDisplayIndex(index);\n                if ((isVisible == null || (dataGridColumn.IsVisible) == isVisible) &&\n                    (isFrozen == null || dataGridColumn.IsFrozen == isFrozen) &&\n                    (isReadOnly == null || dataGridColumn.IsReadOnly == isReadOnly))\n                {\n                    return dataGridColumn;\n                }\n                index--;\n            }\n            return null;\n        }", "label": "ComplexConditional"}
{"text": "private void UnreferencedFunction(JsVariableField variableField, JsFunctionObject functionObject)\n        {\n            // if there is no name, then ignore this declaration because it's malformed.\n            // (won't be a function expression because those are automatically referenced).\n            // also ignore ghosted function fields.\n            if (functionObject.Name != null && variableField.FieldType != JsFieldType.GhostFunction)\n            {\n                // if the function name isn't a simple identifier, then leave it there and mark it as\n                // not renamable because it's probably one of those darn IE-extension event handlers or something.\n                if (JsScanner.IsValidIdentifier(functionObject.Name))\n                {\n                    // unreferenced function declaration. fire a warning.\n                    var ctx = functionObject.IdContext ?? variableField.OriginalContext;\n                    ctx.HandleError(JsError.FunctionNotReferenced, false);\n\n                    // hide it from the output if our settings say we can.\n                    // we don't want to delete it, per se, because we still want it to \n                    // show up in the scope report so the user can see that it was unreachable\n                    // in case they are wondering where it went.\n                    // ES6 has the notion of block-scoped function declarations. ES5 says functions can't\n                    // be defined inside blocks -- only at the root level of the global scope or function scopes.\n                    // so if this is a block scope, don't hide the function, even if it is unreferenced because\n                    // of the cross-browser difference.\n                    if (this.IsKnownAtCompileTime\n                        && m_settings.MinifyCode\n                        && m_settings.RemoveUnneededCode\n                        && !(this is JsBlockScope))\n                    {\n                        functionObject.HideFromOutput = true;\n                    }\n                }\n                else\n                {\n                    // not a valid identifier name for this function. Don't rename it because it's\n                    // malformed and we don't want to mess up the developer's intent.\n                    variableField.CanCrunch = false;\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "/*\n\t\t** Disable a term in the WHERE clause.  Except, do not disable the term\n\t\t** if it controls a LEFT OUTER JOIN and it did not originate in the ON\n\t\t** or USING clause of that join.\n\t\t**\n\t\t** Consider the term t2.z='ok' in the following queries:\n\t\t**\n\t\t**   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok'\n\t\t**   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok'\n\t\t**   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok'\n\t\t**\n\t\t** The t2.z='ok' is disabled in the in (2) because it originates\n\t\t** in the ON clause.  The term is disabled in (3) because it is not part\n\t\t** of a LEFT OUTER JOIN.  In (1), the term is not disabled.\n\t\t**\n\t\t** IMPLEMENTATION-OF: R-24597-58655 No tests are done for terms that are\n\t\t** completely satisfied by indices.\n\t\t**\n\t\t** Disabling a term causes that term to not be tested in the inner loop\n\t\t** of the join.  Disabling is an optimization.  When terms are satisfied\n\t\t** by indices, we disable them to prevent redundant tests in the inner\n\t\t** loop.  We would get the correct results if nothing were ever disabled,\n\t\t** but joins might run a little slower.  The trick is to disable as much\n\t\t** as we can without disabling too much.  If we disabled in (1), we'd get\n\t\t** the wrong answer.  See ticket #813.\n\t\t*/\n\n\t\tprivate static void disableTerm(WhereLevel pLevel, WhereTerm pTerm)\n\t\t{\n\t\t\tif (pTerm != null\n\t\t\t&& (pTerm.wtFlags & TERM_CODED) == 0\n\t\t\t&& (pLevel.iLeftJoin == 0 || ExprHasProperty(pTerm.pExpr, EP_FromJoin)))\n\t\t\t{\n\t\t\t\tpTerm.wtFlags |= TERM_CODED;\n\t\t\t\tif (pTerm.iParent >= 0)\n\t\t\t\t{\n\t\t\t\t\tWhereTerm pOther = pTerm.pWC.a[pTerm.iParent];\n\t\t\t\t\tif ((--pOther.nChild) == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tdisableTerm(pLevel, pOther);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}", "label": "ComplexConditional"}
{"text": "private void Settings_SettingChanged(object sender, StringEventArgs e)\n\t\t{\n\t\t\tstring settingsKey = e.Data;\n\n\t\t\t// Invalidate bed textures on related settings change\n\t\t\tif (settingsKey == SettingsKey.t0_inset\n\t\t\t\t|| settingsKey == SettingsKey.t1_inset\n\t\t\t\t|| settingsKey == SettingsKey.bed_size\n\t\t\t\t|| settingsKey == SettingsKey.print_center\n\t\t\t\t|| settingsKey == SettingsKey.extruder_count\n\t\t\t\t|| settingsKey == SettingsKey.bed_shape)\n\t\t\t{\n\t\t\t\tactiveBedToolClippingImage = int.MinValue;\n\n\t\t\t\t// Force texture rebuild, don't clear allowing redraws of the stale data until rebuilt\n\t\t\t\tbedTextures = null;\n\t\t\t\tthis.EnsureBedTexture(sceneContext.Scene.SelectedItem, clearToPlaceholderImage: false);\n\t\t\t}\n\t\t}", "label": "ComplexConditional"}
{"text": "//This function resets the UV state for the specified tile locations (as well as nearby tiles) such that the UV cache must be re-evaluated\n        public static void ResetUVCache(WorldViewModel _wvm, int tileStartX, int tileStartY, int regionWidth, int regionHeight)\n        {\n            if (_wvm.TilePicker.PaintMode == PaintMode.TileAndWall)\n            {\n                    //Reset UV Cache for nearby tiles and walls\n                    for (int x = -1; x < regionWidth + 1; x++)\n                    {\n                        int tilex = x + tileStartX;\n                        for (int y = -1; y < regionHeight + 1; y++)\n                        {\n                            int tiley = y + tileStartY;\n                            if (tilex < 0 || tiley < 0 || tilex >= _wvm.CurrentWorld.TilesWide || tiley >= _wvm.CurrentWorld.TilesHigh)\n                            {\n                                continue;\n                            }\n                            Tile curtile = _wvm.CurrentWorld.Tiles[tilex, tiley];\n                            if (_wvm.TilePicker.TileStyleActive)\n                            {\n                                curtile.uvTileCache = 0xFFFF;\n                                curtile.lazyMergeId = 0xFF;\n                                curtile.hasLazyChecked = false;\n                            }\n                            if (_wvm.TilePicker.WallStyleActive)\n                                curtile.uvWallCache = 0xFFFF;\n                        }\n                    }\n            }\n        }", "label": "ComplexConditional"}
{"text": "private static void ParseVersion()\n\t\t{\n\t\t\tif ((Version == null || Version < _INITVersion) && RootDirectory != null && RootDirectory.Exists)\n\t\t\t{\n\t\t\t\tvar files = RootDirectory.GetFiles(\"VERSION\", SearchOption.TopDirectoryOnly);\n\n\t\t\t\tforeach (var file in files.Where(f => String.Equals(\"VERSION\", f.Name) && String.IsNullOrWhiteSpace(f.Extension)))\n\t\t\t\t{\n\t\t\t\t\tusing (var stream = file.OpenText())\n\t\t\t\t\t{\n\t\t\t\t\t\tstring ver = stream.ReadToEnd().Trim();\n\t\t\t\t\t\tVersionInfo v;\n\n\t\t\t\t\t\tif (!VersionInfo.TryParse(ver, out v))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tVersion = v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (Version == null || Version < _INITVersion)\n\t\t\t{\n\t\t\t\tVersion = _INITVersion;\n\t\t\t}\n\t\t}", "label": "ComplexConditional"}
{"text": "private IEnumerable<KeyValuePair<HelpPageSampleKey, object>> GetAllActionSamples(string controllerName, string actionName, IEnumerable<string> parameterNames, SampleDirection sampleDirection)\n        {\n            HashSet<string> parameterNamesSet = new HashSet<string>(parameterNames, StringComparer.OrdinalIgnoreCase);\n            foreach (var sample in ActionSamples)\n            {\n                HelpPageSampleKey sampleKey = sample.Key;\n                if (String.Equals(controllerName, sampleKey.ControllerName, StringComparison.OrdinalIgnoreCase) &&\n                    String.Equals(actionName, sampleKey.ActionName, StringComparison.OrdinalIgnoreCase) &&\n                    (sampleKey.ParameterNames.SetEquals(new[] { \"*\" }) || parameterNamesSet.SetEquals(sampleKey.ParameterNames)) &&\n                    sampleDirection == sampleKey.SampleDirection)\n                {\n                    yield return sample;\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "public void Resolve(IList<ISymbol> results)\n            {\n                if (string.IsNullOrEmpty(_name))\n                {\n                    return;\n                }\n\n                // Try to parse the name as declaration ID generated from symbol's documentation comment Id.\n                List<ISymbol> docIdResults;\n                if (DocumentationCommentId.TryGetSymbolsForDeclarationId(RemovePrefix(_name, s_suppressionPrefix), _compilation, out docIdResults))\n                {\n                    foreach (var result in docIdResults)\n                    {\n                        results.Add(result);\n                    }\n\n                    return;\n                }\n\n                // Parse 'e:' prefix used by FxCop to differentiate between event and non-event symbols of the same name.\n                bool isEvent = false;\n                if (_name.Length >= 2 && _name[0] == 'e' && _name[1] == ':')\n                {\n                    isEvent = true;\n                    _index = 2;\n                }\n\n                INamespaceOrTypeSymbol containingSymbol = _compilation.GlobalNamespace;\n                bool? segmentIsNamedTypeName = null;\n\n                while (true)\n                {\n                    var segment = ParseNextNameSegment();\n\n                    // Special case: Roslyn names indexers \"this[]\" in CSharp, FxCop names them \"Item\" with parameters in [] brackets\n                    bool isIndexerProperty = false;\n                    if (segment == \"Item\" && PeekNextChar() == '[')\n                    {\n                        isIndexerProperty = true;\n                        if (_compilation.Language == LanguageNames.CSharp)\n                        {\n                            segment = \"this[]\";\n                        }\n                    }\n\n                    var candidateMembers = containingSymbol.GetMembers(segment);\n                    if (candidateMembers.Length == 0)\n                    {\n                        return;\n                    }\n\n                    if (segmentIsNamedTypeName.HasValue)\n                    {\n                        candidateMembers = segmentIsNamedTypeName.Value ?\n                            candidateMembers.Where(s => s.Kind == SymbolKind.NamedType).ToImmutableArray() :\n                            candidateMembers.Where(s => s.Kind != SymbolKind.NamedType).ToImmutableArray();\n\n                        segmentIsNamedTypeName = null;\n                    }\n\n                    int? arity = null;\n                    ParameterInfo[] parameters = null;\n\n                    // Check for generic arity\n                    if (_scope != TargetScope.Namespace && PeekNextChar() == '`')\n                    {\n                        ++_index;\n                        arity = ReadNextInteger();\n                    }\n\n                    // Check for method or indexer parameter list\n                    var nextChar = PeekNextChar();\n\n                    if (!isIndexerProperty && nextChar == '(' || isIndexerProperty && nextChar == '[')\n                    {\n                        parameters = ParseParameterList();\n                        if (parameters == null)\n                        {\n                            // Failed to resolve parameter list\n                            return;\n                        }\n                    }\n                    else if (nextChar == '.' || nextChar == '+')\n                    {\n                        ++_index;\n\n                        if (arity > 0 || nextChar == '+')\n                        {\n                            // The name continues and either has an arity or specifically continues with a '+'\n                            // so segment must be the name of a named type\n                            containingSymbol = GetFirstMatchingNamedType(candidateMembers, arity ?? 0);\n                        }\n                        else\n                        {\n                            // The name continues with a '.' and does not specify a generic arity\n                            // so segment must be the name of a namespace or a named type\n                            containingSymbol = GetFirstMatchingNamespaceOrType(candidateMembers);\n                        }\n\n                        if (containingSymbol == null)\n                        {\n                            // If we cannot resolve the name on the left of the delimiter, we have no \n                            // hope of finding the symbol.\n                            return;\n                        }\n                        else if (containingSymbol.Kind == SymbolKind.NamedType)\n                        {\n                            // If segment resolves to a named type, that restricts what the next segment\n                            // can resolve to depending on whether the name continues with '+' or '.'\n                            segmentIsNamedTypeName = nextChar == '+';\n                        }\n\n                        continue;\n                    }\n\n                    if (_scope == TargetScope.Member && !isIndexerProperty && parameters != null)\n                    {\n                        TypeInfo? returnType = null;\n                        if (PeekNextChar() == ':')\n                        {\n                            ++_index;\n                            returnType = ParseNamedType(null);\n                        }\n\n                        foreach (var method in GetMatchingMethods(candidateMembers, arity, parameters, returnType))\n                        {\n                            results.Add(method);\n                        }\n\n                        return;\n                    }\n\n                    ISymbol singleResult = null;\n\n                    switch (_scope)\n                    {\n                        case TargetScope.Namespace:\n                            singleResult = candidateMembers.FirstOrDefault(s => s.Kind == SymbolKind.Namespace);\n                            break;\n\n                        case TargetScope.Type:\n                            singleResult = GetFirstMatchingNamedType(candidateMembers, arity ?? 0);\n                            break;\n\n                        case TargetScope.Member:\n                            if (isIndexerProperty)\n                            {\n                                singleResult = GetFirstMatchingIndexer(candidateMembers, parameters);\n                            }\n                            else if (isEvent)\n                            {\n                                singleResult = candidateMembers.FirstOrDefault(s => s.Kind == SymbolKind.Event);\n                            }\n                            else\n                            {\n                                singleResult = candidateMembers.FirstOrDefault(s =>\n                                    s.Kind != SymbolKind.Namespace &&\n                                    s.Kind != SymbolKind.NamedType);\n                            }\n                            break;\n\n                        default:\n                            throw ExceptionUtilities.UnexpectedValue(_scope);\n                    }\n\n                    if (singleResult != null)\n                    {\n                        results.Add(singleResult);\n                    }\n\n                    return;\n                }\n            }", "label": "ComplexConditional"}
{"text": "public string ResolveUrl(RequireSettings settings, string applicationPath) {\n            string url;\n            if (_urlResolveCache.TryGetValue(settings, out url)) {\n                return url;\n            }\n            // Url priority:\n            if (settings.DebugMode) {\n                url = settings.CdnMode\n                    ? Coalesce(UrlCdnDebug, UrlDebug, UrlCdn, Url)\n                    : Coalesce(UrlDebug, Url, UrlCdnDebug, UrlCdn);\n            }\n            else {\n                url = settings.CdnMode\n                    ? Coalesce(UrlCdn, Url, UrlCdnDebug, UrlDebug)\n                    : Coalesce(Url, UrlDebug, UrlCdn, UrlCdnDebug);\n            }\n            if (String.IsNullOrEmpty(url)) {\n                return null;\n            }\n            if (!String.IsNullOrEmpty(settings.Culture)) {\n                string nearestCulture = FindNearestCulture(settings.Culture);\n                if (!String.IsNullOrEmpty(nearestCulture)) {\n                    url = Path.ChangeExtension(url, nearestCulture + Path.GetExtension(url));\n                }\n            }\n            if (!Uri.IsWellFormedUriString(url, UriKind.Absolute) && !VirtualPathUtility.IsAbsolute(url) && !VirtualPathUtility.IsAppRelative(url) && !String.IsNullOrEmpty(BasePath)) {\n                // relative urls are relative to the base path of the module that defined the manifest\n                url = VirtualPathUtility.Combine(BasePath, url);\n            }\n            if (VirtualPathUtility.IsAppRelative(url)) {\n                url = VirtualPathUtility.ToAbsolute(url, applicationPath);\n            }\n            _urlResolveCache[settings] = url;\n            return url;\n        }", "label": "ComplexConditional"}
{"text": "public override void OnDoubleClick(Mobile from)\n        {\n            if (!from.InRange(this.GetWorldLocation(), 2) || !from.InLOS(this))\n            {\n                from.LocalOverheadMessage(MessageType.Regular, 0x3B2, 1019045); // I can't reach that\n            }\n            else if (this.Visible && (this.ItemID == 4656 || this.ItemID == 4702) && DateTime.UtcNow >= this.m_NextUse)\n            {\n                Point3D p = this.GetWorldLocation();\n\n                if (1 > Utility.Random(Math.Max(Math.Abs(from.X - p.X), Math.Abs(from.Y - p.Y))))\n                {\n                    Effects.PlaySound(from.Location, from.Map, from.GetHurtSound());\n                    from.PublicOverheadMessage(MessageType.Regular, from.SpeechHue, true, \"Ouch!\");\n                    Spells.SpellHelper.Damage(TimeSpan.FromSeconds(0.5), from, Utility.Dice(2, 10, 5));\n                }\n\n                Effects.PlaySound(this.GetWorldLocation(), this.Map, 0x387);\n\n                Timer.DelayCall(TimeSpan.FromSeconds(0.25), new TimerCallback(Down1));\n                Timer.DelayCall(TimeSpan.FromSeconds(0.50), new TimerCallback(Down2));\n\n                Timer.DelayCall(TimeSpan.FromSeconds(5.00), new TimerCallback(BackUp));\n\n                this.m_NextUse = DateTime.UtcNow + TimeSpan.FromSeconds(10.0);\n            }\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Determine whether we can resolve a particular typeKey\n        /// </summary>\n        bool IRegistrationContext.CanResolve(Type type, string key)\n        {\n            IRegistrationCollection registrations;\n\n            if (this.registrations.TryGetValue(new TypeKey(type.TypeHandle, key), out registrations) ||\n                this.TryCreateFuncFactory(type, key, out registrations) ||\n                this.TryCreateGenericTypesForUnboundGeneric(type, key, out registrations) ||\n                this.TryCreateSelfBinding(type, key, out registrations))\n            {\n                return true;\n            }\n\n            // Is it a 'get all' request?\n            IRegistration registration;\n            return this.TryRetrieveGetAllRegistration(type, key, out registration);\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n            /// Convert an object to a non-null double value.\n            /// </summary>\n            /// <param name=\"value\">Object to convert.</param>\n            /// <returns>Converted double value.</returns>\n            private static double ValueAsDouble(object value)\n            {\n                if (value == null)\n                {\n                    throw new FormatException(Strings.GeoJsonReader_InvalidNullElement);\n                }\n\n                // At this point we are expecting them to only be numeric, so verify that.\n                if (value is String || value is IDictionary<string, object> || value is IEnumerable || value is bool)\n                {\n                    throw new FormatException(Strings.GeoJsonReader_ExpectedNumeric);\n                }\n\n                // value is already a numeric value at this point, so can safely convert it using InvariantCulture.\n                return Convert.ToDouble(value, CultureInfo.InvariantCulture);\n            }", "label": "ComplexConditional"}
{"text": "#endregion\n\n\n        void AddBeaches([NotNull] Map map)\n        {\n            if (map == null) throw new ArgumentNullException(\"map\");\n            int beachExtentSqr = (args.BeachExtent + 1) * (args.BeachExtent + 1);\n            for (int x = 0; x < map.Width; x++)\n            {\n                for (int y = 0; y < map.Length; y++)\n                {\n                    for (int z = args.WaterLevel; z <= args.WaterLevel + args.BeachHeight; z++)\n                    {\n                        if (map.GetBlock(x, y, z) != bGroundSurface) continue;\n                        bool found = false;\n                        for (int dx = -args.BeachExtent; !found && dx <= args.BeachExtent; dx++)\n                        {\n                            for (int dy = -args.BeachExtent; !found && dy <= args.BeachExtent; dy++)\n                            {\n                                for (int dz = -args.BeachHeight; dz <= 0; dz++)\n                                {\n                                    if (dx * dx + dy * dy + dz * dz > beachExtentSqr) continue;\n                                    int xx = x + dx;\n                                    int yy = y + dy;\n                                    int zz = z + dz;\n                                    if (xx < 0 || xx >= map.Width || yy < 0 || yy >= map.Length || zz < 0 ||\n                                        zz >= map.Height) continue;\n                                    Block block = map.GetBlock(xx, yy, zz);\n                                    if (block == bWater || block == bWaterSurface)\n                                    {\n                                        found = true;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                        if (found)\n                        {\n                            map.SetBlock(x, y, z, bSeaFloor);\n                            if (z > 0 && map.GetBlock(x, y, z - 1) == bGround)\n                            {\n                                map.SetBlock(x, y, z - 1, bSeaFloor);\n                            }\n                        }\n                    }\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        ///     Called when the game receives a window message.\n        /// </summary>\n        /// <param name=\"message\">\n        ///     The message.\n        /// </param>\n        /// <param name=\"cursorPos\">\n        ///     The cursor position.\n        /// </param>\n        /// <param name=\"key\">\n        ///     The key.\n        /// </param>\n        /// <param name=\"wndArgs\">\n        ///     The windows arguments.\n        /// </param>\n        internal void OnReceiveMessage(\n            WindowsMessages message,\n            Vector2 cursorPos,\n            uint key,\n            WndEventComposition wndArgs)\n        {\n            if (message == WindowsMessages.WM_MOUSEMOVE)\n            {\n                if (this.Visible && this.IsInside(cursorPos))\n                {\n                    if (cursorPos.X > this.Position.X + this.Width - 67\n                        && cursorPos.X < this.Position.X + this.Width - 67 + this.Height + 8)\n                    {\n                        this.ShowTooltip();\n                    }\n                }\n                else\n                {\n                    this.ShowTooltip(true);\n                }\n            }\n\n            switch (this.ValueType)\n            {\n                case MenuValueType.Boolean:\n                    if (message != WindowsMessages.WM_LBUTTONDOWN)\n                    {\n                        return;\n                    }\n\n                    if (!this.Visible)\n                    {\n                        return;\n                    }\n\n                    if (!this.IsInside(cursorPos))\n                    {\n                        return;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width)\n                    {\n                        break;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width - this.Height)\n                    {\n                        this.SetValue(!this.GetValue<bool>());\n                    }\n\n                    break;\n                case MenuValueType.Slider:\n                    if (!this.Visible)\n                    {\n                        this.Interacting = false;\n                        return;\n                    }\n\n                    if (message == WindowsMessages.WM_MOUSEMOVE && this.Interacting\n                        || message == WindowsMessages.WM_LBUTTONDOWN && !this.Interacting && this.IsInside(cursorPos))\n                    {\n                        var val = this.GetValue<Slider>();\n                        var t = val.MinValue\n                                + ((cursorPos.X - this.Position.X) * (val.MaxValue - val.MinValue)) / this.Width;\n                        val.Value = (int)t;\n                        this.SetValue(val);\n                    }\n\n                    if (message != WindowsMessages.WM_LBUTTONDOWN && message != WindowsMessages.WM_LBUTTONUP)\n                    {\n                        return;\n                    }\n\n                    if (!this.IsInside(cursorPos) && message == WindowsMessages.WM_LBUTTONDOWN)\n                    {\n                        return;\n                    }\n\n                    this.Interacting = message == WindowsMessages.WM_LBUTTONDOWN;\n                    break;\n                case MenuValueType.Color:\n                    if (message != WindowsMessages.WM_LBUTTONDOWN)\n                    {\n                        return;\n                    }\n\n                    if (!this.Visible)\n                    {\n                        return;\n                    }\n\n                    if (!this.IsInside(cursorPos))\n                    {\n                        return;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width)\n                    {\n                        break;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width - this.Height)\n                    {\n                        var c = this.GetValue<System.Drawing.Color>();\n                        ColorPicker.Load(delegate(System.Drawing.Color args) { this.SetValue(args); }, c);\n                    }\n\n                    break;\n                case MenuValueType.Circle:\n                    if (message != WindowsMessages.WM_LBUTTONDOWN)\n                    {\n                        return;\n                    }\n\n                    if (!this.Visible)\n                    {\n                        return;\n                    }\n\n                    if (!this.IsInside(cursorPos))\n                    {\n                        return;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width)\n                    {\n                        break;\n                    }\n\n                    if (cursorPos.X - this.Position.X > this.Width - this.Height)\n                    {\n                        var val = this.GetValue<Circle>();\n                        val.Active = !val.Active;\n                        this.SetValue(val);\n                    }\n                    else if (cursorPos.X - this.Position.X > this.Width - 2 * this.Height)\n                    {\n                        var c = this.GetValue<Circle>();\n                        ColorPicker.Load(\n                            delegate(System.Drawing.Color args)\n                                {\n                                    var val = this.GetValue<Circle>();\n                                    val.Color = args;\n                                    this.SetValue(val);\n                                },\n                            c.Color);\n                    }\n\n                    break;\n                case MenuValueType.KeyBind:\n                    if (!MenuGUI.IsChatOpen && !MenuGUI.IsShopOpen)\n                    {\n                        switch (message)\n                        {\n                            case WindowsMessages.WM_KEYDOWN:\n                                var val = this.GetValue<KeyBind>();\n                                if (key == val.Key || key == val.SecondaryKey)\n                                {\n                                    if (val.Type == KeyBindType.Press)\n                                    {\n                                        if (!val.Active)\n                                        {\n                                            val.Active = true;\n                                            this.SetValue(val);\n                                        }\n                                    }\n                                }\n                                break;\n                            case WindowsMessages.WM_KEYUP:\n\n                                var val2 = this.GetValue<KeyBind>();\n                                if (key == val2.Key || key == val2.SecondaryKey)\n                                {\n                                    if (val2.Type == KeyBindType.Press)\n                                    {\n                                        val2.Active = false;\n                                        this.SetValue(val2);\n                                    }\n                                    else\n                                    {\n                                        val2.Active = !val2.Active;\n                                        this.SetValue(val2);\n                                    }\n                                }\n                                break;\n                        }\n                    }\n\n                    if (key == 8 && message == WindowsMessages.WM_KEYUP && this.Interacting)\n                    {\n                        var val = this.GetValue<KeyBind>();\n                        val.Key = 0;\n                        val.SecondaryKey = 0;\n                        this.SetValue(val);\n                        this.Interacting = false;\n                        this.KeybindSettingStage = KeybindSetStage.NotSetting;\n                    }\n\n                    if (message == WindowsMessages.WM_KEYUP && this.Interacting\n                        && this.KeybindSettingStage != KeybindSetStage.NotSetting)\n                    {\n                        if (this.KeybindSettingStage == KeybindSetStage.Keybind1)\n                        {\n                            var val = this.GetValue<KeyBind>();\n                            val.Key = key;\n                            this.SetValue(val);\n                            this.KeybindSettingStage = KeybindSetStage.Keybind2;\n                        }\n                        else if (this.KeybindSettingStage == KeybindSetStage.Keybind2)\n                        {\n                            var val = this.GetValue<KeyBind>();\n                            val.SecondaryKey = key;\n                            this.SetValue(val);\n                            this.Interacting = false;\n                            this.KeybindSettingStage = KeybindSetStage.NotSetting;\n                        }\n                    }\n\n                    if (message == WindowsMessages.WM_KEYUP && this.Interacting\n                        && this.KeybindSettingStage == KeybindSetStage.NotSetting)\n                    {\n                        var val = this.GetValue<KeyBind>();\n                        val.Key = key;\n                        val.SecondaryKey = 0;\n                        this.SetValue(val);\n                        this.Interacting = false;\n                    }\n\n                    if (!this.Visible)\n                    {\n                        return;\n                    }\n\n                    if (message != WindowsMessages.WM_LBUTTONDOWN && wndArgs.Msg != WindowsMessages.WM_RBUTTONDOWN)\n                    {\n                        return;\n                    }\n\n                    if (!this.IsInside(cursorPos))\n                    {\n                        return;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width)\n                    {\n                        break;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width - this.Height)\n                    {\n                        var val = this.GetValue<KeyBind>();\n                        val.Active = !val.Active;\n                        this.SetValue(val);\n                    }\n                    else\n                    {\n                        if (wndArgs.Msg == WindowsMessages.WM_RBUTTONDOWN)\n                        {\n                            this.KeybindSettingStage = KeybindSetStage.Keybind1;\n                        }\n                        //this.Stage = KeybindSetStage.NotSetting;\n                        this.Interacting = !this.Interacting;\n                    }\n\n                    break;\n                case MenuValueType.StringList:\n                    if (!this.Visible)\n                    {\n                        return;\n                    }\n\n                    if (message != WindowsMessages.WM_LBUTTONDOWN)\n                    {\n                        return;\n                    }\n\n                    if (!this.IsInside(cursorPos))\n                    {\n                        return;\n                    }\n\n                    if (cursorPos.X > this.Position.X + this.Width)\n                    {\n                        break;\n                    }\n\n                    var slVal = this.GetValue<StringList>();\n                    if (cursorPos.X > this.Position.X + this.Width - this.Height)\n                    {\n                        slVal.SelectedIndex = slVal.SelectedIndex == slVal.SList.Length - 1\n                                                  ? 0\n                                                  : (slVal.SelectedIndex + 1);\n                        this.SetValue(slVal);\n                    }\n                    else if (cursorPos.X > this.Position.X + this.Width - 2 * this.Height)\n                    {\n                        slVal.SelectedIndex = slVal.SelectedIndex == 0\n                                                  ? slVal.SList.Length - 1\n                                                  : (slVal.SelectedIndex - 1);\n                        this.SetValue(slVal);\n                    }\n\n                    break;\n            }\n        }", "label": "ComplexConditional"}
{"text": "public override bool OnMoveOver(Mobile m)\n\t\t{\n\t\t\tif (m is BaseCreature && !((BaseCreature)m).Controlled)\n\t\t\t{\n\t\t\t\treturn (!Alive || !m.Alive || IsDeadBondedPet || m.IsDeadBondedPet) || (Hidden && IsStaff());\n\t\t\t}\n\n\t\t\t#region Dueling\n\t\t\tif (Region.IsPartOf(typeof(SafeZone)) && m is PlayerMobile)\n\t\t\t{\n\t\t\t\tPlayerMobile pm = (PlayerMobile)m;\n\n\t\t\t\tif (pm.DuelContext == null || pm.DuelPlayer == null || !pm.DuelContext.Started || pm.DuelContext.Finished ||\n\t\t\t\t\tpm.DuelPlayer.Eliminated)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t#endregion\n\n\t\t\treturn base.OnMoveOver(m);\n\t\t}", "label": "ComplexConditional"}
{"text": "static MultiData()\n\t\t{\n\t\t\tstring idxPath = Core.FindDataFile(\"multi.idx\");\n\t\t\tstring mulPath = Core.FindDataFile(\"multi.mul\");\n\n\t\t\tif (File.Exists(idxPath) && File.Exists(mulPath))\n\t\t\t{\n\t\t\t\tm_Index = new FileStream(idxPath, FileMode.Open, FileAccess.Read, FileShare.Read);\n\t\t\t\tm_IndexReader = new BinaryReader(m_Index);\n\n\t\t\t\tm_Stream = new FileStream(mulPath, FileMode.Open, FileAccess.Read, FileShare.Read);\n\t\t\t\tm_StreamReader = new BinaryReader(m_Stream);\n\n\t\t\t\tm_Components = new MultiComponentList[(int)(m_Index.Length / 12)];\n\n\t\t\t\tstring vdPath = Core.FindDataFile(\"verdata.mul\");\n\n\t\t\t\tif (File.Exists(vdPath))\n\t\t\t\t{\n\t\t\t\t\tusing (var fs = new FileStream(vdPath, FileMode.Open, FileAccess.Read, FileShare.Read))\n\t\t\t\t\t{\n\t\t\t\t\t\tvar bin = new BinaryReader(fs);\n\n\t\t\t\t\t\tint count = bin.ReadInt32();\n\n\t\t\t\t\t\tfor (int i = 0; i < count; ++i)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint file = bin.ReadInt32();\n\t\t\t\t\t\t\tint index = bin.ReadInt32();\n\t\t\t\t\t\t\tint lookup = bin.ReadInt32();\n\t\t\t\t\t\t\tint length = bin.ReadInt32();\n\t\t\t\t\t\t\tint extra = bin.ReadInt32();\n\n\t\t\t\t\t\t\tif (file == 14 && index >= 0 && index < m_Components.Length && lookup >= 0 && length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbin.BaseStream.Seek(lookup, SeekOrigin.Begin);\n\n\t\t\t\t\t\t\t\tm_Components[index] = new MultiComponentList(bin, length / 12);\n\n\t\t\t\t\t\t\t\tbin.BaseStream.Seek(24 + (i * 20), SeekOrigin.Begin);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbin.Close();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tConsole.WriteLine(\"Warning: Multi data files not found\");\n\n\t\t\t\tm_Components = new MultiComponentList[0];\n\t\t\t}\n\t\t}", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// This method is an optimization that\n        /// skips matching elements at the end of the \n        /// two arrays being diff'ed.\n        /// Care's taken so that this will never\n        /// overlap with the pre-skip.\n        /// </summary>\n        private void CalculatePostSkip()\n        {\n            int leftLen = _left.Count;\n            int rightLen = _right.Count;\n            while (_postSkip < leftLen && _postSkip < rightLen &&\n                   _postSkip < (leftLen - _preSkip) &&\n                   _compareFunc(_left[leftLen - _postSkip - 1], _right[rightLen - _postSkip - 1]))\n            {\n                _postSkip++;\n            }\n        }", "label": "ComplexConditional"}
{"text": "protected virtual void OnDeathDeny(Mobile m)\n\t\t{\n\t\t\tif (m == null || m.Deleted)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tPlayerMobile pm = m as PlayerMobile;\n\t\t\tPvPTeam team;\n\n\t\t\tif (pm == null || !IsParticipant(pm, out team) || team == null || team.Deleted)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tpm.SendMessage(\"You have been spared death, this time...\");\n\t\t\tteam.OnMemberDeath(pm);\n\t\t}", "label": "ComplexConditional"}
{"text": "private CursPos CursorPosition()\n        {\n            if (RealCursorPosition.X > CurrentTopLeft.X - 10 && RealCursorPosition.X < CurrentTopLeft.X + 10 &&\n                RealCursorPosition.Y > CurrentTopLeft.Y + 10 && RealCursorPosition.Y < CurrentBottomRight.Y - 10)\n            {\n                Cursor = Cursors.SizeWE;\n                return CursPos.LeftLine;\n            }\n            if (RealCursorPosition.X >= CurrentTopLeft.X - 10 && RealCursorPosition.X <= CurrentTopLeft.X + 10 &&\n                RealCursorPosition.Y >= CurrentTopLeft.Y - 10 && RealCursorPosition.Y <= CurrentTopLeft.Y + 10)\n            {\n                Cursor = Cursors.SizeNWSE;\n                return CursPos.TopLeft;\n            }\n            if (RealCursorPosition.X >= CurrentTopLeft.X - 10 && RealCursorPosition.X <= CurrentTopLeft.X + 10 &&\n                RealCursorPosition.Y >= CurrentBottomRight.Y - 10 && RealCursorPosition.Y <= CurrentBottomRight.Y + 10)\n            {\n                Cursor = Cursors.SizeNESW;\n                return CursPos.BottomLeft;\n            }\n            if (RealCursorPosition.X > CurrentBottomRight.X - 10 && RealCursorPosition.X < CurrentBottomRight.X + 10 &&\n                RealCursorPosition.Y > CurrentTopLeft.Y + 10 && RealCursorPosition.Y < CurrentBottomRight.Y - 10)\n            {\n                Cursor = Cursors.SizeWE;\n                return CursPos.RightLine;\n            }\n            if (RealCursorPosition.X >= CurrentBottomRight.X - 10 &&\n                RealCursorPosition.X <= CurrentBottomRight.X + 10 && RealCursorPosition.Y >= CurrentTopLeft.Y - 10 &&\n                RealCursorPosition.Y <= CurrentTopLeft.Y + 10)\n            {\n                Cursor = Cursors.SizeNESW;\n                return CursPos.TopRight;\n            }\n            if (RealCursorPosition.X >= CurrentBottomRight.X - 10 &&\n                RealCursorPosition.X <= CurrentBottomRight.X + 10 &&\n                RealCursorPosition.Y >= CurrentBottomRight.Y - 10 && RealCursorPosition.Y <= CurrentBottomRight.Y + 10)\n            {\n                Cursor = Cursors.SizeNWSE;\n                return CursPos.BottomRight;\n            }\n            if (RealCursorPosition.Y > CurrentTopLeft.Y - 10 && RealCursorPosition.Y < CurrentTopLeft.Y + 10 &&\n                RealCursorPosition.X > CurrentTopLeft.X + 10 && RealCursorPosition.X < CurrentBottomRight.X - 10)\n            {\n                Cursor = Cursors.SizeNS;\n                return CursPos.TopLine;\n            }\n            if (RealCursorPosition.Y > CurrentBottomRight.Y - 10 && RealCursorPosition.Y < CurrentBottomRight.Y + 10 &&\n                RealCursorPosition.X > CurrentTopLeft.X + 10 && RealCursorPosition.X < CurrentBottomRight.X - 10)\n            {\n                Cursor = Cursors.SizeNS;\n                return CursPos.BottomLine;\n            }\n            if (RealCursorPosition.X >= CurrentTopLeft.X + 10 && RealCursorPosition.X <= CurrentBottomRight.X - 10 &&\n                RealCursorPosition.Y >= CurrentTopLeft.Y + 10 && RealCursorPosition.Y <= CurrentBottomRight.Y - 10)\n            {\n                Cursor = Cursors.Hand;\n                return CursPos.WithinSelectionArea;\n            }\n\n            Cursor = Cursors.No;\n            return CursPos.OutsideSelectionArea;\n        }", "label": "ComplexConditional"}
{"text": "private static void Farm_skills(Spell spell, bool skillshot = false)\n        {\n            if (!_q.IsReady())\n                return;\n            var allMinions = MinionManager.GetMinions(ObjectManager.Player.ServerPosition, _q.Range, MinionTypes.All);\n            foreach (var minion in allMinions)\n            {\n                if (!minion.IsValidTarget())\n                    continue;\n                var minionInRangeAa = Orbwalking.InAutoAttackRange(minion);\n                var minionInRangeSpell = minion.Distance(ObjectManager.Player) <= spell.Range;\n                var minionKillableAa = _player.GetAutoAttackDamage(minion, true) - 30 >= minion.Health;\n                var minionKillableSpell = _player.GetSpellDamage(minion, SpellSlot.Q) - 30 >= minion.Health;\n                var lastHit = _orbwalker.ActiveMode == Orbwalking.OrbwalkingMode.LastHit;\n                var laneClear = _orbwalker.ActiveMode == Orbwalking.OrbwalkingMode.LaneClear;\n                if ((lastHit && minionInRangeSpell && minionKillableSpell) &&\n                    _q.GetPrediction(minion).CollisionObjects.Count > 0 && skillshot)\n                {\n                    spell.Cast(minion.Position);\n                }\n                if (laneClear && minionInRangeSpell)\n                {\n                    if (minionKillableSpell && _q.GetPrediction(minion).CollisionObjects.Count > 0 && skillshot)\n                        spell.Cast(minion.Position);\n                    else\n                        spell.Cast(minion);\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n            /// An event was received from the filesystem watcher, analyze the change and apply it.\n            /// <returns>Whether the move has now been synchronized, so that no further action is needed</returns>\n            /// </summary>\n            private bool WatchSyncMove(string remoteFolder, string localFolder, string oldPathname, string newPathname, Grace grace)\n            {\n                bool success = true;\n                SleepWhileSuspended();\n\n                try\n                {\n                // Old item.\n                string oldDirectory = Path.GetDirectoryName(oldPathname);\n                string oldFilename = Path.GetFileName(oldPathname);\n                string oldLocalName = oldPathname.Substring(localFolder.Length + 1);\n                SyncItem oldItem = database.GetSyncItemFromLocalPath(oldPathname);\n                    if (oldItem == null)\n                    {\n                        // The change is about a file which was not in database yet, we can't move it. Further action is needed.\n                        return false;\n                    }\n                string oldRemoteName = oldItem.RemotePath;\n                string oldRemoteBaseName = CmisUtils.GetUpperFolderOfCmisPath(oldRemoteName);\n                bool oldPathnameWorthSyncing = Utils.WorthSyncing(oldDirectory, oldFilename, repoInfo);\n\n                // New item.\n                bool isFolder = Utils.IsFolder(newPathname);\n                string newDirectory = Path.GetDirectoryName(newPathname); // TODO do this only if isFolder is true, modify rest of the logic accordingly.\n                string newFilename = Path.GetFileName(newPathname);\n                string newLocalName = newPathname.Substring(localFolder.Length + 1);\n                SyncItem newItem = SyncItemFactory.CreateFromLocalPath(newPathname, isFolder, repoInfo, database);\n                string newRemoteName = newItem.RemotePath;\n                string newRemoteBaseName = CmisUtils.GetUpperFolderOfCmisPath(newRemoteName);\n                bool newPathnameWorthSyncing = Utils.WorthSyncing(newDirectory, newFilename, repoInfo);\n\n                // Operations.\n                bool rename = oldDirectory.Equals(newDirectory) && !oldFilename.Equals(newFilename);\n                bool move = !oldDirectory.Equals(newDirectory) && oldFilename.Equals(newFilename);\n                if ((rename && move) || (!rename && !move))\n                {\n                    Logger.ErrorFormat(\"Not a valid rename/move: {0} -> {1}\", oldPathname, newPathname);\n                    return true; // It is not our problem that watcher data is not valid.\n                }\n                    if (oldPathnameWorthSyncing && newPathnameWorthSyncing)\n                    {\n                        if (database.ContainsLocalFile(oldPathname))\n                        {\n                            if (database.ContainsLocalFile(newPathname))\n                            {\n                                //database already contains path so revert back to delete/update\n                                success &= WatcherSyncDelete(remoteFolder, localFolder, oldPathname, grace);\n                                success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname);\n                            }\n                            else\n                            {\n                                if (rename)\n                                {\n                                    //rename file...\n                                    IDocument remoteDocument = (IDocument)session.GetObjectByPath(oldRemoteName, true);\n                                    success &= RenameFile(oldDirectory, newFilename, remoteDocument);\n                                }\n                                else //move\n                                {\n                                    //move file...\n                                    IDocument remoteDocument = (IDocument)session.GetObjectByPath(oldRemoteName, true);\n                                    IFolder oldRemoteFolder = (IFolder)session.GetObjectByPath(oldRemoteBaseName, true);\n                                    IFolder newRemoteFolder = (IFolder)session.GetObjectByPath(newRemoteBaseName, true);\n                                    success &= MoveFile(oldDirectory, newDirectory, oldRemoteFolder, newRemoteFolder, remoteDocument);\n                                }\n                            }\n                        }\n                        else if (database.ContainsFolder(oldPathname))\n                        {\n                            if (database.ContainsFolder(newPathname))\n                            {\n                                //database already contains path so revert back to delete/update\n                                success &= WatcherSyncDelete(remoteFolder, localFolder, oldPathname, grace);\n                                success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname);\n                            }\n                            else\n                            {\n                                if (rename)\n                                {\n                                    //rename folder...\n                                    IFolder remoteFolderObject = (IFolder)session.GetObjectByPath(oldRemoteName, true);\n                                    success &= RenameFolder(oldDirectory, newFilename, remoteFolderObject);\n                                }\n                                else //move\n                                {\n                                    //move folder...\n                                    IFolder remoteFolderObject = (IFolder)session.GetObjectByPath(oldRemoteName, true);\n                                    IFolder oldRemoteFolder = (IFolder)session.GetObjectByPath(oldRemoteBaseName, true);\n                                    IFolder newRemoteFolder = (IFolder)session.GetObjectByPath(newRemoteBaseName, true);\n                                    success &= MoveFolder(oldDirectory, newDirectory, oldRemoteFolder, newRemoteFolder, remoteFolderObject);\n                                }\n                            }\n                        }\n                        else\n                        {\n                            //File/Folder has not been synced before so simply update\n                            success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname);\n                        }\n                    }\n                    else if (oldPathnameWorthSyncing && !newPathnameWorthSyncing)\n                    {\n                        //New path not worth syncing\n                        success &= WatcherSyncDelete(remoteFolder, localFolder, oldPathname, grace);\n                    }\n                    else if (!oldPathnameWorthSyncing && newPathnameWorthSyncing)\n                    {\n                        //Old path not worth syncing\n                        success &= WatcherSyncUpdate(remoteFolder, localFolder, newPathname);\n                    }\n                    else\n                    {\n                        //Neither old or new path worth syncing\n                    }\n                }\n                catch (FileNotFoundException e)\n                {\n                    success = false;\n                    Logger.Warn(\"Could process watcher sync move, file or folder not found: \" + oldPathname + \" -> \" + newPathname, e);\n                }\n                catch (Exception e)\n                {\n                    success = false;\n                    ProcessRecoverableException(\"Could not process watcher sync move: \" + oldPathname + \" -> \" + newPathname, e);\n                }\n                return success;\n            }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Get the Ampersand if buffer == \"&amp;\"\n        /// </summary>\n        private int GetAmpersandCharEntity(int iOffset, int length)\n        {\n            byte[] iBuffer = this.buffer;\n\n            if (length != 5 ||\n                iBuffer[offset + 1] != (byte)'a' ||\n                iBuffer[offset + 2] != (byte)'m' ||\n                iBuffer[offset + 3] != (byte)'p')\n\n                throw new Exception(\"XmlExceptionHelper.ThrowInvalidCharRef(this.reader);\");\n\n            return Keys.Ampersand;\n        }", "label": "ComplexConditional"}
{"text": "public OnChartBarAnnotation BarAnnotationAddOrModify(int barIndex, string barAnnotationId, string barAnnotationText,\n\t\t\t\tFont font, Color colorForeground, Color colorBackground, bool aboveBar = true, \n\t\t\t\tint verticalPadding = 5, bool popupParametersDidntChange = false) {\n\t\t\t//Add() candidate starts below\n\t\t\tif (this.OnChartBarAnnotations_byBar.ContainsKey(barIndex) == false) {\n\t\t\t\tthis.OnChartBarAnnotations_byBar.Add(barIndex, new SortedDictionary<string, OnChartBarAnnotation>());\n\t\t\t}\n\t\t\tSortedDictionary<string, OnChartBarAnnotation> annotationsForBar = this.OnChartBarAnnotations_byBar[barIndex];\n\n\t\t\tif (annotationsForBar.ContainsKey(barAnnotationId) == false) {\n\t\t\t\tOnChartBarAnnotation barAnnotationCreated = new OnChartBarAnnotation(\n\t\t\t\t\tbarAnnotationId, barAnnotationText, font, colorForeground, colorBackground,\n\t\t\t\t\taboveBar, verticalPadding, popupParametersDidntChange);\n\t\t\t\tannotationsForBar.Add(barAnnotationId, barAnnotationCreated);\n\n\t\t\t\treturn barAnnotationCreated;\n\t\t\t}\n\t\t\t\n\t\t\t//Modify() candidate starts below\n\t\t\tOnChartBarAnnotation barAnnotationToModify = annotationsForBar[barAnnotationId];\n\t\t\tif (\t   barAnnotationToModify.BarAnnotationText\t\t\t== barAnnotationText\n\t\t\t\t\t&& barAnnotationToModify.Font\t\t\t\t\t\t== font\n\t\t\t   \t\t&& barAnnotationToModify.ColorForeground\t\t\t== colorForeground\n\t\t\t\t\t&& barAnnotationToModify.ColorBackground\t\t\t== colorBackground\n\t\t\t\t\t&& barAnnotationToModify.AboveBar\t\t\t\t\t== aboveBar\n\t\t\t\t\t&& barAnnotationToModify.VerticalPaddingPx\t\t\t== verticalPadding\n\t\t\t\t\t//NOT_VALUABLE_PARAMETER_TO_HIDE_REPORTING && barAnnotationToModify.ReportDidntChangeStatus\t== reportDidntChangeStatus\n\t\t\t\t) {\n\t\t\t\tbarAnnotationToModify.Status = OnChartObjectOperationStatus.OnChartObjectNotModifiedSinceParametersDidntChange;\n\t\t\t\tif (barAnnotationToModify.DebugParametersDidntChange) {\n\t\t\t\t\tAssembler.PopupException(barAnnotationToModify.ToString() + \" //BarAnnotationAddOrModify()\");\n\t\t\t\t}\n\t\t\t\treturn barAnnotationToModify;\n\t\t\t}\n\t\t\t\n\t\t\tbarAnnotationToModify.Status = OnChartObjectOperationStatus.OnChartObjectModified;\n\n\t\t\tif (barAnnotationToModify.BarAnnotationText\t\t\t!= barAnnotationText)\t\t\tbarAnnotationToModify.BarAnnotationText\t\t\t\t= barAnnotationText;\n\t\t\tif (barAnnotationToModify.Font\t\t\t\t\t\t!= font)\t\t\t\t\t\tbarAnnotationToModify.Font\t\t\t\t\t\t\t= font;\n\t\t\tif (barAnnotationToModify.ColorForeground\t\t\t!= colorForeground)\t\t\t\tbarAnnotationToModify.ColorForeground\t\t\t\t= colorForeground;\n\t\t\tif (barAnnotationToModify.ColorBackground\t\t\t!= colorBackground)\t\t\t\tbarAnnotationToModify.ColorBackground\t\t\t\t= colorBackground;\n\t\t\tif (barAnnotationToModify.AboveBar\t\t\t\t\t!= aboveBar)\t\t\t\t\tbarAnnotationToModify.AboveBar\t\t\t\t\t\t= aboveBar;\n\t\t\tif (barAnnotationToModify.VerticalPaddingPx\t\t\t!= verticalPadding)\t\t\t\tbarAnnotationToModify.VerticalPaddingPx\t\t\t\t= verticalPadding;\n\t\t\tif (barAnnotationToModify.DebugParametersDidntChange!= popupParametersDidntChange)\tbarAnnotationToModify.DebugParametersDidntChange\t= popupParametersDidntChange;\n\n\t\t\treturn barAnnotationToModify;\n\t\t}", "label": "ComplexConditional"}
{"text": "protected Option (string prototype, string description)\n\t\t\t: this (prototype, description, 1, false)\n\t\t{\n\t\t}protected Option (string prototype, string description, int maxValueCount)\n\t\t\t: this (prototype, description, maxValueCount, false)\n\t\t{\n\t\t}protected Option (string prototype, string description, int maxValueCount, bool hidden)\n\t\t{\n\t\t\tif (prototype == null)\n\t\t\t\tthrow new ArgumentNullException (\"prototype\");\n\t\t\tif (prototype.Length == 0)\n\t\t\t\tthrow new ArgumentException (\"Cannot be the empty string.\", \"prototype\");\n\t\t\tif (maxValueCount < 0)\n\t\t\t\tthrow new ArgumentOutOfRangeException (\"maxValueCount\");\n\n\t\t\tthis.prototype   = prototype;\n\t\t\tthis.description = description;\n\t\t\tthis.count       = maxValueCount;\n\t\t\tthis.names       = (this is OptionSet.Category)\n\t\t\t\t// append GetHashCode() so that \"duplicate\" categories have distinct\n\t\t\t\t// names, e.g. adding multiple \"\" categories should be valid.\n\t\t\t\t? new[]{prototype + this.GetHashCode ()}\n\t\t\t\t: prototype.Split ('|');\n\n\t\t\tif (this is OptionSet.Category || this is CommandOption)\n\t\t\t\treturn;\n\n\t\t\tthis.type        = ParsePrototype ();\n\t\t\tthis.hidden      = hidden;\n\n\t\t\tif (this.count == 0 && type != OptionValueType.None)\n\t\t\t\tthrow new ArgumentException (\n\t\t\t\t\t\t\"Cannot provide maxValueCount of 0 for OptionValueType.Required or \" +\n\t\t\t\t\t\t\t\"OptionValueType.Optional.\",\n\t\t\t\t\t\t\"maxValueCount\");\n\t\t\tif (this.type == OptionValueType.None && maxValueCount > 1)\n\t\t\t\tthrow new ArgumentException (\n\t\t\t\t\t\tstring.Format (\"Cannot provide maxValueCount of {0} for OptionValueType.None.\", maxValueCount),\n\t\t\t\t\t\t\"maxValueCount\");\n\t\t\tif (Array.IndexOf (names, \"<>\") >= 0 && \n\t\t\t\t\t((names.Length == 1 && this.type != OptionValueType.None) ||\n\t\t\t\t\t (names.Length > 1 && this.MaxValueCount > 1)))\n\t\t\t\tthrow new ArgumentException (\n\t\t\t\t\t\t\"The default option handler '<>' cannot require values.\",\n\t\t\t\t\t\t\"prototype\");\n\t\t}", "label": "ComplexConditional"}
{"text": "public override void OnGotMeleeAttack(Mobile attacker)\n        {\n            base.OnGotMeleeAttack(attacker);\n\n            if (attacker != null && attacker.Alive && attacker.Weapon is BaseRanged && 0.4 > Utility.RandomDouble())\n            {\n                ThrowHatchet(attacker);\n            }\n        }", "label": "ComplexConditional"}
{"text": "internal override SqlExpression VisitNew(SqlNew sox) {\n\t\t\tfor (int i = 0, n = sox.Args.Count; i < n; i++) {\n\t\t\t\tif (inGroupBy) {\n\t\t\t\t\t// we don't want to fetch expressions for group by,\n\t\t\t\t\t// since we want links to remain links so SqlFlattener\n\t\t\t\t\t// can deal with them properly\n\t\t\t\t\tsox.Args[i] = this.VisitExpression(sox.Args[i]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsox.Args[i] = this.FetchExpression(sox.Args[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0, n = sox.Members.Count; i < n; i++) {\n\t\t\t\tSqlMemberAssign ma = sox.Members[i];\n\t\t\t\tMetaDataMember mm = sox.MetaType.GetDataMember(ma.Member);\n\t\t\t\tMetaType otherType = mm.DeclaringType.InheritanceRoot;\n\t\t\t\tif (mm.IsAssociation && ma.Expression != null && ma.Expression.NodeType != SqlNodeType.Link\n\t\t\t\t\t&& this.shape != null && this.shape.IsPreloaded(mm.Member) && mm.LoadMethod == null\n\t\t\t\t\t&& this.alreadyIncluded != null && !this.alreadyIncluded.Contains(otherType)) {\n\t\t\t\t\t\t// The expression is already fetched, add it to the alreadyIncluded set.\n\t\t\t\t\t\tthis.alreadyIncluded.Add(otherType);\n\t\t\t\t\t\tma.Expression = this.VisitExpression(ma.Expression);\n\t\t\t\t\t\tthis.alreadyIncluded.Remove(otherType);\n\t\t\t\t\t}\n\t\t\t\telse if (mm.IsAssociation || mm.IsDeferred) {\n\t\t\t\t\tma.Expression = this.VisitExpression(ma.Expression);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tma.Expression = this.FetchExpression(ma.Expression);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sox;\n\t\t}", "label": "ComplexConditional"}
{"text": "public override void OnClick()\n\t\t\t{\n\t\t\t\tif (!m_Familiar.Deleted && m_Familiar.Controlled && m_From == m_Familiar.ControlMaster && m_From.CheckAlive())\n\t\t\t\t{\n\t\t\t\t\tm_Familiar.BeginRelease(m_From);\n\t\t\t\t}\n\t\t\t}", "label": "ComplexConditional"}
{"text": "/// <summary>\n\t\t/// Split an individual face\n\t\t/// </summary>\n\t\t/// <param name=\"faceIndex\">face index in the array of faces</param>\n\t\t/// <param name=\"segment1\">segment representing the intersection of the face with the plane</param>\n\t\t/// <param name=\"segment2\">segment representing the intersection of other face with the plane of the current face plane</param>\n\t\tprivate bool SplitFace(CsgFace face, Segment segment1, Segment segment2, Stack<CsgFace> facesFromSplit)\n\t\t{\n\t\t\tVector3 startPos, endPos;\n\t\t\tSegmentEnd startType, endType, middleType;\n\t\t\tdouble startDist, endDist;\n\n\t\t\tVertex startVertex = segment1.StartVertex;\n\t\t\tVertex endVertex = segment1.EndVertex;\n\n\t\t\t//starting point: deeper starting point\n\t\t\tif (segment2.StartDistance > segment1.StartDistance + EqualityTolerance)\n\t\t\t{\n\t\t\t\tstartDist = segment2.StartDistance;\n\t\t\t\tstartType = segment1.MiddleType;\n\t\t\t\tstartPos = segment2.StartPosition;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tstartDist = segment1.StartDistance;\n\t\t\t\tstartType = segment1.StartType;\n\t\t\t\tstartPos = segment1.StartPosition;\n\t\t\t}\n\n\t\t\t//ending point: deepest ending point\n\t\t\tif (segment2.EndDistance < segment1.EndDistance - EqualityTolerance)\n\t\t\t{\n\t\t\t\tendDist = segment2.EndDistance;\n\t\t\t\tendType = segment1.MiddleType;\n\t\t\t\tendPos = segment2.EndPosition;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tendDist = segment1.EndDistance;\n\t\t\t\tendType = segment1.EndType;\n\t\t\t\tendPos = segment1.EndPosition;\n\t\t\t}\n\t\t\tmiddleType = segment1.MiddleType;\n\n\t\t\tif (startType == SegmentEnd.Vertex)\n\t\t\t{\n\t\t\t\t//set vertex to BOUNDARY if it is start type\n\t\t\t\tstartVertex.Status = FaceStatus.Boundary;\n\t\t\t}\n\n\t\t\tif (endType == SegmentEnd.Vertex)\n\t\t\t{\n\t\t\t\t//set vertex to BOUNDARY if it is end type\n\t\t\t\tendVertex.Status = FaceStatus.Boundary;\n\t\t\t}\n\n\t\t\tif (startType == SegmentEnd.Vertex && endType == SegmentEnd.Vertex)\n\t\t\t{\n\t\t\t\t//VERTEX-_______-VERTEX\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse if (middleType == SegmentEnd.Edge)\n\t\t\t{\n\t\t\t\t//______-EDGE-______\n\t\t\t\t//gets the edge\n\t\t\t\tint splitEdge;\n\t\t\t\tif ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v1))\n\t\t\t\t{\n\t\t\t\t\tsplitEdge = 1;\n\t\t\t\t}\n\t\t\t\telse if ((startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v2))\n\t\t\t\t{\n\t\t\t\t\tsplitEdge = 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsplitEdge = 3;\n\t\t\t\t}\n\n\t\t\t\tif (startType == SegmentEnd.Vertex)\n\t\t\t\t{\n\t\t\t\t\t//VERTEX-EDGE-EDGE\n\t\t\t\t\treturn BreakFaceInTwo(face, endPos, splitEdge, facesFromSplit);\n\t\t\t\t}\n\t\t\t\telse if (endType == SegmentEnd.Vertex)\n\t\t\t\t{\n\t\t\t\t\t//EDGE-EDGE-VERTEX\n\t\t\t\t\treturn BreakFaceInTwo(face, startPos, splitEdge, facesFromSplit);\n\t\t\t\t}\n\t\t\t\telse if (startDist == endDist)\n\t\t\t\t{\n\t\t\t\t\t// EDGE-EDGE-EDGE\n\t\t\t\t\treturn BreakFaceInTwo(face, endPos, splitEdge, facesFromSplit);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif ((startVertex == face.v1 && endVertex == face.v2) || (startVertex == face.v2 && endVertex == face.v3) || (startVertex == face.v3 && endVertex == face.v1))\n\t\t\t\t\t{\n\t\t\t\t\t\treturn BreakFaceInThree(face, startPos, endPos, splitEdge, facesFromSplit);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\treturn BreakFaceInThree(face, endPos, startPos, splitEdge, facesFromSplit);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//______-FACE-______\n\t\t\telse if (startType == SegmentEnd.Vertex && endType == SegmentEnd.Edge)\n\t\t\t{\n\t\t\t\t//VERTEX-FACE-EDGE\n\t\t\t\treturn BreakFaceInTwo(face, endPos, endVertex, facesFromSplit);\n\t\t\t}\n\t\t\telse if (startType == SegmentEnd.Edge && endType == SegmentEnd.Vertex)\n\t\t\t{\n\t\t\t\t//EDGE-FACE-VERTEX\n\t\t\t\treturn BreakFaceInTwo(face, startPos, startVertex, facesFromSplit);\n\t\t\t}\n\t\t\telse if (startType == SegmentEnd.Vertex && endType == SegmentEnd.Face)\n\t\t\t{\n\t\t\t\t//VERTEX-FACE-FACE\n\t\t\t\treturn BreakFaceInThree(face, endPos, facesFromSplit);\n\t\t\t}\n\t\t\telse if (startType == SegmentEnd.Face && endType == SegmentEnd.Vertex)\n\t\t\t{\n\t\t\t\t//FACE-FACE-VERTEX\n\t\t\t\treturn BreakFaceInThree(face, startPos, facesFromSplit);\n\t\t\t}\n\t\t\telse if (startType == SegmentEnd.Edge && endType == SegmentEnd.Edge)\n\t\t\t{\n\t\t\t\t//EDGE-FACE-EDGE\n\t\t\t\treturn BreakFaceInThree(face, startPos, endPos, startVertex, endVertex, facesFromSplit);\n\t\t\t}\n\t\t\telse if (startType == SegmentEnd.Edge && endType == SegmentEnd.Face)\n\t\t\t{\n\t\t\t\t//EDGE-FACE-FACE\n\t\t\t\treturn BreakFaceInFour(face, startPos, endPos, startVertex, facesFromSplit);\n\t\t\t}\n\t\t\telse if (startType == SegmentEnd.Face && endType == SegmentEnd.Edge)\n\t\t\t{\n\t\t\t\t//FACE-FACE-EDGE\n\t\t\t\treturn BreakFaceInFour(face, endPos, startPos, endVertex, facesFromSplit);\n\t\t\t}\n\t\t\telse if (startType == SegmentEnd.Face\n\t\t\t\t&& endType == SegmentEnd.Face)\n\t\t\t{\n\t\t\t\t//FACE-FACE-FACE\n\t\t\t\tVector3 segmentVector = new Vector3(startPos.X - endPos.X, startPos.Y - endPos.Y, startPos.Z - endPos.Z);\n\n\t\t\t\t//if the intersection segment is a point only...\n\t\t\t\tif (Math.Abs(segmentVector.X) < EqualityTolerance\n\t\t\t\t\t&& Math.Abs(segmentVector.Y) < EqualityTolerance\n\t\t\t\t\t&& Math.Abs(segmentVector.Z) < EqualityTolerance)\n\t\t\t\t{\n\t\t\t\t\treturn BreakFaceInThree(face, startPos, facesFromSplit);\n\t\t\t\t}\n\n\t\t\t\t//gets the vertex more lined with the intersection segment\n\t\t\t\tdouble dot1 = Math.Abs(Vector3Ex.Dot(segmentVector, (endPos - face.v1.Position).GetNormal()));\n\t\t\t\tdouble dot2 = Math.Abs(Vector3Ex.Dot(segmentVector, (endPos - face.v2.Position).GetNormal()));\n\t\t\t\tdouble dot3 = Math.Abs(Vector3Ex.Dot(segmentVector, (endPos - face.v3.Position).GetNormal()));\n\n\t\t\t\tint linedVertex;\n\t\t\t\tVector3 linedVertexPos;\n\t\t\t\tif (dot1 > dot2\n\t\t\t\t\t&& dot1 > dot3)\n\t\t\t\t{\n\t\t\t\t\tlinedVertex = 1;\n\t\t\t\t\tlinedVertexPos = face.v1.Position;\n\t\t\t\t}\n\t\t\t\telse if (dot2 > dot3\n\t\t\t\t\t&& dot2 > dot1)\n\t\t\t\t{\n\t\t\t\t\tlinedVertex = 2;\n\t\t\t\t\tlinedVertexPos = face.v2.Position;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlinedVertex = 3;\n\t\t\t\t\tlinedVertexPos = face.v3.Position;\n\t\t\t\t}\n\n\t\t\t\t// Now find which of the intersection endpoints is nearest to that vertex.\n\t\t\t\tif ((linedVertexPos - startPos).Length > (linedVertexPos - endPos).Length)\n\t\t\t\t{\n\t\t\t\t\treturn BreakFaceInFive(face, startPos, endPos, linedVertex, facesFromSplit);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn BreakFaceInFive(face, endPos, startPos, linedVertex, facesFromSplit);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}", "label": "ComplexConditional"}
{"text": "private bool CreateTextureResources(RenderContext context, DeviceContextProxy deviceContext)\n            {\n                var currSampleDesc = context.RenderHost.RenderBuffer.ColorBufferSampleDesc;\n    #if MSAASEPARATE\n                hasMSAA = currSampleDesc.Count > 1 || currSampleDesc.Quality > 0;\n    #endif\n                if (width != (int)context.ActualWidth || height != (int)context.ActualHeight\n                    || sampleDesc.Count != currSampleDesc.Count || sampleDesc.Quality != currSampleDesc.Quality)\n                {\n                    RemoveAndDispose(ref colorTarget);\n                    RemoveAndDispose(ref alphaTarget);\n                    RemoveAndDispose(ref colorTargetNoMSAA);\n                    RemoveAndDispose(ref alphaTargetNoMSAA);\n                    sampleDesc = currSampleDesc;\n\n                    width = (int)context.ActualWidth;\n                    height = (int)context.ActualHeight;\n                    colorDesc.Width = alphaDesc.Width = width;\n                    colorDesc.Height = alphaDesc.Height = height;\n                    colorDesc.SampleDescription = alphaDesc.SampleDescription = sampleDesc;\n    #if MSAASEPARATE\n                    if (hasMSAA)\n                    {\n                        colorDesc.BindFlags = alphaDesc.BindFlags = BindFlags.RenderTarget;\n                    }\n                    else\n    #endif\n                    {\n                        colorDesc.BindFlags = alphaDesc.BindFlags = BindFlags.RenderTarget | BindFlags.ShaderResource;\n                    }\n\n                    colorTarget = Collect(new ShaderResourceViewProxy(Device, colorDesc));\n                    alphaTarget = Collect(new ShaderResourceViewProxy(Device, alphaDesc));\n\n\n                    colorTarget.CreateRenderTargetView();\n                    alphaTarget.CreateRenderTargetView();\n    #if MSAASEPARATE\n                    if (!hasMSAA)\n    #endif\n                    {\n                        alphaTarget.CreateTextureView();\n                        colorTarget.CreateTextureView();\n                        colorTargetNoMSAA = colorTarget;\n                        alphaTargetNoMSAA = alphaTarget;\n                    }\n    #if MSAASEPARATE\n                    else\n                    {\n                        colorDesc.SampleDescription = alphaDesc.SampleDescription = new SampleDescription(1, 0);\n                        colorDesc.BindFlags = alphaDesc.BindFlags = BindFlags.ShaderResource;\n                        colorTargetNoMSAA = Collect(new ShaderResourceViewProxy(Device, colorDesc));\n                        alphaTargetNoMSAA = Collect(new ShaderResourceViewProxy(Device, alphaDesc));\n                        colorTargetNoMSAA.CreateTextureView();\n                        alphaTargetNoMSAA.CreateTextureView();\n                    }\n    #endif\n                    RaiseInvalidateRender();\n                    return true; // Skip this frame if texture resized to reduce latency.\n                }\n                return false;\n            }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Hits the test.\n        /// </summary>\n        /// <param name=\"context\">The context.</param>\n        /// <param name=\"modelMatrix\">The model matrix.</param>\n        /// <param name=\"rayWS\">The ray ws.</param>\n        /// <param name=\"hits\">The hits.</param>\n        /// <param name=\"originalSource\">The original source.</param>\n        /// <param name=\"fixedSize\">if set to <c>true</c> [fixed size].</param>\n        /// <returns></returns>\n        public override bool HitTest(RenderContext context, Matrix modelMatrix,\n            ref Ray rayWS, ref List<HitTestResult> hits,\n            object originalSource, bool fixedSize)\n        {\n            if (!IsInitialized || context == null || Width == 0 || Height == 0 || (!fixedSize && !BoundingSphere.TransformBoundingSphere(modelMatrix).Intersects(ref rayWS)))\n            {\n                return false;\n            }\n\n            return fixedSize ? HitTestFixedSize(context, ref modelMatrix, ref rayWS, ref hits, originalSource, BillboardVertices.Count)\n                : HitTestNonFixedSize(context, ref modelMatrix, ref rayWS, ref hits, originalSource, BillboardVertices.Count);\n        }", "label": "ComplexConditional"}
{"text": "private (Type applicationType, Type authorizationType, Type scopeType, Type tokenType) GetEntityTypes(Type keyType)\n        {\n            Type applicationType   = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:ApplicationType\"),\n                 authorizationType = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:AuthorizationType\"),\n                 scopeType         = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:ScopeType\"),\n                 tokenType         = GetConfigurationNodeAsType(\"Modules:OrchardCore.OpenId:EntityFrameworkCore:TokenType\");\n\n            if (applicationType != null && authorizationType != null && scopeType != null && tokenType != null)\n            {\n                return (applicationType, authorizationType, scopeType, tokenType);\n            }\n\n            if (keyType == typeof(string))\n            {\n                return (\n                    applicationType:   typeof(OpenIddictApplication),\n                    authorizationType: typeof(OpenIddictAuthorization),\n                    scopeType:         typeof(OpenIddictScope),\n                    tokenType:         typeof(OpenIddictToken));\n            }\n\n            return (\n                applicationType:   typeof(OpenIddictApplication<>).MakeGenericType(keyType),\n                authorizationType: typeof(OpenIddictAuthorization<>).MakeGenericType(keyType),\n                scopeType:         typeof(OpenIddictScope<>).MakeGenericType(keyType),\n                tokenType:         typeof(OpenIddictToken<>).MakeGenericType(keyType));\n        }", "label": "ComplexConditional"}
{"text": "protected virtual async Task<byte[]> DownloadAsync(string url, CancellationToken token, HttpClient client, TaskParameter parameters, DownloadInformation downloadInformation)\n        {\n            if (!parameters.Preload)\n            {\n                await Task.Delay(25).ConfigureAwait(false);\n                token.ThrowIfCancellationRequested();\n            }\n\n            var progressAction = parameters.OnDownloadProgress;\n\n            using (var httpHeadersTimeoutTokenSource = new CancellationTokenSource())\n            using (var headersTimeoutTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token, httpHeadersTimeoutTokenSource.Token))\n            {\n                httpHeadersTimeoutTokenSource.CancelAfter(TimeSpan.FromSeconds(Configuration.HttpHeadersTimeout));\n\n                try\n                {\n                    var headerTimeoutToken = headersTimeoutTokenSource.Token;\n\n                    using (var response = await client.GetAsync(url, HttpCompletionOption.ResponseHeadersRead, headerTimeoutToken).ConfigureAwait(false))\n                    {\n                        headerTimeoutToken.ThrowIfCancellationRequested();\n\n                        if (!response.IsSuccessStatusCode)\n                        {\n                            if (response.Content == null)\n                                throw new DownloadHttpStatusCodeException(response.StatusCode);\n\n                            using (response.Content)\n                            {\n                                var content = await response.Content.ReadAsStringAsync().ConfigureAwait(false);\n                                throw new DownloadHttpStatusCodeException(response.StatusCode, content);\n                            }\n                        }\n\n                        if (response.Content == null)\n                            throw new DownloadException(\"No content\");\n\n                        var mediaType = response.Content.Headers?.ContentType?.MediaType;\n                        if (!string.IsNullOrWhiteSpace(mediaType) && !mediaType.StartsWith(\"image/\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (InvalidContentTypes.Any(v => mediaType.StartsWith(v, StringComparison.OrdinalIgnoreCase)))\n                                throw new DownloadException($\"Invalid response content type ({mediaType})\");\n                        }\n\n                        if (!parameters.CacheDuration.HasValue && Configuration.TryToReadDiskCacheDurationFromHttpHeaders\n                            && response.Headers?.CacheControl?.MaxAge != null && response.Headers.CacheControl.MaxAge > TimeSpan.Zero)\n                        {\n                            downloadInformation.CacheValidity = response.Headers.CacheControl.MaxAge.Value;\n                        }\n\n                        ModifyParametersAfterResponse(response, parameters);\n\n                        using (var httpReadTimeoutTokenSource = new CancellationTokenSource())\n                        using (var readTimeoutTokenSource = CancellationTokenSource.CreateLinkedTokenSource(token, httpReadTimeoutTokenSource.Token))\n                        {\n                            var readTimeoutToken = readTimeoutTokenSource.Token;\n                            var httpReadTimeoutToken = httpReadTimeoutTokenSource.Token;\n                            var total = (int)(response.Content.Headers.ContentLength ?? -1);\n                            var canReportProgress = progressAction != null;\n\n                            httpReadTimeoutTokenSource.CancelAfter(TimeSpan.FromSeconds(Configuration.HttpReadTimeout));\n                            readTimeoutToken.ThrowIfCancellationRequested();\n\n                            try\n                            {\n                                using (var outputStream = new MemoryStream())\n                                using (var sourceStream = await response.Content.ReadAsStreamAsync().ConfigureAwait(false))\n                                {\n                                    httpReadTimeoutToken.Register(() => sourceStream.TryDispose());\n\n                                    var totalRead = 0;\n                                    var buffer = new byte[Configuration.HttpReadBufferSize];\n                                    var read = 0;\n\n                                    while ((read = await sourceStream.ReadAsync(buffer, 0, buffer.Length).ConfigureAwait(false)) > 0)\n                                    {\n                                        readTimeoutToken.ThrowIfCancellationRequested();\n                                        outputStream.Write(buffer, 0, read);\n                                        totalRead += read;\n\n                                        if (canReportProgress)\n                                            progressAction(new DownloadProgress(totalRead, total));\n                                    }\n\n                                    if (outputStream.Length == 0)\n                                        throw new DownloadException(\"Zero length stream\");\n\n                                    if (outputStream.Length < 32)\n                                        throw new DownloadException(\"Invalid stream\");\n\n                                    return outputStream.ToArray();\n                                }\n                            }\n                            catch (Exception ex) when (ex is OperationCanceledException || ex is ObjectDisposedException)\n                            {\n                                if (httpReadTimeoutTokenSource.IsCancellationRequested)\n                                    throw new DownloadReadTimeoutException();\n\n                                throw;\n                            }\n                        }\n                    }\n                }\n                catch (OperationCanceledException)\n                {\n                    if (httpHeadersTimeoutTokenSource.IsCancellationRequested)\n                        throw new DownloadHeadersTimeoutException();\n                    else\n                        throw;\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "private void TreeContextMenu_Opening(object sender, CancelEventArgs e)\n\t\t{\n\n\t\t\tvar root = JsonTreeView.SelectedNode;\n\t\t\tdynamic json = root.Tag;\n\n\t\t\t// root is array, children > 0, root[0](=child) is object or array\n\t\t\tif (\n\t\t\t\troot.GetNodeCount(false) > 0 &&\n\t\t\t\tjson != null && json is Codeplex.Data.DynamicJson && json.IsArray &&\n\t\t\t\troot.FirstNode.Tag != null && root.FirstNode.Tag is Codeplex.Data.DynamicJson && (((dynamic)root.FirstNode.Tag).IsArray || ((dynamic)root.FirstNode.Tag).IsObject))\n\t\t\t{\n\t\t\t\tTreeContextMenu_OutputCSV.Enabled = true;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tTreeContextMenu_OutputCSV.Enabled = false;\n\t\t\t}\n\n\t\t}", "label": "ComplexConditional"}
{"text": "public static bool ValueEquals(object objA, object objB)\n\t\t{\n\t\t\tif (objA == null && objB == null)\n\t\t\t\treturn true;\n\t\t\tif (objA != null && objB == null)\n\t\t\t\treturn false;\n\t\t\tif (objA == null && objB != null)\n\t\t\t\treturn false;\n\n\t\t\t// comparing an Int32 and Int64 both of the same value returns false\n\t\t\t// make types the same then compare\n\t\t\tif (objA.GetType() != objB.GetType())\n\t\t\t{\n\t\t\t\tif (ConvertUtils.IsInteger(objA) && ConvertUtils.IsInteger(objB))\n\t\t\t\t\treturn Convert.ToDecimal(objA, CultureInfo.CurrentCulture).Equals(Convert.ToDecimal(objB, CultureInfo.CurrentCulture));\n\t\t\t\telse if ((objA is double || objA is float || objA is decimal) && (objB is double || objB is float || objB is decimal))\n\t\t\t\t\treturn MathUtils.ApproxEquals(Convert.ToDouble(objA, CultureInfo.CurrentCulture), Convert.ToDouble(objB, CultureInfo.CurrentCulture));\n\t\t\t\telse\n\t\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn objA.Equals(objB);\n\t\t}", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Internal use only\n        /// </summary>\n        /// <param name=\"type\"></param>\n        /// <param name=\"reader\"></param>\n        /// <param name=\"startBound\"></param>\n        /// <param name=\"length\"></param>\n        /// <param name=\"returnNullIfFirstMissing\"></param>\n        /// <returns></returns>\n        public static Func<IDataReader, object> GetTypeDeserializer(\n#if CSHARP30\nType type, IDataReader reader, int startBound, int length, bool returnNullIfFirstMissing\n#else\nType type, IDataReader reader, int startBound = 0, int length = -1, bool returnNullIfFirstMissing = false\n#endif\n)\n        {\n\n            var dm = new DynamicMethod(string.Format(\"Deserialize{0}\", Guid.NewGuid()), typeof(object), new[] { typeof(IDataReader) }, true);\n            var il = dm.GetILGenerator();\n            il.DeclareLocal(typeof(int));\n            il.DeclareLocal(type);\n            il.Emit(OpCodes.Ldc_I4_0);\n            il.Emit(OpCodes.Stloc_0);\n\n            if (length == -1)\n            {\n                length = reader.FieldCount - startBound;\n            }\n\n            if (reader.FieldCount <= startBound)\n            {\n                throw MultiMapException(reader);\n            }\n\n            var names = Enumerable.Range(startBound, length).Select(i => reader.GetName(i)).ToArray();\n\n            ITypeMap typeMap = GetTypeMap(type);\n\n            int index = startBound;\n\n            ConstructorInfo specializedConstructor = null;\n\n            bool supportInitialize = false;\n            if (type.IsValueType)\n            {\n                il.Emit(OpCodes.Ldloca_S, (byte)1);\n                il.Emit(OpCodes.Initobj, type);\n            }\n            else\n            {\n                var types = new Type[length];\n                for (int i = startBound; i < startBound + length; i++)\n                {\n                    types[i - startBound] = reader.GetFieldType(i);\n                }\n\n                var explicitConstr = typeMap.FindExplicitConstructor();\n                if (explicitConstr != null)\n                {\n                    var structLocals = new Dictionary<Type, LocalBuilder>();\n\n                    var consPs = explicitConstr.GetParameters();\n                    foreach(var p in consPs)\n                    {\n                        if(!p.ParameterType.IsValueType)\n                        {\n                            il.Emit(OpCodes.Ldnull);\n                        }\n                        else\n                        {\n                            LocalBuilder loc;\n                            if(!structLocals.TryGetValue(p.ParameterType, out loc))\n                            {\n                                structLocals[p.ParameterType] = loc = il.DeclareLocal(p.ParameterType);\n                            }\n\n                            il.Emit(OpCodes.Ldloca, (short)loc.LocalIndex);\n                            il.Emit(OpCodes.Initobj, p.ParameterType);\n                            il.Emit(OpCodes.Ldloca, (short)loc.LocalIndex);\n                            il.Emit(OpCodes.Ldobj, p.ParameterType);\n                        }\n                    }\n\n                    il.Emit(OpCodes.Newobj, explicitConstr);\n                    il.Emit(OpCodes.Stloc_1);\n                    supportInitialize = typeof(ISupportInitialize).IsAssignableFrom(type);\n                    if (supportInitialize)\n                    {\n                        il.Emit(OpCodes.Ldloc_1);\n                        il.EmitCall(OpCodes.Callvirt, typeof(ISupportInitialize).GetMethod(\"BeginInit\"), null);\n                    }\n                }\n                else\n                {\n                    var ctor = typeMap.FindConstructor(names, types);\n                    if (ctor == null)\n                    {\n                        string proposedTypes = \"(\" + string.Join(\", \", types.Select((t, i) => t.FullName + \" \" + names[i]).ToArray()) + \")\";\n                        throw new InvalidOperationException(string.Format(\"A parameterless default constructor or one matching signature {0} is required for {1} materialization\", proposedTypes, type.FullName));\n                    }\n\n                    if (ctor.GetParameters().Length == 0)\n                    {\n                        il.Emit(OpCodes.Newobj, ctor);\n                        il.Emit(OpCodes.Stloc_1);\n                        supportInitialize = typeof(ISupportInitialize).IsAssignableFrom(type);\n                        if (supportInitialize)\n                        {\n                            il.Emit(OpCodes.Ldloc_1);\n                            il.EmitCall(OpCodes.Callvirt, typeof(ISupportInitialize).GetMethod(\"BeginInit\"), null);\n                        }\n                    }\n                    else\n                    {\n                        specializedConstructor = ctor;\n                    }\n                }\n            }\n\n            il.BeginExceptionBlock();\n            if (type.IsValueType)\n            {\n                il.Emit(OpCodes.Ldloca_S, (byte)1);// [target]\n            }\n            else if (specializedConstructor == null)\n            {\n                il.Emit(OpCodes.Ldloc_1);// [target]\n            }\n\n            var members = (specializedConstructor != null\n                ? names.Select(n => typeMap.GetConstructorParameter(specializedConstructor, n))\n                : names.Select(n => typeMap.GetMember(n))).ToList();\n\n            // stack is now [target]\n\n            bool first = true;\n            var allDone = il.DefineLabel();\n            int enumDeclareLocal = -1, valueCopyLocal = il.DeclareLocal(typeof(object)).LocalIndex;\n            foreach (var item in members)\n            {\n                if (item != null)\n                {\n                    if (specializedConstructor == null)\n                        il.Emit(OpCodes.Dup); // stack is now [target][target]\n                    Label isDbNullLabel = il.DefineLabel();\n                    Label finishLabel = il.DefineLabel();\n\n                    il.Emit(OpCodes.Ldarg_0); // stack is now [target][target][reader]\n                    EmitInt32(il, index); // stack is now [target][target][reader][index]\n                    il.Emit(OpCodes.Dup);// stack is now [target][target][reader][index][index]\n                    il.Emit(OpCodes.Stloc_0);// stack is now [target][target][reader][index]\n                    il.Emit(OpCodes.Callvirt, getItem); // stack is now [target][target][value-as-object]\n                    il.Emit(OpCodes.Dup); // stack is now [target][target][value-as-object][value-as-object]\n                    StoreLocal(il, valueCopyLocal);\n                    Type colType = reader.GetFieldType(index);\n                    Type memberType = item.MemberType;\n\n                    if (memberType == typeof(char) || memberType == typeof(char?))\n                    {\n                        il.EmitCall(OpCodes.Call, typeof(SqlMapper).GetMethod(\n                            memberType == typeof(char) ? \"ReadChar\" : \"ReadNullableChar\", BindingFlags.Static | BindingFlags.Public), null); // stack is now [target][target][typed-value]\n                    }\n                    else\n                    {\n                        il.Emit(OpCodes.Dup); // stack is now [target][target][value][value]\n                        il.Emit(OpCodes.Isinst, typeof(DBNull)); // stack is now [target][target][value-as-object][DBNull or null]\n                        il.Emit(OpCodes.Brtrue_S, isDbNullLabel); // stack is now [target][target][value-as-object]\n\n                        // unbox nullable enums as the primitive, i.e. byte etc\n\n                        var nullUnderlyingType = Nullable.GetUnderlyingType(memberType);\n                        var unboxType = nullUnderlyingType != null && nullUnderlyingType.IsEnum ? nullUnderlyingType : memberType;\n\n                        if (unboxType.IsEnum)\n                        {\n                            Type numericType = Enum.GetUnderlyingType(unboxType);\n                            if(colType == typeof(string))\n                            {\n                                if (enumDeclareLocal == -1)\n                                {\n                                    enumDeclareLocal = il.DeclareLocal(typeof(string)).LocalIndex;\n                                }\n                                il.Emit(OpCodes.Castclass, typeof(string)); // stack is now [target][target][string]\n                                StoreLocal(il, enumDeclareLocal); // stack is now [target][target]\n                                il.Emit(OpCodes.Ldtoken, unboxType); // stack is now [target][target][enum-type-token]\n                                il.EmitCall(OpCodes.Call, typeof(Type).GetMethod(\"GetTypeFromHandle\"), null);// stack is now [target][target][enum-type]\n                                LoadLocal(il, enumDeclareLocal); // stack is now [target][target][enum-type][string]\n                                il.Emit(OpCodes.Ldc_I4_1); // stack is now [target][target][enum-type][string][true]\n                                il.EmitCall(OpCodes.Call, enumParse, null); // stack is now [target][target][enum-as-object]\n                                il.Emit(OpCodes.Unbox_Any, unboxType); // stack is now [target][target][typed-value]\n                            }\n                            else\n                            {\n                                FlexibleConvertBoxedFromHeadOfStack(il, colType, unboxType, numericType);\n                            }\n\n                            if (nullUnderlyingType != null)\n                            {\n                                il.Emit(OpCodes.Newobj, memberType.GetConstructor(new[] { nullUnderlyingType })); // stack is now [target][target][typed-value]\n                            }\n                        }\n                        else if (memberType.FullName == LinqBinary)\n                        {\n                            il.Emit(OpCodes.Unbox_Any, typeof(byte[])); // stack is now [target][target][byte-array]\n                            il.Emit(OpCodes.Newobj, memberType.GetConstructor(new Type[] { typeof(byte[]) }));// stack is now [target][target][binary]\n                        }\n                        else\n                        {\n                            TypeCode dataTypeCode = Type.GetTypeCode(colType), unboxTypeCode = Type.GetTypeCode(unboxType);\n                            bool hasTypeHandler;\n                            if ((hasTypeHandler = typeHandlers.ContainsKey(unboxType)) || colType == unboxType || dataTypeCode == unboxTypeCode || dataTypeCode == Type.GetTypeCode(nullUnderlyingType))\n                            {\n                                if (hasTypeHandler)\n                                {\n#pragma warning disable 618\n                                    il.EmitCall(OpCodes.Call, typeof(TypeHandlerCache<>).MakeGenericType(unboxType).GetMethod(\"Parse\"), null); // stack is now [target][target][typed-value]\n#pragma warning restore 618\n                                }\n                                else\n                                {\n                                    il.Emit(OpCodes.Unbox_Any, unboxType); // stack is now [target][target][typed-value]\n                                }\n                            }\n                            else\n                            {\n                                // not a direct match; need to tweak the unbox\n                                FlexibleConvertBoxedFromHeadOfStack(il, colType, nullUnderlyingType ?? unboxType, null);\n                                if (nullUnderlyingType != null)\n                                {\n                                    il.Emit(OpCodes.Newobj, unboxType.GetConstructor(new[] { nullUnderlyingType })); // stack is now [target][target][typed-value]\n                                }\n\n                            }\n\n                        }\n                    }\n                    if (specializedConstructor == null)\n                    {\n                        // Store the value in the property/field\n                        if (item.Property != null)\n                        {\n                            if (type.IsValueType)\n                            {\n                                il.Emit(OpCodes.Call, DefaultTypeMap.GetPropertySetter(item.Property, type)); // stack is now [target]\n                            }\n                            else\n                            {\n                                il.Emit(OpCodes.Callvirt, DefaultTypeMap.GetPropertySetter(item.Property, type)); // stack is now [target]\n                            }\n                        }\n                        else\n                        {\n                            il.Emit(OpCodes.Stfld, item.Field); // stack is now [target]\n                        }\n                    }\n\n                    il.Emit(OpCodes.Br_S, finishLabel); // stack is now [target]\n\n                    il.MarkLabel(isDbNullLabel); // incoming stack: [target][target][value]\n                    if (specializedConstructor != null)\n                    {\n                        il.Emit(OpCodes.Pop);\n                        if (item.MemberType.IsValueType)\n                        {\n                            int localIndex = il.DeclareLocal(item.MemberType).LocalIndex;\n                            LoadLocalAddress(il, localIndex);\n                            il.Emit(OpCodes.Initobj, item.MemberType);\n                            LoadLocal(il, localIndex);\n                        }\n                        else\n                        {\n                            il.Emit(OpCodes.Ldnull);\n                        }\n                    }\n                    else\n                    {\n                        il.Emit(OpCodes.Pop); // stack is now [target][target]\n                        il.Emit(OpCodes.Pop); // stack is now [target]\n                    }\n\n                    if (first && returnNullIfFirstMissing)\n                    {\n                        il.Emit(OpCodes.Pop);\n                        il.Emit(OpCodes.Ldnull); // stack is now [null]\n                        il.Emit(OpCodes.Stloc_1);\n                        il.Emit(OpCodes.Br, allDone);\n                    }\n\n                    il.MarkLabel(finishLabel);\n                }\n                first = false;\n                index += 1;\n            }\n            if (type.IsValueType)\n            {\n                il.Emit(OpCodes.Pop);\n            }\n            else\n            {\n                if (specializedConstructor != null)\n                {\n                    il.Emit(OpCodes.Newobj, specializedConstructor);\n                }\n                il.Emit(OpCodes.Stloc_1); // stack is empty\n                if (supportInitialize)\n                {\n                    il.Emit(OpCodes.Ldloc_1);\n                    il.EmitCall(OpCodes.Callvirt, typeof(ISupportInitialize).GetMethod(\"EndInit\"), null);\n                }\n            }\n            il.MarkLabel(allDone);\n            il.BeginCatchBlock(typeof(Exception)); // stack is Exception\n            il.Emit(OpCodes.Ldloc_0); // stack is Exception, index\n            il.Emit(OpCodes.Ldarg_0); // stack is Exception, index, reader\n            LoadLocal(il, valueCopyLocal); // stack is Exception, index, reader, value\n            il.EmitCall(OpCodes.Call, typeof(SqlMapper).GetMethod(\"ThrowDataException\"), null);\n            il.EndExceptionBlock();\n\n            il.Emit(OpCodes.Ldloc_1); // stack is [rval]\n            if (type.IsValueType)\n            {\n                il.Emit(OpCodes.Box, type);\n            }\n            il.Emit(OpCodes.Ret);\n\n            return (Func<IDataReader, object>)dm.CreateDelegate(typeof(Func<IDataReader, object>));\n        }", "label": "ComplexConditional"}
{"text": "#endregion\n\n\n    #region ----- SearchBracketBackward -----\n    /// <summary>\n    /// Finds the offset of the opening bracket in the block defined by offset skipping\n    /// brackets, strings and comments.\n    /// </summary>\n    /// <param name=\"document\">The document.</param>\n    /// <param name=\"offset\">The offset of an position in the block (before the closing bracket).</param>\n    /// <param name=\"openBracket\">The character for the opening bracket.</param>\n    /// <param name=\"closingBracket\">The character for the closing bracket.</param>\n    /// <returns>\n    /// Returns the offset of the opening bracket or -1 if no matching bracket was found.\n    /// </returns>\n    public override int SearchBracketBackward(IDocument document, int offset, char openBracket, char closingBracket)\n    {\n      if (offset >= document.TextLength) \n        return -1;\n\n      // first try \"quick find\" - find the matching bracket if there is no string/comment in the way\n      int quickResult = base.SearchBracketBackward(document, offset, openBracket, closingBracket);\n      if (quickResult >= 0) \n        return quickResult;\n\n      // we need to parse the line from the beginning, so get the line start position\n      int linestart = ScanLineStart(document, offset + 1);\n\n      // we need to know where offset is - in a string/comment or in normal code?\n      // ignore cases where offset is in a block comment\n      int starttype = GetStartType(document, linestart, offset + 1);\n      if (starttype != 0)\n        return -1; // start position is in a comment/string\n\n      // I don't see any possibility to parse a C# document backwards...\n      // We have to do it forwards and push all bracket positions on a stack.\n      Stack bracketStack = new Stack();\n      bool blockComment = false;\n      bool lineComment = false;\n      bool inChar = false;\n      bool inString = false;\n      bool verbatim = false;\n\n      for (int i = 0; i <= offset; ++i)\n      {\n        char ch = document.GetCharAt(i);\n        switch (ch)\n        {\n          case '\\r':\n          case '\\n':\n            lineComment = false;\n            inChar = false;\n            if (!verbatim) inString = false;\n            break;\n          case '/':\n            if (blockComment)\n            {\n              Debug.Assert(i > 0);\n              if (document.GetCharAt(i - 1) == '*')\n              {\n                blockComment = false;\n              }\n            }\n            if (!inString && !inChar && i + 1 < document.TextLength)\n            {\n              if (!blockComment && document.GetCharAt(i + 1) == '/')\n              {\n                lineComment = true;\n              }\n              if (!lineComment && document.GetCharAt(i + 1) == '*')\n              {\n                blockComment = true;\n              }\n            }\n            break;\n          case '\"':\n            if (!(inChar || lineComment || blockComment))\n            {\n              if (inString && verbatim)\n              {\n                if (i + 1 < document.TextLength && document.GetCharAt(i + 1) == '\"')\n                {\n                  ++i; // skip escaped quote\n                  inString = false; // let the string go\n                }\n                else\n                {\n                  verbatim = false;\n                }\n              }\n              else if (!inString && offset > 0 && document.GetCharAt(i - 1) == '@')\n              {\n                verbatim = true;\n              }\n              inString = !inString;\n            }\n            break;\n          case '\\'':\n            if (!(inString || lineComment || blockComment))\n            {\n              inChar = !inChar;\n            }\n            break;\n          case '\\\\':\n            if ((inString && !verbatim) || inChar)\n              ++i; // skip next character\n            break;\n          default:\n            if (ch == openBracket)\n            {\n              if (!(inString || inChar || lineComment || blockComment))\n              {\n                bracketStack.Push(i);\n              }\n            }\n            else if (ch == closingBracket)\n            {\n              if (!(inString || inChar || lineComment || blockComment))\n              {\n                if (bracketStack.Count > 0)\n                  bracketStack.Pop();\n              }\n            }\n            break;\n        }\n      }\n      if (bracketStack.Count > 0) return (int) bracketStack.Pop();\n      return -1;\n    }", "label": "ComplexConditional"}
{"text": "public override void OnResponse(NetState state, RelayInfo info)\n        {\n            if (this.m_State == null)\n                return;\n\n            Mobile focus = this.m_State.Mobile;\n            Mobile from = state.Mobile;\n\n            if (focus == null)\n            {\n                from.SendMessage(\"That character is no longer online.\");\n                return;\n            }\n            else if (focus.Deleted)\n            {\n                from.SendMessage(\"That character no longer exists.\");\n                return;\n            }\n            else if (from != focus && focus.Hidden && from.AccessLevel < focus.AccessLevel && (!(focus is PlayerMobile) || !((PlayerMobile)focus).VisibilityList.Contains(from)))\n            {\n                from.SendMessage(\"That character is no longer visible.\");\n                return;\n            }\n\n            switch ( info.ButtonID )\n            {\n                case 1: // Tell\n                    {\n                        TextRelay text = info.GetTextEntry(0);\n\n                        if (text != null)\n                        {\n                            focus.SendMessage(0x482, \"{0} tells you:\", from.Name);\n                            focus.SendMessage(0x482, text.Text);\n\n                            CommandLogging.WriteLine(from, \"{0} {1} telling {2} \\\"{3}\\\" \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus), text.Text);\n                        }\n\n                        from.SendGump(new ClientGump(from, this.m_State));\n\n                        break;\n                    }\n                case 4: // Props\n                    {\n                        this.Resend(from, info);\n\n                        if (!BaseCommand.IsAccessible(from, focus))\n                            from.SendMessage(\"That is not accessible.\");\n                        else\n                        {\n                            from.SendGump(new PropertiesGump(from, focus));\n                            CommandLogging.WriteLine(from, \"{0} {1} opening properties gump of {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus));\n                        }\n\n                        break;\n                    }\n                case 5: // Go to\n                    {\n                        if (focus.Map == null || focus.Map == Map.Internal)\n                        {\n                            from.SendMessage(\"That character is not in the world.\");\n                        }\n                        else\n                        {\n                            from.MoveToWorld(focus.Location, focus.Map);\n                            this.Resend(from, info);\n\n                            CommandLogging.WriteLine(from, \"{0} {1} going to {2}, Location {3}, Map {4}\", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus), focus.Location, focus.Map);\n                        }\n\n                        break;\n                    }\n                case 6: // Get\n                    {\n                        if (from.Map == null || from.Map == Map.Internal)\n                        {\n                            from.SendMessage(\"You cannot bring that person here.\");\n                        }\n                        else\n                        {\n                            focus.MoveToWorld(from.Location, from.Map);\n                            this.Resend(from, info);\n\n                            CommandLogging.WriteLine(from, \"{0} {1} bringing {2} to Location {3}, Map {4}\", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus), from.Location, from.Map);\n                        }\n\n                        break;\n                    }\n                case 7: // Move\n                    {\n                        from.Target = new MoveTarget(focus);\n                        this.Resend(from, info);\n\n                        break;\n                    }\n                case 8: // Kick\n                    {\n                        if (from.AccessLevel >= AccessLevel.GameMaster && from.AccessLevel > focus.AccessLevel)\n                        {\n                            focus.Say(\"I've been kicked!\");\n\n                            this.m_State.Dispose();\n\n                            CommandLogging.WriteLine(from, \"{0} {1} kicking {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus));\n                        }\n\n                        break;\n                    }\n                case 9: // Kill\n                    {\n                        if (from.AccessLevel >= AccessLevel.GameMaster && from.AccessLevel > focus.AccessLevel)\n                        {\n                            focus.Kill();\n                            CommandLogging.WriteLine(from, \"{0} {1} killing {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus));\n                        }\n\n                        this.Resend(from, info);\n\n                        break;\n                    }\n                case 10: //Res\n                    {\n                        if (from.AccessLevel >= AccessLevel.GameMaster && from.AccessLevel > focus.AccessLevel)\n                        {\n                            focus.PlaySound(0x214);\n                            focus.FixedEffect(0x376A, 10, 16);\n\n                            focus.Resurrect();\n\n                            CommandLogging.WriteLine(from, \"{0} {1} resurrecting {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus));\n                        }\n\n                        this.Resend(from, info);\n\n                        break;\n                    }\n                case 11: // Skills\n                    {\n                        this.Resend(from, info);\n\n                        if (from.AccessLevel > focus.AccessLevel)\n                        {\n                            from.SendGump(new SkillsGump(from, (Mobile)focus));\n                            CommandLogging.WriteLine(from, \"{0} {1} Opening Skills gump of {2} \", from.AccessLevel, CommandLogging.Format(from), CommandLogging.Format(focus));\n                        }\n\n                        break;\n                    }\n            }\n        }", "label": "ComplexConditional"}
{"text": "#endregion\n\n        #region \"Declaration Conflicts\"\n\n        public bool LocalVariableConflict(\n            SyntaxToken token)\n        {\n            if (token.Parent.IsKind(SyntaxKind.IdentifierName) &&\n                token.Parent.IsParentKind(SyntaxKind.InvocationExpression) &&\n                token.GetPreviousToken().Kind() != SyntaxKind.DotToken &&\n                token.GetNextToken().Kind() != SyntaxKind.DotToken)\n            {\n                var expression = (ExpressionSyntax)token.Parent;\n                var enclosingMemberDeclaration = expression.FirstAncestorOrSelf<MemberDeclarationSyntax>();\n                if (enclosingMemberDeclaration != null)\n                {\n                    var locals = enclosingMemberDeclaration.GetLocalDeclarationMap()[token.ValueText];\n                    if (locals.Length > 0)\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Copy the dependent files with relative locations in the mapfile.\n        /// </summary>\n        /// <param name=\"oldFile\">The old file name</param>\n        /// <param name=\"newFile\">The new file name</param>\n        private void CopyDependentFiles(string oldFile, string newFile)\n        {\n            if (oldFile == \"new.map\")\n                oldFile = Application.StartupPath + \"\\\\templates\\\\new.map\"; // template\n\n            string oldPath = oldFile.Substring(0, oldFile.LastIndexOf('\\\\'));\n            string newPath = newFile.Substring(0, newFile.LastIndexOf('\\\\'));\n            mapObj map = mapControl.Target;\n            string file = map.fontset.filename;\n            if (file != null && !File.Exists(file) && !File.Exists(Path.Combine(newPath, file)) && File.Exists(Path.Combine(oldPath, file)))\n                File.Copy(Path.Combine(oldPath, file), Path.Combine(newPath, file));\n\n            file = map.symbolset.filename;\n            if (file != null && !File.Exists(file) && !File.Exists(Path.Combine(newPath, file)) && File.Exists(Path.Combine(oldPath, file)))\n            {\n                File.Copy(Path.Combine(oldPath, file), Path.Combine(newPath, file));\n                // copy the images defined in the symbol file\n                for (int i = 0; i < map.symbolset.numsymbols; i++)\n                {\n                    symbolObj sym = map.symbolset.getSymbol(i);\n                    if (sym.type == (int)MS_SYMBOL_TYPE.MS_SYMBOL_PIXMAP && sym.imagepath != null)\n                    {\n                        file = sym.imagepath;\n                        if (!File.Exists(file) && !File.Exists(Path.Combine(newPath, file)) && File.Exists(Path.Combine(oldPath, file)))\n                            File.Copy(Path.Combine(oldPath, file), Path.Combine(newPath, file));\n                    }\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        ///   Reads the next value as an Enumerated value with tag UNIVERSAL 10, converting it to\n        ///   the non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <typeparamref name=\"TEnum\"/>.\n        /// </summary>\n        /// <typeparam name=\"TEnum\">Destination enum type</typeparam>\n        /// <returns>\n        ///   the Enumerated value converted to a <typeparamref name=\"TEnum\"/>.\n        /// </returns>\n        /// <remarks>\n        ///   This method does not validate that the return value is defined within\n        ///   <typeparamref name=\"TEnum\"/>.\n        /// </remarks>\n        /// <exception cref=\"CryptographicException\">\n        ///   the next value does not have the correct tag --OR--\n        ///   the length encoding is not valid under the current encoding rules --OR--\n        ///   the contents are not valid under the current encoding rules --OR--\n        ///   the encoded value is too big to fit in a <typeparamref name=\"TEnum\"/> value\n        /// </exception>\n        /// <exception cref=\"ArgumentException\">\n        ///   <typeparamref name=\"TEnum\"/> is not an enum type --OR--\n        ///   <typeparamref name=\"TEnum\"/> was declared with <see cref=\"FlagsAttribute\"/>\n        /// </exception>\n        /// <seealso cref=\"ReadEnumeratedValue{TEnum}(Asn1Tag)\"/>\n        public TEnum ReadEnumeratedValue<TEnum>() where TEnum : struct\n        {\n            Type tEnum = typeof(TEnum);\n\n            return (TEnum)Enum.ToObject(tEnum, ReadEnumeratedValue(tEnum));\n        }/// <summary>\n        ///   Reads the next value as an Enumerated with tag UNIVERSAL 10, converting it to the\n        ///   non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <typeparamref name=\"TEnum\"/>.\n        /// </summary>\n        /// <param name=\"expectedTag\">The tag to check for before reading.</param>\n        /// <typeparam name=\"TEnum\">Destination enum type</typeparam>\n        /// <returns>\n        ///   the Enumerated value converted to a <typeparamref name=\"TEnum\"/>.\n        /// </returns>\n        /// <remarks>\n        ///   This method does not validate that the return value is defined within\n        ///   <typeparamref name=\"TEnum\"/>.\n        /// </remarks>\n        /// <exception cref=\"CryptographicException\">\n        ///   the next value does not have the correct tag --OR--\n        ///   the length encoding is not valid under the current encoding rules --OR--\n        ///   the contents are not valid under the current encoding rules --OR--\n        ///   the encoded value is too big to fit in a <typeparamref name=\"TEnum\"/> value\n        /// </exception>\n        /// <exception cref=\"ArgumentException\">\n        ///   <typeparamref name=\"TEnum\"/> is not an enum type --OR--\n        ///   <typeparamref name=\"TEnum\"/> was declared with <see cref=\"FlagsAttribute\"/>\n        ///   --OR--\n        ///   <paramref name=\"expectedTag\"/>.<see cref=\"Asn1Tag.TagClass\"/> is\n        ///   <see cref=\"TagClass.Universal\"/>, but\n        ///   <paramref name=\"expectedTag\"/>.<see cref=\"Asn1Tag.TagValue\"/> is not correct for\n        ///   the method\n        /// </exception>\n        public TEnum ReadEnumeratedValue<TEnum>(Asn1Tag expectedTag) where TEnum : struct\n        {\n            Type tEnum = typeof(TEnum);\n\n            return (TEnum)Enum.ToObject(tEnum, ReadEnumeratedValue(expectedTag, tEnum));\n        }/// <summary>\n        ///   Reads the next value as an Enumerated value with tag UNIVERSAL 10, converting it to\n        ///   the non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <paramref name=\"tEnum\"/>.\n        /// </summary>\n        /// <param name=\"tEnum\">Type object representing the destination type.</param>\n        /// <returns>\n        ///   the Enumerated value converted to a <paramref name=\"tEnum\"/>.\n        /// </returns>\n        /// <remarks>\n        ///   This method does not validate that the return value is defined within\n        ///   <paramref name=\"tEnum\"/>.\n        /// </remarks>\n        /// <exception cref=\"CryptographicException\">\n        ///   the next value does not have the correct tag --OR--\n        ///   the length encoding is not valid under the current encoding rules --OR--\n        ///   the contents are not valid under the current encoding rules --OR--\n        ///   the encoded value is too big to fit in a <paramref name=\"tEnum\"/> value\n        /// </exception>\n        /// <exception cref=\"ArgumentException\">\n        ///   <paramref name=\"tEnum\"/> is not an enum type --OR--\n        ///   <paramref name=\"tEnum\"/> was declared with <see cref=\"FlagsAttribute\"/>\n        /// </exception>\n        /// <seealso cref=\"ReadEnumeratedValue(Asn1Tag, Type)\"/>\n        public Enum ReadEnumeratedValue(Type tEnum) =>\n            ReadEnumeratedValue(Asn1Tag.Enumerated, tEnum);/// <summary>\n        ///   Reads the next value as an Enumerated with tag UNIVERSAL 10, converting it to the\n        ///   non-[<see cref=\"FlagsAttribute\"/>] enum specfied by <paramref name=\"tEnum\"/>.\n        /// </summary>\n        /// <param name=\"expectedTag\">The tag to check for before reading.</param>\n        /// <param name=\"tEnum\">Type object representing the destination type.</param>\n        /// <returns>\n        ///   the Enumerated value converted to a <paramref name=\"tEnum\"/>.\n        /// </returns>\n        /// <remarks>\n        ///   This method does not validate that the return value is defined within\n        ///   <paramref name=\"tEnum\"/>.\n        /// </remarks>\n        /// <exception cref=\"CryptographicException\">\n        ///   the next value does not have the correct tag --OR--\n        ///   the length encoding is not valid under the current encoding rules --OR--\n        ///   the contents are not valid under the current encoding rules --OR--\n        ///   the encoded value is too big to fit in a <paramref name=\"tEnum\"/> value\n        /// </exception>\n        /// <exception cref=\"ArgumentException\">\n        ///   <paramref name=\"tEnum\"/> is not an enum type --OR--\n        ///   <paramref name=\"tEnum\"/> was declared with <see cref=\"FlagsAttribute\"/>\n        ///   --OR--\n        ///   <paramref name=\"tEnum\"/>.<see cref=\"Asn1Tag.TagClass\"/> is\n        ///   <see cref=\"TagClass.Universal\"/>, but\n        ///   <paramref name=\"tEnum\"/>.<see cref=\"Asn1Tag.TagValue\"/> is not correct for\n        ///   the method\n        /// </exception>\n        public Enum ReadEnumeratedValue(Asn1Tag expectedTag, Type tEnum)\n        {\n            const UniversalTagNumber tagNumber = UniversalTagNumber.Enumerated;\n\n            // This will throw an ArgumentException if TEnum isn't an enum type,\n            // so we don't need to validate it.\n            Type backingType = tEnum.GetEnumUnderlyingType();\n\n            if (tEnum.IsDefined(typeof(FlagsAttribute), false))\n            {\n                throw new ArgumentException(\n                    SR.Cryptography_Asn_EnumeratedValueRequiresNonFlagsEnum,\n                    nameof(tEnum));\n            }\n\n            // T-REC-X.690-201508 sec 8.4 says the contents are the same as for integers.\n            int sizeLimit = Marshal.SizeOf(backingType);\n\n            if (backingType == typeof(int) ||\n                backingType == typeof(long) ||\n                backingType == typeof(short) ||\n                backingType == typeof(sbyte))\n            {\n                if (!TryReadSignedInteger(sizeLimit, expectedTag, tagNumber, out long value))\n                {\n                    throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding);\n                }\n\n                return (Enum)Enum.ToObject(tEnum, value);\n            }\n\n            if (backingType == typeof(uint) ||\n                backingType == typeof(ulong) ||\n                backingType == typeof(ushort) ||\n                backingType == typeof(byte))\n            {\n                if (!TryReadUnsignedInteger(sizeLimit, expectedTag, tagNumber, out ulong value))\n                {\n                    throw new CryptographicException(SR.Cryptography_Der_Invalid_Encoding);\n                }\n\n                return (Enum)Enum.ToObject(tEnum, value);\n            }\n\n            Debug.Fail($\"No handler for type {backingType.Name}\");\n            throw new CryptographicException();\n        }", "label": "ComplexConditional"}
{"text": "public bool CheckAllowedProjectile(Item projectile)\n\t\t{\n\t\t\tif (projectile == null || AllowedProjectiles == null) return false;\n\n\t\t\tfor (int i = 0; i < AllowedProjectiles.Length; i++)\n\t\t\t{\n\t\t\t\tType t = AllowedProjectiles[i];\n\t\t\t\tType pt = projectile.GetType();\n\n\t\t\t\tif (t == null || pt == null) continue;\n\n\t\t\t\tif (pt.IsSubclassOf(t) || pt.Equals(t) || (t.IsInterface && ContainsInterface(pt.GetInterfaces(), t)))\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}", "label": "ComplexConditional"}
{"text": "public override void OnResponse(NetState sender, RelayInfo info)\n        {\n            Mobile from = sender.Mobile;\n\n            if (info.ButtonID == 0 || this.m_Plant.Deleted || this.m_Plant.PlantStatus >= PlantStatus.DecorativePlant)\n                return;\n\t\t\t\n            if (((info.ButtonID >= 6 && info.ButtonID <= 10) || info.ButtonID == 12) && !from.InRange(this.m_Plant.GetWorldLocation(), 3))\n            {\n                from.LocalOverheadMessage(MessageType.Regular, 0x3E9, 500446); // That is too far away.\n                return;\n            }\n\n            if (!this.m_Plant.IsUsableBy(from))\n            {\n                this.m_Plant.LabelTo(from, 1061856); // You must have the item in your backpack or locked down in order to use it.\n                return;\n            }\n\n            switch ( info.ButtonID )\n            {\n                case 1: // Reproduction menu\n                    {\n                        if (this.m_Plant.PlantStatus > PlantStatus.BowlOfDirt)\n                        {\n                            from.SendGump(new ReproductionGump(this.m_Plant));\n                        }\n                        else\n                        {\n                            from.SendLocalizedMessage(1061885); // You need to plant a seed in the bowl first.\n\n                            from.SendGump(new MainPlantGump(this.m_Plant));\n                        }\n\n                        break;\n                    }\n                case 2: // Infestation\n                    {\n                        from.Send(new DisplayHelpTopic(54, true)); // INFESTATION LEVEL\n\n                        from.SendGump(new MainPlantGump(this.m_Plant));\n\n                        break;\n                    }\n                case 3: // Fungus\n                    {\n                        from.Send(new DisplayHelpTopic(56, true)); // FUNGUS LEVEL\n\n                        from.SendGump(new MainPlantGump(this.m_Plant));\n\n                        break;\n                    }\n                case 4: // Poison\n                    {\n                        from.Send(new DisplayHelpTopic(58, true)); // POISON LEVEL\n\n                        from.SendGump(new MainPlantGump(this.m_Plant));\n\n                        break;\n                    }\n                case 5: // Disease\n                    {\n                        from.Send(new DisplayHelpTopic(60, true)); // DISEASE LEVEL\n\n                        from.SendGump(new MainPlantGump(this.m_Plant));\n\n                        break;\n                    }\n                case 6: // Water\n                    {\n                        Item[] item = from.Backpack.FindItemsByType(typeof(BaseBeverage));\n\t\t\t\t\t\n                        bool foundUsableWater = false;\n\t\t\t\t\t\n                        if (item != null && item.Length > 0)\n                        {\n                            for (int i = 0; i < item.Length; ++i)\n                            {\n                                BaseBeverage beverage = (BaseBeverage)item[i];\n\t\t\t\t\t\t\t\n                                if (!beverage.IsEmpty && beverage.Pourable && beverage.Content == BeverageType.Water)\n                                {\n                                    foundUsableWater = true;\n                                    this.m_Plant.Pour(from, beverage);\n                                    break;\n                                }\n                            }\n                        }\n\t\t\t\t\t\n                        if (!foundUsableWater)\n                        {\n                            from.Target = new PlantPourTarget(this.m_Plant);\n                            from.SendLocalizedMessage(1060808, \"#\" + this.m_Plant.GetLocalizedPlantStatus().ToString()); // Target the container you wish to use to water the ~1_val~.\n                        }\n\n                        from.SendGump(new MainPlantGump(this.m_Plant));\n\n                        break;\n                    }\n                case 7: // Poison potion\n                    {\n                        this.AddPotion(from, PotionEffect.PoisonGreater, PotionEffect.PoisonDeadly);\n\n                        break;\n                    }\n                case 8: // Cure potion\n                    {\n                        this.AddPotion(from, PotionEffect.CureGreater);\n\n                        break;\n                    }\n                case 9: // Heal potion\n                    {\n                        this.AddPotion(from, PotionEffect.HealGreater);\n\n                        break;\n                    }\n                case 10: // Strength potion\n                    {\n                        this.AddPotion(from, PotionEffect.StrengthGreater);\n\n                        break;\n                    }\n                case 11: // Help\n                    {\n                        from.Send(new DisplayHelpTopic(48, true)); // PLANT GROWING\n\n                        from.SendGump(new MainPlantGump(this.m_Plant));\n\n                        break;\n                    }\n                case 12: // Empty the bowl\n                    {\n                        from.SendGump(new EmptyTheBowlGump(this.m_Plant));\n\n                        break;\n                    }\n            }\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"street1\">The street1.</param>\n        /// <param name=\"street2\">The street2.</param>\n        /// <param name=\"city\">The city.</param>\n        /// <param name=\"state\">The state.</param>\n        /// <param name=\"postalCode\">The postal code.</param>\n        /// <param name=\"country\">The country.</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid,\n            string street1, string street2, string city, string state, string postalCode, string country )\n        {\n            AddNewGroupAddress( rockContext, group, locationTypeGuid, street1, street2, city, state, postalCode, country, false );\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"street1\">The street1.</param>\n        /// <param name=\"street2\">The street2.</param>\n        /// <param name=\"city\">The city.</param>\n        /// <param name=\"state\">The state.</param>\n        /// <param name=\"postalCode\">The postal code.</param>\n        /// <param name=\"country\">The country.</param>\n        /// <param name=\"moveExistingToPrevious\">if set to <c>true</c> [move existing to previous].</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid,\n            string street1, string street2, string city, string state, string postalCode, string country, bool moveExistingToPrevious )\n        {\n            var isMappedMailing = locationTypeGuid != SystemGuid.DefinedValue.GROUP_LOCATION_TYPE_PREVIOUS; // Mapped and Mailing = true unless location type is Previous\n            AddNewGroupAddress( rockContext, group, locationTypeGuid, street1, street2, city, state, postalCode, country, moveExistingToPrevious, \"\", isMappedMailing, isMappedMailing );\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"street1\">The street1.</param>\n        /// <param name=\"street2\">The street2.</param>\n        /// <param name=\"city\">The city.</param>\n        /// <param name=\"state\">The state.</param>\n        /// <param name=\"postalCode\">The postal code.</param>\n        /// <param name=\"country\">The country.</param>\n        /// <param name=\"moveExistingToPrevious\">if set to <c>true</c> [move existing to previous].</param>\n        /// <param name=\"modifiedBy\">The description of the page or process that called the function.</param>\n        /// <param name=\"isMailingLocation\">Sets the Is Mailing option on the new address.</param>\n        /// <param name=\"isMappedLocation\">Sets the Is Mapped option on the new address.</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid,\n            string street1, string street2, string city, string state, string postalCode, string country, bool moveExistingToPrevious,\n            string modifiedBy, bool isMailingLocation, bool isMappedLocation )\n        {\n            if ( !string.IsNullOrWhiteSpace( street1 ) ||\n                 !string.IsNullOrWhiteSpace( street2 ) ||\n                 !string.IsNullOrWhiteSpace( city ) ||\n                 !string.IsNullOrWhiteSpace( postalCode ) ||\n                 !string.IsNullOrWhiteSpace( country ) )\n            {\n                var location = new LocationService( rockContext ).Get( street1, street2, city, state, postalCode, country, group, true );\n                AddNewGroupAddress( rockContext, group, locationTypeGuid, location, moveExistingToPrevious, modifiedBy, isMailingLocation, isMappedLocation );\n            }\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"locationId\">The location identifier.</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid, int? locationId )\n        {\n            AddNewGroupAddress( rockContext, group, locationTypeGuid, locationId, false );\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"locationId\">The location identifier.</param>\n        /// <param name=\"moveExistingToPrevious\">if set to <c>true</c> [move existing to previous].</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid,\n            int? locationId, bool moveExistingToPrevious )\n        {\n            var isMappedMailing = locationTypeGuid != SystemGuid.DefinedValue.GROUP_LOCATION_TYPE_PREVIOUS; // Mapped and Mailing = true unless location type is Previous\n            AddNewGroupAddress( rockContext, group, locationTypeGuid, locationId, moveExistingToPrevious, \"\", isMappedMailing, isMappedMailing );\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"locationId\">The location identifier.</param>\n        /// <param name=\"moveExistingToPrevious\">if set to <c>true</c> [move existing to previous].</param>\n        /// <param name=\"modifiedBy\">The modified by.</param>\n        /// <param name=\"isMailingLocation\">Sets the Is Mailing option on the new address.</param>\n        /// <param name=\"isMappedLocation\">Sets the Is Mapped option on the new address.</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid, \n            int? locationId, bool moveExistingToPrevious, string modifiedBy, bool isMailingLocation, bool isMappedLocation )\n        {\n            if ( locationId.HasValue )\n            {\n                var location = new LocationService( rockContext ).Get( locationId.Value );\n                AddNewGroupAddress( rockContext, group, locationTypeGuid, location, moveExistingToPrevious, modifiedBy, isMailingLocation, isMappedLocation );\n            }\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"location\">The location.</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid, Location location )\n        {\n            AddNewGroupAddress( rockContext, group, locationTypeGuid, location, false );\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"location\">The location.</param>\n        /// <param name=\"moveExistingToPrevious\">if set to <c>true</c> [move existing to previous].</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid, Location location, bool moveExistingToPrevious )\n        {\n            var isMappedMailing = locationTypeGuid != SystemGuid.DefinedValue.GROUP_LOCATION_TYPE_PREVIOUS; // Mapped and Mailing = true unless location type is Previous\n            AddNewGroupAddress( rockContext, group, locationTypeGuid, location, moveExistingToPrevious, \"\", isMappedMailing, isMappedMailing );\n        }/// <summary>\n        /// Adds the new group address (it is doesn't already exist) and saves changes to the database.\n        /// </summary>\n        /// <param name=\"rockContext\">The rock context.</param>\n        /// <param name=\"group\">The group.</param>\n        /// <param name=\"locationTypeGuid\">The location type unique identifier.</param>\n        /// <param name=\"location\">The location.</param>\n        /// <param name=\"moveExistingToPrevious\">if set to <c>true</c> [move existing to previous].</param>\n        /// <param name=\"modifiedBy\">The description of the page or process that called the function.</param>\n        /// <param name=\"isMailingLocation\">Sets the Is Mailing option on the new address.</param>\n        /// <param name=\"isMappedLocation\">Sets the Is Mapped option on the new address.</param>\n        public static void AddNewGroupAddress( RockContext rockContext, Group group, string locationTypeGuid,\n            Location location, bool moveExistingToPrevious, string modifiedBy, bool isMailingLocation, bool isMappedLocation )\n        {\n            if ( location != null )\n            {\n                var groupType = GroupTypeCache.Get( group.GroupTypeId );\n                if ( groupType != null )\n                {\n                    var locationType = groupType.LocationTypeValues.FirstOrDefault( l => l.Guid.Equals( locationTypeGuid.AsGuid() ) );\n                    if ( locationType != null )\n                    {\n                        var groupLocationService = new GroupLocationService( rockContext );\n                        if ( !groupLocationService.Queryable()\n                            .Where( gl =>\n                                gl.GroupId == group.Id &&\n                                gl.GroupLocationTypeValueId == locationType.Id &&\n                                gl.LocationId == location.Id )\n                            .Any() )\n                        {\n                            if ( moveExistingToPrevious )\n                            {\n                                var prevLocationType = groupType.LocationTypeValues.FirstOrDefault( l => l.Guid.Equals( Rock.SystemGuid.DefinedValue.GROUP_LOCATION_TYPE_PREVIOUS.AsGuid() ) );\n                                if ( prevLocationType != null )\n                                {\n                                    foreach ( var prevLoc in groupLocationService.Queryable( \"Location,GroupLocationTypeValue\" )\n                                        .Where( gl =>\n                                            gl.GroupId == group.Id &&\n                                            gl.GroupLocationTypeValueId == locationType.Id ) )\n                                    {\n                                        prevLoc.GroupLocationTypeValueId = prevLocationType.Id;\n                                        prevLoc.IsMailingLocation = false;\n                                        prevLoc.IsMappedLocation = false;\n                                    }\n                                }\n                            }\n\n                            string addressChangeField = locationType.Value;\n\n                            var groupLocation = groupLocationService.Queryable()\n                                .Where( gl =>\n                                    gl.GroupId == group.Id &&\n                                    gl.LocationId == location.Id )\n                                .FirstOrDefault();\n                            if ( groupLocation == null )\n                            {\n                                groupLocation = new GroupLocation();\n                                groupLocation.Location = location;\n                                groupLocation.IsMailingLocation = isMailingLocation;\n                                groupLocation.IsMappedLocation = isMappedLocation;\n                                group.GroupLocations.Add( groupLocation );\n                            }\n                            groupLocation.GroupLocationTypeValueId = locationType.Id;\n\n                            rockContext.SaveChanges();\n                        }\n                    }\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "private string GetIndent(Paragraph para, IEnumerable<Style> docStyles)\n        {\n            string indent = string.Empty;\n            if (para != null && para.ParagraphProperties != null && para.ParagraphProperties.Indentation != null)\n            {\n                var indentation = para.ParagraphProperties.Indentation;\n                if (indentation.Left != null && indentation.Left.HasValue)\n                {\n                    indent = WordListManager.TwipsToSpaces(indentation.Left);\n                }\n                else if (indentation.Start != null && indentation.Start.HasValue)\n                {\n                    indent = WordListManager.TwipsToSpaces(indentation.Start);\n                }\n            }\n            if (para != null && para.ParagraphProperties != null && para.ParagraphProperties.ParagraphStyleId != null &&\n                para.ParagraphProperties.ParagraphStyleId.Val != null &&\n                para.ParagraphProperties.ParagraphStyleId.Val.HasValue)\n            {\n                var style = docStyles.Where(r => r.StyleId == para.ParagraphProperties.ParagraphStyleId.Val.Value)\n                    .Select(r => r).FirstOrDefault();\n\n                if (style != null)\n                {\n                    var pp = style.Where(r => r is StyleParagraphProperties)\n                        .Select(r => r as StyleParagraphProperties).FirstOrDefault();\n\n                    if (pp != null && pp.Indentation != null)\n                    {\n                        if (pp.Indentation.Left != null && pp.Indentation.Left.HasValue)\n                        {\n                            indent = WordListManager.TwipsToSpaces(pp.Indentation.Left);\n                        }\n                        else if (pp.Indentation.Start != null && pp.Indentation.Start.HasValue)\n                        {\n                            indent = WordListManager.TwipsToSpaces(pp.Indentation.Start);\n                        }\n                    }\n                }\n            }\n\n            return indent;\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n\t\t/// Draw the this <see cref=\"CurveItem\"/> to the specified <see cref=\"Graphics\"/>\n\t\t/// device.  The format (stair-step or line) of the curve is\n\t\t/// defined by the <see cref=\"StepType\"/> property.  The routine\n\t\t/// only draws the line segments; the symbols are drawn by the\n\t\t/// <see cref=\"Symbol.Draw\"/> method.  This method\n\t\t/// is normally only called by the Draw method of the\n\t\t/// <see cref=\"CurveItem\"/> object\n\t\t/// </summary>\n\t\t/// <param name=\"g\">\n\t\t/// A graphic device object to be drawn into.  This is normally e.Graphics from the\n\t\t/// PaintEventArgs argument to the Paint() method.\n\t\t/// </param>\n\t\t/// <param name=\"scaleFactor\">\n\t\t/// The scaling factor to be used for rendering objects.  This is calculated and\n\t\t/// passed down by the parent <see cref=\"GraphPane\"/> object using the\n\t\t/// <see cref=\"PaneBase.CalcScaleFactor\"/> method, and is used to proportionally adjust\n\t\t/// font sizes, etc. according to the actual size of the graph.\n\t\t/// </param>\n\t\t/// <param name=\"pane\">\n\t\t/// A reference to the <see cref=\"GraphPane\"/> object that is the parent or\n\t\t/// owner of this object.\n\t\t/// </param>\n\t\t/// <param name=\"curve\">A <see cref=\"LineItem\"/> representing this\n\t\t/// curve.</param>\n\t\tpublic void DrawCurve( Graphics g, GraphPane pane,\n                                CurveItem curve, float scaleFactor )\n\t\t{\n\t\t\tLine source = this;\n\t\t\tif ( curve.IsSelected )\n\t\t\t\tsource = Selection.Line;\n\n\t\t\t// switch to int to optimize drawing speed (per Dale-a-b)\n\t\t\tint\ttmpX, tmpY,\n\t\t\t\t\tlastX = int.MaxValue,\n\t\t\t\t\tlastY = int.MaxValue;\n\n\t\t\tdouble curX, curY, lowVal;\n\t\t\tPointPair curPt, lastPt = new PointPair();\n\n\t\t\tbool lastBad = true;\n\t\t\tIPointList points = curve.Points;\n\t\t\tValueHandler valueHandler = new ValueHandler( pane, false );\n\t\t\tAxis yAxis = curve.GetYAxis( pane );\n\t\t\tAxis xAxis = curve.GetXAxis( pane );\n\n\t\t\tbool xIsLog = xAxis._scale.IsLog;\n\t\t\tbool yIsLog = yAxis._scale.IsLog;\n\n\t\t\t// switch to int to optimize drawing speed (per Dale-a-b)\n\t\t\tint minX = (int)pane.Chart.Rect.Left;\n\t\t\tint maxX = (int)pane.Chart.Rect.Right;\n\t\t\tint minY = (int)pane.Chart.Rect.Top;\n\t\t\tint maxY = (int)pane.Chart.Rect.Bottom;\n\n\t\t\tusing ( Pen pen = source.GetPen( pane, scaleFactor ) )\n\t\t\t{\n\t\t\t\tif ( points != null && !_color.IsEmpty && this.IsVisible )\n\t\t\t\t{\n\t\t\t\t\t//bool lastOut = false;\n\t\t\t\t\tbool isOut;\n\n\t\t\t\t\tbool isOptDraw = _isOptimizedDraw && points.Count > 1000;\n\n\t\t\t\t\t// (Dale-a-b) we'll set an element to true when it has been drawn\t\n\t\t\t\t\tbool[,] isPixelDrawn = null;\n\t\t\t\t\t\n\t\t\t\t\tif ( isOptDraw )\n\t\t\t\t\t\tisPixelDrawn = new bool[maxX + 1, maxY + 1]; \n\t\t\t\t\t\n\t\t\t\t\t// Loop over each point in the curve\n\t\t\t\t\tfor ( int i = 0; i < points.Count; i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tcurPt = points[i];\n\t\t\t\t\t\tif ( pane.LineType == LineType.Stack )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif ( !valueHandler.GetValues( curve, i, out curX, out lowVal, out curY ) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tcurX = PointPair.Missing;\n\t\t\t\t\t\t\t\tcurY = PointPair.Missing;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcurX = curPt.X;\n\t\t\t\t\t\t\tcurY = curPt.Y;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Any value set to double max is invalid and should be skipped\n\t\t\t\t\t\t// This is used for calculated values that are out of range, divide\n\t\t\t\t\t\t//   by zero, etc.\n\t\t\t\t\t\t// Also, any value <= zero on a log scale is invalid\n\t\t\t\t\t\tif ( curX == PointPair.Missing ||\n\t\t\t\t\t\t\t\tcurY == PointPair.Missing ||\n\t\t\t\t\t\t\t\tSystem.Double.IsNaN( curX ) ||\n\t\t\t\t\t\t\t\tSystem.Double.IsNaN( curY ) ||\n\t\t\t\t\t\t\t\tSystem.Double.IsInfinity( curX ) ||\n\t\t\t\t\t\t\t\tSystem.Double.IsInfinity( curY ) ||\n\t\t\t\t\t\t\t\t( xIsLog && curX <= 0.0 ) ||\n\t\t\t\t\t\t\t\t( yIsLog && curY <= 0.0 ) )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// If the point is invalid, then make a linebreak only if IsIgnoreMissing is false\n\t\t\t\t\t\t\t// LastX and LastY are always the last valid point, so this works out\n\t\t\t\t\t\t\tlastBad = lastBad || !pane.IsIgnoreMissing;\n\t\t\t\t\t\t\tisOut = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// Transform the current point from user scale units to\n\t\t\t\t\t\t\t// screen coordinates\n\t\t\t\t\t\t\ttmpX = (int) xAxis.Scale.Transform( curve.IsOverrideOrdinal, i, curX );\n\t\t\t\t\t\t\ttmpY = (int) yAxis.Scale.Transform( curve.IsOverrideOrdinal, i, curY );\n\n\t\t\t\t\t\t\t// Maintain an array of \"used\" pixel locations to avoid duplicate drawing operations\n\t\t\t\t\t\t\t// contributed by Dale-a-b\n\t\t\t\t\t\t\tif ( isOptDraw && tmpX >= minX && tmpX <= maxX &&\n\t\t\t\t\t\t\t\t\t\ttmpY >= minY && tmpY <= maxY ) // guard against the zoom-in case\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ( isPixelDrawn[tmpX, tmpY] )\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tisPixelDrawn[tmpX, tmpY] = true;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tisOut = ( tmpX < minX && lastX < minX ) || ( tmpX > maxX && lastX > maxX ) ||\n\t\t\t\t\t\t\t\t( tmpY < minY && lastY < minY ) || ( tmpY > maxY && lastY > maxY );\n\n\t\t\t\t\t\t\tif ( !lastBad )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// GDI+ plots the data wrong and/or throws an exception for\n\t\t\t\t\t\t\t\t\t// outrageous coordinates, so we do a sanity check here\n\t\t\t\t\t\t\t\t\tif ( lastX > 5000000 || lastX < -5000000 ||\n\t\t\t\t\t\t\t\t\t\t\tlastY > 5000000 || lastY < -5000000 ||\n\t\t\t\t\t\t\t\t\t\t\ttmpX > 5000000 || tmpX < -5000000 ||\n\t\t\t\t\t\t\t\t\t\t\ttmpY > 5000000 || tmpY < -5000000 )\n\t\t\t\t\t\t\t\t\t\tInterpolatePoint( g, pane, curve, lastPt, scaleFactor, pen,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlastX, lastY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\telse if ( !isOut )\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif ( !curve.IsSelected && this._gradientFill.IsGradientValueType )\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tusing ( Pen tPen = GetPen( pane, scaleFactor, lastPt ) )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tif ( this.StepType == StepType.NonStep )\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( tPen, lastX, lastY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse if ( this.StepType == StepType.ForwardStep )\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( tPen, lastX, lastY, tmpX, lastY );\n\t\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( tPen, tmpX, lastY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse if ( this.StepType == StepType.RearwardStep )\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( tPen, lastX, lastY, lastX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( tPen, lastX, tmpY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse if ( this.StepType == StepType.ForwardSegment )\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( tPen, lastX, lastY, tmpX, lastY );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( tPen, lastX, tmpY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif ( this.StepType == StepType.NonStep )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( pen, lastX, lastY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if ( this.StepType == StepType.ForwardStep )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( pen, lastX, lastY, tmpX, lastY );\n\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( pen, tmpX, lastY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if ( this.StepType == StepType.RearwardStep )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( pen, lastX, lastY, lastX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( pen, lastX, tmpY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if ( this.StepType == StepType.ForwardSegment )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( pen, lastX, lastY, tmpX, lastY );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse if ( this.StepType == StepType.RearwardSegment )\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tg.DrawLine( pen, lastX, tmpY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcatch\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tInterpolatePoint( g, pane, curve, lastPt, scaleFactor, pen,\n\t\t\t\t\t\t\t\t\t\t\t\tlastX, lastY, tmpX, tmpY );\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tlastPt = curPt;\n\t\t\t\t\t\t\tlastX = tmpX;\n\t\t\t\t\t\t\tlastY = tmpY;\n\t\t\t\t\t\t\tlastBad = false;\n\t\t\t\t\t\t\t//lastOut = isOut;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Job that will run quick SQL queries on a schedule.\n        /// \n        /// Called by the <see cref=\"IScheduler\" /> when a\n        /// <see cref=\"ITrigger\" /> fires that is associated with\n        /// the <see cref=\"IJob\" />.\n        /// </summary>\n        public virtual void Execute( IJobExecutionContext context )\n        {\n            JobDataMap dataMap = context.JobDetail.JobDataMap;\n\n            Guid? entryWorkflowType = dataMap.GetString( \"EraEntryWorkflow\" ).AsGuidOrNull();\n            Guid? exitWorkflowType = dataMap.GetString( \"EraExitWorkflow\" ).AsGuidOrNull();\n            bool updateVisitDates = dataMap.GetBooleanValue( \"SetVisitDates\" );\n\n            int commandTimeout = dataMap.GetString( \"CommandTimeout\" ).AsIntegerOrNull() ?? 3600;\n\n            // configuration\n            //\n\n            // giving\n            int exitGivingCount = 1;\n\n            // attendance\n            int exitAttendanceCountShort = 1;\n            int exitAttendanceCountLong = 8;\n\n            // get era dataset from stored proc\n            var resultContext = new RockContext();\n\n            \n            var eraAttribute = AttributeCache.Get( SystemGuid.Attribute.PERSON_ERA_CURRENTLY_AN_ERA.AsGuid() );\n            var eraStartAttribute = AttributeCache.Get( SystemGuid.Attribute.PERSON_ERA_START_DATE.AsGuid() );\n            var eraEndAttribute = AttributeCache.Get( SystemGuid.Attribute.PERSON_ERA_END_DATE.AsGuid() );\n\n            if (eraAttribute == null || eraStartAttribute == null || eraEndAttribute == null)\n            {\n                throw new Exception( \"Family analytic attributes could not be found\" );\n            }\n\n            resultContext.Database.CommandTimeout = commandTimeout;\n\n            context.UpdateLastStatusMessage( \"Getting Family Analytics Era Dataset...\" );\n\n            var results = resultContext.Database.SqlQuery<EraResult>( \"spCrm_FamilyAnalyticsEraDataset\" ).ToList();\n\n            int personEntityTypeId = EntityTypeCache.Get( \"Rock.Model.Person\" ).Id;\n            int attributeEntityTypeId = EntityTypeCache.Get( \"Rock.Model.Attribute\" ).Id;\n            int eraAttributeId = eraAttribute.Id;\n            int personAnalyticsCategoryId = CategoryCache.Get( SystemGuid.Category.HISTORY_PERSON_ANALYTICS.AsGuid() ).Id;\n\n            int progressPosition = 0;\n            int progressTotal = results.Count;\n\n            foreach (var result in results )\n            {\n                progressPosition++;\n                // create new rock context for each family (https://weblog.west-wind.com/posts/2014/Dec/21/Gotcha-Entity-Framework-gets-slow-in-long-Iteration-Loops)\n                RockContext updateContext = new RockContext();\n                updateContext.SourceOfChange = SOURCE_OF_CHANGE;\n                updateContext.Database.CommandTimeout = commandTimeout;\n                var attributeValueService = new AttributeValueService( updateContext );\n                var historyService = new HistoryService( updateContext );\n\n                // if era ensure it still meets requirements\n                if ( result.IsEra )\n                {\n                    if (result.ExitGiftCountDuration < exitGivingCount && result.ExitAttendanceCountDurationShort < exitAttendanceCountShort && result.ExitAttendanceCountDurationLong < exitAttendanceCountLong )\n                    {\n                        // exit era (delete attribute value from each person in family)\n                        var family = new GroupService( updateContext ).Queryable( \"Members, Members.Person\" ).AsNoTracking().Where( m => m.Id == result.FamilyId ).FirstOrDefault();\n\n                        if ( family != null ) {\n                            foreach ( var person in family.Members.Select( m => m.Person ) ) {\n\n                                // remove the era flag\n                                var eraAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraAttribute.Id && v.EntityId == person.Id ).FirstOrDefault();\n                                if ( eraAttributeValue != null )\n                                {\n                                    attributeValueService.Delete( eraAttributeValue );\n                                }\n\n                                // set end date\n                                var eraEndAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraEndAttribute.Id && v.EntityId == person.Id ).FirstOrDefault();\n                                if ( eraEndAttributeValue == null )\n                                {\n                                    eraEndAttributeValue = new AttributeValue();\n                                    eraEndAttributeValue.EntityId = person.Id;\n                                    eraEndAttributeValue.AttributeId = eraEndAttribute.Id;\n                                    attributeValueService.Add( eraEndAttributeValue );\n                                }\n                                eraEndAttributeValue.Value = RockDateTime.Now.ToString();\n\n                                // add a history record\n                                if ( personAnalyticsCategoryId != 0 && personEntityTypeId != 0 && attributeEntityTypeId != 0 && eraAttributeId != 0 )\n                                {\n                                    History historyRecord = new History();\n                                    historyService.Add( historyRecord );\n                                    historyRecord.EntityTypeId = personEntityTypeId;\n                                    historyRecord.EntityId = person.Id;\n                                    historyRecord.CreatedDateTime = RockDateTime.Now;\n                                    historyRecord.CreatedByPersonAliasId = person.PrimaryAliasId;\n                                    historyRecord.Caption = \"eRA\";\n\n                                    historyRecord.Verb = \"EXITED\";\n                                    historyRecord.ChangeType = History.HistoryChangeType.Attribute.ConvertToString();\n                                    historyRecord.ValueName = \"eRA\";\n                                    historyRecord.NewValue = \"Exited\";\n                                    \n                                    historyRecord.RelatedEntityTypeId = attributeEntityTypeId;\n                                    historyRecord.RelatedEntityId = eraAttributeId;\n                                    historyRecord.CategoryId = personAnalyticsCategoryId;\n                                    historyRecord.SourceOfChange = SOURCE_OF_CHANGE;\n                                }\n\n                                updateContext.SaveChanges();\n                            }\n\n                            // launch exit workflow\n                            if ( exitWorkflowType.HasValue )\n                            {\n                                LaunchWorkflow( exitWorkflowType.Value, family );\n                            }\n                        }\n                    }\n                }\n                else\n                {\n                    // entered era\n                    var family = new GroupService( updateContext ).Queryable( \"Members\" ).AsNoTracking().Where( m => m.Id == result.FamilyId ).FirstOrDefault();\n\n                    if ( family != null )\n                    {\n                        foreach ( var person in family.Members.Where( m => ! m.Person.IsDeceased ).Select( m => m.Person ) )\n                        {\n                            // set era attribute to true\n                            var eraAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraAttribute.Id && v.EntityId == person.Id ).FirstOrDefault();\n                            if ( eraAttributeValue == null )\n                            {\n                                eraAttributeValue = new AttributeValue();\n                                eraAttributeValue.EntityId = person.Id;\n                                eraAttributeValue.AttributeId = eraAttribute.Id;\n                                attributeValueService.Add( eraAttributeValue );\n                            }\n                            eraAttributeValue.Value = bool.TrueString;\n\n                            // add start date\n                            var eraStartAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraStartAttribute.Id && v.EntityId == person.Id ).FirstOrDefault();\n                            if (eraStartAttributeValue == null )\n                            {\n                                eraStartAttributeValue = new AttributeValue();\n                                eraStartAttributeValue.EntityId = person.Id;\n                                eraStartAttributeValue.AttributeId = eraStartAttribute.Id;\n                                attributeValueService.Add( eraStartAttributeValue );\n                            }\n                            eraStartAttributeValue.Value = RockDateTime.Now.ToString();\n\n                            // delete end date if it exists\n                            var eraEndAttributeValue = attributeValueService.Queryable().Where( v => v.AttributeId == eraEndAttribute.Id && v.EntityId == person.Id ).FirstOrDefault();\n                            if ( eraEndAttributeValue != null )\n                            {\n                                attributeValueService.Delete( eraEndAttributeValue );\n                            }\n\n                            // add a history record\n                            if ( personAnalyticsCategoryId != 0 && personEntityTypeId != 0 && attributeEntityTypeId != 0 && eraAttributeId != 0 )\n                            {\n                                History historyRecord = new History();\n                                historyService.Add( historyRecord );\n                                historyRecord.EntityTypeId = personEntityTypeId;\n                                historyRecord.EntityId = person.Id;\n                                historyRecord.CreatedDateTime = RockDateTime.Now;\n                                historyRecord.CreatedByPersonAliasId = person.PrimaryAliasId;\n                                historyRecord.Caption = \"eRA\";\n                                historyRecord.Verb = \"ENTERED\";\n                                historyRecord.ChangeType = History.HistoryChangeType.Attribute.ConvertToString();\n                                historyRecord.RelatedEntityTypeId = attributeEntityTypeId;\n                                historyRecord.RelatedEntityId = eraAttributeId;\n                                historyRecord.CategoryId = personAnalyticsCategoryId;\n                                historyRecord.SourceOfChange = SOURCE_OF_CHANGE;\n                            }\n\n                            updateContext.SaveChanges();\n                        }\n\n                        // launch entry workflow\n                        if ( entryWorkflowType.HasValue )\n                        {\n                            LaunchWorkflow( entryWorkflowType.Value, family );\n                        }\n                    }\n                }\n\n                // update stats\n                context.UpdateLastStatusMessage( $\"Updating eRA {progressPosition} of {progressTotal}\" );\n            }\n\n            // load giving attributes\n            context.UpdateLastStatusMessage( \"Updating Giving...\" );\n            resultContext.Database.ExecuteSqlCommand( \"spCrm_FamilyAnalyticsGiving\" );\n\n            // load attendance attributes\n            context.UpdateLastStatusMessage( \"Updating Attendance...\" );\n            resultContext.Database.ExecuteSqlCommand( \"spCrm_FamilyAnalyticsAttendance\" );\n\n            // process visit dates\n            if ( updateVisitDates )\n            {\n                context.UpdateLastStatusMessage( \"Updating Visit Dates...\" );\n                resultContext.Database.ExecuteSqlCommand( \"spCrm_FamilyAnalyticsUpdateVisitDates\" );\n            }\n\n            context.UpdateLastStatusMessage( \"\" );\n        }", "label": "ComplexConditional"}
{"text": "private static void AntiGapcloser_OnEnemyGapcloser(ActiveGapcloser gapcloser)\n        {\n            var pos = _e.GetPrediction(gapcloser.Sender).CastPosition;\n            if (_config.Item(\"Gap_E\").GetValue<bool>())\n            {\n                if (_e.IsReady() && gapcloser.Sender.IsValidTarget(_e.Range) && _w.IsReady())\n                {\n                    _e.CastIfHitchanceEquals(gapcloser.Sender, HitChance.High, Packets());\n                    Utility.DelayAction.Add(50, () => _w.Cast(new Vector3(pos.X - 2, pos.Y - 2, pos.Z), Packets()));\n                    Utility.DelayAction.Add(150, () => _w.Cast(new Vector3(pos.X + 2, pos.Y + 2, pos.Z), Packets()));\n                }\n                else if (_e.IsReady() && gapcloser.Sender.IsValidTarget(_e.Range))\n                {\n                    _e.CastIfHitchanceEquals(gapcloser.Sender, HitChance.High, Packets());\n                }\n            }\n            if (Items.HasItem(3092) && Items.CanUseItem(3092) && _config.Item(\"usefrostq\").GetValue<bool>() &&\n                gapcloser.Sender.IsValidTarget(800))\n            {\n                _frostqueen.Cast(gapcloser.Sender);\n            }\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        ///     Gets the automatic attack damage.\n        /// </summary>\n        /// <param name=\"source\">The source.</param>\n        /// <param name=\"target\">The target.</param>\n        /// <param name=\"includePassive\">if set to <c>true</c> [include passive].</param>\n        /// <returns></returns>\n        public static double GetAutoAttackDamage(\n            this Obj_AI_Base source,\n            Obj_AI_Base target,\n            bool includePassive = false)\n        {\n            double result = source.TotalAttackDamage;\n            var k = 1d;\n            if (source.CharData.BaseSkinName == \"Kalista\")\n            {\n                k = 0.9d;\n            }\n            if (source.CharData.BaseSkinName == \"Kled\" &&\n                ObjectManager.Player.Spellbook.GetSpell(SpellSlot.Q).Name == \"KledRiderQ\")\n            {\n                k = 0.8d;\n            }\n\n            if (!includePassive)\n            {\n                return CalcPhysicalDamage(source, target, result*k);\n            }\n\n            var reduction = 0d;\n\n            var hero = source as Obj_AI_Hero;\n            if (hero != null)\n            {\n                // Spoils of War\n                var minionTarget = target as Obj_AI_Minion;\n                if (hero.IsMelee() && minionTarget != null && minionTarget.IsEnemy\n                    && minionTarget.Team != GameObjectTeam.Neutral\n                    && hero.Buffs.Any(buff => buff.Name == \"talentreaperdisplay\" && buff.Count > 0))\n                {\n                    if (\n                        HeroManager.AllHeroes.Any(\n                            h =>\n                                h.NetworkId != source.NetworkId && h.Team == source.Team\n                                && h.Distance(minionTarget.Position) < 1100))\n                    {\n                        var value = 0;\n\n                        if (Items.HasItem(3302, hero))\n                        {\n                            value = 200; // Relic Shield\n                        }\n                        else if (Items.HasItem(3097, hero))\n                        {\n                            value = 240; // Targon's Brace\n                        }\n                        else if (Items.HasItem(3401, hero))\n                        {\n                            value = 400; // Face of the Mountain\n                        }\n\n                        return value + hero.TotalAttackDamage;\n                    }\n                }\n\n                //Champions passive damages:\n                result +=\n                    AttackPassives.Where(\n                        p => (p.ChampionName == \"\" || p.ChampionName == hero.ChampionName) && p.IsActive(hero, target))\n                        .Sum(passive => passive.GetDamage(hero, target));\n\n                // BotRK\n                if (Items.HasItem(3153, hero))\n                {\n                    var d = 0.06*target.Health;\n                    if (target is Obj_AI_Minion)\n                    {\n                        d = Math.Min(d, 60);\n                    }\n\n                    result += d;\n                }\n            }\n\n            var targetHero = target as Obj_AI_Hero;\n            if (targetHero != null)\n            {\n                // Ninja tabi\n                if (Items.HasItem(3047, targetHero))\n                {\n                    k *= 0.9d;\n                }\n\n                // Nimble Fighter\n                if (targetHero.ChampionName == \"Fizz\")\n                {\n                    var f = new int[] {4, 6, 8, 10, 12, 14};\n                    reduction += f[(targetHero.Level - 1)/3];\n                }\n            }\n\n            //TODO: need to check if there are items or spells in game that reduce magical dmg % or by amount\n            if (hero != null && hero.ChampionName == \"Corki\")\n            {\n                return CalcMixedDamage(source, target, (result - reduction)*k, result*k);\n            }\n\n            return CalcPhysicalDamage(source, target, (result - reduction)*k + PassiveFlatMod(source, target));\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Gets the Leases, if any persisted to file, for an event hub partitions in the current namespace.\n        /// </summary>\n        /// <param name=\"ns\">Namespace name.</param>\n        /// <param name=\"eventHub\">Event hub name.</param>\n        /// <param name=\"consumerGroup\"></param>\n        /// <returns>The in-memory or persisted lease for the event hub partition.</returns>\n        public static Dictionary<string, Lease> GetLease(string ns, string eventHub, string consumerGroup)\n        {\n            if (string.IsNullOrWhiteSpace(ns) ||\n                string.IsNullOrWhiteSpace(eventHub) ||\n                string.IsNullOrWhiteSpace(consumerGroup))\n            {\n                return null;\n            }\n            var key = string.Format(KeyFormat, ns, eventHub, consumerGroup);\n            return mapDictionary.ContainsKey(key) ?\n                   mapDictionary[key].Leases :\n                   null;\n        }/// <summary>\n        /// Gets the Lease, if any persisted to file, for an event hub partition in the current namespace.\n        /// </summary>\n        /// <param name=\"ns\">Namespace name.</param>\n        /// <param name=\"eventHub\">Event hub name.</param>\n        /// <param name=\"consumerGroup\">Consumer group</param>\n        /// <param name=\"partitionId\">Partition Id.</param>\n        /// <returns>The in-memory or persisted lease for the event hub partition.</returns>\n        public static Lease GetLease(string ns, string eventHub, string consumerGroup, string partitionId)\n        {\n            if (string.IsNullOrWhiteSpace(ns) ||\n                string.IsNullOrWhiteSpace(eventHub) ||\n                string.IsNullOrWhiteSpace(consumerGroup) ||\n                string.IsNullOrWhiteSpace(partitionId))\n            {\n                return null;\n            }\n            var key = string.Format(KeyFormat, ns, eventHub, consumerGroup);\n            var value = mapDictionary.ContainsKey(key) &&\n                   mapDictionary[key].Leases != null && \n                   mapDictionary[key].Leases.ContainsKey(partitionId) ?\n                   mapDictionary[key].Leases[partitionId] :\n                   GetDefaultLease(partitionId);\n            return value;\n        }", "label": "ComplexConditional"}
{"text": "// When the ScrollViewer zooms in or out, we update DpiScale on our CanvasVirtualControl\n        // to match. This adjusts its pixel density to match the current zoom level. But its size\n        // in dips stays the same, so layout and scroll position are not affected by the zoom.\n        void ScrollViewer_ViewChanged(object sender, ScrollViewerViewChangedEventArgs e)\n        {\n            // Cancel out the display DPI, so our fractal always renders at 96 DPI regardless of display\n            // configuration. This boosts performance on high DPI displays, at the cost of visual quality.\n            // For even better performance (but lower quality) this value could be further reduced.\n            float dpiAdjustment = 96 / displayDpi;\n\n            // Adjust DPI to match the current zoom level.\n            float dpiScale = dpiAdjustment * scrollViewer.ZoomFactor;\n\n            // To boost performance during pinch-zoom manipulations, we only update DPI when it has\n            // changed by more than 20%, or at the end of the zoom (when e.IsIntermediate reports false).\n            // Smaller changes will just scale the existing bitmap, which is much faster than recomputing\n            // the fractal at a different resolution. To trade off between zooming perf vs. smoothness,\n            // adjust the thresholds used in this ratio comparison.\n            var ratio = canvas.DpiScale / dpiScale;\n\n            if (e == null || !e.IsIntermediate || ratio <= 0.8 || ratio >= 1.25)\n            {\n                canvas.DpiScale = dpiScale;\n            }\n        }", "label": "ComplexConditional"}
{"text": "private int Internal_ExecCall(int argsCount, int instructionPtr, CallbackFunction handler = null,\n\t\t\tCallbackFunction continuation = null, bool thisCall = false, string debugText = null, DynValue unwindHandler = null)\n\t\t{\n\t\t\tDynValue fn = m_ValueStack.Peek(argsCount);\n\t\t\tCallStackItemFlags flags = (thisCall ? CallStackItemFlags.MethodCall : CallStackItemFlags.None);\n\n\t\t\t// if TCO threshold reached\n\t\t\tif ((m_ExecutionStack.Count > this.m_Script.Options.TailCallOptimizationThreshold && m_ExecutionStack.Count > 1)\n\t\t\t\t|| (m_ValueStack.Count > this.m_Script.Options.TailCallOptimizationThreshold && m_ValueStack.Count > 1))\n\t\t\t{\n\t\t\t\t// and the \"will-be\" return address is valid (we don't want to crash here)\n\t\t\t\tif (instructionPtr >= 0 && instructionPtr < this.m_RootChunk.Code.Count)\n\t\t\t\t{\n\t\t\t\t\tInstruction I = this.m_RootChunk.Code[instructionPtr];\n\n\t\t\t\t\t// and we are followed *exactly* by a RET 1\n\t\t\t\t\tif (I.OpCode == OpCode.Ret && I.NumVal == 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tCallStackItem csi = m_ExecutionStack.Peek();\n\n\t\t\t\t\t\t// if the current stack item has no \"odd\" things pending and neither has the new coming one..\n\t\t\t\t\t\tif (csi.ClrFunction == null && csi.Continuation == null && csi.ErrorHandler == null\n\t\t\t\t\t\t\t&& csi.ErrorHandlerBeforeUnwind == null && continuation == null && unwindHandler == null && handler == null)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tinstructionPtr = PerformTCO(instructionPtr, argsCount);\n\t\t\t\t\t\t\tflags |= CallStackItemFlags.TailCall;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\n\t\t\tif (fn.Type == DataType.ClrFunction)\n\t\t\t{\n\t\t\t\t//IList<DynValue> args = new Slice<DynValue>(m_ValueStack, m_ValueStack.Count - argsCount, argsCount, false);\n\t\t\t\tIList<DynValue> args = CreateArgsListForFunctionCall(argsCount, 0);\n\t\t\t\t// we expand tuples before callbacks\n\t\t\t\t// args = DynValue.ExpandArgumentsToList(args);\n\t\t\t\tSourceRef sref = GetCurrentSourceRef(instructionPtr);\n\n\t\t\t\tm_ExecutionStack.Push(new CallStackItem()\n\t\t\t\t{\n\t\t\t\t\tClrFunction = fn.Callback,\n\t\t\t\t\tReturnAddress = instructionPtr,\n\t\t\t\t\tCallingSourceRef = sref,\n\t\t\t\t\tBasePointer = -1,\n\t\t\t\t\tErrorHandler = handler,\n\t\t\t\t\tContinuation = continuation,\n\t\t\t\t\tErrorHandlerBeforeUnwind = unwindHandler,\n\t\t\t\t\tFlags = flags,\n\t\t\t\t});\n\n\t\t\t\tvar ret = fn.Callback.Invoke(new ScriptExecutionContext(this, fn.Callback, sref), args, isMethodCall: thisCall);\n\t\t\t\tm_ValueStack.RemoveLast(argsCount + 1);\n\t\t\t\tm_ValueStack.Push(ret);\n\n\t\t\t\tm_ExecutionStack.Pop();\n\n\t\t\t\treturn Internal_CheckForTailRequests(null, instructionPtr);\n\t\t\t}\n\t\t\telse if (fn.Type == DataType.Function)\n\t\t\t{\n\t\t\t\tm_ValueStack.Push(DynValue.NewNumber(argsCount));\n\t\t\t\tm_ExecutionStack.Push(new CallStackItem()\n\t\t\t\t{\n\t\t\t\t\tBasePointer = m_ValueStack.Count,\n\t\t\t\t\tReturnAddress = instructionPtr,\n\t\t\t\t\tDebug_EntryPoint = fn.Function.EntryPointByteCodeLocation,\n\t\t\t\t\tCallingSourceRef = GetCurrentSourceRef(instructionPtr),\n\t\t\t\t\tClosureScope = fn.Function.ClosureContext,\n\t\t\t\t\tErrorHandler = handler,\n\t\t\t\t\tContinuation = continuation,\n\t\t\t\t\tErrorHandlerBeforeUnwind = unwindHandler,\n\t\t\t\t\tFlags = flags,\n\t\t\t\t});\n\t\t\t\treturn fn.Function.EntryPointByteCodeLocation;\n\t\t\t}\n\n\t\t\t// fallback to __call metamethod\n\t\t\tvar m = GetMetamethod(fn, \"__call\");\n\n\t\t\tif (m != null && m.IsNotNil())\n\t\t\t{\n\t\t\t\tDynValue[] tmp = new DynValue[argsCount + 1];\n\t\t\t\tfor (int i = 0; i < argsCount + 1; i++)\n\t\t\t\t\ttmp[i] = m_ValueStack.Pop();\n\n\t\t\t\tm_ValueStack.Push(m);\n\n\t\t\t\tfor (int i = argsCount; i >= 0; i--)\n\t\t\t\t\tm_ValueStack.Push(tmp[i]);\n\n\t\t\t\treturn Internal_ExecCall(argsCount + 1, instructionPtr, handler, continuation);\n\t\t\t}\n\n\t\t\tthrow ScriptRuntimeException.AttemptToCallNonFunc(fn.Type, debugText);\n\t\t}", "label": "ComplexConditional"}
{"text": "private void update()\n\t\t{\n\t\t\tdouble epsilon = 1e-30;\n\t\t\tif (Math.Abs(m_world_x1 - m_world_x2) < epsilon ||\n\t\t\t   Math.Abs(m_world_y1 - m_world_y2) < epsilon ||\n\t\t\t   Math.Abs(m_device_x1 - m_device_x2) < epsilon ||\n\t\t\t   Math.Abs(m_device_y1 - m_device_y2) < epsilon)\n\t\t\t{\n\t\t\t\tm_wx1 = m_world_x1;\n\t\t\t\tm_wy1 = m_world_y1;\n\t\t\t\tm_wx2 = m_world_x1 + 1.0;\n\t\t\t\tm_wy2 = m_world_y2 + 1.0;\n\t\t\t\tm_dx1 = m_device_x1;\n\t\t\t\tm_dy1 = m_device_y1;\n\t\t\t\tm_kx = 1.0;\n\t\t\t\tm_ky = 1.0;\n\t\t\t\tm_is_valid = false;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdouble world_x1 = m_world_x1;\n\t\t\tdouble world_y1 = m_world_y1;\n\t\t\tdouble world_x2 = m_world_x2;\n\t\t\tdouble world_y2 = m_world_y2;\n\t\t\tdouble device_x1 = m_device_x1;\n\t\t\tdouble device_y1 = m_device_y1;\n\t\t\tdouble device_x2 = m_device_x2;\n\t\t\tdouble device_y2 = m_device_y2;\n\t\t\tif (m_aspect != aspect_ratio_e.aspect_ratio_stretch)\n\t\t\t{\n\t\t\t\tdouble d;\n\t\t\t\tm_kx = (device_x2 - device_x1) / (world_x2 - world_x1);\n\t\t\t\tm_ky = (device_y2 - device_y1) / (world_y2 - world_y1);\n\n\t\t\t\tif ((m_aspect == aspect_ratio_e.aspect_ratio_meet) == (m_kx < m_ky))\n\t\t\t\t{\n\t\t\t\t\td = (world_y2 - world_y1) * m_ky / m_kx;\n\t\t\t\t\tworld_y1 += (world_y2 - world_y1 - d) * m_align_y;\n\t\t\t\t\tworld_y2 = world_y1 + d;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\td = (world_x2 - world_x1) * m_kx / m_ky;\n\t\t\t\t\tworld_x1 += (world_x2 - world_x1 - d) * m_align_x;\n\t\t\t\t\tworld_x2 = world_x1 + d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tm_wx1 = world_x1;\n\t\t\tm_wy1 = world_y1;\n\t\t\tm_wx2 = world_x2;\n\t\t\tm_wy2 = world_y2;\n\t\t\tm_dx1 = device_x1;\n\t\t\tm_dy1 = device_y1;\n\t\t\tm_kx = (device_x2 - device_x1) / (world_x2 - world_x1);\n\t\t\tm_ky = (device_y2 - device_y1) / (world_y2 - world_y1);\n\t\t\tm_is_valid = true;\n\t\t}", "label": "ComplexConditional"}
{"text": "public static void Reduce32(uint x, uint[] z)\n        {\n            long cc = 0;\n\n            if (x != 0)\n            {\n                long xx12 = x;\n\n                cc += (long)z[0] + xx12;\n                z[0] = (uint)cc;\n                cc >>= 32;\n                cc += (long)z[1] - xx12;\n                z[1] = (uint)cc;\n                cc >>= 32;\n                if (cc != 0)\n                {\n                    cc += (long)z[2];\n                    z[2] = (uint)cc;\n                    cc >>= 32;\n                }\n                cc += (long)z[3] + xx12;\n                z[3] = (uint)cc;\n                cc >>= 32;\n                cc += (long)z[4] + xx12;\n                z[4] = (uint)cc;\n                cc >>= 32;\n\n                Debug.Assert(cc == 0 || cc == 1);\n            }\n\n            if ((cc != 0 && Nat.IncAt(12, z, 5) != 0)\n                || (z[11] == P11 && Nat.Gte(12, z, P)))\n            {\n                AddPInvTo(z);\n            }\n        }", "label": "ComplexConditional"}
{"text": "/// <summary>\n\t\t/// Constructs a Segment based on elements obtained from the two planes relations\n\t\t/// </summary>\n\t\t/// <param name=\"line\"></param>\n\t\t/// <param name=\"face\"></param>\n\t\t/// <param name=\"side1\"></param>\n\t\t/// <param name=\"side2\"></param>\n\t\t/// <param name=\"side3\"></param>\n\t\tpublic Segment(Line line, CsgFace face, PlaneSide side1, PlaneSide side2, PlaneSide side3)\n\t\t{\n\t\t\tthis.line = line;\n\t\t\tindex = 0;\n\n\t\t\t//VERTEX is an end\n\t\t\tif (side1 == PlaneSide.On)\n\t\t\t{\n\t\t\t\tSetVertex(face.v1);\n\t\t\t\t//other vertices on the same side - VERTEX-VERTEX VERTEX\n\t\t\t\tif (side2 == side3)\n\t\t\t\t{\n\t\t\t\t\tSetVertex(face.v1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//VERTEX is an end\n\t\t\tif (side2 == PlaneSide.On)\n\t\t\t{\n\t\t\t\tSetVertex(face.v2);\n\t\t\t\t//other vertices on the same side - VERTEX-VERTEX VERTEX\n\t\t\t\tif (side1 == side3)\n\t\t\t\t{\n\t\t\t\t\tSetVertex(face.v2);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//VERTEX is an end\n\t\t\tif (side3 == PlaneSide.On)\n\t\t\t{\n\t\t\t\tSetVertex(face.v3);\n\t\t\t\t//other vertices on the same side - VERTEX-VERTEX VERTEX\n\t\t\t\tif (side1 == side2)\n\t\t\t\t{\n\t\t\t\t\tSetVertex(face.v3);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//There are undefined ends - one or more edges cut the planes intersection line\n\t\t\tif (GetNumEndsSet() != 2)\n\t\t\t{\n\t\t\t\t//EDGE is an end\n\t\t\t\tif ((side1 == PlaneSide.Front && side2 == PlaneSide.Back)\n\t\t\t\t\t|| (side1 == PlaneSide.Back && side2 == PlaneSide.Front))\n\t\t\t\t{\n\t\t\t\t\tSetEdge(face.v1, face.v2);\n\t\t\t\t}\n\t\t\t\t//EDGE is an end\n\t\t\t\tif ((side2 == PlaneSide.Front && side3 == PlaneSide.Back)\n\t\t\t\t\t|| (side2 == PlaneSide.Back && side3 == PlaneSide.Front))\n\t\t\t\t{\n\t\t\t\t\tSetEdge(face.v2, face.v3);\n\t\t\t\t}\n\t\t\t\t//EDGE is an end\n\t\t\t\tif ((side3 == PlaneSide.Front && side1 == PlaneSide.Back)\n\t\t\t\t\t|| (side3 == PlaneSide.Back && side1 == PlaneSide.Front))\n\t\t\t\t{\n\t\t\t\t\tSetEdge(face.v3, face.v1);\n\t\t\t\t}\n\t\t\t}\n\t\t}", "label": "ComplexConditional"}
{"text": "/// <summary>\n        /// Updates the selection set, given the hit object and the modifier keys</summary>\n        /// <param name=\"hitRecord\">HitRecord</param>\n        /// <param name=\"modifiers\">Modifier keys</param>\n        private void UpdateSelection(HitRecord hitRecord, Keys modifiers)\n        {\n            TimelinePath hitObject = hitRecord.HitPath;\n            bool hitIsValidAnchor = true;\n\n            switch (hitRecord.Type)\n            {\n                case HitType.GroupMove:\n                    SelectGroups(hitObject);\n                    break;\n\n                case HitType.TrackMove:\n                    SelectTracks(hitObject);\n                    break;\n\n                case HitType.Interval:\n                case HitType.Key:\n                case HitType.Marker:\n                    SelectEvents(hitObject);\n                    Owner.Constrain = (modifiers & Owner.ConstrainModifierKeys) != 0;\n                    break;\n                \n                default:\n                    Anchor = null;\n                    hitIsValidAnchor = false;\n                    break;\n            }\n\n            if (hitIsValidAnchor)\n            {\n                // If the Shift key is not held down or the current Anchor is null, or the user\n                //  has switched between track and group, or the user has picked an event, then\n                //  update the Anchor. IEvents are always additive with the shift key.\n                if ((modifiers & Keys.Shift) == 0 ||\n                    Anchor == null ||\n                    (Anchor.Last is IGroup && hitObject.Last is ITrack) ||\n                    (Anchor.Last is ITrack && hitObject.Last is IGroup) ||\n                    (Anchor.Last is IEvent && hitObject.Last is IEvent))\n                {\n                    Anchor = hitObject;\n                }\n            }\n        }", "label": "ComplexConditional"}
{"text": "public HashSet<Vec2I> GetCollisionsAt(int x, int y)\n        {\n            if (x >= Width || x < 0 || y >= Height || y < 0 || m_collisionMap == null)\n                return null;\n\n            return m_collisionMap[x, y];\n        }", "label": "ComplexConditional"}
{"text": "void RegisterRenamers(ConfuserContext context, NameService service) {\n\t\t\tbool wpf = false,\n\t\t\t     caliburn = false,\n\t\t\t     winforms = false,\n\t\t\t     json = false;\n\n\t\t\tforeach (var module in context.Modules)\n\t\t\t\tforeach (var asmRef in module.GetAssemblyRefs()) {\n\t\t\t\t\tif (asmRef.Name == \"WindowsBase\" || asmRef.Name == \"PresentationCore\" ||\n\t\t\t\t\t    asmRef.Name == \"PresentationFramework\" || asmRef.Name == \"System.Xaml\") {\n\t\t\t\t\t\twpf = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (asmRef.Name == \"Caliburn.Micro\") {\n\t\t\t\t\t\tcaliburn = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (asmRef.Name == \"System.Windows.Forms\") {\n\t\t\t\t\t\twinforms = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if (asmRef.Name == \"Newtonsoft.Json\") {\n\t\t\t\t\t\tjson = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (wpf) {\n\t\t\t\tvar wpfAnalyzer = new WPFAnalyzer();\n\t\t\t\tcontext.Logger.Debug(\"WPF found, enabling compatibility.\");\n\t\t\t\tservice.Renamers.Add(wpfAnalyzer);\n\t\t\t\tif (caliburn) {\n\t\t\t\t\tcontext.Logger.Debug(\"Caliburn.Micro found, enabling compatibility.\");\n\t\t\t\t\tservice.Renamers.Add(new CaliburnAnalyzer(wpfAnalyzer));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (winforms) {\n\t\t\t\tvar winformsAnalyzer = new WinFormsAnalyzer();\n\t\t\t\tcontext.Logger.Debug(\"WinForms found, enabling compatibility.\");\n\t\t\t\tservice.Renamers.Add(winformsAnalyzer);\n\t\t\t}\n\n\t\t\tif (json) {\n\t\t\t\tvar jsonAnalyzer = new JsonAnalyzer();\n\t\t\t\tcontext.Logger.Debug(\"Newtonsoft.Json found, enabling compatibility.\");\n\t\t\t\tservice.Renamers.Add(jsonAnalyzer);\n\t\t\t}\n\t\t}", "label": "ComplexConditional"}
{"text": "\t// __LLBLGENPRO_USER_CODE_REGION_START AdditionalNamespaces\n\t// __LLBLGENPRO_USER_CODE_REGION_END\n\t/// <summary>Entity class which represents the entity 'Product'.<br/><br/></summary>\n\t[Serializable]\n\tpublic partial class ProductEntity : CommonEntityBase\n\t\t// __LLBLGENPRO_USER_CODE_REGION_START AdditionalInterfaces\n\t\t// __LLBLGENPRO_USER_CODE_REGION_END\t\n\t{\n\t\tprivate EntityCollection<BillOfMaterialEntity> _billOfMaterials;\n\t\tprivate EntityCollection<BillOfMaterialEntity> _billOfMaterials_;\n\t\tprivate EntityCollection<ProductCostHistoryEntity> _productCostHistories;\n\t\tprivate EntityCollection<ProductDocumentEntity> _productDocuments;\n\t\tprivate EntityCollection<ProductInventoryEntity> _productInventories;\n\t\tprivate EntityCollection<ProductListPriceHistoryEntity> _productListPriceHistories;\n\t\tprivate EntityCollection<ProductProductPhotoEntity> _productProductPhotos;\n\t\tprivate EntityCollection<ProductReviewEntity> _productReviews;\n\t\tprivate EntityCollection<ProductVendorEntity> _productVendors;\n\t\tprivate EntityCollection<PurchaseOrderDetailEntity> _purchaseOrderDetails;\n\t\tprivate EntityCollection<ShoppingCartItemEntity> _shoppingCartItems;\n\t\tprivate EntityCollection<SpecialOfferProductEntity> _specialOfferProducts;\n\t\tprivate EntityCollection<TransactionHistoryEntity> _transactionHistories;\n\t\tprivate EntityCollection<WorkOrderEntity> _workOrders;\n\t\tprivate ProductModelEntity _productModel;\n\t\tprivate ProductSubcategoryEntity _productSubcategory;\n\t\tprivate UnitMeasureEntity _unitMeasure;\n\t\tprivate UnitMeasureEntity _unitMeasure_;\n\n\t\t// __LLBLGENPRO_USER_CODE_REGION_START PrivateMembers\n\t\t// __LLBLGENPRO_USER_CODE_REGION_END\n\t\tprivate static ProductEntityStaticMetaData _staticMetaData = new ProductEntityStaticMetaData();\n\t\tprivate static ProductRelations _relationsFactory = new ProductRelations();\n\n\t\t/// <summary>All names of fields mapped onto a relation. Usable for in-memory filtering</summary>\n\t\tpublic static partial class MemberNames\n\t\t{\n\t\t\t/// <summary>Member name ProductModel</summary>\n\t\t\tpublic static readonly string ProductModel = \"ProductModel\";\n\t\t\t/// <summary>Member name ProductSubcategory</summary>\n\t\t\tpublic static readonly string ProductSubcategory = \"ProductSubcategory\";\n\t\t\t/// <summary>Member name UnitMeasure</summary>\n\t\t\tpublic static readonly string UnitMeasure = \"UnitMeasure\";\n\t\t\t/// <summary>Member name UnitMeasure_</summary>\n\t\t\tpublic static readonly string UnitMeasure_ = \"UnitMeasure_\";\n\t\t\t/// <summary>Member name BillOfMaterials</summary>\n\t\t\tpublic static readonly string BillOfMaterials = \"BillOfMaterials\";\n\t\t\t/// <summary>Member name BillOfMaterials_</summary>\n\t\t\tpublic static readonly string BillOfMaterials_ = \"BillOfMaterials_\";\n\t\t\t/// <summary>Member name ProductCostHistories</summary>\n\t\t\tpublic static readonly string ProductCostHistories = \"ProductCostHistories\";\n\t\t\t/// <summary>Member name ProductDocuments</summary>\n\t\t\tpublic static readonly string ProductDocuments = \"ProductDocuments\";\n\t\t\t/// <summary>Member name ProductInventories</summary>\n\t\t\tpublic static readonly string ProductInventories = \"ProductInventories\";\n\t\t\t/// <summary>Member name ProductListPriceHistories</summary>\n\t\t\tpublic static readonly string ProductListPriceHistories = \"ProductListPriceHistories\";\n\t\t\t/// <summary>Member name ProductProductPhotos</summary>\n\t\t\tpublic static readonly string ProductProductPhotos = \"ProductProductPhotos\";\n\t\t\t/// <summary>Member name ProductReviews</summary>\n\t\t\tpublic static readonly string ProductReviews = \"ProductReviews\";\n\t\t\t/// <summary>Member name ProductVendors</summary>\n\t\t\tpublic static readonly string ProductVendors = \"ProductVendors\";\n\t\t\t/// <summary>Member name PurchaseOrderDetails</summary>\n\t\t\tpublic static readonly string PurchaseOrderDetails = \"PurchaseOrderDetails\";\n\t\t\t/// <summary>Member name ShoppingCartItems</summary>\n\t\t\tpublic static readonly string ShoppingCartItems = \"ShoppingCartItems\";\n\t\t\t/// <summary>Member name SpecialOfferProducts</summary>\n\t\t\tpublic static readonly string SpecialOfferProducts = \"SpecialOfferProducts\";\n\t\t\t/// <summary>Member name TransactionHistories</summary>\n\t\t\tpublic static readonly string TransactionHistories = \"TransactionHistories\";\n\t\t\t/// <summary>Member name WorkOrders</summary>\n\t\t\tpublic static readonly string WorkOrders = \"WorkOrders\";\n\t\t}\n\n\t\t/// <summary>Static meta-data storage for navigator related information</summary>\n\t\tprotected class ProductEntityStaticMetaData : EntityStaticMetaDataBase\n\t\t{\n\t\t\tpublic ProductEntityStaticMetaData()\n\t\t\t{\n\t\t\t\tSetEntityCoreInfo(\"ProductEntity\", InheritanceHierarchyType.None, false, (int)AdventureWorks.Dal.Adapter.EntityType.ProductEntity, typeof(ProductEntity), typeof(ProductEntityFactory), false);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<BillOfMaterialEntity>>(\"BillOfMaterials\", a => a._billOfMaterials, (a, b) => a._billOfMaterials = b, a => a.BillOfMaterials, () => new ProductRelations().BillOfMaterialEntityUsingComponentId, typeof(BillOfMaterialEntity), (int)AdventureWorks.Dal.Adapter.EntityType.BillOfMaterialEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<BillOfMaterialEntity>>(\"BillOfMaterials_\", a => a._billOfMaterials_, (a, b) => a._billOfMaterials_ = b, a => a.BillOfMaterials_, () => new ProductRelations().BillOfMaterialEntityUsingProductAssemblyId, typeof(BillOfMaterialEntity), (int)AdventureWorks.Dal.Adapter.EntityType.BillOfMaterialEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ProductCostHistoryEntity>>(\"ProductCostHistories\", a => a._productCostHistories, (a, b) => a._productCostHistories = b, a => a.ProductCostHistories, () => new ProductRelations().ProductCostHistoryEntityUsingProductId, typeof(ProductCostHistoryEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ProductCostHistoryEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ProductDocumentEntity>>(\"ProductDocuments\", a => a._productDocuments, (a, b) => a._productDocuments = b, a => a.ProductDocuments, () => new ProductRelations().ProductDocumentEntityUsingProductId, typeof(ProductDocumentEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ProductDocumentEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ProductInventoryEntity>>(\"ProductInventories\", a => a._productInventories, (a, b) => a._productInventories = b, a => a.ProductInventories, () => new ProductRelations().ProductInventoryEntityUsingProductId, typeof(ProductInventoryEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ProductInventoryEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ProductListPriceHistoryEntity>>(\"ProductListPriceHistories\", a => a._productListPriceHistories, (a, b) => a._productListPriceHistories = b, a => a.ProductListPriceHistories, () => new ProductRelations().ProductListPriceHistoryEntityUsingProductId, typeof(ProductListPriceHistoryEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ProductListPriceHistoryEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ProductProductPhotoEntity>>(\"ProductProductPhotos\", a => a._productProductPhotos, (a, b) => a._productProductPhotos = b, a => a.ProductProductPhotos, () => new ProductRelations().ProductProductPhotoEntityUsingProductId, typeof(ProductProductPhotoEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ProductProductPhotoEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ProductReviewEntity>>(\"ProductReviews\", a => a._productReviews, (a, b) => a._productReviews = b, a => a.ProductReviews, () => new ProductRelations().ProductReviewEntityUsingProductId, typeof(ProductReviewEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ProductReviewEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ProductVendorEntity>>(\"ProductVendors\", a => a._productVendors, (a, b) => a._productVendors = b, a => a.ProductVendors, () => new ProductRelations().ProductVendorEntityUsingProductId, typeof(ProductVendorEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ProductVendorEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<PurchaseOrderDetailEntity>>(\"PurchaseOrderDetails\", a => a._purchaseOrderDetails, (a, b) => a._purchaseOrderDetails = b, a => a.PurchaseOrderDetails, () => new ProductRelations().PurchaseOrderDetailEntityUsingProductId, typeof(PurchaseOrderDetailEntity), (int)AdventureWorks.Dal.Adapter.EntityType.PurchaseOrderDetailEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<ShoppingCartItemEntity>>(\"ShoppingCartItems\", a => a._shoppingCartItems, (a, b) => a._shoppingCartItems = b, a => a.ShoppingCartItems, () => new ProductRelations().ShoppingCartItemEntityUsingProductId, typeof(ShoppingCartItemEntity), (int)AdventureWorks.Dal.Adapter.EntityType.ShoppingCartItemEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<SpecialOfferProductEntity>>(\"SpecialOfferProducts\", a => a._specialOfferProducts, (a, b) => a._specialOfferProducts = b, a => a.SpecialOfferProducts, () => new ProductRelations().SpecialOfferProductEntityUsingProductId, typeof(SpecialOfferProductEntity), (int)AdventureWorks.Dal.Adapter.EntityType.SpecialOfferProductEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<TransactionHistoryEntity>>(\"TransactionHistories\", a => a._transactionHistories, (a, b) => a._transactionHistories = b, a => a.TransactionHistories, () => new ProductRelations().TransactionHistoryEntityUsingProductId, typeof(TransactionHistoryEntity), (int)AdventureWorks.Dal.Adapter.EntityType.TransactionHistoryEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, EntityCollection<WorkOrderEntity>>(\"WorkOrders\", a => a._workOrders, (a, b) => a._workOrders = b, a => a.WorkOrders, () => new ProductRelations().WorkOrderEntityUsingProductId, typeof(WorkOrderEntity), (int)AdventureWorks.Dal.Adapter.EntityType.WorkOrderEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, ProductModelEntity>(\"ProductModel\", \"Products\", (a, b) => a._productModel = b, a => a._productModel, (a, b) => a.ProductModel = b, AdventureWorks.Dal.Adapter.RelationClasses.StaticProductRelations.ProductModelEntityUsingProductModelIdStatic, ()=>new ProductRelations().ProductModelEntityUsingProductModelId, null, new int[] { (int)ProductFieldIndex.ProductModelId }, null, true, (int)AdventureWorks.Dal.Adapter.EntityType.ProductModelEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, ProductSubcategoryEntity>(\"ProductSubcategory\", \"Products\", (a, b) => a._productSubcategory = b, a => a._productSubcategory, (a, b) => a.ProductSubcategory = b, AdventureWorks.Dal.Adapter.RelationClasses.StaticProductRelations.ProductSubcategoryEntityUsingProductSubcategoryIdStatic, ()=>new ProductRelations().ProductSubcategoryEntityUsingProductSubcategoryId, null, new int[] { (int)ProductFieldIndex.ProductSubcategoryId }, null, true, (int)AdventureWorks.Dal.Adapter.EntityType.ProductSubcategoryEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, UnitMeasureEntity>(\"UnitMeasure\", \"Products\", (a, b) => a._unitMeasure = b, a => a._unitMeasure, (a, b) => a.UnitMeasure = b, AdventureWorks.Dal.Adapter.RelationClasses.StaticProductRelations.UnitMeasureEntityUsingSizeUnitMeasureCodeStatic, ()=>new ProductRelations().UnitMeasureEntityUsingSizeUnitMeasureCode, null, new int[] { (int)ProductFieldIndex.SizeUnitMeasureCode }, null, true, (int)AdventureWorks.Dal.Adapter.EntityType.UnitMeasureEntity);\n\t\t\t\tAddNavigatorMetaData<ProductEntity, UnitMeasureEntity>(\"UnitMeasure_\", \"Products_\", (a, b) => a._unitMeasure_ = b, a => a._unitMeasure_, (a, b) => a.UnitMeasure_ = b, AdventureWorks.Dal.Adapter.RelationClasses.StaticProductRelations.UnitMeasureEntityUsingWeightUnitMeasureCodeStatic, ()=>new ProductRelations().UnitMeasureEntityUsingWeightUnitMeasureCode, null, new int[] { (int)ProductFieldIndex.WeightUnitMeasureCode }, null, true, (int)AdventureWorks.Dal.Adapter.EntityType.UnitMeasureEntity);\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Static ctor</summary>\n\t\tstatic ProductEntity()\n\t\t{\n\t\t}\n\n\t\t/// <summary> CTor</summary>\n\t\tpublic ProductEntity()\n\t\t{\n\t\t\tInitClassEmpty(null, null);\n\t\t}\n\n\t\t/// <summary> CTor</summary>\n\t\t/// <param name=\"fields\">Fields object to set as the fields for this entity.</param>\n\t\tpublic ProductEntity(IEntityFields2 fields)\n\t\t{\n\t\t\tInitClassEmpty(null, fields);\n\t\t}\n\n\t\t/// <summary> CTor</summary>\n\t\t/// <param name=\"validator\">The custom validator object for this ProductEntity</param>\n\t\tpublic ProductEntity(IValidator validator)\n\t\t{\n\t\t\tInitClassEmpty(validator, null);\n\t\t}\n\n\t\t/// <summary> CTor</summary>\n\t\t/// <param name=\"productId\">PK value for Product which data should be fetched into this Product object</param>\n\t\tpublic ProductEntity(System.Int32 productId) : this(productId, null)\n\t\t{\n\t\t}\n\n\t\t/// <summary> CTor</summary>\n\t\t/// <param name=\"productId\">PK value for Product which data should be fetched into this Product object</param>\n\t\t/// <param name=\"validator\">The custom validator object for this ProductEntity</param>\n\t\tpublic ProductEntity(System.Int32 productId, IValidator validator)\n\t\t{\n\t\t\tInitClassEmpty(validator, null);\n\t\t\tthis.ProductId = productId;\n\t\t}\n\n\t\t/// <summary>Private CTor for deserialization</summary>\n\t\t/// <param name=\"info\"></param>\n\t\t/// <param name=\"context\"></param>\n\t\tprotected ProductEntity(SerializationInfo info, StreamingContext context) : base(info, context)\n\t\t{\n\t\t\t// __LLBLGENPRO_USER_CODE_REGION_START DeserializationConstructor\n\t\t\t// __LLBLGENPRO_USER_CODE_REGION_END\n\t\t}\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'BillOfMaterial' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoBillOfMaterials() { return CreateRelationInfoForNavigator(\"BillOfMaterials\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'BillOfMaterial' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoBillOfMaterials_() { return CreateRelationInfoForNavigator(\"BillOfMaterials_\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ProductCostHistory' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductCostHistories() { return CreateRelationInfoForNavigator(\"ProductCostHistories\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ProductDocument' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductDocuments() { return CreateRelationInfoForNavigator(\"ProductDocuments\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ProductInventory' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductInventories() { return CreateRelationInfoForNavigator(\"ProductInventories\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ProductListPriceHistory' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductListPriceHistories() { return CreateRelationInfoForNavigator(\"ProductListPriceHistories\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ProductProductPhoto' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductProductPhotos() { return CreateRelationInfoForNavigator(\"ProductProductPhotos\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ProductReview' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductReviews() { return CreateRelationInfoForNavigator(\"ProductReviews\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ProductVendor' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductVendors() { return CreateRelationInfoForNavigator(\"ProductVendors\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'PurchaseOrderDetail' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoPurchaseOrderDetails() { return CreateRelationInfoForNavigator(\"PurchaseOrderDetails\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'ShoppingCartItem' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoShoppingCartItems() { return CreateRelationInfoForNavigator(\"ShoppingCartItems\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'SpecialOfferProduct' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoSpecialOfferProducts() { return CreateRelationInfoForNavigator(\"SpecialOfferProducts\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'TransactionHistory' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoTransactionHistories() { return CreateRelationInfoForNavigator(\"TransactionHistories\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entities of type 'WorkOrder' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoWorkOrders() { return CreateRelationInfoForNavigator(\"WorkOrders\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entity of type 'ProductModel' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductModel() { return CreateRelationInfoForNavigator(\"ProductModel\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entity of type 'ProductSubcategory' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoProductSubcategory() { return CreateRelationInfoForNavigator(\"ProductSubcategory\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entity of type 'UnitMeasure' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoUnitMeasure() { return CreateRelationInfoForNavigator(\"UnitMeasure\"); }\n\n\t\t/// <summary>Creates a new IRelationPredicateBucket object which contains the predicate expression and relation collection to fetch the related entity of type 'UnitMeasure' to this entity.</summary>\n\t\t/// <returns></returns>\n\t\tpublic virtual IRelationPredicateBucket GetRelationInfoUnitMeasure_() { return CreateRelationInfoForNavigator(\"UnitMeasure_\"); }\n\t\t\n\t\t/// <inheritdoc/>\n\t\tprotected override EntityStaticMetaDataBase GetEntityStaticMetaData() {\treturn _staticMetaData; }\n\n\t\t/// <summary>Initializes the class members</summary>\n\t\tprivate void InitClassMembers()\n\t\t{\n\t\t\tPerformDependencyInjection();\n\t\t\t// __LLBLGENPRO_USER_CODE_REGION_START InitClassMembers\n\t\t\t// __LLBLGENPRO_USER_CODE_REGION_END\n\t\t\tOnInitClassMembersComplete();\n\t\t}\n\n\t\t/// <summary>Initializes the class with empty data, as if it is a new Entity.</summary>\n\t\t/// <param name=\"validator\">The validator object for this ProductEntity</param>\n\t\t/// <param name=\"fields\">Fields of this entity</param>\n\t\tprivate void InitClassEmpty(IValidator validator, IEntityFields2 fields)\n\t\t{\n\t\t\tOnInitializing();\n\t\t\tthis.Fields = fields ?? CreateFields();\n\t\t\tthis.Validator = validator;\n\t\t\tInitClassMembers();\n\t\t\t// __LLBLGENPRO_USER_CODE_REGION_START InitClassEmpty\n\t\t\t// __LLBLGENPRO_USER_CODE_REGION_END\n\n\t\t\tOnInitialized();\n\t\t}\n\n\t\t/// <summary>The relations object holding all relations of this entity with other entity classes.</summary>\n\t\tpublic static ProductRelations Relations { get { return _relationsFactory; } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'BillOfMaterial' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathBillOfMaterials { get { return _staticMetaData.GetPrefetchPathElement(\"BillOfMaterials\", CommonEntityBase.CreateEntityCollection<BillOfMaterialEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'BillOfMaterial' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathBillOfMaterials_ { get { return _staticMetaData.GetPrefetchPathElement(\"BillOfMaterials_\", CommonEntityBase.CreateEntityCollection<BillOfMaterialEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductCostHistory' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductCostHistories { get { return _staticMetaData.GetPrefetchPathElement(\"ProductCostHistories\", CommonEntityBase.CreateEntityCollection<ProductCostHistoryEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductDocument' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductDocuments { get { return _staticMetaData.GetPrefetchPathElement(\"ProductDocuments\", CommonEntityBase.CreateEntityCollection<ProductDocumentEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductInventory' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductInventories { get { return _staticMetaData.GetPrefetchPathElement(\"ProductInventories\", CommonEntityBase.CreateEntityCollection<ProductInventoryEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductListPriceHistory' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductListPriceHistories { get { return _staticMetaData.GetPrefetchPathElement(\"ProductListPriceHistories\", CommonEntityBase.CreateEntityCollection<ProductListPriceHistoryEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductProductPhoto' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductProductPhotos { get { return _staticMetaData.GetPrefetchPathElement(\"ProductProductPhotos\", CommonEntityBase.CreateEntityCollection<ProductProductPhotoEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductReview' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductReviews { get { return _staticMetaData.GetPrefetchPathElement(\"ProductReviews\", CommonEntityBase.CreateEntityCollection<ProductReviewEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductVendor' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductVendors { get { return _staticMetaData.GetPrefetchPathElement(\"ProductVendors\", CommonEntityBase.CreateEntityCollection<ProductVendorEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'PurchaseOrderDetail' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathPurchaseOrderDetails { get { return _staticMetaData.GetPrefetchPathElement(\"PurchaseOrderDetails\", CommonEntityBase.CreateEntityCollection<PurchaseOrderDetailEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ShoppingCartItem' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathShoppingCartItems { get { return _staticMetaData.GetPrefetchPathElement(\"ShoppingCartItems\", CommonEntityBase.CreateEntityCollection<ShoppingCartItemEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'SpecialOfferProduct' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathSpecialOfferProducts { get { return _staticMetaData.GetPrefetchPathElement(\"SpecialOfferProducts\", CommonEntityBase.CreateEntityCollection<SpecialOfferProductEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'TransactionHistory' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathTransactionHistories { get { return _staticMetaData.GetPrefetchPathElement(\"TransactionHistories\", CommonEntityBase.CreateEntityCollection<TransactionHistoryEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'WorkOrder' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathWorkOrders { get { return _staticMetaData.GetPrefetchPathElement(\"WorkOrders\", CommonEntityBase.CreateEntityCollection<WorkOrderEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductModel' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductModel { get { return _staticMetaData.GetPrefetchPathElement(\"ProductModel\", CommonEntityBase.CreateEntityCollection<ProductModelEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'ProductSubcategory' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathProductSubcategory { get { return _staticMetaData.GetPrefetchPathElement(\"ProductSubcategory\", CommonEntityBase.CreateEntityCollection<ProductSubcategoryEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'UnitMeasure' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathUnitMeasure { get { return _staticMetaData.GetPrefetchPathElement(\"UnitMeasure\", CommonEntityBase.CreateEntityCollection<UnitMeasureEntity>()); } }\n\n\t\t/// <summary>Creates a new PrefetchPathElement2 object which contains all the information to prefetch the related entities of type 'UnitMeasure' for this entity.</summary>\n\t\t/// <returns>Ready to use IPrefetchPathElement2 implementation.</returns>\n\t\tpublic static IPrefetchPathElement2 PrefetchPathUnitMeasure_ { get { return _staticMetaData.GetPrefetchPathElement(\"UnitMeasure_\", CommonEntityBase.CreateEntityCollection<UnitMeasureEntity>()); } }\n\n\t\t/// <summary>The Class property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"Class\".<br/>Table field type characteristics (type, precision, scale, length): NChar, 0, 0, 2.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual System.String Class\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.Class, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.Class, value); }\n\t\t}\n\n\t\t/// <summary>The Color property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"Color\".<br/>Table field type characteristics (type, precision, scale, length): NVarChar, 0, 0, 15.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual System.String Color\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.Color, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.Color, value); }\n\t\t}\n\n\t\t/// <summary>The DaysToManufacture property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"DaysToManufacture\".<br/>Table field type characteristics (type, precision, scale, length): Int, 10, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Int32 DaysToManufacture\n\t\t{\n\t\t\tget { return (System.Int32)GetValue((int)ProductFieldIndex.DaysToManufacture, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.DaysToManufacture, value); }\n\t\t}\n\n\t\t/// <summary>The DiscontinuedDate property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"DiscontinuedDate\".<br/>Table field type characteristics (type, precision, scale, length): DateTime, 0, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual Nullable<System.DateTime> DiscontinuedDate\n\t\t{\n\t\t\tget { return (Nullable<System.DateTime>)GetValue((int)ProductFieldIndex.DiscontinuedDate, false); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.DiscontinuedDate, value); }\n\t\t}\n\n\t\t/// <summary>The FinishedGoodsFlag property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"FinishedGoodsFlag\".<br/>Table field type characteristics (type, precision, scale, length): Bit, 0, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Boolean FinishedGoodsFlag\n\t\t{\n\t\t\tget { return (System.Boolean)GetValue((int)ProductFieldIndex.FinishedGoodsFlag, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.FinishedGoodsFlag, value); }\n\t\t}\n\n\t\t/// <summary>The ListPrice property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ListPrice\".<br/>Table field type characteristics (type, precision, scale, length): Money, 19, 4, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Decimal ListPrice\n\t\t{\n\t\t\tget { return (System.Decimal)GetValue((int)ProductFieldIndex.ListPrice, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.ListPrice, value); }\n\t\t}\n\n\t\t/// <summary>The MakeFlag property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"MakeFlag\".<br/>Table field type characteristics (type, precision, scale, length): Bit, 0, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Boolean MakeFlag\n\t\t{\n\t\t\tget { return (System.Boolean)GetValue((int)ProductFieldIndex.MakeFlag, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.MakeFlag, value); }\n\t\t}\n\n\t\t/// <summary>The ModifiedDate property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ModifiedDate\".<br/>Table field type characteristics (type, precision, scale, length): DateTime, 0, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.DateTime ModifiedDate\n\t\t{\n\t\t\tget { return (System.DateTime)GetValue((int)ProductFieldIndex.ModifiedDate, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.ModifiedDate, value); }\n\t\t}\n\n\t\t/// <summary>The Name property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"Name\".<br/>Table field type characteristics (type, precision, scale, length): NVarChar, 0, 0, 50.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.String Name\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.Name, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.Name, value); }\n\t\t}\n\n\t\t/// <summary>The ProductId property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ProductID\".<br/>Table field type characteristics (type, precision, scale, length): Int, 10, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, true, true</remarks>\n\t\tpublic virtual System.Int32 ProductId\n\t\t{\n\t\t\tget { return (System.Int32)GetValue((int)ProductFieldIndex.ProductId, true); }\n\t\t\tset { SetValue((int)ProductFieldIndex.ProductId, value); }\t\t}\n\n\t\t/// <summary>The ProductLine property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ProductLine\".<br/>Table field type characteristics (type, precision, scale, length): NChar, 0, 0, 2.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual System.String ProductLine\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.ProductLine, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.ProductLine, value); }\n\t\t}\n\n\t\t/// <summary>The ProductModelId property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ProductModelID\".<br/>Table field type characteristics (type, precision, scale, length): Int, 10, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual Nullable<System.Int32> ProductModelId\n\t\t{\n\t\t\tget { return (Nullable<System.Int32>)GetValue((int)ProductFieldIndex.ProductModelId, false); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.ProductModelId, value); }\n\t\t}\n\n\t\t/// <summary>The ProductNumber property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ProductNumber\".<br/>Table field type characteristics (type, precision, scale, length): NVarChar, 0, 0, 25.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.String ProductNumber\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.ProductNumber, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.ProductNumber, value); }\n\t\t}\n\n\t\t/// <summary>The ProductSubcategoryId property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ProductSubcategoryID\".<br/>Table field type characteristics (type, precision, scale, length): Int, 10, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual Nullable<System.Int32> ProductSubcategoryId\n\t\t{\n\t\t\tget { return (Nullable<System.Int32>)GetValue((int)ProductFieldIndex.ProductSubcategoryId, false); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.ProductSubcategoryId, value); }\n\t\t}\n\n\t\t/// <summary>The ReorderPoint property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"ReorderPoint\".<br/>Table field type characteristics (type, precision, scale, length): SmallInt, 5, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Int16 ReorderPoint\n\t\t{\n\t\t\tget { return (System.Int16)GetValue((int)ProductFieldIndex.ReorderPoint, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.ReorderPoint, value); }\n\t\t}\n\n\t\t/// <summary>The Rowguid property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"rowguid\".<br/>Table field type characteristics (type, precision, scale, length): UniqueIdentifier, 0, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Guid Rowguid\n\t\t{\n\t\t\tget { return (System.Guid)GetValue((int)ProductFieldIndex.Rowguid, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.Rowguid, value); }\n\t\t}\n\n\t\t/// <summary>The SafetyStockLevel property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"SafetyStockLevel\".<br/>Table field type characteristics (type, precision, scale, length): SmallInt, 5, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Int16 SafetyStockLevel\n\t\t{\n\t\t\tget { return (System.Int16)GetValue((int)ProductFieldIndex.SafetyStockLevel, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.SafetyStockLevel, value); }\n\t\t}\n\n\t\t/// <summary>The SellEndDate property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"SellEndDate\".<br/>Table field type characteristics (type, precision, scale, length): DateTime, 0, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual Nullable<System.DateTime> SellEndDate\n\t\t{\n\t\t\tget { return (Nullable<System.DateTime>)GetValue((int)ProductFieldIndex.SellEndDate, false); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.SellEndDate, value); }\n\t\t}\n\n\t\t/// <summary>The SellStartDate property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"SellStartDate\".<br/>Table field type characteristics (type, precision, scale, length): DateTime, 0, 0, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.DateTime SellStartDate\n\t\t{\n\t\t\tget { return (System.DateTime)GetValue((int)ProductFieldIndex.SellStartDate, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.SellStartDate, value); }\n\t\t}\n\n\t\t/// <summary>The Size property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"Size\".<br/>Table field type characteristics (type, precision, scale, length): NVarChar, 0, 0, 5.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual System.String Size\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.Size, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.Size, value); }\n\t\t}\n\n\t\t/// <summary>The SizeUnitMeasureCode property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"SizeUnitMeasureCode\".<br/>Table field type characteristics (type, precision, scale, length): NChar, 0, 0, 3.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual System.String SizeUnitMeasureCode\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.SizeUnitMeasureCode, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.SizeUnitMeasureCode, value); }\n\t\t}\n\n\t\t/// <summary>The StandardCost property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"StandardCost\".<br/>Table field type characteristics (type, precision, scale, length): Money, 19, 4, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): false, false, false</remarks>\n\t\tpublic virtual System.Decimal StandardCost\n\t\t{\n\t\t\tget { return (System.Decimal)GetValue((int)ProductFieldIndex.StandardCost, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.StandardCost, value); }\n\t\t}\n\n\t\t/// <summary>The Style property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"Style\".<br/>Table field type characteristics (type, precision, scale, length): NChar, 0, 0, 2.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual System.String Style\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.Style, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.Style, value); }\n\t\t}\n\n\t\t/// <summary>The Weight property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"Weight\".<br/>Table field type characteristics (type, precision, scale, length): Decimal, 8, 2, 0.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual Nullable<System.Decimal> Weight\n\t\t{\n\t\t\tget { return (Nullable<System.Decimal>)GetValue((int)ProductFieldIndex.Weight, false); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.Weight, value); }\n\t\t}\n\n\t\t/// <summary>The WeightUnitMeasureCode property of the Entity Product<br/><br/></summary>\n\t\t/// <remarks>Mapped on  table field: \"Product\".\"WeightUnitMeasureCode\".<br/>Table field type characteristics (type, precision, scale, length): NChar, 0, 0, 3.<br/>Table field behavior characteristics (is nullable, is PK, is identity): true, false, false</remarks>\n\t\tpublic virtual System.String WeightUnitMeasureCode\n\t\t{\n\t\t\tget { return (System.String)GetValue((int)ProductFieldIndex.WeightUnitMeasureCode, true); }\n\t\t\tset\t{ SetValue((int)ProductFieldIndex.WeightUnitMeasureCode, value); }\n\t\t}\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'BillOfMaterialEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(BillOfMaterialEntity))]\n\t\tpublic virtual EntityCollection<BillOfMaterialEntity> BillOfMaterials { get { return GetOrCreateEntityCollection<BillOfMaterialEntity, BillOfMaterialEntityFactory>(\"Product\", true, false, ref _billOfMaterials); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'BillOfMaterialEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(BillOfMaterialEntity))]\n\t\tpublic virtual EntityCollection<BillOfMaterialEntity> BillOfMaterials_ { get { return GetOrCreateEntityCollection<BillOfMaterialEntity, BillOfMaterialEntityFactory>(\"Product_\", true, false, ref _billOfMaterials_); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ProductCostHistoryEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ProductCostHistoryEntity))]\n\t\tpublic virtual EntityCollection<ProductCostHistoryEntity> ProductCostHistories { get { return GetOrCreateEntityCollection<ProductCostHistoryEntity, ProductCostHistoryEntityFactory>(\"Product\", true, false, ref _productCostHistories); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ProductDocumentEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ProductDocumentEntity))]\n\t\tpublic virtual EntityCollection<ProductDocumentEntity> ProductDocuments { get { return GetOrCreateEntityCollection<ProductDocumentEntity, ProductDocumentEntityFactory>(\"Product\", true, false, ref _productDocuments); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ProductInventoryEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ProductInventoryEntity))]\n\t\tpublic virtual EntityCollection<ProductInventoryEntity> ProductInventories { get { return GetOrCreateEntityCollection<ProductInventoryEntity, ProductInventoryEntityFactory>(\"Product\", true, false, ref _productInventories); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ProductListPriceHistoryEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ProductListPriceHistoryEntity))]\n\t\tpublic virtual EntityCollection<ProductListPriceHistoryEntity> ProductListPriceHistories { get { return GetOrCreateEntityCollection<ProductListPriceHistoryEntity, ProductListPriceHistoryEntityFactory>(\"Product\", true, false, ref _productListPriceHistories); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ProductProductPhotoEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ProductProductPhotoEntity))]\n\t\tpublic virtual EntityCollection<ProductProductPhotoEntity> ProductProductPhotos { get { return GetOrCreateEntityCollection<ProductProductPhotoEntity, ProductProductPhotoEntityFactory>(\"Product\", true, false, ref _productProductPhotos); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ProductReviewEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ProductReviewEntity))]\n\t\tpublic virtual EntityCollection<ProductReviewEntity> ProductReviews { get { return GetOrCreateEntityCollection<ProductReviewEntity, ProductReviewEntityFactory>(\"Product\", true, false, ref _productReviews); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ProductVendorEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ProductVendorEntity))]\n\t\tpublic virtual EntityCollection<ProductVendorEntity> ProductVendors { get { return GetOrCreateEntityCollection<ProductVendorEntity, ProductVendorEntityFactory>(\"Product\", true, false, ref _productVendors); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'PurchaseOrderDetailEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(PurchaseOrderDetailEntity))]\n\t\tpublic virtual EntityCollection<PurchaseOrderDetailEntity> PurchaseOrderDetails { get { return GetOrCreateEntityCollection<PurchaseOrderDetailEntity, PurchaseOrderDetailEntityFactory>(\"Product\", true, false, ref _purchaseOrderDetails); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'ShoppingCartItemEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(ShoppingCartItemEntity))]\n\t\tpublic virtual EntityCollection<ShoppingCartItemEntity> ShoppingCartItems { get { return GetOrCreateEntityCollection<ShoppingCartItemEntity, ShoppingCartItemEntityFactory>(\"Product\", true, false, ref _shoppingCartItems); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'SpecialOfferProductEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(SpecialOfferProductEntity))]\n\t\tpublic virtual EntityCollection<SpecialOfferProductEntity> SpecialOfferProducts { get { return GetOrCreateEntityCollection<SpecialOfferProductEntity, SpecialOfferProductEntityFactory>(\"Product\", true, false, ref _specialOfferProducts); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'TransactionHistoryEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(TransactionHistoryEntity))]\n\t\tpublic virtual EntityCollection<TransactionHistoryEntity> TransactionHistories { get { return GetOrCreateEntityCollection<TransactionHistoryEntity, TransactionHistoryEntityFactory>(\"Product\", true, false, ref _transactionHistories); } }\n\n\t\t/// <summary>Gets the EntityCollection with the related entities of type 'WorkOrderEntity' which are related to this entity via a relation of type '1:n'. If the EntityCollection hasn't been fetched yet, the collection returned will be empty.<br/><br/></summary>\n\t\t[TypeContainedAttribute(typeof(WorkOrderEntity))]\n\t\tpublic virtual EntityCollection<WorkOrderEntity> WorkOrders { get { return GetOrCreateEntityCollection<WorkOrderEntity, WorkOrderEntityFactory>(\"Product\", true, false, ref _workOrders); } }\n\n\t\t/// <summary>Gets / sets related entity of type 'ProductModelEntity' which has to be set using a fetch action earlier. If no related entity is set for this property, null is returned..<br/><br/></summary>\n\t\t[Browsable(false)]\n\t\tpublic virtual ProductModelEntity ProductModel\n\t\t{\n\t\t\tget { return _productModel; }\n\t\t\tset { SetSingleRelatedEntityNavigator(value, \"ProductModel\"); }\n\t\t}\n\n\t\t/// <summary>Gets / sets related entity of type 'ProductSubcategoryEntity' which has to be set using a fetch action earlier. If no related entity is set for this property, null is returned..<br/><br/></summary>\n\t\t[Browsable(false)]\n\t\tpublic virtual ProductSubcategoryEntity ProductSubcategory\n\t\t{\n\t\t\tget { return _productSubcategory; }\n\t\t\tset { SetSingleRelatedEntityNavigator(value, \"ProductSubcategory\"); }\n\t\t}\n\n\t\t/// <summary>Gets / sets related entity of type 'UnitMeasureEntity' which has to be set using a fetch action earlier. If no related entity is set for this property, null is returned..<br/><br/></summary>\n\t\t[Browsable(false)]\n\t\tpublic virtual UnitMeasureEntity UnitMeasure\n\t\t{\n\t\t\tget { return _unitMeasure; }\n\t\t\tset { SetSingleRelatedEntityNavigator(value, \"UnitMeasure\"); }\n\t\t}\n\n\t\t/// <summary>Gets / sets related entity of type 'UnitMeasureEntity' which has to be set using a fetch action earlier. If no related entity is set for this property, null is returned..<br/><br/></summary>\n\t\t[Browsable(false)]\n\t\tpublic virtual UnitMeasureEntity UnitMeasure_\n\t\t{\n\t\t\tget { return _unitMeasure_; }\n\t\t\tset { SetSingleRelatedEntityNavigator(value, \"UnitMeasure_\"); }\n\t\t}\n\n\t\t// __LLBLGENPRO_USER_CODE_REGION_START CustomEntityCode\n\t\t// __LLBLGENPRO_USER_CODE_REGION_END\n\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "\n    /// <summary>\n    /// Synthesized expression evaluation method.\n    /// </summary>\n    internal sealed class EEMethodSymbol : MethodSymbol\n    {\n        // We only create a single EE method (per EE type) that represents an arbitrary expression,\n        // whose lowering may produce synthesized members (lambdas, dynamic sites, etc).\n        // We may thus assume that the method ordinal is always 0.\n        //\n        // Consider making the implementation more flexible in order to avoid this assumption.\n        // In future we might need to compile multiple expression and then we'll need to assign \n        // a unique method ordinal to each of them to avoid duplicate synthesized member names.\n        private const int _methodOrdinal = 0;\n\n        internal readonly TypeMap TypeMap;\n        internal readonly MethodSymbol SubstitutedSourceMethod;\n        internal readonly ImmutableArray<LocalSymbol> Locals;\n        internal readonly ImmutableArray<LocalSymbol> LocalsForBinding;\n\n        private readonly EENamedTypeSymbol _container;\n        private readonly string _name;\n        private readonly ImmutableArray<Location> _locations;\n        private readonly ImmutableArray<TypeParameterSymbol> _typeParameters;\n        private readonly ImmutableArray<ParameterSymbol> _parameters;\n        private readonly ParameterSymbol _thisParameter;\n        private readonly ImmutableDictionary<string, DisplayClassVariable> _displayClassVariables;\n\n        /// <summary>\n        /// Invoked at most once to generate the method body.\n        /// (If the compilation has no errors, it will be invoked\n        /// exactly once, otherwise it may be skipped.)\n        /// </summary>\n        private readonly GenerateMethodBody _generateMethodBody;\n        private TypeSymbol _lazyReturnType;\n\n        // NOTE: This is only used for asserts, so it could be conditional on DEBUG.\n        private readonly ImmutableArray<TypeParameterSymbol> _allTypeParameters;\n\n        internal EEMethodSymbol(\n            EENamedTypeSymbol container,\n            string name,\n            Location location,\n            MethodSymbol sourceMethod,\n            ImmutableArray<LocalSymbol> sourceLocals,\n            ImmutableArray<LocalSymbol> sourceLocalsForBinding,\n            ImmutableDictionary<string, DisplayClassVariable> sourceDisplayClassVariables,\n            GenerateMethodBody generateMethodBody)\n        {\n            Debug.Assert(sourceMethod.IsDefinition);\n            Debug.Assert(sourceMethod.ContainingSymbol == container.SubstitutedSourceType.OriginalDefinition);\n            Debug.Assert(sourceLocals.All(l => l.ContainingSymbol == sourceMethod));\n\n            _container = container;\n            _name = name;\n            _locations = ImmutableArray.Create(location);\n\n            // What we want is to map all original type parameters to the corresponding new type parameters\n            // (since the old ones have the wrong owners).  Unfortunately, we have a circular dependency:\n            //   1) Each new type parameter requires the entire map in order to be able to construct its constraint list.\n            //   2) The map cannot be constructed until all new type parameters exist.\n            // Our solution is to pass each new type parameter a lazy reference to the type map.  We then \n            // initialize the map as soon as the new type parameters are available - and before they are \n            // handed out - so that there is never a period where they can require the type map and find\n            // it uninitialized.\n\n            var sourceMethodTypeParameters = sourceMethod.TypeParameters;\n            var allSourceTypeParameters = container.SourceTypeParameters.Concat(sourceMethodTypeParameters);\n\n            var getTypeMap = new Func<TypeMap>(() => this.TypeMap);\n            _typeParameters = sourceMethodTypeParameters.SelectAsArray(\n                (tp, i, arg) => (TypeParameterSymbol)new EETypeParameterSymbol(this, tp, i, getTypeMap),\n                (object)null);\n            _allTypeParameters = container.TypeParameters.Concat(_typeParameters);\n            this.TypeMap = new TypeMap(allSourceTypeParameters, _allTypeParameters);\n\n            EENamedTypeSymbol.VerifyTypeParameters(this, _typeParameters);\n\n            var substitutedSourceType = container.SubstitutedSourceType;\n            this.SubstitutedSourceMethod = sourceMethod.AsMember(substitutedSourceType);\n            if (sourceMethod.Arity > 0)\n            {\n                this.SubstitutedSourceMethod = this.SubstitutedSourceMethod.Construct(_typeParameters.As<TypeSymbol>());\n            }\n            TypeParameterChecker.Check(this.SubstitutedSourceMethod, _allTypeParameters);\n\n            // Create a map from original parameter to target parameter.\n            var parameterBuilder = ArrayBuilder<ParameterSymbol>.GetInstance();\n\n            var substitutedSourceThisParameter = this.SubstitutedSourceMethod.ThisParameter;\n            var substitutedSourceHasThisParameter = (object)substitutedSourceThisParameter != null;\n            if (substitutedSourceHasThisParameter)\n            {\n                _thisParameter = MakeParameterSymbol(0, GeneratedNames.ThisProxyFieldName(), substitutedSourceThisParameter);\n                Debug.Assert(_thisParameter.Type == this.SubstitutedSourceMethod.ContainingType);\n                parameterBuilder.Add(_thisParameter);\n            }\n\n            var ordinalOffset = (substitutedSourceHasThisParameter ? 1 : 0);\n            foreach (var substitutedSourceParameter in this.SubstitutedSourceMethod.Parameters)\n            {\n                var ordinal = substitutedSourceParameter.Ordinal + ordinalOffset;\n                Debug.Assert(ordinal == parameterBuilder.Count);\n                var parameter = MakeParameterSymbol(ordinal, substitutedSourceParameter.Name, substitutedSourceParameter);\n                parameterBuilder.Add(parameter);\n            }\n\n            _parameters = parameterBuilder.ToImmutableAndFree();\n\n            var localsBuilder = ArrayBuilder<LocalSymbol>.GetInstance();\n            var localsMap = PooledDictionary<LocalSymbol, LocalSymbol>.GetInstance();\n            foreach (var sourceLocal in sourceLocals)\n            {\n                var local = sourceLocal.ToOtherMethod(this, this.TypeMap);\n                localsMap.Add(sourceLocal, local);\n                localsBuilder.Add(local);\n            }\n            this.Locals = localsBuilder.ToImmutableAndFree();\n            localsBuilder = ArrayBuilder<LocalSymbol>.GetInstance();\n            foreach (var sourceLocal in sourceLocalsForBinding)\n            {\n                LocalSymbol local;\n                if (!localsMap.TryGetValue(sourceLocal, out local))\n                {\n                    local = sourceLocal.ToOtherMethod(this, this.TypeMap);\n                    localsMap.Add(sourceLocal, local);\n                }\n                localsBuilder.Add(local);\n            }\n            this.LocalsForBinding = localsBuilder.ToImmutableAndFree();\n\n            // Create a map from variable name to display class field.\n            var displayClassVariables = PooledDictionary<string, DisplayClassVariable>.GetInstance();\n            foreach (var pair in sourceDisplayClassVariables)\n            {\n                var variable = pair.Value;\n                var displayClassInstanceFromLocal = variable.DisplayClassInstance as DisplayClassInstanceFromLocal;\n                var displayClassInstance = (displayClassInstanceFromLocal == null) ?\n                    (DisplayClassInstance)new DisplayClassInstanceFromThis(_parameters[0]) :\n                    new DisplayClassInstanceFromLocal((EELocalSymbol)localsMap[displayClassInstanceFromLocal.Local]);\n                variable = variable.SubstituteFields(displayClassInstance, this.TypeMap);\n                displayClassVariables.Add(pair.Key, variable);\n            }\n\n            _displayClassVariables = displayClassVariables.ToImmutableDictionary();\n            displayClassVariables.Free();\n            localsMap.Free();\n\n            _generateMethodBody = generateMethodBody;\n        }\n\n        private ParameterSymbol MakeParameterSymbol(int ordinal, string name, ParameterSymbol sourceParameter)\n        {\n            return new SynthesizedParameterSymbol(this, sourceParameter.Type, ordinal, sourceParameter.RefKind, name, sourceParameter.CustomModifiers);\n        }\n\n        internal override bool IsMetadataNewSlot(bool ignoreInterfaceImplementationChanges = false)\n        {\n            return false;\n        }\n\n        internal override bool IsMetadataVirtual(bool ignoreInterfaceImplementationChanges = false)\n        {\n            return false;\n        }\n\n        internal override bool IsMetadataFinal\n        {\n            get { return false; }\n        }\n\n        public override MethodKind MethodKind\n        {\n            get { return MethodKind.Ordinary; }\n        }\n\n        public override string Name\n        {\n            get { return _name; }\n        }\n\n        public override int Arity\n        {\n            get { return _typeParameters.Length; }\n        }\n\n        public override bool IsExtensionMethod\n        {\n            get { return false; }\n        }\n\n        internal override bool HasSpecialName\n        {\n            get { return true; }\n        }\n\n        internal override System.Reflection.MethodImplAttributes ImplementationAttributes\n        {\n            get { return default(System.Reflection.MethodImplAttributes); }\n        }\n\n        internal override bool HasDeclarativeSecurity\n        {\n            get { return false; }\n        }\n\n        public override DllImportData GetDllImportData()\n        {\n            return null;\n        }\n\n        internal override IEnumerable<Cci.SecurityAttribute> GetSecurityInformation()\n        {\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        internal override MarshalPseudoCustomAttributeData ReturnValueMarshallingInformation\n        {\n            get { return null; }\n        }\n\n        internal override bool RequiresSecurityObject\n        {\n            get { return false; }\n        }\n\n        internal override bool TryGetThisParameter(out ParameterSymbol thisParameter)\n        {\n            thisParameter = null;\n            return true;\n        }\n\n        public override bool HidesBaseMethodsByName\n        {\n            get { return false; }\n        }\n\n        public override bool IsVararg\n        {\n            get { return this.SubstitutedSourceMethod.IsVararg; }\n        }\n\n        public override bool ReturnsVoid\n        {\n            get { return this.ReturnType.SpecialType == SpecialType.System_Void; }\n        }\n\n        public override bool IsAsync\n        {\n            get { return false; }\n        }\n\n        public override TypeSymbol ReturnType\n        {\n            get\n            {\n                if (_lazyReturnType == null)\n                {\n                    throw new InvalidOperationException();\n                }\n                return _lazyReturnType;\n            }\n        }\n\n        public override ImmutableArray<TypeSymbol> TypeArguments\n        {\n            get { return _typeParameters.Cast<TypeParameterSymbol, TypeSymbol>(); }\n        }\n\n        public override ImmutableArray<TypeParameterSymbol> TypeParameters\n        {\n            get { return _typeParameters; }\n        }\n\n        public override ImmutableArray<ParameterSymbol> Parameters\n        {\n            get { return _parameters; }\n        }\n\n        public override ImmutableArray<MethodSymbol> ExplicitInterfaceImplementations\n        {\n            get { return ImmutableArray<MethodSymbol>.Empty; }\n        }\n\n        public override ImmutableArray<CustomModifier> ReturnTypeCustomModifiers\n        {\n            get { return ImmutableArray<CustomModifier>.Empty; }\n        }\n\n        public override Symbol AssociatedSymbol\n        {\n            get { return null; }\n        }\n\n        internal override ImmutableArray<string> GetAppliedConditionalSymbols()\n        {\n            throw ExceptionUtilities.Unreachable;\n        }\n\n        internal override Cci.CallingConvention CallingConvention\n        {\n            get\n            {\n                Debug.Assert(this.IsStatic);\n                var cc = Cci.CallingConvention.Default;\n                if (this.IsVararg)\n                {\n                    cc |= Cci.CallingConvention.ExtraArguments;\n                }\n                if (this.IsGenericMethod)\n                {\n                    cc |= Cci.CallingConvention.Generic;\n                }\n                return cc;\n            }\n        }\n\n        internal override bool GenerateDebugInfo\n        {\n            get { return false; }\n        }\n\n        public override Symbol ContainingSymbol\n        {\n            get { return _container; }\n        }\n\n        public override ImmutableArray<Location> Locations\n        {\n            get { return _locations; }\n        }\n\n        public override ImmutableArray<SyntaxReference> DeclaringSyntaxReferences\n        {\n            get { throw ExceptionUtilities.Unreachable; }\n        }\n\n        public override Accessibility DeclaredAccessibility\n        {\n            get { return Accessibility.Internal; }\n        }\n\n        public override bool IsStatic\n        {\n            get { return true; }\n        }\n\n        public override bool IsVirtual\n        {\n            get { return false; }\n        }\n\n        public override bool IsOverride\n        {\n            get { return false; }\n        }\n\n        public override bool IsAbstract\n        {\n            get { return false; }\n        }\n\n        public override bool IsSealed\n        {\n            get { return false; }\n        }\n\n        public override bool IsExtern\n        {\n            get { return false; }\n        }\n\n        internal override ObsoleteAttributeData ObsoleteAttributeData\n        {\n            get { throw ExceptionUtilities.Unreachable; }\n        }\n\n        internal override void GenerateMethodBody(TypeCompilationState compilationState, DiagnosticBag diagnostics)\n        {\n            var body = _generateMethodBody(this, diagnostics);\n            var compilation = compilationState.Compilation;\n\n            _lazyReturnType = CalculateReturnType(compilation, body);\n\n            // Can't do this until the return type has been computed.\n            TypeParameterChecker.Check(this, _allTypeParameters);\n\n            if (diagnostics.HasAnyErrors())\n            {\n                return;\n            }\n\n            DiagnosticsPass.IssueDiagnostics(compilation, body, diagnostics, this);\n            if (diagnostics.HasAnyErrors())\n            {\n                return;\n            }\n\n            // Check for use-site diagnostics (e.g. missing types in the signature).\n            DiagnosticInfo useSiteDiagnosticInfo = null;\n            this.CalculateUseSiteDiagnostic(ref useSiteDiagnosticInfo);\n            if (useSiteDiagnosticInfo != null && useSiteDiagnosticInfo.Severity == DiagnosticSeverity.Error)\n            {\n                diagnostics.Add(useSiteDiagnosticInfo, this.Locations[0]);\n                return;\n            }\n\n            var declaredLocals = PooledHashSet<LocalSymbol>.GetInstance();\n            try\n            {\n                // Rewrite local declaration statement.\n                body = (BoundStatement)LocalDeclarationRewriter.Rewrite(compilation, _container, declaredLocals, body);\n\n                // Verify local declaration names.\n                foreach (var local in declaredLocals)\n                {\n                    Debug.Assert(local.Locations.Length > 0);\n                    var name = local.Name;\n                    if (name.StartsWith(\"$\", StringComparison.Ordinal))\n                    {\n                        diagnostics.Add(ErrorCode.ERR_UnexpectedCharacter, local.Locations[0], name[0]);\n                        return;\n                    }\n                }\n\n                // Rewrite references to placeholder \"locals\".\n                body = (BoundStatement)PlaceholderLocalRewriter.Rewrite(compilation, _container, declaredLocals, body);\n            }\n            finally\n            {\n                declaredLocals.Free();\n            }\n\n            var syntax = body.Syntax;\n            var statementsBuilder = ArrayBuilder<BoundStatement>.GetInstance();\n            statementsBuilder.Add(body);\n            // Insert an implicit return statement if necessary.\n            if (body.Kind != BoundKind.ReturnStatement)\n            {\n                statementsBuilder.Add(new BoundReturnStatement(syntax, expressionOpt: null));\n            }\n\n            var localsBuilder = ArrayBuilder<LocalSymbol>.GetInstance();\n            var localsSet = PooledHashSet<LocalSymbol>.GetInstance();\n            foreach (var local in this.LocalsForBinding)\n            {\n                Debug.Assert(!localsSet.Contains(local));\n                localsBuilder.Add(local);\n                localsSet.Add(local);\n            }\n            foreach (var local in this.Locals)\n            {\n                if (!localsSet.Contains(local))\n                {\n                    localsBuilder.Add(local);\n                }\n            }\n            localsSet.Free();\n\n            body = new BoundBlock(syntax, localsBuilder.ToImmutableAndFree(), statementsBuilder.ToImmutableAndFree()) { WasCompilerGenerated = true };\n\n            Debug.Assert(!diagnostics.HasAnyErrors());\n            Debug.Assert(!body.HasErrors);\n\n            bool sawLambdas;\n            bool sawAwaitInExceptionHandler;\n            body = LocalRewriter.Rewrite(\n                compilation: this.DeclaringCompilation,\n                method: this,\n                methodOrdinal: _methodOrdinal,\n                containingType: _container,\n                statement: body,\n                compilationState: compilationState,\n                previousSubmissionFields: null,\n                allowOmissionOfConditionalCalls: false,\n                diagnostics: diagnostics,\n                sawLambdas: out sawLambdas,\n                sawAwaitInExceptionHandler: out sawAwaitInExceptionHandler);\n\n            Debug.Assert(!sawAwaitInExceptionHandler);\n\n            if (body.HasErrors)\n            {\n                return;\n            }\n\n            // Variables may have been captured by lambdas in the original method\n            // or in the expression, and we need to preserve the existing values of\n            // those variables in the expression. This requires rewriting the variables\n            // in the expression based on the closure classes from both the original\n            // method and the expression, and generating a preamble that copies\n            // values into the expression closure classes.\n            //\n            // Consider the original method:\n            // static void M()\n            // {\n            //     int x, y, z;\n            //     ...\n            //     F(() => x + y);\n            // }\n            // and the expression in the EE: \"F(() => x + z)\".\n            //\n            // The expression is first rewritten using the closure class and local <1>\n            // from the original method: F(() => <1>.x + z)\n            // Then lambda rewriting introduces a new closure class that includes\n            // the locals <1> and z, and a corresponding local <2>: F(() => <2>.<1>.x + <2>.z)\n            // And a preamble is added to initialize the fields of <2>:\n            //     <2> = new <>c__DisplayClass0();\n            //     <2>.<1> = <1>;\n            //     <2>.z = z;\n\n            // Rewrite \"this\" and \"base\" references to parameter in this method.\n            // Rewrite variables within body to reference existing display classes.\n            body = (BoundStatement)CapturedVariableRewriter.Rewrite(\n                this.SubstitutedSourceMethod.IsStatic ? null : _parameters[0],\n                compilation.Conversions,\n                _displayClassVariables,\n                body,\n                diagnostics);\n\n            if (body.HasErrors)\n            {\n                Debug.Assert(false, \"Please add a test case capturing whatever caused this assert.\");\n                return;\n            }\n\n            if (diagnostics.HasAnyErrors())\n            {\n                return;\n            }\n\n            if (sawLambdas)\n            {\n                var closureDebugInfoBuilder = ArrayBuilder<ClosureDebugInfo>.GetInstance();\n                var lambdaDebugInfoBuilder = ArrayBuilder<LambdaDebugInfo>.GetInstance();\n\n                body = LambdaRewriter.Rewrite(\n                    loweredBody: body,\n                    thisType: this.SubstitutedSourceMethod.ContainingType,\n                    thisParameter: _thisParameter,\n                    method: this,\n                    methodOrdinal: _methodOrdinal,\n                    closureDebugInfoBuilder: closureDebugInfoBuilder,\n                    lambdaDebugInfoBuilder: lambdaDebugInfoBuilder,\n                    slotAllocatorOpt: null,\n                    compilationState: compilationState,\n                    diagnostics: diagnostics,\n                    assignLocals: true);\n\n                // we don't need this information:\n                closureDebugInfoBuilder.Free();\n                lambdaDebugInfoBuilder.Free();\n            }\n\n            // Insert locals from the original method,\n            // followed by any new locals.\n            var block = (BoundBlock)body;\n            var localBuilder = ArrayBuilder<LocalSymbol>.GetInstance();\n            foreach (var local in this.Locals)\n            {\n                Debug.Assert(!(local is EELocalSymbol) || (((EELocalSymbol)local).Ordinal == localBuilder.Count));\n                localBuilder.Add(local);\n            }\n            foreach (var local in block.Locals)\n            {\n                var oldLocal = local as EELocalSymbol;\n                if (oldLocal != null)\n                {\n                    Debug.Assert(localBuilder[oldLocal.Ordinal] == oldLocal);\n                    continue;\n                }\n                localBuilder.Add(local);\n            }\n\n            body = block.Update(localBuilder.ToImmutableAndFree(), block.Statements);\n            TypeParameterChecker.Check(body, _allTypeParameters);\n            compilationState.AddSynthesizedMethod(this, body);\n        }\n\n        private static TypeSymbol CalculateReturnType(CSharpCompilation compilation, BoundStatement bodyOpt)\n        {\n            if (bodyOpt == null)\n            {\n                // If the method doesn't do anything, then it doesn't return anything.\n                return compilation.GetSpecialType(SpecialType.System_Void);\n            }\n\n            switch (bodyOpt.Kind)\n            {\n                case BoundKind.ReturnStatement:\n                    return ((BoundReturnStatement)bodyOpt).ExpressionOpt.Type;\n                case BoundKind.ExpressionStatement:\n                case BoundKind.LocalDeclaration:\n                case BoundKind.MultipleLocalDeclarations:\n                    return compilation.GetSpecialType(SpecialType.System_Void);\n                default:\n                    throw ExceptionUtilities.UnexpectedValue(bodyOpt.Kind);\n            }\n        }\n\n        internal override void AddSynthesizedReturnTypeAttributes(ref ArrayBuilder<SynthesizedAttributeData> attributes)\n        {\n            base.AddSynthesizedReturnTypeAttributes(ref attributes);\n\n            if (this.ReturnType.ContainsDynamic())\n            {\n                var compilation = this.DeclaringCompilation;\n                if ((object)compilation.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_DynamicAttribute__ctor) != null)\n                {\n                    AddSynthesizedAttribute(ref attributes, compilation.SynthesizeDynamicAttribute(this.ReturnType, this.ReturnTypeCustomModifiers.Length));\n                }\n            }\n        }\n\n        internal override int CalculateLocalSyntaxOffset(int localPosition, SyntaxTree localTree)\n        {\n            return localPosition;\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    internal static partial class LZMA\n    {\n        /* #define SHOW_STAT */\n        /* #define SHOW_STAT2 */\n        /* #define SHOW_DEBUG_INFO */\n        /* #define PROTOTYPE */\n\n        [System.Diagnostics.Conditional(\"SHOW_DEBUG_INFO\")]\n        internal static void DebugPrint(string format, params object[] args)\n        {\n#if BUILD_TESTING\n            System.Diagnostics.Debug.Write(String.Format(format, args));\n#endif\n        }\n\n        internal static void Print(string format, params object[] args)\n        {\n#if BUILD_TESTING\n            System.Diagnostics.Debug.Write(String.Format(format, args));\n#endif\n        }\n    }\n    partial class LZMA\n    {\n        internal class CMatchFinder\n        {\n            #region Constants\n\n            internal const int kEmptyHashValue = 0;\n            internal const uint kMaxValForNormalize = 0xFFFFFFFF;\n            internal const uint kNormalizeStepMin = 1u << 10; // it must be power of 2\n            internal const uint kNormalizeMask = ~(kNormalizeStepMin - 1u);\n            internal const uint kMaxHistorySize = (3u << 30);\n\n            internal const int kStartMaxLen = 3;\n\n            #endregion\n\n            #region Variables\n\n            public P<byte> mBuffer;\n            public uint mPos;\n            public uint mPosLimit;\n            public uint mStreamPos;\n            public uint mLenLimit;\n\n            public uint mCyclicBufferPos;\n            public uint mCyclicBufferSize; // it must be = (historySize + 1)\n\n            public uint mMatchMaxLen;\n            public uint[] mHash;\n            public P<uint> mSon;\n            public uint mHashMask;\n            public uint mCutValue;\n\n            public P<byte> mBufferBase;\n            public ISeqInStream mStream;\n            public bool mStreamEndWasReached;\n\n            public uint mBlockSize;\n            public uint mKeepSizeBefore;\n            public uint mKeepSizeAfter;\n\n            public uint mNumHashBytes;\n            public bool mDirectInput;\n            public long mDirectInputRem;\n            public bool mBtMode;\n            public bool mBigHash;\n            public uint mHistorySize;\n            public uint mFixedHashSize;\n            public uint mHashSizeSum;\n            public uint mNumSons;\n            public SRes mResult;\n\n            #endregion\n\n            internal CMatchFinder()\n            {\n                TR(\"MatchFinder_Construct\", 0);\n\n                mBufferBase = null;\n                mDirectInput = false;\n                mHash = null;\n                mCutValue = 32;\n                mBtMode = true;\n                mNumHashBytes = 4;\n                mBigHash = false;\n            }\n\n            internal bool MatchFinder_NeedMove()\n            {\n                if (mDirectInput)\n                    return false;\n\n                // if (p.streamEndWasReached) return false;\n                return mBufferBase + mBlockSize - mBuffer <= mKeepSizeAfter;\n            }\n\n            internal P<byte> MatchFinder_GetPointerToCurrentPos()\n            {\n                return mBuffer;\n            }\n\n            internal void MatchFinder_MoveBlock()\n            {\n                // Note: source and destination memory regions may overlap!\n                CUtils.memmove(mBufferBase, mBuffer - mKeepSizeBefore, mStreamPos - mPos + mKeepSizeBefore);\n                mBuffer = mBufferBase + mKeepSizeBefore;\n            }\n\n            internal void MatchFinder_ReadIfRequired()\n            {\n                if (!mStreamEndWasReached && mKeepSizeAfter >= mStreamPos - mPos)\n                    MatchFinder_ReadBlock();\n            }\n\n            private void LzInWindow_Free(ISzAlloc alloc)\n            {\n                if (!mDirectInput)\n                {\n                    alloc.FreeBytes(alloc, mBufferBase.mBuffer);\n                    mBufferBase = null;\n                }\n            }\n\n            // keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G)\n            private bool LzInWindow_Create(uint keepSizeReserv, ISzAlloc alloc)\n            {\n                uint blockSize = mKeepSizeBefore + mKeepSizeAfter + keepSizeReserv;\n\n                if (mDirectInput)\n                {\n                    mBlockSize = blockSize;\n                    return true;\n                }\n\n                if (mBufferBase == null || mBlockSize != blockSize)\n                {\n                    LzInWindow_Free(alloc);\n                    mBlockSize = blockSize;\n                    mBufferBase = alloc.AllocBytes(alloc, (long)blockSize);\n                }\n\n                return mBufferBase != null;\n            }\n\n            internal byte MatchFinder_GetIndexByte(int index)\n            {\n                return mBuffer[index];\n            }\n\n            internal uint MatchFinder_GetNumAvailableBytes()\n            {\n                return mStreamPos - mPos;\n            }\n\n            internal void MatchFinder_ReduceOffsets(uint subValue)\n            {\n                mPosLimit -= subValue;\n                mPos -= subValue;\n                mStreamPos -= subValue;\n            }\n\n            private void MatchFinder_ReadBlock()\n            {\n                if (mStreamEndWasReached || mResult != SZ_OK)\n                    return;\n\n                if (mDirectInput)\n                {\n                    uint curSize = 0xFFFFFFFF - mStreamPos;\n                    if (curSize > mDirectInputRem)\n                        curSize = (uint)mDirectInputRem;\n\n                    mDirectInputRem -= curSize;\n                    mStreamPos += curSize;\n                    if (mDirectInputRem == 0)\n                        mStreamEndWasReached = true;\n\n                    return;\n                }\n\n                for (;;)\n                {\n                    P<byte> dest = mBuffer + (mStreamPos - mPos);\n                    long size = mBufferBase + mBlockSize - dest;\n                    if (size == 0)\n                        return;\n\n                    mResult = mStream.Read(dest, ref size);\n                    if (mResult != SZ_OK)\n                        return;\n\n                    if (size == 0)\n                    {\n                        mStreamEndWasReached = true;\n                        return;\n                    }\n\n                    mStreamPos += (uint)size;\n                    if (mStreamPos - mPos > mKeepSizeAfter)\n                        return;\n                }\n            }\n\n            private void MatchFinder_CheckAndMoveAndRead()\n            {\n                if (MatchFinder_NeedMove())\n                    MatchFinder_MoveBlock();\n\n                MatchFinder_ReadBlock();\n            }\n\n            private void MatchFinder_FreeThisClassMemory(ISzAlloc alloc)\n            {\n                alloc.FreeUInt32(alloc, mHash);\n                mHash = null;\n            }\n\n            internal void MatchFinder_Free(ISzAlloc alloc)\n            {\n                MatchFinder_FreeThisClassMemory(alloc);\n                LzInWindow_Free(alloc);\n            }\n\n            private static uint[] AllocRefs(uint num, ISzAlloc alloc)\n            {\n                long sizeInBytes = (long)num * sizeof(uint);\n                if (sizeInBytes / sizeof(uint) != num)\n                    return null;\n\n                return alloc.AllocUInt32(alloc, num);\n            }\n\n            // Conditions:\n            //     historySize <= 3 GB\n            //     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB\n            internal bool MatchFinder_Create(uint historySize, uint keepAddBufferBefore, uint matchMaxLen, uint keepAddBufferAfter, ISzAlloc alloc)\n            {\n                if (historySize > kMaxHistorySize)\n                {\n                    MatchFinder_Free(alloc);\n                    return false;\n                }\n\n                uint sizeReserv = historySize >> 1;\n                if (historySize > ((uint)2 << 30))\n                    sizeReserv = historySize >> 2;\n                sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);\n\n                mKeepSizeBefore = historySize + keepAddBufferBefore + 1;\n                mKeepSizeAfter = matchMaxLen + keepAddBufferAfter;\n\n                // we need one additional byte, since we use MoveBlock after pos++ and before dictionary using\n                if (LzInWindow_Create(sizeReserv, alloc))\n                {\n                    uint newCyclicBufferSize = historySize + 1;\n                    uint hs;\n\n                    mMatchMaxLen = matchMaxLen;\n\n                    {\n                        mFixedHashSize = 0;\n\n                        if (mNumHashBytes == 2)\n                        {\n                            hs = (1 << 16) - 1;\n                        }\n                        else\n                        {\n                            hs = historySize - 1;\n                            hs |= (hs >> 1);\n                            hs |= (hs >> 2);\n                            hs |= (hs >> 4);\n                            hs |= (hs >> 8);\n                            hs >>= 1;\n                            hs |= 0xFFFF; // don't change it! It's required for Deflate\n                            if (hs > (1 << 24))\n                            {\n                                if (mNumHashBytes == 3)\n                                    hs = (1 << 24) - 1;\n                                else\n                                    hs >>= 1;\n                            }\n                        }\n\n                        mHashMask = hs;\n                        hs++;\n\n                        if (mNumHashBytes > 2)\n                            mFixedHashSize += kHash2Size;\n                        if (mNumHashBytes > 3)\n                            mFixedHashSize += kHash3Size;\n                        if (mNumHashBytes > 4)\n                            mFixedHashSize += kHash4Size;\n\n                        hs += mFixedHashSize;\n                    }\n\n                    {\n                        uint prevSize = mHashSizeSum + mNumSons;\n\n                        mHistorySize = historySize;\n                        mHashSizeSum = hs;\n                        mCyclicBufferSize = newCyclicBufferSize;\n                        mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);\n\n                        uint newSize = mHashSizeSum + mNumSons;\n                        if (mHash != null && prevSize == newSize)\n                            return true;\n\n                        MatchFinder_FreeThisClassMemory(alloc);\n\n                        mHash = AllocRefs(newSize, alloc);\n                        if (mHash != null)\n                        {\n                            mSon = P.From(mHash, mHashSizeSum);\n                            return true;\n                        }\n                    }\n                }\n\n                MatchFinder_Free(alloc);\n                return false;\n            }\n\n            private void MatchFinder_SetLimits()\n            {\n                uint limit = kMaxValForNormalize - mPos;\n                uint limit2 = mCyclicBufferSize - mCyclicBufferPos;\n                if (limit2 < limit)\n                    limit = limit2;\n                limit2 = mStreamPos - mPos;\n                if (limit2 <= mKeepSizeAfter)\n                {\n                    if (limit2 > 0)\n                        limit2 = 1;\n                }\n                else\n                {\n                    limit2 -= mKeepSizeAfter;\n                }\n                if (limit2 < limit)\n                    limit = limit2;\n                uint lenLimit = mStreamPos - mPos;\n                if (lenLimit > mMatchMaxLen)\n                    lenLimit = mMatchMaxLen;\n                mLenLimit = lenLimit;\n                mPosLimit = mPos + limit;\n            }\n\n            internal void MatchFinder_Init()\n            {\n                //for(uint i = 0; i < mHashSizeSum; i++)\n                //    mHash[i] = kEmptyHashValue;\n                Array.Clear(mHash, 0, (int)mHashSizeSum);\n\n                mCyclicBufferPos = 0;\n                mBuffer = mBufferBase;\n                mPos = mCyclicBufferSize;\n                mStreamPos = mCyclicBufferSize;\n                mResult = SZ_OK;\n                mStreamEndWasReached = false;\n                MatchFinder_ReadBlock();\n                MatchFinder_SetLimits();\n            }\n\n            private uint MatchFinder_GetSubValue()\n            {\n                return (mPos - mHistorySize - 1) & kNormalizeMask;\n            }\n\n            internal static void MatchFinder_Normalize3(uint subValue, P<uint> items, uint numItems)\n            {\n                for (uint i = 0; i < numItems; i++)\n                {\n                    uint value = items[i];\n                    if (value <= subValue)\n                        value = kEmptyHashValue;\n                    else\n                        value -= subValue;\n                    items[i] = value;\n                }\n            }\n\n            private void MatchFinder_Normalize()\n            {\n                uint subValue = MatchFinder_GetSubValue();\n                MatchFinder_Normalize3(subValue, mHash, mHashSizeSum + mNumSons);\n                MatchFinder_ReduceOffsets(subValue);\n            }\n\n            private void MatchFinder_CheckLimits()\n            {\n                if (mPos == kMaxValForNormalize)\n                    MatchFinder_Normalize();\n\n                if (!mStreamEndWasReached && mKeepSizeAfter == mStreamPos - mPos)\n                    MatchFinder_CheckAndMoveAndRead();\n\n                if (mCyclicBufferPos == mCyclicBufferSize)\n                    mCyclicBufferPos = 0;\n\n                MatchFinder_SetLimits();\n            }\n\n            private static P<uint> Hc_GetMatchesSpec(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue, P<uint> distances, uint maxLen)\n            {\n                son[_cyclicBufferPos] = curMatch;\n\n                for (;;)\n                {\n                    uint delta = pos - curMatch;\n                    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n                        return distances;\n\n                    P<byte> pb = cur - delta;\n                    curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];\n                    if (pb[maxLen] == cur[maxLen] && pb[0] == cur[0])\n                    {\n                        uint len = 0;\n                        while (++len != lenLimit)\n                            if (pb[len] != cur[len])\n                                break;\n\n                        if (maxLen < len)\n                        {\n                            distances[0] = maxLen = len;\n                            distances++;\n                            distances[0] = delta - 1;\n                            distances++;\n                            if (len == lenLimit)\n                                return distances;\n                        }\n                    }\n                }\n            }\n\n            internal static P<uint> GetMatchesSpec1(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue, P<uint> distances, uint maxLen)\n            {\n                P<uint> ptr0 = son + (_cyclicBufferPos << 1) + 1;\n                P<uint> ptr1 = son + (_cyclicBufferPos << 1);\n                uint len0 = 0;\n                uint len1 = 0;\n\n                for (;;)\n                {\n                    uint delta = pos - curMatch;\n                    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n                    {\n                        ptr0[0] = ptr1[0] = CMatchFinder.kEmptyHashValue;\n                        return distances;\n                    }\n\n                    P<uint> pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);\n                    P<byte> pb = cur - delta;\n                    uint len = (len0 < len1 ? len0 : len1);\n\n                    if (pb[len] == cur[len])\n                    {\n                        if (++len != lenLimit && pb[len] == cur[len])\n                            while (++len != lenLimit)\n                                if (pb[len] != cur[len])\n                                    break;\n\n                        if (maxLen < len)\n                        {\n                            distances[0] = maxLen = len;\n                            distances++;\n                            distances[0] = delta - 1;\n                            distances++;\n\n                            if (len == lenLimit)\n                            {\n                                ptr1[0] = pair[0];\n                                ptr0[0] = pair[1];\n                                return distances;\n                            }\n                        }\n                    }\n\n                    if (pb[len] < cur[len])\n                    {\n                        ptr1[0] = curMatch;\n                        ptr1 = pair + 1;\n                        curMatch = ptr1[0];\n                        len1 = len;\n                    }\n                    else\n                    {\n                        ptr0[0] = curMatch;\n                        ptr0 = pair;\n                        curMatch = ptr0[0];\n                        len0 = len;\n                    }\n                }\n            }\n\n            private static void SkipMatchesSpec(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue)\n            {\n                P<uint> ptr0 = son + (_cyclicBufferPos << 1) + 1;\n                P<uint> ptr1 = son + (_cyclicBufferPos << 1);\n                uint len0 = 0;\n                uint len1 = 0;\n\n                for (;;)\n                {\n                    uint delta = pos - curMatch;\n                    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n                    {\n                        ptr0[0] = ptr1[0] = CMatchFinder.kEmptyHashValue;\n                        return;\n                    }\n\n                    P<uint> pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);\n                    P<byte> pb = cur - delta;\n                    uint len = (len0 < len1 ? len0 : len1);\n\n                    if (pb[len] == cur[len])\n                    {\n                        while (++len != lenLimit)\n                            if (pb[len] != cur[len])\n                                break;\n\n                        if (len == lenLimit)\n                        {\n                            ptr1[0] = pair[0];\n                            ptr0[0] = pair[1];\n                            return;\n                        }\n                    }\n\n                    if (pb[len] < cur[len])\n                    {\n                        ptr1[0] = curMatch;\n                        ptr1 = pair + 1;\n                        curMatch = ptr1[0];\n                        len1 = len;\n                    }\n                    else\n                    {\n                        ptr0[0] = curMatch;\n                        ptr0 = pair;\n                        curMatch = ptr0[0];\n                        len0 = len;\n                    }\n                }\n            }\n\n            private void MatchFinder_MovePos()\n            {\n                mCyclicBufferPos++;\n                mBuffer++;\n                mPos++;\n\n                if (mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n            }\n\n            internal uint Bt2_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 2)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n                uint hashValue = cur[0] | ((uint)cur[1] << 8);\n                uint curMatch = mHash[hashValue];\n                mHash[hashValue] = mPos;\n\n                uint offset = 0;\n                offset = (uint)(GetMatchesSpec1(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, 1) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n\n                if (++mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal uint Bt3_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 3)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;\n\n                uint delta2 = mPos - mHash[hash2Value];\n                uint curMatch = mHash[kFix3HashSize + hashValue];\n\n                mHash[hash2Value] = mPos;\n                mHash[kFix3HashSize + hashValue] = mPos;\n\n                uint maxLen = 2;\n                uint offset = 0;\n\n                if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])\n                {\n                    while (maxLen != lenLimit)\n                    {\n                        if (cur[maxLen - delta2] != cur[maxLen])\n                            break;\n\n                        maxLen++;\n                    }\n\n                    distances[0] = maxLen;\n                    distances[1] = delta2 - 1;\n                    offset = 2;\n\n                    if (maxLen == lenLimit)\n                    {\n                        SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                        mCyclicBufferPos++;\n                        mBuffer++;\n\n                        if (++mPos == mPosLimit)\n                            MatchFinder_CheckLimits();\n\n                        return offset;\n                    }\n                }\n\n                offset = (uint)(GetMatchesSpec1(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, maxLen) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n\n                if (++mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal uint Bt4_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 4)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                uint delta2 = mPos - mHash[hash2Value];\n                uint delta3 = mPos - mHash[kFix3HashSize + hash3Value];\n                uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                mHash[hash2Value] = mPos;\n                mHash[kFix3HashSize + hash3Value] = mPos;\n                mHash[kFix4HashSize + hashValue] = mPos;\n\n                uint maxLen = 1;\n                uint offset = 0;\n\n                if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])\n                {\n                    distances[0] = maxLen = 2;\n                    distances[1] = delta2 - 1;\n                    offset = 2;\n                }\n\n                if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])\n                {\n                    maxLen = 3;\n                    distances[offset + 1] = delta3 - 1;\n                    offset += 2;\n                    delta2 = delta3;\n                }\n\n                if (offset != 0)\n                {\n                    while (maxLen != lenLimit && cur[maxLen - delta2] == cur[maxLen])\n                        maxLen++;\n\n                    distances[offset - 2] = maxLen;\n\n                    if (maxLen == lenLimit)\n                    {\n                        SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n                        mCyclicBufferPos++;\n                        mBuffer++;\n\n                        if (++mPos == mPosLimit)\n                            MatchFinder_CheckLimits();\n\n                        return offset;\n                    }\n                }\n\n                if (maxLen < 3)\n                    maxLen = 3;\n\n                offset = (uint)(GetMatchesSpec1(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, maxLen) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n\n                if (++mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal uint Hc4_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 4)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                uint delta2 = mPos - mHash[hash2Value];\n                uint delta3 = mPos - mHash[kFix3HashSize + hash3Value];\n                uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                mHash[hash2Value] = mPos;\n                mHash[kFix3HashSize + hash3Value] = mPos;\n                mHash[kFix4HashSize + hashValue] = mPos;\n\n                uint maxLen = 1;\n                uint offset = 0;\n\n                if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])\n                {\n                    TR(\"Hc4_MatchFinder_GetMatches:a1\", maxLen);\n                    TR(\"Hc4_MatchFinder_GetMatches:a2\", delta2);\n                    distances[0] = maxLen = 2;\n                    distances[1] = delta2 - 1;\n                    offset = 2;\n                }\n\n                if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])\n                {\n                    TR(\"Hc4_MatchFinder_GetMatches:b1\", offset);\n                    TR(\"Hc4_MatchFinder_GetMatches:b2\", delta3);\n                    maxLen = 3;\n                    distances[offset + 1] = delta3 - 1;\n                    offset += 2;\n                    delta2 = delta3;\n                }\n\n                if (offset != 0)\n                {\n                    while (maxLen != lenLimit && cur[maxLen - delta2] == cur[maxLen])\n                        maxLen++;\n\n                    TR(\"Hc4_MatchFinder_GetMatches:c1\", offset);\n                    TR(\"Hc4_MatchFinder_GetMatches:c2\", maxLen);\n\n                    distances[offset - 2] = maxLen;\n\n                    if (maxLen == lenLimit)\n                    {\n                        TR(\"Hc4_MatchFinder_GetMatches:d\", curMatch);\n                        mSon[mCyclicBufferPos] = curMatch;\n                        mCyclicBufferPos++;\n                        mBuffer++;\n                        mPos++;\n                        if (mPos == mPosLimit)\n                            MatchFinder_CheckLimits();\n                        return offset;\n                    }\n                }\n\n                if (maxLen < 3)\n                    maxLen = 3;\n\n                offset = (uint)(Hc_GetMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, maxLen) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n                mPos++;\n\n                if (mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal void Bt2_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 2)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint hashValue = cur[0] | ((uint)cur[1] << 8);\n\n                    uint curMatch = mHash[hashValue];\n\n                    mHash[hashValue] = mPos;\n\n                    SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n\n            internal void Bt3_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 3)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint temp = cur[0].CRC() ^ cur[1];\n                    uint hash2Value = temp & (kHash2Size - 1);\n                    uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;\n\n                    uint curMatch = mHash[kFix3HashSize + hashValue];\n\n                    mHash[hash2Value] = mPos;\n                    mHash[kFix3HashSize + hashValue] = mPos;\n\n                    SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n\n            internal void Bt4_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 4)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint temp = cur[0].CRC() ^ cur[1];\n                    uint hash2Value = temp & (kHash2Size - 1);\n                    uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                    uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                    uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                    mHash[hash2Value] = mPos;\n                    mHash[kFix3HashSize + hash3Value] = mPos;\n                    mHash[kFix4HashSize + hashValue] = mPos;\n\n                    SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n\n            internal void Hc4_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 4)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint temp = cur[0].CRC() ^ cur[1];\n                    uint hash2Value = temp & (kHash2Size - 1);\n                    uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                    uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                    uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                    mHash[hash2Value] = mPos;\n                    mHash[kFix3HashSize + hash3Value] = mPos;\n                    mHash[kFix4HashSize + hashValue] = mPos;\n\n                    mSon[mCyclicBufferPos] = curMatch;\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n        }\n\n        // Conditions:\n        //    GetNumAvailableBytes must be called before each GetMatchLen.\n        //    GetPointerToCurrentPos result must be used only before any other function\n\n        internal interface IMatchFinder\n        {\n            void Init(object p);\n            byte GetIndexByte(object p, Int32 index);\n            uint GetNumAvailableBytes(object p);\n            P<byte> GetPointerToCurrentPos(object p);\n            uint GetMatches(object p, P<uint> distances);\n            void Skip(object p, uint num);\n        }\n\n        internal static void MatchFinder_CreateVTable(CMatchFinder p, out IMatchFinder vTable)\n        {\n            TR(\"MatchFinder_CreateVTable\", p.mNumHashBytes);\n            if (!p.mBtMode)\n                vTable = new MatchFinderHc4();\n            else if (p.mNumHashBytes == 2)\n                vTable = new MatchFinderBt2();\n            else if (p.mNumHashBytes == 3)\n                vTable = new MatchFinderBt3();\n            else\n                vTable = new MatchFinderBt4();\n        }\n\n        private abstract class MatchFinderBase : IMatchFinder\n        {\n            public void Init(object p)\n            {\n                ((CMatchFinder)p).MatchFinder_Init();\n            }\n\n            public byte GetIndexByte(object p, int index)\n            {\n                return ((CMatchFinder)p).MatchFinder_GetIndexByte(index);\n            }\n\n            public uint GetNumAvailableBytes(object p)\n            {\n                return ((CMatchFinder)p).MatchFinder_GetNumAvailableBytes();\n            }\n\n            public P<byte> GetPointerToCurrentPos(object p)\n            {\n                return ((CMatchFinder)p).MatchFinder_GetPointerToCurrentPos();\n            }\n\n            public abstract uint GetMatches(object p, P<uint> distances);\n            public abstract void Skip(object p, uint num);\n        }\n\n        private sealed class MatchFinderHc4 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Hc4_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Hc4_MatchFinder_Skip(num);\n            }\n        }\n\n        private sealed class MatchFinderBt2 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Bt2_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Bt2_MatchFinder_Skip(num);\n            }\n        }\n\n        private sealed class MatchFinderBt3 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Bt3_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Bt3_MatchFinder_Skip(num);\n            }\n        }\n\n        private sealed class MatchFinderBt4 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Bt4_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Bt4_MatchFinder_Skip(num);\n            }\n        }\n    }\n    partial class LZMA\n    {\n        internal const int kMtHashBlockSize = (1 << 13);\n        internal const int kMtHashNumBlocks = (1 << 3);\n        internal const int kMtHashNumBlocksMask = (kMtHashNumBlocks - 1);\n\n        internal const int kMtBtBlockSize = (1 << 14);\n        internal const int kMtBtNumBlocks = (1 << 6);\n        internal const int kMtBtNumBlocksMask = (kMtBtNumBlocks - 1);\n\n        private const uint kMtMaxValForNormalize = 0xFFFFFFFF;\n        private const int kEmptyHashValue = 0;\n\n        private const int kHashBufferSize = (kMtHashBlockSize * kMtHashNumBlocks);\n        private const int kBtBufferSize = (kMtBtBlockSize * kMtBtNumBlocks);\n\n        internal sealed class CMtSync\n        {\n            #region Variables\n\n            internal bool mWasCreated;\n            internal bool mNeedStart;\n            internal bool mExit;\n            internal bool mStopWriting;\n\n            internal CThread mThread;\n            internal CEvent mCanStart;\n            internal CEvent mWasStarted;\n            internal CEvent mWasStopped;\n            internal CSemaphore mFreeSemaphore;\n            internal CSemaphore mFilledSemaphore;\n            internal bool mCsWasInitialized;\n            internal bool mCsWasEntered;\n            internal CCriticalSection mCS;\n            internal uint mNumProcessedBlocks;\n\n            #endregion\n\n            #region Methods\n\n            internal void MtSync_Construct()\n            {\n                mWasCreated = false;\n                mCsWasInitialized = false;\n                mCsWasEntered = false;\n                Thread_Construct(out mThread);\n                Event_Construct(out mCanStart);\n                Event_Construct(out mWasStarted);\n                Event_Construct(out mWasStopped);\n                Semaphore_Construct(out mFreeSemaphore);\n                Semaphore_Construct(out mFilledSemaphore);\n            }\n\n            internal void MtSync_GetNextBlock()\n            {\n                if (mNeedStart)\n                {\n                    mNumProcessedBlocks = 1;\n                    mNeedStart = false;\n\n                    Trace.MatchObjectWait(this, \"MtSync_GetNextBlock:start\");\n                    mStopWriting = false;\n                    Trace.MatchObjectWait(this, \"MtSync_GetNextBlock:start\");\n\n                    mExit = false;\n                    Event_Reset(mWasStarted);\n                    Event_Reset(mWasStopped);\n                    Event_Set(mCanStart);\n                    Event_Wait(mWasStarted);\n                }\n                else\n                {\n                    CriticalSection_Leave(mCS);\n                    mCsWasEntered = false;\n                    mNumProcessedBlocks++;\n                    Semaphore_Release1(mFreeSemaphore);\n                }\n                Semaphore_Wait(mFilledSemaphore);\n                CriticalSection_Enter(mCS);\n                mCsWasEntered = true;\n            }\n\n            /* MtSync_StopWriting must be called if Writing was started */\n\n            internal void MtSync_StopWriting()\n            {\n                uint myNumBlocks = mNumProcessedBlocks;\n                if (!Thread_WasCreated(mThread) || mNeedStart)\n                    return;\n\n                Trace.MatchObjectWait(this, \"MtSync_StopWriting:stop\");\n                mStopWriting = true;\n                Trace.MatchObjectWait(this, \"MtSync_StopWriting:stop\");\n\n                if (mCsWasEntered)\n                {\n                    CriticalSection_Leave(mCS);\n                    mCsWasEntered = false;\n                }\n\n                Semaphore_Release1(mFreeSemaphore);\n\n                Event_Wait(mWasStopped);\n\n                while (myNumBlocks++ != mNumProcessedBlocks)\n                {\n                    Semaphore_Wait(mFilledSemaphore);\n                    Semaphore_Release1(mFreeSemaphore);\n                }\n\n                mNeedStart = true;\n            }\n\n            internal void MtSync_Destruct()\n            {\n                if (Thread_WasCreated(mThread))\n                {\n                    MtSync_StopWriting();\n                    mExit = true;\n                    if (mNeedStart)\n                        Event_Set(mCanStart);\n                    Thread_Wait(mThread);\n                    Thread_Close(ref mThread);\n                }\n\n                if (mCsWasInitialized)\n                {\n                    CriticalSection_Delete(mCS);\n                    mCsWasInitialized = false;\n                }\n\n                Event_Close(ref mCanStart);\n                Event_Close(ref mWasStarted);\n                Event_Close(ref mWasStopped);\n                Semaphore_Close(ref mFreeSemaphore);\n                Semaphore_Close(ref mFilledSemaphore);\n\n                if (mWasCreated)\n                    Trace.MatchObjectDestroy(this, \"MtSync_Destruct\");\n\n                mWasCreated = false;\n            }\n\n            private SRes MtSync_Create2(Action startAddress, string threadName, uint numBlocks)\n            {\n                if (mWasCreated)\n                    return SZ_OK;\n\n                Trace.MatchObjectCreate(this, \"MtSync_Create2\");\n\n                if (CriticalSection_Init(out mCS) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                mCsWasInitialized = true;\n\n                if (AutoResetEvent_CreateNotSignaled(out mCanStart) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                if (AutoResetEvent_CreateNotSignaled(out mWasStarted) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                if (AutoResetEvent_CreateNotSignaled(out mWasStopped) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                if (Semaphore_Create(out mFreeSemaphore, numBlocks, numBlocks) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                if (Semaphore_Create(out mFilledSemaphore, 0, numBlocks) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                mNeedStart = true;\n\n                if (Thread_Create(out mThread, startAddress, threadName) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                mWasCreated = true;\n\n                return SZ_OK;\n            }\n\n            internal SRes MtSync_Create(Action startAddress, string threadName, uint numBlocks)\n            {\n                SRes res = MtSync_Create2(startAddress, threadName, numBlocks);\n                if (res != SZ_OK)\n                    MtSync_Destruct();\n                return res;\n            }\n\n            #endregion\n        }\n\n        internal interface IMatchFinderMt : IMatchFinder\n        {\n            /* LZ */\n            P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances);\n\n            /* Hash */\n            void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads);\n        }\n\n        internal class CMatchFinderMt\n            : CMatchFinder /* Hash */\n        {\n            #region Variables\n\n            internal IMatchFinderMt mInterface;\n\n            /* LZ */\n            internal P<byte> mPointerToCurPos;\n            internal P<uint> mBtBuf;\n            internal uint mBtBufPos;\n            internal uint mBtBufPosLimit;\n            internal uint mLzPos;\n            internal uint mBtNumAvailBytes;\n\n            internal uint[] mLocalHash;\n            internal uint mLocalFixedHashSize;\n            internal uint mLocalHistorySize;\n\n            /* LZ + BT */\n            internal CMtSync mBtSync = new CMtSync();\n\n            /* BT */\n            internal uint[] mHashBuf;\n            internal uint mHashBufPos;\n            internal uint mHashBufPosLimit;\n            internal uint mHashNumAvail;\n\n            internal P<uint> mLocalSon;\n            internal uint mLocalMatchMaxLen;\n            internal uint mLocalNumHashBytes;\n            internal uint mLocalPos;\n            internal P<byte> mLocalBuffer;\n            internal uint mLocalCyclicBufferPos;\n            internal uint mLocalCyclicBufferSize; // it must be historySize + 1\n            internal uint mLocalCutValue;\n\n            /* BT + Hash */\n            internal CMtSync mHashSync = new CMtSync();\n\n            #endregion\n\n            #region Methods\n\n            internal CMatchFinderMt()\n            {\n                TR(\"MatchFinderMt_Construct\", 0);\n\n                mHashBuf = null;\n                mHashSync.MtSync_Construct();\n                mBtSync.MtSync_Construct();\n            }\n\n            internal void MatchFinderMt_GetNextBlock_Hash()\n            {\n                mHashSync.MtSync_GetNextBlock();\n                mHashBufPosLimit = mHashBufPos = ((mHashSync.mNumProcessedBlocks - 1) & kMtHashNumBlocksMask) * kMtHashBlockSize;\n                mHashBufPosLimit += mHashBuf[mHashBufPos++];\n                mHashNumAvail = mHashBuf[mHashBufPos++];\n            }\n\n            internal void MatchFinderMt_Destruct(ISzAlloc alloc)\n            {\n                mHashSync.MtSync_Destruct();\n                mBtSync.MtSync_Destruct();\n                alloc.FreeUInt32(alloc, mHashBuf);\n                mHashBuf = null;\n            }\n\n            /* ReleaseStream is required to finish multithreading */\n            internal void MatchFinderMt_ReleaseStream()\n            {\n                mBtSync.MtSync_StopWriting();\n            }\n\n            #endregion\n\n            private void MatchFinderMt_Normalize()\n            {\n                CMatchFinder.MatchFinder_Normalize3(mLzPos - mLocalHistorySize - 1, mLocalHash, mLocalFixedHashSize);\n                mLzPos = mLocalHistorySize + 1;\n            }\n\n            internal void MatchFinderMt_GetNextBlock_Bt()\n            {\n                mBtSync.MtSync_GetNextBlock();\n                uint blockIndex = (mBtSync.mNumProcessedBlocks - 1) & kMtBtNumBlocksMask;\n                mBtBufPos = blockIndex * kMtBtBlockSize;\n                mBtBufPosLimit = mBtBufPos;\n                mBtBufPosLimit += mBtBuf[mBtBufPos++];\n                mBtNumAvailBytes = mBtBuf[mBtBufPos++];\n                if (mLzPos >= kMtMaxValForNormalize - kMtBtBlockSize)\n                    MatchFinderMt_Normalize();\n            }\n\n            internal P<byte> MatchFinderMt_GetPointerToCurrentPos()\n            {\n                return mPointerToCurPos;\n            }\n\n            internal uint MatchFinderMt_GetNumAvailableBytes()\n            {\n                TR(\"MatchFinderMt_GetNumAvailableBytes\", mBtBufPos);\n                if (mBtBufPos == mBtBufPosLimit)\n                    MatchFinderMt_GetNextBlock_Bt();\n\n                TR(\"MatchFinderMt_GetNumAvailableBytes\", mBtNumAvailBytes);\n                return mBtNumAvailBytes;\n            }\n\n            internal byte MatchFinderMt_GetIndexByte(int index)\n            {\n                return mPointerToCurPos[index];\n            }\n\n            #region More Methods. Not sure if the are right in this class.\n\n            internal void HashThreadFunc()\n            {\n                CMtSync p = mHashSync;\n                for (;;)\n                {\n                    uint numProcessedBlocks = 0;\n                    Event_Wait(p.mCanStart);\n                    Event_Set(p.mWasStarted);\n                    for (;;)\n                    {\n                        if (p.mExit)\n                            return;\n\n                        Trace.MatchObjectWait(p, \"HashThreadFunc:stop\");\n                        if (p.mStopWriting)\n                        {\n                            Trace.MatchObjectWait(p, \"HashThreadFunc:stop\");\n                            p.mNumProcessedBlocks = numProcessedBlocks;\n                            Event_Set(p.mWasStopped);\n                            break;\n                        }\n                        Trace.MatchObjectWait(p, \"HashThreadFunc:stop\");\n\n                        if (base.MatchFinder_NeedMove())\n                        {\n                            CriticalSection_Enter(mBtSync.mCS);\n                            CriticalSection_Enter(mHashSync.mCS);\n                            {\n                                P<byte> beforePtr = base.MatchFinder_GetPointerToCurrentPos();\n                                base.MatchFinder_MoveBlock();\n                                P<byte> afterPtr = base.MatchFinder_GetPointerToCurrentPos();\n                                mPointerToCurPos -= beforePtr - afterPtr;\n                                mLocalBuffer -= beforePtr - afterPtr;\n                            }\n                            CriticalSection_Leave(mBtSync.mCS);\n                            CriticalSection_Leave(mHashSync.mCS);\n                            continue;\n                        }\n\n                        Semaphore_Wait(p.mFreeSemaphore);\n\n                        base.MatchFinder_ReadIfRequired();\n                        if (base.mPos > (kMtMaxValForNormalize - kMtHashBlockSize))\n                        {\n                            uint subValue = (base.mPos - base.mHistorySize - 1);\n                            base.MatchFinder_ReduceOffsets(subValue);\n                            CMatchFinder.MatchFinder_Normalize3(subValue, P.From(base.mHash, base.mFixedHashSize), base.mHashMask + 1);\n                        }\n\n                        P<uint> heads = P.From(mHashBuf, ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize);\n                        uint num = base.mStreamPos - base.mPos;\n                        heads[0] = 2;\n                        heads[1] = num;\n                        if (num >= base.mNumHashBytes)\n                        {\n                            num = num - base.mNumHashBytes + 1;\n                            if (num > kMtHashBlockSize - 2)\n                                num = kMtHashBlockSize - 2;\n                            mInterface.GetHeadsFunc(base.mBuffer, base.mPos, P.From(base.mHash, base.mFixedHashSize), base.mHashMask, heads + 2, num);\n                            heads[0] += num;\n                        }\n                        base.mPos += num;\n                        base.mBuffer += num;\n\n                        Semaphore_Release1(p.mFilledSemaphore);\n                    }\n                }\n            }\n\n            internal void BtGetMatches(P<uint> distances)\n            {\n                uint numProcessed = 0;\n                uint curPos = 2;\n                uint limit = kMtBtBlockSize - (mLocalMatchMaxLen * 2);\n\n                distances[1] = mHashNumAvail;\n\n                while (curPos < limit)\n                {\n                    if (mHashBufPos == mHashBufPosLimit)\n                    {\n                        MatchFinderMt_GetNextBlock_Hash();\n                        distances[1] = numProcessed + mHashNumAvail;\n\n                        if (mHashNumAvail >= mLocalNumHashBytes)\n                            continue;\n\n                        while (mHashNumAvail != 0)\n                        {\n                            distances[curPos++] = 0;\n                            mHashNumAvail--;\n                        }\n\n                        break;\n                    }\n                    {\n                        TR(\"BtGetMatches:cyclicBufferPos0\", mLocalCyclicBufferPos);\n\n                        uint size = mHashBufPosLimit - mHashBufPos;\n                        uint lenLimit = mLocalMatchMaxLen;\n                        uint pos = mLocalPos;\n                        uint cyclicBufferPos = mLocalCyclicBufferPos;\n\n                        if (lenLimit >= mHashNumAvail)\n                            lenLimit = mHashNumAvail;\n\n                        {\n                            uint size2 = mHashNumAvail - lenLimit + 1;\n                            if (size2 < size)\n                                size = size2;\n\n                            size2 = mLocalCyclicBufferSize - cyclicBufferPos;\n                            if (size2 < size)\n                                size = size2;\n                        }\n\n                        while (curPos < limit && size-- != 0)\n                        {\n                            P<uint> startDistances = distances + curPos;\n                            uint num = (uint)(CMatchFinder.GetMatchesSpec1(lenLimit, pos - mHashBuf[mHashBufPos++],\n                                pos, mLocalBuffer, mLocalSon, cyclicBufferPos, mLocalCyclicBufferSize, mLocalCutValue,\n                                startDistances + 1, mLocalNumHashBytes - 1) - startDistances);\n                            TR(\"GetMatchesSpec1\", num);\n                            startDistances[0] = num - 1;\n                            curPos += num;\n                            cyclicBufferPos++;\n                            pos++;\n                            mLocalBuffer++;\n                        }\n\n                        numProcessed += pos - mLocalPos;\n                        mHashNumAvail -= pos - mLocalPos;\n                        mLocalPos = pos;\n\n                        if (cyclicBufferPos == mLocalCyclicBufferSize)\n                            cyclicBufferPos = 0;\n\n                        mLocalCyclicBufferPos = cyclicBufferPos;\n\n                        TR(\"BtGetMatches:cyclicBufferPos1\", mLocalCyclicBufferPos);\n                    }\n                }\n\n                distances[0] = curPos;\n            }\n\n            internal void BtFillBlock(uint globalBlockIndex)\n            {\n                CMtSync sync = mHashSync;\n                if (!sync.mNeedStart)\n                {\n                    CriticalSection_Enter(sync.mCS);\n                    sync.mCsWasEntered = true;\n                }\n\n                BtGetMatches(mBtBuf + (globalBlockIndex & kMtBtNumBlocksMask) * kMtBtBlockSize);\n\n                if (mLocalPos > kMtMaxValForNormalize - kMtBtBlockSize)\n                {\n                    uint subValue = mLocalPos - mLocalCyclicBufferSize;\n                    CMatchFinder.MatchFinder_Normalize3(subValue, mLocalSon, mLocalCyclicBufferSize * 2);\n                    mLocalPos -= subValue;\n                }\n\n                if (!sync.mNeedStart)\n                {\n                    CriticalSection_Leave(sync.mCS);\n                    sync.mCsWasEntered = false;\n                }\n            }\n\n            internal void BtThreadFunc()\n            {\n                CMtSync p = mBtSync;\n                for (;;)\n                {\n                    Event_Wait(p.mCanStart);\n                    Event_Set(p.mWasStarted);\n\n                    uint blockIndex = 0;\n                    for (;;)\n                    {\n                        if (p.mExit)\n                            return;\n\n                        Trace.MatchObjectWait(p, \"BtThreadFunc:stop\");\n                        if (p.mStopWriting)\n                        {\n                            Trace.MatchObjectWait(p, \"BtThreadFunc:stop\");\n                            p.mNumProcessedBlocks = blockIndex;\n                            mHashSync.MtSync_StopWriting();\n                            Event_Set(p.mWasStopped);\n                            break;\n                        }\n                        Trace.MatchObjectWait(p, \"BtThreadFunc:stop\");\n\n                        Semaphore_Wait(p.mFreeSemaphore);\n                        BtFillBlock(blockIndex++);\n                        Semaphore_Release1(p.mFilledSemaphore);\n                    }\n                }\n            }\n\n            internal SRes MatchFinderMt_Create(uint historySize, uint keepAddBufferBefore, uint matchMaxLen, uint keepAddBufferAfter, ISzAlloc alloc)\n            {\n                mLocalHistorySize = historySize;\n\n                if (kMtBtBlockSize <= matchMaxLen * 4)\n                    return SZ_ERROR_PARAM;\n\n                if (mHashBuf == null)\n                {\n                    mHashBuf = alloc.AllocUInt32(alloc, kHashBufferSize + kBtBufferSize);\n                    if (mHashBuf == null)\n                        return SZ_ERROR_MEM;\n\n                    mBtBuf = P.From(mHashBuf, kHashBufferSize);\n                }\n\n                keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);\n                keepAddBufferAfter += kMtHashBlockSize;\n\n                if (!base.MatchFinder_Create(historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))\n                    return SZ_ERROR_MEM;\n\n                SRes res;\n                if ((res = mHashSync.MtSync_Create(HashThreadFunc, \"LZMA Hash Thread\", kMtHashNumBlocks)) != SZ_OK)\n                    return res;\n                if ((res = mBtSync.MtSync_Create(BtThreadFunc, \"LZMA BT Thread\", kMtBtNumBlocks)) != SZ_OK)\n                    return res;\n                return SZ_OK;\n            }\n\n            internal void MatchFinderMt_CreateVTable(out IMatchFinder vTable)\n            {\n                // Careful: don't use this.mNumHashBytes - it hasn't been initialized yet!\n                TR(\"MatchFinderMt_CreateVTable\", base.mNumHashBytes);\n                switch (base.mNumHashBytes)\n                {\n                    case 2:\n                        vTable = mInterface = new MatchFinderMt2();\n                        break;\n                    case 3:\n                        vTable = mInterface = new MatchFinderMt3();\n                        break;\n                    default:\n#if PROTOTYPE\n                    vTable = mInterface = new MatchFinderMt5();\n                    break;\n                case 4:\n#endif\n                        if (base.mBigHash)\n                            vTable = mInterface = new MatchFinderMt4b();\n                        else\n                            vTable = mInterface = new MatchFinderMt4a();\n                        break;\n                }\n            }\n\n            #endregion\n        }\n\n        private abstract class MatchFinderMtBase : IMatchFinderMt\n        {\n            public virtual void Init(object p)\n            {\n                MatchFinderMt_Init((CMatchFinderMt)p);\n            }\n\n            public virtual byte GetIndexByte(object p, int index)\n            {\n                return ((CMatchFinderMt)p).MatchFinderMt_GetIndexByte(index);\n            }\n\n            public virtual uint GetNumAvailableBytes(object p)\n            {\n                return ((CMatchFinderMt)p).MatchFinderMt_GetNumAvailableBytes();\n            }\n\n            public virtual P<byte> GetPointerToCurrentPos(object p)\n            {\n                return ((CMatchFinderMt)p).MatchFinderMt_GetPointerToCurrentPos();\n            }\n\n            public virtual uint GetMatches(object p, P<uint> distances)\n            {\n                return MatchFinderMt_GetMatches((CMatchFinderMt)p, distances);\n            }\n\n            public abstract void Skip(object p, uint num);\n            public abstract P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances);\n            public abstract void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads);\n\n            /* Call it after ReleaseStream / SetStream */\n            private static void MatchFinderMt_Init(CMatchFinderMt p)\n            {\n                CMatchFinder mf = p;\n\n                p.mBtBufPos = p.mBtBufPosLimit = 0;\n                p.mHashBufPos = p.mHashBufPosLimit = 0;\n                mf.MatchFinder_Init();\n                p.mPointerToCurPos = mf.MatchFinder_GetPointerToCurrentPos();\n                p.mBtNumAvailBytes = 0;\n                p.mLzPos = p.mLocalHistorySize + 1;\n\n                p.mLocalHash = mf.mHash;\n                p.mLocalFixedHashSize = mf.mFixedHashSize;\n\n                p.mLocalSon = mf.mSon;\n                p.mLocalMatchMaxLen = mf.mMatchMaxLen;\n                p.mLocalNumHashBytes = mf.mNumHashBytes;\n                p.mLocalPos = mf.mPos;\n                p.mLocalBuffer = mf.mBuffer;\n                p.mLocalCyclicBufferPos = mf.mCyclicBufferPos;\n                p.mLocalCyclicBufferSize = mf.mCyclicBufferSize;\n                p.mLocalCutValue = mf.mCutValue;\n            }\n\n            private static uint MatchFinderMt_GetMatches(CMatchFinderMt p, P<uint> distances)\n            {\n                TR(\"MatchFinderMt_GetMatches\", p.mBtBufPos);\n                P<uint> btBuf = p.mBtBuf + p.mBtBufPos;\n                uint len = btBuf[0];\n                btBuf++;\n                p.mBtBufPos += 1 + len;\n\n                if (len == 0)\n                {\n                    if (p.mBtNumAvailBytes-- >= 4)\n                        len = (uint)(p.mInterface.MixMatchesFunc(p, p.mLzPos - p.mLocalHistorySize, distances) - distances);\n                }\n                else\n                {\n                    // Condition: there are matches in btBuf with length < p.numHashBytes\n                    p.mBtNumAvailBytes--;\n                    P<uint> distances2 = p.mInterface.MixMatchesFunc(p, p.mLzPos - btBuf[1], distances);\n\n                    do\n                    {\n                        distances2[0] = btBuf[0];\n                        distances2++;\n                        btBuf++;\n\n                        distances2[0] = btBuf[0];\n                        distances2++;\n                        btBuf++;\n\n                        len -= 2;\n                    }\n                    while (len != 0);\n\n                    len = (uint)(distances2 - distances);\n                }\n\n                p.mLzPos++;\n                p.mPointerToCurPos++;\n                return len;\n            }\n        }\n\n        private sealed class MatchFinderMt2 : MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt0_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return MatchFinderMt2_GetMatches((CMatchFinderMt)p, distances);\n            }\n\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = buffer[0] | ((uint)buffer[1] << 8);\n                    TR(\"GetHeads2\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                throw new InvalidOperationException(); // was a NULL delegate\n            }\n\n            private static void MatchFinderMt0_Skip(CMatchFinderMt p, uint num)\n            {\n                do\n                {\n                    if (p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    p.mBtNumAvailBytes--;\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while (--num != 0);\n            }\n\n            private static uint MatchFinderMt2_GetMatches(CMatchFinderMt p, P<uint> distances)\n            {\n                P<uint> btBuf = p.mBtBuf + p.mBtBufPos;\n                uint len = btBuf[0];\n                btBuf++;\n                p.mBtBufPos += 1 + len;\n                p.mBtNumAvailBytes--;\n\n                for (uint i = 0; i < len; i += 2)\n                {\n                    distances[0] = btBuf[0];\n                    distances++;\n                    btBuf++;\n\n                    distances[0] = btBuf[0];\n                    distances++;\n                    btBuf++;\n                }\n\n                p.mLzPos++;\n                p.mPointerToCurPos++;\n                return len;\n            }\n        }\n\n        private sealed class MatchFinderMt3 : MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt2_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8)) & hashMask;\n                    TR(\"GetHeads3\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                return MixMatches2((CMatchFinderMt)p, matchMinPos, distances);\n            }\n\n            private static P<uint> MixMatches2(CMatchFinderMt p, uint matchMinPos, P<uint> distances)\n            {\n                uint[] hash = p.mLocalHash;\n                P<byte> cur = p.mPointerToCurPos;\n                uint lzPos = p.mLzPos;\n                uint hash2Value = (cur[0].CRC() ^ cur[1]) & (kHash2Size - 1);\n\n                uint curMatch2 = hash[hash2Value];\n                hash[hash2Value] = lzPos;\n\n                if (curMatch2 >= matchMinPos && cur[(long)curMatch2 - lzPos] == cur[0])\n                {\n                    distances[0] = 2;\n                    distances++;\n                    distances[0] = lzPos - curMatch2 - 1;\n                    distances++;\n                }\n\n                return distances;\n            }\n\n            private static void MatchFinderMt2_Skip(CMatchFinderMt p, uint num)\n            {\n                do\n                {\n                    if (p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    if (p.mBtNumAvailBytes-- >= 2)\n                    {\n                        P<byte> cur = p.mPointerToCurPos;\n                        uint[] hash = p.mLocalHash;\n                        uint hash2Value = (cur[0].CRC() ^ cur[1]) & (kHash2Size - 1);\n                        hash[hash2Value] = p.mLzPos;\n                    }\n\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while (--num != 0);\n            }\n        }\n\n        private abstract class MatchFinderMt4 : MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt3_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                return MixMatches3((CMatchFinderMt)p, matchMinPos, distances);\n            }\n\n            private static P<uint> MixMatches3(CMatchFinderMt p, uint matchMinPos, P<uint> distances)\n            {\n                uint[] hash = p.mLocalHash;\n                P<byte> cur = p.mPointerToCurPos;\n                uint lzPos = p.mLzPos;\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n\n                uint curMatch2 = hash[hash2Value];\n                uint curMatch3 = hash[kFix3HashSize + hash3Value];\n\n                hash[hash2Value] = lzPos;\n                hash[kFix3HashSize + hash3Value] = lzPos;\n\n                if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])\n                {\n                    distances[1] = lzPos - curMatch2 - 1;\n\n                    if (cur[curMatch2 - lzPos + 2] == cur[2])\n                    {\n                        distances[0] = 3;\n                        return distances + 2;\n                    }\n\n                    distances[0] = 2;\n                    distances += 2;\n                }\n\n                if (curMatch3 >= matchMinPos && cur[curMatch3 - lzPos] == cur[0])\n                {\n                    distances[0] = 3;\n                    distances++;\n\n                    distances[0] = lzPos - curMatch3 - 1;\n                    distances++;\n                }\n\n                return distances;\n            }\n\n            private static void MatchFinderMt3_Skip(CMatchFinderMt p, uint num)\n            {\n                do\n                {\n                    if (p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    if (p.mBtNumAvailBytes-- >= 3)\n                    {\n                        P<byte> cur = p.mPointerToCurPos;\n                        uint[] hash = p.mLocalHash;\n                        uint temp = cur[0].CRC() ^ cur[1];\n                        uint hash2Value = temp & (kHash2Size - 1);\n                        uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                        hash[kFix3HashSize + hash3Value] = p.mLzPos;\n                        hash[hash2Value] = p.mLzPos;\n                    }\n\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while (--num != 0);\n            }\n        }\n\n        private sealed class MatchFinderMt4a : MatchFinderMt4\n        {\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5)) & hashMask;\n                    TR(\"GetHeads4\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n        }\n\n        private sealed class MatchFinderMt4b : MatchFinderMt4\n        {\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ ((uint)buffer[3] << 16)) & hashMask;\n                    TR(\"GetHeads4b\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n        }\n\n#if PROTOTYPE\n        private sealed class MatchFinderMt5: MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt4_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                for(; numHeads != 0; numHeads--)\n                {\n                    uint value = ((buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5) ^ (buffer[4].CRC() << 3)) & hashMask);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                }\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                return MixMatches4((CMatchFinderMt)p, matchMinPos, distances);\n            }\n\n            private static void MatchFinderMt4_Skip(CMatchFinderMt p, uint count)\n            {\n                do\n                {\n                    if(p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    if(p.mBtNumAvailBytes-- >= 4)\n                    {\n                        P<byte> cur = p.mPointerToCurPos;\n                        uint[] hash = p.mHash;\n                        uint temp = cur[0].CRC() ^ cur[1];\n                        uint hash2Value = temp & (kHash2Size - 1);\n                        uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                        uint hash4Value = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & (kHash4Size - 1);\n                        hash[kFix4HashSize + hash4Value] = p.mLzPos;\n                        hash[kFix3HashSize + hash3Value] = p.mLzPos;\n                        hash[hash2Value] = p.mLzPos;\n                    }\n\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while(--count != 0);\n            }\n\n            private static P<uint> MixMatches4(CMatchFinderMt p, uint matchMinPos, P<uint> distances)\n            {\n                uint[] hash = p.mHash;\n                P<byte> cur = p.mPointerToCurPos;\n                uint lzPos = p.mLzPos;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                uint hash4Value = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & (kHash4Size - 1);\n\n                uint curMatch2 = hash[hash2Value];\n                uint curMatch3 = hash[kFix3HashSize + hash3Value];\n                uint curMatch4 = hash[kFix4HashSize + hash4Value];\n\n                hash[hash2Value] = lzPos;\n                hash[kFix3HashSize + hash3Value] = lzPos;\n                hash[kFix4HashSize + hash4Value] = lzPos;\n\n                if(curMatch2 >= matchMinPos && cur[(long)curMatch2 - lzPos] == cur[0])\n                {\n                    distances[1] = lzPos - curMatch2 - 1;\n                    if(cur[(long)curMatch2 - lzPos + 2] == cur[2])\n                    {\n                        distances[0] = (cur[(long)curMatch2 - lzPos + 3] == cur[3]) ? 4u : 3u;\n                        return distances + 2;\n                    }\n\n                    distances[0] = 2;\n                    distances += 2;\n                }\n\n                if(curMatch3 >= matchMinPos && cur[(long)curMatch3 - lzPos] == cur[0])\n                {\n                    distances[1] = lzPos - curMatch3 - 1;\n                    if(cur[(long)curMatch3 - lzPos + 3] == cur[3])\n                    {\n                        distances[0] = 4;\n                        return distances + 2;\n                    }\n\n                    distances[0] = 3;\n                    distances += 2;\n                }\n\n                if(curMatch4 >= matchMinPos\n                    && cur[(long)curMatch4 - lzPos] == cur[0]\n                    && cur[(long)curMatch4 - lzPos + 3] == cur[3])\n                {\n                    distances[0] = 4;\n                    distances++;\n\n                    distances[0] = lzPos - curMatch4 - 1;\n                    distances++;\n                }\n\n                return distances;\n            }\n        }\n#endif\n    }\n    partial class LZMA\n    {\n        internal const int kHash2Size = (1 << 10);\n        internal const int kHash3Size = (1 << 16);\n        internal const int kHash4Size = (1 << 20);\n\n        internal const int kFix3HashSize = (kHash2Size);\n        internal const int kFix4HashSize = (kHash2Size + kHash3Size);\n        internal const int kFix5HashSize = (kHash2Size + kHash3Size + kHash4Size);\n    }\n    partial class LZMA\n    {\n        public sealed class CLzma2Dec\n        {\n            #region Constants\n\n            /*\n            00000000  -  EOS\n            00000001 U U  -  Uncompressed Reset Dic\n            00000010 U U  -  Uncompressed No Reset\n            100uuuuu U U P P  -  LZMA no reset\n            101uuuuu U U P P  -  LZMA reset state\n            110uuuuu U U P P S  -  LZMA reset state + new prop\n            111uuuuu U U P P S  -  LZMA reset state + new prop + reset dic\n\n              u, U - Unpack Size\n              P - Pack Size\n              S - Props\n            */\n\n            private const int LZMA2_CONTROL_LZMA = (1 << 7);\n            private const int LZMA2_CONTROL_COPY_NO_RESET = 2;\n            private const int LZMA2_CONTROL_COPY_RESET_DIC = 1;\n            private const int LZMA2_CONTROL_EOF = 0;\n\n            private const int LZMA2_LCLP_MAX = 4;\n\n            private enum Lzma2State\n            {\n                Control,\n                Unpack0,\n                Unpack1,\n                Pack0,\n                Pack1,\n                Prop,\n                Data,\n                DataCont,\n                Finished,\n                Error,\n            }\n\n            #endregion\n\n            #region Variables\n\n            internal CLzmaDec mDecoder = new CLzmaDec();\n            internal uint mPackSize;\n            internal uint mUnpackSize;\n            private Lzma2State mState;\n            private byte mControl;\n            private bool mNeedInitDic;\n            private bool mNeedInitState;\n            private bool mNeedInitProp;\n\n            #endregion\n\n            #region Private Methods\n\n            private bool IsUncompressedState()\n            {\n                return (mControl & LZMA2_CONTROL_LZMA) == 0;\n            }\n\n            private int GetLzmaMode()\n            {\n                return (mControl >> 5) & 3;\n            }\n\n            private static bool IsThereProp(int mode)\n            {\n                return mode >= 2;\n            }\n\n            private static uint DicSizeFromProp(byte p)\n            {\n                return (2u | (p & 1u)) << ((p >> 1) + 11);\n            }\n\n            private static SRes Lzma2Dec_GetOldProps(byte prop, P<byte> props)\n            {\n                if (prop > 40)\n                    return SZ_ERROR_UNSUPPORTED;\n\n                uint dicSize = (prop == 40) ? 0xFFFFFFFF : DicSizeFromProp(prop);\n                props[0] = (byte)LZMA2_LCLP_MAX;\n                props[1] = (byte)(dicSize);\n                props[2] = (byte)(dicSize >> 8);\n                props[3] = (byte)(dicSize >> 16);\n                props[4] = (byte)(dicSize >> 24);\n                return SZ_OK;\n            }\n\n            private Lzma2State Lzma2Dec_UpdateState(byte b)\n            {\n                switch (mState)\n                {\n                    case Lzma2State.Control:\n                        mControl = b;\n                        TR(\"Lzma2Dec_UpdateState:1\", checked((int)mDecoder.mDicPos));\n                        TR(\"Lzma2Dec_UpdateState:2\", b);\n                        DebugPrint(\"\\n {0:X4} \", mDecoder.mDicPos);\n                        DebugPrint(\" {0:X2}\", b);\n\n                        if (mControl == 0)\n                            return Lzma2State.Finished;\n\n                        if (IsUncompressedState())\n                        {\n                            if ((mControl & 0x7F) > 2)\n                                return Lzma2State.Error;\n\n                            mUnpackSize = 0;\n                        }\n                        else\n                        {\n                            mUnpackSize = (uint)(mControl & 0x1F) << 16;\n                        }\n\n                        return Lzma2State.Unpack0;\n\n                    case Lzma2State.Unpack0:\n                        mUnpackSize |= (uint)b << 8;\n                        return Lzma2State.Unpack1;\n\n                    case Lzma2State.Unpack1:\n                        mUnpackSize |= (uint)b;\n                        mUnpackSize++;\n\n                        TR(\"Lzma2Dec_UpdateState:3\", mUnpackSize);\n                        DebugPrint(\" {0:00000000}\", mUnpackSize);\n\n                        if (IsUncompressedState())\n                            return Lzma2State.Data;\n                        else\n                            return Lzma2State.Pack0;\n\n                    case Lzma2State.Pack0:\n                        mPackSize = (uint)b << 8;\n                        return Lzma2State.Pack1;\n\n                    case Lzma2State.Pack1:\n                        mPackSize |= (uint)b;\n                        mPackSize++;\n\n                        TR(\"Lzma2Dec_UpdateState:4\", mPackSize);\n                        DebugPrint(\" {0:00000000}\", mPackSize);\n\n                        if (IsThereProp(GetLzmaMode()))\n                            return Lzma2State.Prop;\n                        else if (mNeedInitProp)\n                            return Lzma2State.Error;\n                        else\n                            return Lzma2State.Data;\n\n                    case Lzma2State.Prop:\n                        if (b >= (9 * 5 * 5))\n                            return Lzma2State.Error;\n\n                        int lc = b % 9;\n                        b /= 9;\n                        mDecoder.mProp.mPB = b / 5;\n                        int lp = b % 5;\n\n                        if (lc + lp > LZMA2_LCLP_MAX)\n                            return Lzma2State.Error;\n\n                        mDecoder.mProp.mLC = lc;\n                        mDecoder.mProp.mLP = lp;\n                        mNeedInitProp = false;\n                        return Lzma2State.Data;\n\n                    default:\n                        return Lzma2State.Error;\n                }\n            }\n\n            private static void LzmaDec_UpdateWithUncompressed(CLzmaDec p, P<byte> src, long size)\n            {\n                CUtils.memcpy(p.mDic + p.mDicPos, src, size);\n                p.mDicPos += size;\n                if (p.mCheckDicSize == 0 && p.mProp.mDicSize - p.mProcessedPos <= size)\n                    p.mCheckDicSize = p.mProp.mDicSize;\n                p.mProcessedPos += (uint)size;\n            }\n\n            #endregion\n\n            #region Header\n\n            public void Lzma2Dec_Construct()\n            {\n                mDecoder.LzmaDec_Construct();\n            }\n\n            public void Lzma2Dec_FreeProbs(ISzAlloc alloc)\n            {\n                mDecoder.LzmaDec_FreeProbs(alloc);\n            }\n\n            public void Lzma2Dec_Free(ISzAlloc alloc)\n            {\n                mDecoder.LzmaDec_Free(alloc);\n            }\n\n            public SRes Lzma2Dec_AllocateProbs(byte prop, ISzAlloc alloc)\n            {\n                byte[] props = new byte[LZMA_PROPS_SIZE];\n\n                SRes res;\n                if ((res = Lzma2Dec_GetOldProps(prop, props)) != SZ_OK)\n                    return res;\n\n                return mDecoder.LzmaDec_AllocateProbs(props, LZMA_PROPS_SIZE, alloc);\n            }\n\n            public SRes Lzma2Dec_Allocate(byte prop, ISzAlloc alloc)\n            {\n                byte[] props = new byte[LZMA_PROPS_SIZE];\n\n                SRes res;\n                if ((res = Lzma2Dec_GetOldProps(prop, props)) != SZ_OK)\n                    return res;\n\n                return mDecoder.LzmaDec_Allocate(props, LZMA_PROPS_SIZE, alloc);\n            }\n\n            public void Lzma2Dec_Init()\n            {\n                mState = Lzma2State.Control;\n                mNeedInitDic = true;\n                mNeedInitState = true;\n                mNeedInitProp = true;\n                mDecoder.LzmaDec_Init();\n            }\n\n            /*\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen or dicLimit).\n              LZMA_FINISH_ANY - use smallest number of input bytes\n              LZMA_FINISH_END - read EndOfStream marker after decoding\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n                  LZMA_STATUS_NEEDS_MORE_INPUT\n              SZ_ERROR_DATA - Data error\n            */\n\n            public SRes Lzma2Dec_DecodeToDic(long dicLimit, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long inSize = srcLen;\n                srcLen = 0;\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                while (mState != Lzma2State.Finished)\n                {\n                    long dicPos = mDecoder.mDicPos;\n                    if (mState == Lzma2State.Error)\n                        return SZ_ERROR_DATA;\n\n                    if (dicPos == dicLimit && finishMode == ELzmaFinishMode.LZMA_FINISH_ANY)\n                    {\n                        status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                        return SZ_OK;\n                    }\n\n                    if (mState != Lzma2State.Data && mState != Lzma2State.DataCont)\n                    {\n                        if (srcLen == inSize)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                            return SZ_OK;\n                        }\n                        srcLen++;\n                        mState = Lzma2Dec_UpdateState(src[0]);\n                        src++;\n                        continue;\n                    }\n\n                    long destSizeCur = dicLimit - dicPos;\n                    long srcSizeCur = inSize - srcLen;\n                    ELzmaFinishMode curFinishMode = ELzmaFinishMode.LZMA_FINISH_ANY;\n\n                    if (mUnpackSize <= destSizeCur)\n                    {\n                        destSizeCur = mUnpackSize;\n                        curFinishMode = ELzmaFinishMode.LZMA_FINISH_END;\n                    }\n\n                    if (IsUncompressedState())\n                    {\n                        if (srcLen == inSize)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                            return SZ_OK;\n                        }\n\n                        if (mState == Lzma2State.Data)\n                        {\n                            bool initDic = (mControl == LZMA2_CONTROL_COPY_RESET_DIC);\n                            if (initDic)\n                                mNeedInitProp = mNeedInitState = true;\n                            else if (mNeedInitDic)\n                                return SZ_ERROR_DATA;\n\n                            mNeedInitDic = false;\n                            mDecoder.LzmaDec_InitDicAndState(initDic, false);\n                        }\n\n                        if (srcSizeCur > destSizeCur)\n                            srcSizeCur = destSizeCur;\n\n                        if (srcSizeCur == 0)\n                            return SZ_ERROR_DATA;\n\n                        LzmaDec_UpdateWithUncompressed(mDecoder, src, srcSizeCur);\n\n                        src += srcSizeCur;\n                        srcLen += srcSizeCur;\n                        mUnpackSize -= (uint)srcSizeCur;\n                        mState = (mUnpackSize == 0) ? Lzma2State.Control : Lzma2State.DataCont;\n                    }\n                    else\n                    {\n                        long outSizeProcessed;\n\n                        if (mState == Lzma2State.Data)\n                        {\n                            int mode = GetLzmaMode();\n                            bool initDic = (mode == 3);\n                            bool initState = (mode > 0);\n                            if ((!initDic && mNeedInitDic) || (!initState && mNeedInitState))\n                                return SZ_ERROR_DATA;\n\n                            mDecoder.LzmaDec_InitDicAndState(initDic, initState);\n                            mNeedInitDic = false;\n                            mNeedInitState = false;\n                            mState = Lzma2State.DataCont;\n                        }\n\n                        if (srcSizeCur > mPackSize)\n                            srcSizeCur = mPackSize;\n\n                        SRes res = mDecoder.LzmaDec_DecodeToDic(dicPos + destSizeCur, src, ref srcSizeCur, curFinishMode, out status);\n\n                        src += srcSizeCur;\n                        srcLen += srcSizeCur;\n                        mPackSize -= (uint)srcSizeCur;\n\n                        outSizeProcessed = mDecoder.mDicPos - dicPos;\n                        mUnpackSize -= (uint)outSizeProcessed;\n\n                        if (res != SZ_OK)\n                            return res;\n\n                        if (status == ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT)\n                            return res;\n\n                        if (srcSizeCur == 0 && outSizeProcessed == 0)\n                        {\n                            if (status != ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK || mUnpackSize != 0 || mPackSize != 0)\n                                return SZ_ERROR_DATA;\n\n                            mState = Lzma2State.Control;\n                        }\n\n                        if (status == ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK)\n                            status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                    }\n                }\n\n                status = ELzmaStatus.LZMA_STATUS_FINISHED_WITH_MARK;\n                return SZ_OK;\n            }\n\n            public SRes Lzma2Dec_DecodeToBuf(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                srcLen = 0;\n                destLen = 0;\n\n                for (;;)\n                {\n                    if (mDecoder.mDicPos == mDecoder.mDicBufSize)\n                        mDecoder.mDicPos = 0;\n\n                    long outSizeCur;\n                    ELzmaFinishMode curFinishMode;\n                    long dicPos = mDecoder.mDicPos;\n                    if (outSize > mDecoder.mDicBufSize - dicPos)\n                    {\n                        outSizeCur = mDecoder.mDicBufSize;\n                        curFinishMode = ELzmaFinishMode.LZMA_FINISH_ANY;\n                    }\n                    else\n                    {\n                        outSizeCur = dicPos + outSize;\n                        curFinishMode = finishMode;\n                    }\n\n                    long srcSizeCur = inSize;\n                    SRes res = Lzma2Dec_DecodeToDic(outSizeCur, src, ref srcSizeCur, curFinishMode, out status);\n                    src += srcSizeCur;\n                    inSize -= srcSizeCur;\n                    srcLen += srcSizeCur;\n                    outSizeCur = mDecoder.mDicPos - dicPos;\n                    CUtils.memcpy(dest, mDecoder.mDic + dicPos, outSizeCur);\n                    dest += outSizeCur;\n                    outSize -= outSizeCur;\n                    destLen += outSizeCur;\n\n                    if (res != 0)\n                        return res;\n\n                    if (outSizeCur == 0 || outSize == 0)\n                        return SZ_OK;\n                }\n            }\n\n            #endregion\n\n            #region Public Static Methods\n\n            /*\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen).\n              LZMA_FINISH_ANY - use smallest number of input bytes\n              LZMA_FINISH_END - read EndOfStream marker after decoding\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n              SZ_ERROR_DATA - Data error\n              SZ_ERROR_MEM  - Memory allocation error\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n              SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).\n            */\n\n            public static SRes Lzma2Decode(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, byte prop, ELzmaFinishMode finishMode, out ELzmaStatus status, ISzAlloc alloc)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                destLen = 0;\n                srcLen = 0;\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                CLzma2Dec p = new CLzma2Dec();\n                p.Lzma2Dec_Construct();\n                SRes res;\n                if ((res = p.Lzma2Dec_AllocateProbs(prop, alloc)) != SZ_OK)\n                    return res;\n                p.mDecoder.mDic = dest;\n                p.mDecoder.mDicBufSize = outSize;\n                p.Lzma2Dec_Init();\n                srcLen = inSize;\n                res = p.Lzma2Dec_DecodeToDic(outSize, src, ref srcLen, finishMode, out status);\n                destLen = p.mDecoder.mDicPos;\n                if (res == SZ_OK && status == ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT)\n                    res = SZ_ERROR_INPUT_EOF;\n                p.Lzma2Dec_FreeProbs(alloc);\n                return res;\n            }\n\n            #endregion\n        }\n    }\n    partial class LZMA\n    {\n        public sealed class CLzma2EncProps\n        {\n            #region Variables\n\n            public CLzmaEncProps mLzmaProps;\n            public long mBlockSize;\n            public int mNumBlockThreads;\n            public int mNumTotalThreads;\n\n            #endregion\n\n            #region Methods\n\n            public CLzma2EncProps() { }\n            public CLzma2EncProps(CLzma2EncProps other)\n            {\n                mLzmaProps = new CLzmaEncProps(other.mLzmaProps);\n                mBlockSize = other.mBlockSize;\n                mNumBlockThreads = other.mNumBlockThreads;\n                mNumTotalThreads = other.mNumTotalThreads;\n            }\n\n            public void Lzma2EncProps_Init()\n            {\n                mLzmaProps = CLzmaEncProps.LzmaEncProps_Init();\n                mNumTotalThreads = -1;\n                mNumBlockThreads = -1;\n                mBlockSize = 0;\n            }\n\n            public void Lzma2EncProps_Normalize()\n            {\n                CLzmaEncProps normalizedLzmaProps = new CLzmaEncProps(mLzmaProps);\n                normalizedLzmaProps.LzmaEncProps_Normalize();\n                int tempThreadsNormalized = normalizedLzmaProps.mNumThreads;\n                int tempThreads = mLzmaProps.mNumThreads;\n                int tempBlockThreads = mNumBlockThreads;\n                int tempTotalThreads = mNumTotalThreads;\n\n                if (tempBlockThreads > NUM_MT_CODER_THREADS_MAX)\n                    tempBlockThreads = NUM_MT_CODER_THREADS_MAX;\n\n                if (tempTotalThreads <= 0)\n                {\n                    if (tempBlockThreads <= 0)\n                        tempBlockThreads = 1;\n\n                    tempTotalThreads = tempThreadsNormalized * tempBlockThreads;\n                }\n                else if (tempBlockThreads <= 0)\n                {\n                    tempBlockThreads = tempTotalThreads / tempThreadsNormalized;\n\n                    if (tempBlockThreads == 0)\n                    {\n                        tempThreads = 1;\n                        tempBlockThreads = tempTotalThreads;\n                    }\n\n                    if (tempBlockThreads > NUM_MT_CODER_THREADS_MAX)\n                        tempBlockThreads = NUM_MT_CODER_THREADS_MAX;\n                }\n                else if (tempThreads <= 0)\n                {\n                    tempThreads = tempTotalThreads / tempBlockThreads;\n                    if (tempThreads == 0)\n                        tempThreads = 1;\n                }\n                else\n                {\n                    tempTotalThreads = tempThreadsNormalized * tempBlockThreads;\n                }\n\n                mLzmaProps.mNumThreads = tempThreads;\n                mNumBlockThreads = tempBlockThreads;\n                mNumTotalThreads = tempTotalThreads;\n                mLzmaProps.LzmaEncProps_Normalize();\n\n                if (mBlockSize == 0)\n                {\n                    uint dictSize = mLzmaProps.mDictSize;\n                    long blockSize = (long)dictSize << 2;\n\n                    const uint kMinSize = 1 << 20;\n                    const uint kMaxSize = 1 << 28;\n\n                    if (blockSize < kMinSize)\n                        blockSize = kMinSize;\n\n                    if (blockSize > kMaxSize)\n                        blockSize = kMaxSize;\n\n                    if (blockSize < dictSize)\n                        blockSize = dictSize;\n\n                    mBlockSize = blockSize;\n                }\n            }\n\n            #endregion\n        }\n\n        internal sealed class CLzma2EncInternal\n        {\n            #region Constants\n\n            private const int LZMA2_CONTROL_LZMA = (1 << 7);\n            private const int LZMA2_CONTROL_COPY_NO_RESET = 2;\n            private const int LZMA2_CONTROL_COPY_RESET_DIC = 1;\n            private const int LZMA2_CONTROL_EOF = 0;\n\n            private const int LZMA2_PACK_SIZE_MAX = (1 << 16);\n            private const int LZMA2_COPY_CHUNK_SIZE = LZMA2_PACK_SIZE_MAX;\n            private const int LZMA2_UNPACK_SIZE_MAX = (1 << 21);\n            internal const int LZMA2_KEEP_WINDOW_SIZE = LZMA2_UNPACK_SIZE_MAX;\n\n            private const int LZMA2_CHUNK_SIZE_COMPRESSED_MAX = ((1 << 16) + 16);\n\n            #endregion\n\n            #region Variables\n\n            internal CLzmaEnc mEnc;\n            internal ulong mSrcPos;\n            internal byte mProps;\n            internal bool mNeedInitState;\n            internal bool mNeedInitProp;\n\n            #endregion\n\n            #region Internal Methods\n\n            internal SRes Lzma2EncInt_Init(CLzma2EncProps props)\n            {\n                byte[] propsEncoded = new byte[LZMA_PROPS_SIZE];\n                long propsSize = LZMA_PROPS_SIZE;\n\n                SRes res;\n                if ((res = mEnc.LzmaEnc_SetProps(props.mLzmaProps)) != SZ_OK)\n                    return res;\n\n                if ((res = mEnc.LzmaEnc_WriteProperties(propsEncoded, ref propsSize)) != SZ_OK)\n                    return res;\n\n                mSrcPos = 0;\n                mProps = propsEncoded[0];\n                mNeedInitState = true;\n                mNeedInitProp = true;\n                return SZ_OK;\n            }\n\n            internal SRes Lzma2EncInt_EncodeSubblock(P<byte> outBuf, ref long packSizeRes, ISeqOutStream outStream)\n            {\n                long packSizeLimit = packSizeRes;\n                long packSize = packSizeLimit;\n                uint unpackSize = LZMA2_UNPACK_SIZE_MAX;\n                uint lzHeaderSize = 5u + (mNeedInitProp ? 1u : 0u);\n\n                packSizeRes = 0;\n                if (packSize < lzHeaderSize)\n                    return SZ_ERROR_OUTPUT_EOF;\n                packSize -= lzHeaderSize;\n\n                mEnc.LzmaEnc_SaveState();\n                SRes res = mEnc.LzmaEnc_CodeOneMemBlock(mNeedInitState, outBuf + lzHeaderSize, ref packSize, LZMA2_PACK_SIZE_MAX, ref unpackSize);\n\n                TR(\"Lzma2EncInt_EncodeSubblock:packSize\", checked((int)packSize));\n                TR(\"Lzma2EncInt_EncodeSubblock:unpackSize\", unpackSize);\n                DebugPrint(\"\\npackSize = {0:0000000} unpackSize = {1:0000000}  \", packSize, unpackSize);\n\n                if (unpackSize == 0)\n                    return res;\n\n                bool useCopyBlock;\n                if (res == SZ_OK)\n                    useCopyBlock = (packSize + 2 >= unpackSize || packSize > (1 << 16));\n                else\n                {\n                    if (res != SZ_ERROR_OUTPUT_EOF)\n                        return res;\n                    res = SZ_OK;\n                    useCopyBlock = true;\n                }\n\n                if (useCopyBlock)\n                {\n                    long destPos = 0;\n                    DebugPrint(\"################# COPY           \");\n\n                    while (unpackSize > 0)\n                    {\n                        uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;\n                        if (packSizeLimit - destPos < u + 3)\n                            return SZ_ERROR_OUTPUT_EOF;\n\n                        outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);\n                        outBuf[destPos++] = (byte)((u - 1) >> 8);\n                        outBuf[destPos++] = (byte)(u - 1);\n\n                        CUtils.memcpy(outBuf + destPos, mEnc.LzmaEnc_GetCurBuf() - unpackSize, u);\n\n                        unpackSize -= u;\n                        destPos += u;\n                        mSrcPos += u;\n\n                        if (outStream != null)\n                        {\n                            packSizeRes += destPos;\n                            if (outStream.Write(outBuf, destPos) != destPos)\n                                return SZ_ERROR_WRITE;\n                            destPos = 0;\n                        }\n                        else\n                        {\n                            packSizeRes = destPos;\n                        }\n\n                        /* needInitState = true; */\n                    }\n\n                    mEnc.LzmaEnc_RestoreState();\n                    return SZ_OK;\n                }\n                else\n                {\n                    long destPos = 0;\n                    uint u = unpackSize - 1;\n                    uint pm = (uint)(packSize - 1);\n\n                    uint mode;\n                    if (mSrcPos == 0)\n                        mode = 3;\n                    else if (!mNeedInitState)\n                        mode = 0;\n                    else if (!mNeedInitProp)\n                        mode = 1;\n                    else\n                        mode = 2;\n\n                    DebugPrint(\"               \");\n\n                    outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));\n                    outBuf[destPos++] = (byte)(u >> 8);\n                    outBuf[destPos++] = (byte)u;\n                    outBuf[destPos++] = (byte)(pm >> 8);\n                    outBuf[destPos++] = (byte)pm;\n\n                    if (mNeedInitProp)\n                        outBuf[destPos++] = mProps;\n\n                    mNeedInitProp = false;\n                    mNeedInitState = false;\n                    destPos += packSize;\n                    mSrcPos += unpackSize;\n\n                    if (outStream != null && outStream.Write(outBuf, destPos) != destPos)\n                        return SZ_ERROR_WRITE;\n\n                    packSizeRes = destPos;\n                    return SZ_OK;\n                }\n            }\n\n            private static SRes Progress(ICompressProgress p, ulong inSize, ulong outSize)\n            {\n                return (p != null && p.Progress(inSize, outSize) != SZ_OK) ? SZ_ERROR_PROGRESS : SZ_OK;\n            }\n\n            internal SRes Lzma2Enc_EncodeMt1(CLzma2Enc mainEncoder, ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress)\n            {\n                ulong packTotal = 0;\n                SRes res = SZ_OK;\n\n                if (mainEncoder.mOutBuf == null)\n                {\n                    mainEncoder.mOutBuf = IAlloc_AllocBytes(mainEncoder.mAlloc, LZMA2_CHUNK_SIZE_COMPRESSED_MAX);\n                    if (mainEncoder.mOutBuf == null)\n                        return SZ_ERROR_MEM;\n                }\n\n                if ((res = Lzma2EncInt_Init(mainEncoder.mProps)) != SZ_OK)\n                    return res;\n\n                if ((res = mEnc.LzmaEnc_PrepareForLzma2(inStream, LZMA2_KEEP_WINDOW_SIZE, mainEncoder.mAlloc, mainEncoder.mAllocBig)) != SZ_OK)\n                    return res;\n\n                for (;;)\n                {\n                    long packSize = LZMA2_CHUNK_SIZE_COMPRESSED_MAX;\n                    res = Lzma2EncInt_EncodeSubblock(mainEncoder.mOutBuf, ref packSize, outStream);\n                    if (res != SZ_OK)\n                        break;\n                    packTotal += (ulong)packSize;\n                    res = Progress(progress, mSrcPos, packTotal);\n                    if (res != SZ_OK)\n                        break;\n                    if (packSize == 0)\n                        break;\n                }\n\n                mEnc.LzmaEnc_Finish();\n\n                if (res == SZ_OK)\n                {\n                    if (outStream.Write(new byte[] { 0 }, 1) != 1)\n                        return SZ_ERROR_WRITE;\n                }\n\n                return res;\n            }\n\n            #endregion\n        }\n\n        /* ---------- CLzmaEnc2Handle Interface ---------- */\n\n        /* Lzma2Enc_* functions can return the following exit codes:\n        Returns:\n          SZ_OK           - OK\n          SZ_ERROR_MEM    - Memory allocation error\n          SZ_ERROR_PARAM  - Incorrect paramater in props\n          SZ_ERROR_WRITE  - Write callback error\n          SZ_ERROR_PROGRESS - some break from progress callback\n          SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)\n        */\n\n        public sealed class CLzma2Enc\n        {\n            private const int LZMA2_LCLP_MAX = 4;\n\n            #region Variables\n\n            internal CLzma2EncProps mProps = new CLzma2EncProps();\n\n            internal byte[] mOutBuf;\n\n            internal ISzAlloc mAlloc;\n            internal ISzAlloc mAllocBig;\n\n            internal CLzma2EncInternal[] mCoders;\n\n#if !_7ZIP_ST\n            internal CMtCoder mMtCoder;\n#endif\n\n            #endregion\n\n            #region Public Methods\n\n            public CLzma2Enc(ISzAlloc alloc, ISzAlloc allocBig) // Lzma2Enc_Create\n            {\n                Trace.AllocSmallObject(\"CLzma2Enc\", alloc);\n\n                mProps.Lzma2EncProps_Init();\n                mProps.Lzma2EncProps_Normalize();\n                mOutBuf = null;\n                mAlloc = alloc;\n                mAllocBig = allocBig;\n\n                mCoders = new CLzma2EncInternal[NUM_MT_CODER_THREADS_MAX];\n                for (int i = 0; i < mCoders.Length; i++)\n                {\n                    mCoders[i] = new CLzma2EncInternal();\n                    mCoders[i].mEnc = null;\n                }\n\n#if !_7ZIP_ST\n                mMtCoder = new CMtCoder();\n#endif\n            }\n\n            public void Lzma2Enc_Destroy()\n            {\n                for (uint i = 0; i < mCoders.Length; i++)\n                {\n                    CLzma2EncInternal t = mCoders[i];\n                    if (t.mEnc != null)\n                    {\n                        t.mEnc.LzmaEnc_Destroy(mAlloc, mAllocBig);\n                        t.mEnc = null;\n                    }\n                }\n\n#if !_7ZIP_ST\n                mMtCoder.MtCoder_Destruct();\n#endif\n\n                IAlloc_FreeBytes(mAlloc, mOutBuf);\n                IAlloc_FreeObject(mAlloc, this);\n            }\n\n            public SRes Lzma2Enc_SetProps(CLzma2EncProps props)\n            {\n                TR(\"Lzma2Enc_SetProps:level\", props.mLzmaProps.mLevel);\n                TR(\"Lzma2Enc_SetProps:dictSize\", props.mLzmaProps.mDictSize);\n                TR(\"Lzma2Enc_SetProps:lc\", props.mLzmaProps.mLC);\n                TR(\"Lzma2Enc_SetProps:lp\", props.mLzmaProps.mLP);\n                TR(\"Lzma2Enc_SetProps:pb\", props.mLzmaProps.mPB);\n                TR(\"Lzma2Enc_SetProps:algo\", props.mLzmaProps.mAlgo);\n                TR(\"Lzma2Enc_SetProps:fb\", props.mLzmaProps.mFB);\n                TR(\"Lzma2Enc_SetProps:btMode\", props.mLzmaProps.mBtMode);\n                TR(\"Lzma2Enc_SetProps:numHashBytes\", props.mLzmaProps.mNumHashBytes);\n                TR(\"Lzma2Enc_SetProps:mc\", props.mLzmaProps.mMC);\n                TR(\"Lzma2Enc_SetProps:writeEndMark\", props.mLzmaProps.mWriteEndMark);\n                TR(\"Lzma2Enc_SetProps:numThreads\", props.mLzmaProps.mNumThreads);\n                TR(\"Lzma2Enc_SetProps:blockSize\", checked((int)props.mBlockSize));\n                TR(\"Lzma2Enc_SetProps:numBlockThreads\", props.mNumBlockThreads);\n                TR(\"Lzma2Enc_SetProps:numTotalThreads\", props.mNumTotalThreads);\n\n                CLzmaEncProps lzmaProps = new CLzmaEncProps(props.mLzmaProps);\n                lzmaProps.LzmaEncProps_Normalize();\n                if (lzmaProps.mLC + lzmaProps.mLP > LZMA2_LCLP_MAX)\n                    return SZ_ERROR_PARAM;\n\n                mProps = new CLzma2EncProps(props);\n                mProps.Lzma2EncProps_Normalize();\n                return SZ_OK;\n            }\n\n            private static uint LZMA2_DIC_SIZE_FROM_PROP(int p)\n            {\n                return (uint)(2 | (p & 1)) << (p / 2 + 11);\n            }\n\n            public byte Lzma2Enc_WriteProperties()\n            {\n                uint dicSize = mProps.mLzmaProps.LzmaEncProps_GetDictSize();\n\n                int i = 0;\n                while (i < 40 && dicSize > LZMA2_DIC_SIZE_FROM_PROP(i))\n                    i++;\n\n                TR(\"Lzma2Enc_WriteProperties\", i);\n                return (byte)i;\n            }\n\n            public SRes Lzma2Enc_Encode(ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress)\n            {\n                for (int i = 0; i < mProps.mNumBlockThreads; i++)\n                {\n                    CLzma2EncInternal t = mCoders[i];\n                    if (t.mEnc == null)\n                    {\n                        t.mEnc = LzmaEnc_Create(mAlloc);\n                        if (t.mEnc == null)\n                            return SZ_ERROR_MEM;\n                    }\n                }\n\n#if !_7ZIP_ST\n                if (mProps.mNumBlockThreads <= 1)\n#endif\n                    return mCoders[0].Lzma2Enc_EncodeMt1(this, outStream, inStream, progress);\n\n#if !_7ZIP_ST\n                mMtCoder.mProgress = progress;\n                mMtCoder.mInStream = inStream;\n                mMtCoder.mOutStream = outStream;\n                mMtCoder.mAlloc = mAlloc;\n                mMtCoder.mMtCallback = new CMtCallbackImp(this);\n\n                mMtCoder.mBlockSize = mProps.mBlockSize;\n                mMtCoder.mDestBlockSize = mProps.mBlockSize + (mProps.mBlockSize >> 10) + 16;\n                mMtCoder.mNumThreads = mProps.mNumBlockThreads;\n\n                return mMtCoder.MtCoder_Code();\n#endif\n            }\n\n            #endregion\n        }\n\n#if !_7ZIP_ST\n        internal sealed class CMtCallbackImp\n        {\n            #region Implementation\n\n            private CLzma2Enc mLzma2Enc;\n\n            internal CMtCallbackImp(CLzma2Enc enc)\n            {\n                mLzma2Enc = enc;\n            }\n\n            internal SRes Code(int index, P<byte> dest, ref long destSize, P<byte> src, long srcSize, bool finished)\n            {\n                CLzma2EncInternal p = mLzma2Enc.mCoders[index];\n\n                SRes res = SZ_OK;\n                long destLim = destSize;\n                destSize = 0;\n\n                if (srcSize != 0)\n                {\n                    if ((res = p.Lzma2EncInt_Init(mLzma2Enc.mProps)) != SZ_OK)\n                        return res;\n\n                    if ((res = p.mEnc.LzmaEnc_MemPrepare(src, srcSize, CLzma2EncInternal.LZMA2_KEEP_WINDOW_SIZE, mLzma2Enc.mAlloc, mLzma2Enc.mAllocBig)) != SZ_OK)\n                        return res;\n\n                    while (p.mSrcPos < (ulong)srcSize)\n                    {\n                        long packSize = destLim - destSize;\n\n                        res = p.Lzma2EncInt_EncodeSubblock(dest + destSize, ref packSize, null);\n                        if (res != SZ_OK)\n                            break;\n\n                        destSize += packSize;\n\n                        if (packSize == 0)\n                        {\n                            res = SZ_ERROR_FAIL;\n                            break;\n                        }\n\n                        if (mLzma2Enc.mMtCoder.mMtProgress.MtProgress_Set(index, p.mSrcPos, (ulong)destSize) != SZ_OK)\n                        {\n                            res = SZ_ERROR_PROGRESS;\n                            break;\n                        }\n                    }\n\n                    p.mEnc.LzmaEnc_Finish();\n                    if (res != SZ_OK)\n                        return res;\n                }\n\n                if (finished)\n                {\n                    if (destSize == destLim)\n                        return SZ_ERROR_OUTPUT_EOF;\n\n                    dest[destSize++] = 0;\n                }\n\n                return res;\n            }\n\n            #endregion\n        }\n#endif\n    }\n    partial class LZMA\n    {\n        /* ---------- LZMA Properties ---------- */\n\n        public sealed class CLzmaProps\n        {\n            private const int LZMA_DIC_MIN = (1 << 12);\n\n            #region Variables\n\n            public int mLC;\n            public int mLP;\n            public int mPB;\n            public uint mDicSize;\n\n            #endregion\n\n            #region Methods\n\n            public CLzmaProps() { }\n            public CLzmaProps(CLzmaProps other)\n            {\n                this.mLC = other.mLC;\n                this.mLP = other.mLP;\n                this.mPB = other.mPB;\n                this.mDicSize = other.mDicSize;\n            }\n\n            /* LzmaProps_Decode - decodes properties\n            Returns:\n              SZ_OK\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n            */\n\n            public SRes LzmaProps_Decode(P<byte> data, uint size)\n            {\n                if (size < LZMA_PROPS_SIZE)\n                    return SZ_ERROR_UNSUPPORTED;\n\n                uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);\n                if (dicSize < LZMA_DIC_MIN)\n                    dicSize = LZMA_DIC_MIN;\n                mDicSize = dicSize;\n\n                byte d = data[0];\n                if (d >= (9 * 5 * 5))\n                    return SZ_ERROR_UNSUPPORTED;\n\n                mLC = d % 9;\n                d /= 9;\n                mPB = d / 5;\n                mLP = d % 5;\n\n                return SZ_OK;\n            }\n\n            #endregion\n        }\n\n\n        /* ---------- LZMA Decoder state ---------- */\n\n        /* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.\n           Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */\n\n        public const int LZMA_REQUIRED_INPUT_MAX = 20;\n\n        public sealed class CLzmaDec\n        {\n            #region Constants\n\n            private enum ELzmaDummy\n            {\n                DUMMY_ERROR, /* unexpected end of input stream */\n                DUMMY_LIT,\n                DUMMY_MATCH,\n                DUMMY_REP,\n            }\n\n            private const int kNumTopBits = 24;\n            private const uint kTopValue = (1u << kNumTopBits);\n\n            private const int kNumBitModelTotalBits = 11;\n            private const int kBitModelTotal = (1 << kNumBitModelTotalBits);\n            private const int kNumMoveBits = 5;\n\n            private const int RC_INIT_SIZE = 5;\n\n            private const int kNumPosBitsMax = 4;\n            private const int kNumPosStatesMax = (1 << kNumPosBitsMax);\n\n            private const int kLenNumLowBits = 3;\n            private const int kLenNumLowSymbols = (1 << kLenNumLowBits);\n            private const int kLenNumMidBits = 3;\n            private const int kLenNumMidSymbols = (1 << kLenNumMidBits);\n            private const int kLenNumHighBits = 8;\n            private const int kLenNumHighSymbols = (1 << kLenNumHighBits);\n\n            private const int kLenChoice = 0;\n            private const int kLenChoice2 = (kLenChoice + 1);\n            private const int kLenLow = (kLenChoice2 + 1);\n            private const int kLenMid = (kLenLow + (kNumPosStatesMax << kLenNumLowBits));\n            private const int kLenHigh = (kLenMid + (kNumPosStatesMax << kLenNumMidBits));\n            private const int kNumLenProbs = (kLenHigh + kLenNumHighSymbols);\n\n\n            private const int kNumStates = 12;\n            private const uint kNumLitStates = 7;\n\n            private const int kStartPosModelIndex = 4;\n            private const int kEndPosModelIndex = 14;\n            private const int kNumFullDistances = (1 << (kEndPosModelIndex >> 1));\n\n            private const int kNumPosSlotBits = 6;\n            private const int kNumLenToPosStates = 4;\n\n            private const int kNumAlignBits = 4;\n            private const int kAlignTableSize = (1 << kNumAlignBits);\n\n            private const int kMatchMinLen = 2;\n            private const int kMatchSpecLenStart = (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols);\n\n            private const int kIsMatch = 0;\n            private const int kIsRep = (kIsMatch + (kNumStates << kNumPosBitsMax));\n            private const int kIsRepG0 = (kIsRep + kNumStates);\n            private const int kIsRepG1 = (kIsRepG0 + kNumStates);\n            private const int kIsRepG2 = (kIsRepG1 + kNumStates);\n            private const int kIsRep0Long = (kIsRepG2 + kNumStates);\n            private const int kPosSlot = (kIsRep0Long + (kNumStates << kNumPosBitsMax));\n            private const int kSpecPos = (kPosSlot + (kNumLenToPosStates << kNumPosSlotBits));\n            private const int kAlign = (kSpecPos + kNumFullDistances - kEndPosModelIndex);\n            private const int kLenCoder = (kAlign + kAlignTableSize);\n            private const int kRepLenCoder = (kLenCoder + kNumLenProbs);\n            private const int kLiteral = (kRepLenCoder + kNumLenProbs);\n\n            private const uint LZMA_BASE_SIZE = 1846;\n            private const uint LZMA_LIT_SIZE = 768;\n\n            #endregion\n\n            #region Variables\n\n            internal CLzmaProps mProp = new CLzmaProps();\n            internal ushort[] mProbs;\n            internal P<byte> mDic;\n            internal P<byte> mBuf;\n            internal uint mRange, mCode;\n            internal long mDicPos;\n            internal long mDicBufSize;\n            internal uint mProcessedPos;\n            internal uint mCheckDicSize;\n            internal uint mState;\n            internal uint[] mReps = new uint[4];\n            internal uint mRemainLen;\n            internal bool mNeedFlush;\n            internal bool mNeedInitState;\n            internal uint mNumProbs;\n            internal uint mTempBufSize;\n            internal byte[] mTempBuf = new byte[LZMA_REQUIRED_INPUT_MAX];\n\n            #endregion\n\n            #region Public Methods\n\n            public void LzmaDec_Construct()\n            {\n                //#if Literal != LZMA_BASE_SIZE\n                //StopCompilingDueBUG\n                //#endif\n\n                mDic = null;\n                mProbs = null;\n            }\n\n            public void LzmaDec_Init()\n            {\n                mDicPos = 0;\n                LzmaDec_InitDicAndState(true, true);\n            }\n\n            /* ---------- Interfaces ---------- */\n\n            /* There are 3 levels of interfaces:\n                 1) Dictionary Interface\n                 2) Buffer Interface\n                 3) One Call Interface\n               You can select any of these interfaces, but don't mix functions from different\n               groups for same object. */\n\n\n            /* There are two variants to allocate state for Dictionary Interface:\n                 1) LzmaDec_Allocate / LzmaDec_Free\n                 2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs\n               You can use variant 2, if you set dictionary buffer manually.\n               For Buffer Interface you must always use variant 1.\n\n            LzmaDec_Allocate* can return:\n              SZ_OK\n              SZ_ERROR_MEM         - Memory allocation error\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n            */\n\n            public SRes LzmaDec_AllocateProbs(P<byte> props, uint propsSize, ISzAlloc alloc)\n            {\n                SRes res;\n                CLzmaProps propNew = new CLzmaProps();\n                if ((res = propNew.LzmaProps_Decode(props, propsSize)) != SZ_OK) return res;\n                if ((res = LzmaDec_AllocateProbs2(propNew, alloc)) != SZ_OK) return res;\n                mProp = new CLzmaProps(propNew);\n                return SZ_OK;\n            }\n\n            public void LzmaDec_FreeProbs(ISzAlloc alloc)\n            {\n                alloc.FreeUInt16(alloc, mProbs);\n                mProbs = null;\n            }\n\n            public SRes LzmaDec_Allocate(P<byte> props, uint propsSize, ISzAlloc alloc)\n            {\n                CLzmaProps propNew = new CLzmaProps();\n\n                SRes res;\n                if ((res = propNew.LzmaProps_Decode(props, propsSize)) != SZ_OK)\n                    return res;\n\n                if ((res = LzmaDec_AllocateProbs2(propNew, alloc)) != SZ_OK)\n                    return res;\n\n                long dicBufSize = propNew.mDicSize;\n                if (mDic == null || dicBufSize != mDicBufSize)\n                {\n                    LzmaDec_FreeDict(alloc);\n                    mDic = alloc.AllocBytes(alloc, dicBufSize);\n                    if (mDic == null)\n                    {\n                        LzmaDec_FreeProbs(alloc);\n                        return SZ_ERROR_MEM;\n                    }\n                }\n\n                mDicBufSize = dicBufSize;\n                mProp = new CLzmaProps(propNew);\n                return SZ_OK;\n            }\n\n            public void LzmaDec_Free(ISzAlloc alloc)\n            {\n                LzmaDec_FreeProbs(alloc);\n                LzmaDec_FreeDict(alloc);\n            }\n\n            /* ---------- Dictionary Interface ---------- */\n\n            /* You can use it, if you want to eliminate the overhead for data copying from\n               dictionary to some other external buffer.\n               You must work with CLzmaDec variables directly in this interface.\n\n               STEPS:\n                 LzmaDec_Constr()\n                 LzmaDec_Allocate()\n                 for (each new stream)\n                 {\n                   LzmaDec_Init()\n                   while (it needs more decompression)\n                   {\n                     LzmaDec_DecodeToDic()\n                     use data from CLzmaDec::dic and update CLzmaDec::dicPos\n                   }\n                 }\n                 LzmaDec_Free()\n            */\n\n            /* LzmaDec_DecodeToDic\n   \n               The decoding to internal dictionary buffer (CLzmaDec::dic).\n               You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!\n\n            finishMode:\n              It has meaning only if the decoding reaches output limit (dicLimit).\n              LZMA_FINISH_ANY - Decode just dicLimit bytes.\n              LZMA_FINISH_END - Stream must be finished after dicLimit.\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n                  LZMA_STATUS_NEEDS_MORE_INPUT\n                  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK\n              SZ_ERROR_DATA - Data error\n            */\n\n            public SRes LzmaDec_DecodeToDic(long dicLimit, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long inSize = srcLen;\n                srcLen = 0;\n\n                LzmaDec_WriteRem(dicLimit);\n\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                while (mRemainLen != kMatchSpecLenStart)\n                {\n                    if (mNeedFlush)\n                    {\n                        while (inSize > 0 && mTempBufSize < RC_INIT_SIZE)\n                        {\n                            mTempBuf[mTempBufSize] = src[0];\n                            mTempBufSize++;\n                            src++;\n                            srcLen++;\n                            inSize--;\n                        }\n\n                        if (mTempBufSize < RC_INIT_SIZE)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                            return SZ_OK;\n                        }\n\n                        if (mTempBuf[0] != 0)\n                            return SZ_ERROR_DATA;\n\n                        LzmaDec_InitRc(mTempBuf);\n                        mTempBufSize = 0;\n                    }\n\n                    bool checkEndMarkNow = false;\n\n                    if (mDicPos >= dicLimit)\n                    {\n                        if (mRemainLen == 0 && mCode == 0)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n                            return SZ_OK;\n                        }\n\n                        if (finishMode == ELzmaFinishMode.LZMA_FINISH_ANY)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                            return SZ_OK;\n                        }\n\n                        if (mRemainLen != 0)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                            return SZ_ERROR_DATA;\n                        }\n\n                        checkEndMarkNow = true;\n                    }\n\n                    if (mNeedInitState)\n                        LzmaDec_InitStateReal();\n\n                    if (mTempBufSize == 0)\n                    {\n                        P<byte> bufLimit;\n                        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)\n                        {\n                            ELzmaDummy dummyRes = LzmaDec_TryDummy(src, inSize);\n\n                            if (dummyRes == ELzmaDummy.DUMMY_ERROR)\n                            {\n                                CUtils.memcpy(mTempBuf, src, inSize);\n                                mTempBufSize = (uint)inSize;\n                                srcLen += inSize;\n                                status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                                return SZ_OK;\n                            }\n\n                            if (checkEndMarkNow && dummyRes != ELzmaDummy.DUMMY_MATCH)\n                            {\n                                status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                                return SZ_ERROR_DATA;\n                            }\n\n                            bufLimit = src;\n                        }\n                        else\n                        {\n                            bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;\n                        }\n\n                        mBuf = src;\n\n                        if (LzmaDec_DecodeReal2(dicLimit, bufLimit) != 0)\n                            return SZ_ERROR_DATA;\n\n                        long processed = mBuf - src;\n                        srcLen += processed;\n                        src += processed;\n                        inSize -= processed;\n                    }\n                    else\n                    {\n                        uint rem = mTempBufSize;\n                        uint lookAhead = 0;\n\n                        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)\n                            mTempBuf[rem++] = src[lookAhead++];\n\n                        mTempBufSize = rem;\n\n                        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)\n                        {\n                            ELzmaDummy dummyRes = LzmaDec_TryDummy(mTempBuf, rem);\n\n                            if (dummyRes == ELzmaDummy.DUMMY_ERROR)\n                            {\n                                srcLen += lookAhead;\n                                status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                                return SZ_OK;\n                            }\n\n                            if (checkEndMarkNow && dummyRes != ELzmaDummy.DUMMY_MATCH)\n                            {\n                                status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                                return SZ_ERROR_DATA;\n                            }\n                        }\n\n                        mBuf = mTempBuf;\n\n                        if (LzmaDec_DecodeReal2(dicLimit, mBuf) != 0)\n                            return SZ_ERROR_DATA;\n\n                        lookAhead -= rem - (uint)(mBuf - mTempBuf);\n                        srcLen += lookAhead;\n                        src += lookAhead;\n                        inSize -= lookAhead;\n                        mTempBufSize = 0;\n                    }\n                }\n\n                if (mCode != 0)\n                    return SZ_ERROR_DATA;\n\n                status = ELzmaStatus.LZMA_STATUS_FINISHED_WITH_MARK;\n                return SZ_OK;\n            }\n\n\n            /* ---------- Buffer Interface ---------- */\n\n            /* It's zlib-like interface.\n               See LzmaDec_DecodeToDic description for information about STEPS and return results,\n               but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need\n               to work with CLzmaDec variables manually.\n\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen).\n              LZMA_FINISH_ANY - Decode just destLen bytes.\n              LZMA_FINISH_END - Stream must be finished after (*destLen).\n            */\n\n            public SRes LzmaDec_DecodeToBuf(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                srcLen = destLen = 0;\n                for (;;)\n                {\n                    long inSizeCur = inSize;\n\n                    if (mDicPos == mDicBufSize)\n                        mDicPos = 0;\n                    long dicPos = mDicPos;\n\n                    long outSizeCur;\n                    ELzmaFinishMode curFinishMode;\n                    if (outSize > mDicBufSize - dicPos)\n                    {\n                        outSizeCur = mDicBufSize;\n                        curFinishMode = ELzmaFinishMode.LZMA_FINISH_ANY;\n                    }\n                    else\n                    {\n                        outSizeCur = dicPos + outSize;\n                        curFinishMode = finishMode;\n                    }\n\n                    SRes res = LzmaDec_DecodeToDic(outSizeCur, src, ref inSizeCur, curFinishMode, out status);\n                    src += inSizeCur;\n                    inSize -= inSizeCur;\n                    srcLen += inSizeCur;\n                    outSizeCur = mDicPos - dicPos;\n                    CUtils.memcpy(dest, mDic + dicPos, outSizeCur);\n                    dest += outSizeCur;\n                    outSize -= outSizeCur;\n                    destLen += outSizeCur;\n                    if (res != SZ_OK)\n                        return res;\n                    if (outSizeCur == 0 || outSize == 0)\n                        return SZ_OK;\n                }\n            }\n\n\n            /* ---------- One Call Interface ---------- */\n\n            /* LzmaDecode\n\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen).\n              LZMA_FINISH_ANY - Decode just destLen bytes.\n              LZMA_FINISH_END - Stream must be finished after (*destLen).\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n                  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK\n              SZ_ERROR_DATA - Data error\n              SZ_ERROR_MEM  - Memory allocation error\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n              SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).\n            */\n\n            public static SRes LzmaDecode(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, P<byte> propData, uint propSize, ELzmaFinishMode finishMode, out ELzmaStatus status, ISzAlloc alloc)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                destLen = 0;\n                srcLen = 0;\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                if (inSize < RC_INIT_SIZE)\n                    return SZ_ERROR_INPUT_EOF;\n\n                CLzmaDec decoder = new CLzmaDec();\n                decoder.LzmaDec_Construct();\n\n                SRes res;\n                if ((res = decoder.LzmaDec_AllocateProbs(propData, propSize, alloc)) != SZ_OK)\n                    return res;\n\n                decoder.mDic = dest;\n                decoder.mDicBufSize = outSize;\n                decoder.LzmaDec_Init();\n                srcLen = inSize;\n\n                res = decoder.LzmaDec_DecodeToDic(outSize, src, ref srcLen, finishMode, out status);\n\n                destLen = decoder.mDicPos;\n\n                if (res == SZ_OK && status == ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT)\n                    res = SZ_ERROR_INPUT_EOF;\n\n                decoder.LzmaDec_FreeProbs(alloc);\n                return res;\n            }\n\n            #endregion\n\n            #region Internal Methods\n\n            internal void LzmaDec_InitDicAndState(bool initDic, bool initState)\n            {\n                mNeedFlush = true;\n                mRemainLen = 0;\n                mTempBufSize = 0;\n\n                if (initDic)\n                {\n                    mProcessedPos = 0;\n                    mCheckDicSize = 0;\n                    mNeedInitState = true;\n                }\n\n                if (initState)\n                    mNeedInitState = true;\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            /* First LZMA-symbol is always decoded.\n            And it decodes new LZMA-symbols while (buf < bufLimit), but \"buf\" is without last normalization\n            Out:\n              Result:\n                SZ_OK - OK\n                SZ_ERROR_DATA - Error\n              p.remainLen:\n                < kMatchSpecLenStart : normal remain\n                = kMatchSpecLenStart : finished\n                = kMatchSpecLenStart + 1 : Flush marker\n                = kMatchSpecLenStart + 2 : State Init Marker\n            */\n\n            private SRes LzmaDec_DecodeReal(long limit, P<byte> bufLimit)\n            {\n                P<ushort> probs = mProbs;\n\n                uint state = mState;\n                uint rep0 = mReps[0];\n                uint rep1 = mReps[1];\n                uint rep2 = mReps[2];\n                uint rep3 = mReps[3];\n                uint pbMask = (1u << mProp.mPB) - 1;\n                uint lpMask = (1u << mProp.mLP) - 1;\n                int lc = mProp.mLC;\n\n                P<byte> dic = mDic;\n                long dicBufSize = mDicBufSize;\n                long dicPos = mDicPos;\n\n                uint processedPos = mProcessedPos;\n                uint checkDicSize = mCheckDicSize;\n                uint len = 0;\n\n                P<byte> buf = mBuf;\n                uint range = mRange;\n                uint code = mCode;\n\n                do\n                {\n                    uint bound;\n                    uint ttt;\n                    uint posState = processedPos & pbMask;\n\n                    P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;\n                    if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                    {\n                        _UPDATE_0(prob, ttt, bound, ref range);\n                        prob = probs + kLiteral;\n                        if (checkDicSize != 0 || processedPos != 0)\n                            prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)\n                                + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));\n\n                        uint symbol;\n                        if (state < kNumLitStates)\n                        {\n                            state -= (state < 4) ? state : 3;\n                            symbol = 1;\n                            do { _GET_BIT(prob + symbol, ref symbol, out ttt, out bound, ref range, ref code, ref buf); }\n                            while (symbol < 0x100);\n                        }\n                        else\n                        {\n                            uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];\n                            uint offs = 0x100;\n                            state -= (state < 10) ? 3u : 6u;\n                            symbol = 1;\n                            do\n                            {\n                                uint bit;\n                                P<ushort> probLit;\n                                matchByte <<= 1;\n                                bit = (matchByte & offs);\n                                probLit = prob + offs + bit + symbol;\n                                if (_GET_BIT2(probLit, ref symbol, out ttt, out bound, ref range, ref code, ref buf))\n                                    offs &= bit;\n                                else\n                                    offs &= ~bit;\n                            }\n                            while (symbol < 0x100);\n                        }\n                        dic[dicPos++] = (byte)symbol;\n                        processedPos++;\n                        continue;\n                    }\n                    else\n                    {\n                        _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                        prob = probs + kIsRep + state;\n                        if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                        {\n                            _UPDATE_0(prob, ttt, bound, ref range);\n                            state += kNumStates;\n                            prob = probs + kLenCoder;\n                        }\n                        else\n                        {\n                            _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                            if (checkDicSize == 0 && processedPos == 0)\n                                return SZ_ERROR_DATA;\n                            prob = probs + kIsRepG0 + state;\n                            if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                            {\n                                _UPDATE_0(prob, ttt, bound, ref range);\n                                prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;\n                                if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                                {\n                                    _UPDATE_0(prob, ttt, bound, ref range);\n                                    dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];\n                                    dicPos++;\n                                    processedPos++;\n                                    state = state < kNumLitStates ? 9u : 11u;\n                                    continue;\n                                }\n                                _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                            }\n                            else\n                            {\n                                uint distance;\n                                _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                                prob = probs + kIsRepG1 + state;\n                                if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                                {\n                                    _UPDATE_0(prob, ttt, bound, ref range);\n                                    distance = rep1;\n                                }\n                                else\n                                {\n                                    _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                                    prob = probs + kIsRepG2 + state;\n                                    if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                                    {\n                                        _UPDATE_0(prob, ttt, bound, ref range);\n                                        distance = rep2;\n                                    }\n                                    else\n                                    {\n                                        _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                                        distance = rep3;\n                                        rep3 = rep2;\n                                    }\n                                    rep2 = rep1;\n                                }\n                                rep1 = rep0;\n                                rep0 = distance;\n                            }\n                            state = state < kNumLitStates ? 8u : 11u;\n                            prob = probs + kRepLenCoder;\n                        }\n                        {\n                            uint limit2, offset;\n                            P<ushort> probLen = prob + kLenChoice;\n                            if (_IF_BIT_0(probLen, out ttt, out bound, ref range, ref code, ref buf))\n                            {\n                                _UPDATE_0(probLen, ttt, bound, ref range);\n                                probLen = prob + kLenLow + (posState << kLenNumLowBits);\n                                offset = 0;\n                                limit2 = (1 << kLenNumLowBits);\n                            }\n                            else\n                            {\n                                _UPDATE_1(probLen, ttt, bound, ref range, ref code);\n                                probLen = prob + kLenChoice2;\n                                if (_IF_BIT_0(probLen, out ttt, out bound, ref range, ref code, ref buf))\n                                {\n                                    _UPDATE_0(probLen, ttt, bound, ref range);\n                                    probLen = prob + kLenMid + (posState << kLenNumMidBits);\n                                    offset = kLenNumLowSymbols;\n                                    limit2 = (1 << kLenNumMidBits);\n                                }\n                                else\n                                {\n                                    _UPDATE_1(probLen, ttt, bound, ref range, ref code);\n                                    probLen = prob + kLenHigh;\n                                    offset = kLenNumLowSymbols + kLenNumMidSymbols;\n                                    limit2 = (1 << kLenNumHighBits);\n                                }\n                            }\n                            _TREE_DECODE(probLen, limit2, out len, out ttt, out bound, ref range, ref code, ref buf);\n                            len += offset;\n                        }\n\n                        if (state >= kNumStates)\n                        {\n                            uint distance;\n                            prob = probs + kPosSlot +\n                                ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);\n                            _TREE_6_DECODE(prob, out distance, out ttt, out bound, ref range, ref code, ref buf);\n                            if (distance >= kStartPosModelIndex)\n                            {\n                                uint posSlot = (uint)distance;\n                                int numDirectBits = (int)(((distance >> 1) - 1));\n                                distance = (2 | (distance & 1));\n                                if (posSlot < kEndPosModelIndex)\n                                {\n                                    distance <<= numDirectBits;\n                                    prob = probs + kSpecPos + distance - posSlot - 1;\n                                    {\n                                        uint mask = 1;\n                                        uint i = 1;\n                                        do\n                                        {\n                                            if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf))\n                                                distance |= mask;\n                                            mask <<= 1;\n                                        }\n                                        while (--numDirectBits != 0);\n                                    }\n                                }\n                                else\n                                {\n                                    numDirectBits -= kNumAlignBits;\n                                    do\n                                    {\n                                        _NORMALIZE(ref range, ref code, ref buf);\n                                        range >>= 1;\n\n                                        {\n                                            uint t;\n                                            code -= range;\n                                            t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */\n                                            distance = (distance << 1) + (t + 1);\n                                            code += range & t;\n                                        }\n                                        /*\n                                        distance <<= 1;\n                                        if (code >= range)\n                                        {\n                                          code -= range;\n                                          distance |= 1;\n                                        }\n                                        */\n                                    }\n                                    while (--numDirectBits != 0);\n                                    prob = probs + kAlign;\n                                    distance <<= kNumAlignBits;\n                                    {\n                                        uint i = 1;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 1;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 2;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 4;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 8;\n                                    }\n                                    if (distance == (uint)0xFFFFFFFF)\n                                    {\n                                        len += kMatchSpecLenStart;\n                                        state -= kNumStates;\n                                        break;\n                                    }\n                                }\n                            }\n                            rep3 = rep2;\n                            rep2 = rep1;\n                            rep1 = rep0;\n                            rep0 = distance + 1;\n                            if (checkDicSize == 0)\n                            {\n                                if (distance >= processedPos)\n                                    return SZ_ERROR_DATA;\n                            }\n                            else if (distance >= checkDicSize)\n                                return SZ_ERROR_DATA;\n                            state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;\n                        }\n\n                        len += kMatchMinLen;\n\n                        if (limit == dicPos)\n                            return SZ_ERROR_DATA;\n                        {\n                            long rem = limit - dicPos;\n                            uint curLen = ((rem < len) ? (uint)rem : len);\n                            long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);\n\n                            processedPos += curLen;\n\n                            len -= curLen;\n                            if (pos + curLen <= dicBufSize)\n                            {\n                                P<byte> dest = dic + dicPos;\n                                long src = (long)pos - (long)dicPos;\n                                P<byte> lim = dest + curLen;\n                                dicPos += curLen;\n                                do { dest[0] = dest[src]; }\n                                while (++dest != lim);\n                            }\n                            else\n                            {\n                                do\n                                {\n                                    dic[dicPos++] = dic[pos];\n                                    if (++pos == dicBufSize)\n                                        pos = 0;\n                                }\n                                while (--curLen != 0);\n                            }\n                        }\n                    }\n                }\n                while (dicPos < limit && buf < bufLimit);\n                _NORMALIZE(ref range, ref code, ref buf);\n                mBuf = buf;\n                mRange = range;\n                mCode = code;\n                mRemainLen = len;\n                mDicPos = dicPos;\n                mProcessedPos = processedPos;\n                mReps[0] = rep0;\n                mReps[1] = rep1;\n                mReps[2] = rep2;\n                mReps[3] = rep3;\n                mState = state;\n\n                return SZ_OK;\n            }\n\n            private void LzmaDec_WriteRem(long limit)\n            {\n                if (mRemainLen != 0 && mRemainLen < kMatchSpecLenStart)\n                {\n                    P<byte> dic = mDic;\n                    long dicPos = mDicPos;\n                    long dicBufSize = mDicBufSize;\n                    uint len = mRemainLen;\n                    uint rep0 = mReps[0];\n                    if (limit - dicPos < len)\n                        len = (uint)(limit - dicPos);\n\n                    if (mCheckDicSize == 0 && mProp.mDicSize - mProcessedPos <= len)\n                        mCheckDicSize = mProp.mDicSize;\n\n                    mProcessedPos += len;\n                    mRemainLen -= len;\n\n                    while (len != 0)\n                    {\n                        len--;\n                        dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];\n                        dicPos++;\n                    }\n\n                    mDicPos = dicPos;\n                }\n            }\n\n            private SRes LzmaDec_DecodeReal2(long limit, P<byte> bufLimit)\n            {\n                do\n                {\n                    long limit2 = limit;\n                    if (mCheckDicSize == 0)\n                    {\n                        uint rem = mProp.mDicSize - mProcessedPos;\n                        if (limit - mDicPos > rem)\n                            limit2 = mDicPos + rem;\n                    }\n\n                    SRes res;\n                    if ((res = LzmaDec_DecodeReal(limit2, bufLimit)) != SZ_OK)\n                        return res;\n\n                    if (mProcessedPos >= mProp.mDicSize)\n                        mCheckDicSize = mProp.mDicSize;\n\n                    LzmaDec_WriteRem(limit);\n                }\n                while (mDicPos < limit && mBuf < bufLimit && mRemainLen < kMatchSpecLenStart);\n\n                if (mRemainLen > kMatchSpecLenStart)\n                    mRemainLen = kMatchSpecLenStart;\n\n                return SZ_OK;\n            }\n\n            private ELzmaDummy LzmaDec_TryDummy(P<byte> buf, long inSize)\n            {\n                uint range = mRange;\n                uint code = mCode;\n                P<byte> bufLimit = buf + inSize;\n                P<ushort> probs = mProbs;\n                uint state = mState;\n                ELzmaDummy res;\n\n                {\n                    bool xxx;\n\n                    uint bound;\n                    uint ttt;\n                    uint posState = mProcessedPos & ((1u << mProp.mPB) - 1);\n\n                    P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;\n                    if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                        return ELzmaDummy.DUMMY_ERROR;\n                    if (xxx)\n                    {\n                        _UPDATE_0_CHECK(bound, ref range);\n\n                        /* if (bufLimit - buf >= 7) return DUMMY_LIT; */\n\n                        prob = probs + kLiteral;\n                        if (mCheckDicSize != 0 || mProcessedPos != 0)\n                            prob += LZMA_LIT_SIZE *\n                                (((mProcessedPos & ((1 << mProp.mLP) - 1)) << mProp.mLC) +\n                                (mDic[(mDicPos == 0 ? mDicBufSize : mDicPos) - 1] >> (8 - mProp.mLC)));\n\n                        if (state < kNumLitStates)\n                        {\n                            uint symbol = 1;\n                            do\n                            {\n                                if (!_GET_BIT_CHECK(prob + symbol, ref symbol, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                            }\n                            while (symbol < 0x100);\n                        }\n                        else\n                        {\n                            uint matchByte = mDic[mDicPos - mReps[0] + (mDicPos < mReps[0] ? mDicBufSize : 0)];\n                            uint offs = 0x100;\n                            uint symbol = 1;\n                            do\n                            {\n                                matchByte <<= 1;\n                                uint bit = matchByte & offs;\n                                P<ushort> probLit = prob + offs + bit + symbol;\n                                if (!_GET_BIT2_CHECK(probLit, ref symbol, delegate { offs &= ~bit; }, delegate { offs &= bit; }, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                            }\n                            while (symbol < 0x100);\n                        }\n                        res = ELzmaDummy.DUMMY_LIT;\n                    }\n                    else\n                    {\n                        uint len;\n                        _UPDATE_1_CHECK(bound, ref range, ref code);\n\n                        prob = probs + kIsRep + state;\n                        if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                            return ELzmaDummy.DUMMY_ERROR;\n                        if (xxx)\n                        {\n                            _UPDATE_0_CHECK(bound, ref range);\n                            state = 0;\n                            prob = probs + kLenCoder;\n                            res = ELzmaDummy.DUMMY_MATCH;\n                        }\n                        else\n                        {\n                            _UPDATE_1_CHECK(bound, ref range, ref code);\n                            res = ELzmaDummy.DUMMY_REP;\n                            prob = probs + kIsRepG0 + state;\n                            if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            if (xxx)\n                            {\n                                _UPDATE_0_CHECK(bound, ref range);\n                                prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;\n                                if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                                if (xxx)\n                                {\n                                    _UPDATE_0_CHECK(bound, ref range);\n                                    if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                                        return ELzmaDummy.DUMMY_ERROR;\n                                    return ELzmaDummy.DUMMY_REP;\n                                }\n                                else\n                                {\n                                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                                }\n                            }\n                            else\n                            {\n                                _UPDATE_1_CHECK(bound, ref range, ref code);\n                                prob = probs + kIsRepG1 + state;\n                                if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                                if (xxx)\n                                {\n                                    _UPDATE_0_CHECK(bound, ref range);\n                                }\n                                else\n                                {\n                                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                                    prob = probs + kIsRepG2 + state;\n                                    if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                        return ELzmaDummy.DUMMY_ERROR;\n                                    if (xxx)\n                                    {\n                                        _UPDATE_0_CHECK(bound, ref range);\n                                    }\n                                    else\n                                    {\n                                        _UPDATE_1_CHECK(bound, ref range, ref code);\n                                    }\n                                }\n                            }\n                            state = kNumStates;\n                            prob = probs + kRepLenCoder;\n                        }\n                        {\n                            uint limit, offset;\n                            P<ushort> probLen = prob + kLenChoice;\n                            if (!_IF_BIT_0_CHECK(out xxx, probLen, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            if (xxx)\n                            {\n                                _UPDATE_0_CHECK(bound, ref range);\n                                probLen = prob + kLenLow + (posState << kLenNumLowBits);\n                                offset = 0;\n                                limit = 1 << kLenNumLowBits;\n                            }\n                            else\n                            {\n                                _UPDATE_1_CHECK(bound, ref range, ref code);\n                                probLen = prob + kLenChoice2;\n                                if (!_IF_BIT_0_CHECK(out xxx, probLen, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                                if (xxx)\n                                {\n                                    _UPDATE_0_CHECK(bound, ref range);\n                                    probLen = prob + kLenMid + (posState << kLenNumMidBits);\n                                    offset = kLenNumLowSymbols;\n                                    limit = 1 << kLenNumMidBits;\n                                }\n                                else\n                                {\n                                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                                    probLen = prob + kLenHigh;\n                                    offset = kLenNumLowSymbols + kLenNumMidSymbols;\n                                    limit = 1 << kLenNumHighBits;\n                                }\n                            }\n                            if (!_TREE_DECODE_CHECK(probLen, limit, out len, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            len += offset;\n                        }\n\n                        if (state < 4)\n                        {\n                            prob = probs + kPosSlot + ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);\n                            uint posSlot;\n                            if (!_TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, out posSlot, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            if (posSlot >= kStartPosModelIndex)\n                            {\n                                int numDirectBits = (((int)posSlot >> 1) - 1);\n\n                                /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */\n\n                                if (posSlot < kEndPosModelIndex)\n                                {\n                                    prob = probs + kSpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;\n                                }\n                                else\n                                {\n                                    numDirectBits -= kNumAlignBits;\n                                    do\n                                    {\n                                        if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                                            return ELzmaDummy.DUMMY_ERROR;\n\n                                        range >>= 1;\n\n                                        //code -= range & (((code - range) >> 31) - 1);\n                                        if (code >= range)\n                                            code -= range;\n                                    }\n                                    while (--numDirectBits != 0);\n                                    prob = probs + kAlign;\n                                    numDirectBits = kNumAlignBits;\n                                }\n                                {\n                                    uint i = 1;\n                                    do\n                                    {\n                                        if (!_GET_BIT_CHECK(prob + i, ref i, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                            return ELzmaDummy.DUMMY_ERROR;\n                                    }\n                                    while (--numDirectBits != 0);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                    return ELzmaDummy.DUMMY_ERROR;\n                return res;\n            }\n\n            private void LzmaDec_InitRc(P<byte> data)\n            {\n                mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);\n                mRange = 0xFFFFFFFF;\n                mNeedFlush = false;\n            }\n\n            private void LzmaDec_InitStateReal()\n            {\n                uint numProbs = kLiteral + (LZMA_LIT_SIZE << (mProp.mLC + mProp.mLP));\n                for (uint i = 0; i < numProbs; i++)\n                    mProbs[i] = kBitModelTotal >> 1;\n                mReps[0] = 1;\n                mReps[1] = 1;\n                mReps[2] = 1;\n                mReps[3] = 1;\n                mState = 0;\n                mNeedInitState = false;\n            }\n\n            private void LzmaDec_FreeDict(ISzAlloc alloc)\n            {\n                alloc.FreeBytes(alloc, mDic.mBuffer);\n                mDic = null;\n            }\n\n            private SRes LzmaDec_AllocateProbs2(CLzmaProps propNew, ISzAlloc alloc)\n            {\n                uint numProbs = LzmaProps_GetNumProbs(propNew);\n                if (mProbs == null || numProbs != mNumProbs)\n                {\n                    LzmaDec_FreeProbs(alloc);\n                    mProbs = alloc.AllocUInt16(alloc, numProbs);\n                    mNumProbs = numProbs;\n                    if (mProbs == null)\n                        return SZ_ERROR_MEM;\n                }\n                return SZ_OK;\n            }\n\n            #endregion\n\n            #region Macros\n\n            private static void _NORMALIZE(ref uint range, ref uint code, ref P<byte> buf)\n            {\n                if (range < kTopValue)\n                {\n                    range <<= 8;\n                    code = (code << 8) | buf[0];\n                    buf++;\n                }\n            }\n\n            private static bool _IF_BIT_0(P<ushort> p, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                ttt = p[0];\n                _NORMALIZE(ref range, ref code, ref buf);\n                bound = (range >> kNumBitModelTotalBits) * ttt;\n                return code < bound;\n            }\n\n            private static void _UPDATE_0(P<ushort> p, uint ttt, uint bound, ref uint range)\n            {\n                range = bound;\n                p[0] = (ushort)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));\n            }\n\n            private static void _UPDATE_1(P<ushort> p, uint ttt, uint bound, ref uint range, ref uint code)\n            {\n                range -= bound;\n                code -= bound;\n                p[0] = (ushort)(ttt - (ttt >> kNumMoveBits));\n            }\n\n            private static bool _GET_BIT2(P<ushort> p, ref uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                if (_IF_BIT_0(p, out ttt, out bound, ref range, ref code, ref buf))\n                {\n                    _UPDATE_0(p, ttt, bound, ref range);\n                    i = (i + i);\n                    return false; // bit == 0\n                }\n                else\n                {\n                    _UPDATE_1(p, ttt, bound, ref range, ref code);\n                    i = (i + i) + 1;\n                    return true; // bit == 1\n                }\n            }\n\n            private static void _GET_BIT(P<ushort> p, ref uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                _GET_BIT2(p, ref i, out ttt, out bound, ref range, ref code, ref buf);\n            }\n\n            private static void _TREE_GET_BIT(P<ushort> probs, ref uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                _GET_BIT(probs + i, ref i, out ttt, out bound, ref range, ref code, ref buf);\n            }\n\n            private static void _TREE_DECODE(P<ushort> probs, uint limit, out uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                i = 1;\n                do { _TREE_GET_BIT(probs, ref i, out ttt, out bound, ref range, ref code, ref buf); }\n                while (i < limit);\n                i -= limit;\n            }\n\n            /* #define _LZMA_SIZE_OPT */\n\n#if _LZMA_SIZE_OPT\n            //#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)\n#else\n            //#define TREE_6_DECODE(probs, i) \\\n            //  { i = 1; \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  i -= 0x40; }\n#endif\n\n            private static void _TREE_6_DECODE(P<ushort> probs, out uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                _TREE_DECODE(probs, 1 << 6, out i, out ttt, out bound, ref range, ref code, ref buf);\n            }\n\n            private static bool _NORMALIZE_CHECK(ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                if (range < kTopValue)\n                {\n                    if (buf >= bufLimit)\n                        return false; // ELzmaDummy.DUMMY_ERROR;\n\n                    range <<= 8;\n                    code = (code << 8) | buf[0];\n                    buf++;\n                }\n\n                return true;\n            }\n\n            private static bool _IF_BIT_0_CHECK(out bool result, P<ushort> p, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                ttt = p[0];\n                if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                {\n                    result = false;\n                    bound = 0;\n                    return false;\n                }\n                bound = (range >> kNumBitModelTotalBits) * ttt;\n                result = code < bound;\n                return true;\n            }\n\n            private static void _UPDATE_0_CHECK(uint bound, ref uint range)\n            {\n                range = bound;\n            }\n\n            private static void _UPDATE_1_CHECK(uint bound, ref uint range, ref uint code)\n            {\n                range -= bound;\n                code -= bound;\n            }\n\n            private static bool _GET_BIT2_CHECK(P<ushort> p, ref uint i, Action A0, Action A1, out uint ttt, ref uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                bool xxx;\n                if (!_IF_BIT_0_CHECK(out xxx, p, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                    return false;\n                if (xxx)\n                {\n                    _UPDATE_0_CHECK(bound, ref range);\n                    i = (i + i);\n                    A0();\n                }\n                else\n                {\n                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                    i = (i + i) + 1;\n                    A1();\n                }\n                return true;\n            }\n\n            private static bool _GET_BIT_CHECK(P<ushort> p, ref uint i, out uint ttt, ref uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                return _GET_BIT2_CHECK(p, ref i, delegate { }, delegate { }, out ttt, ref bound, ref range, ref code, ref buf, bufLimit);\n            }\n\n            private static bool _TREE_DECODE_CHECK(P<ushort> probs, uint limit, out uint i, out uint ttt, ref uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                i = 1;\n                do\n                {\n                    if (!_GET_BIT_CHECK(probs + i, ref i, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                        return false;\n                }\n                while (i < limit);\n                i -= limit;\n                return true;\n            }\n\n            private static uint LzmaProps_GetNumProbs(CLzmaProps p)\n            {\n                return LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (p.mLC + p.mLP));\n            }\n\n            #endregion\n        }\n\n        /* There are two types of LZMA streams:\n             0) Stream with end mark. That end mark adds about 6 bytes to compressed size.\n             1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */\n\n        public enum ELzmaFinishMode\n        {\n            LZMA_FINISH_ANY,   /* finish at any point */\n            LZMA_FINISH_END    /* block must be finished at the end */\n        }\n\n        /* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!\n\n           You must use LZMA_FINISH_END, when you know that current output buffer\n           covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.\n\n           If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,\n           and output value of destLen will be less than output buffer size limit.\n           You can check status result also.\n\n           You can use multiple checks to test data integrity after full decompression:\n             1) Check Result and \"status\" variable.\n             2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.\n             3) Check that output(srcLen) = compressedSize, if you know real compressedSize.\n                You must use correct finish mode in that case. */\n\n        public enum ELzmaStatus\n        {\n            LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */\n            LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */\n            LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */\n            LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */\n            LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */\n        }\n\n        /* ELzmaStatus is used only as output value for function call */\n    }\n    partial class LZMA\n    {\n        public const int LZMA_PROPS_SIZE = 5;\n\n        public sealed class CLzmaEncProps\n        {\n            #region Variables\n\n            /// <summary>\n            /// 0 &lt;= level &lt;= 9\n            /// </summary>\n            public int mLevel;\n\n            /// <summary>\n            /// (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 27) for 32-bit version <para/>\n            /// (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 30) for 64-bit version <para/>\n            /// default = (1 &lt;&lt; 24)\n            /// </summary>\n            public uint mDictSize;\n\n            /// <summary>\n            /// Estimated size of data that will be compressed. default = 0xFFFFFFFF.\n            /// Encoder uses this value to reduce dictionary size\n            /// </summary>\n            public uint mReduceSize;\n\n            /// <summary>\n            /// 0 &lt;= lc &lt;= 8, default = 3\n            /// </summary>\n            public int mLC;\n\n            /// <summary>\n            /// 0 &lt;= lp &lt;= 4, default = 0\n            /// </summary>\n            public int mLP;\n\n            /// <summary>\n            /// 0 &lt;= pb &lt;= 4, default = 2\n            /// </summary>\n            public int mPB;\n\n            /// <summary>\n            /// 0 - fast, 1 - normal, default = 1\n            /// </summary>\n            public int mAlgo;\n\n            /// <summary>\n            /// 5 &lt;= fb &lt;= 273, default = 32\n            /// </summary>\n            public int mFB;\n\n            /// <summary>\n            /// 0 - hashChain Mode, 1 - binTree mode - normal, default = 1\n            /// </summary>\n            public int mBtMode;\n\n            /// <summary>\n            /// 2, 3 or 4, default = 4\n            /// </summary>\n            public int mNumHashBytes;\n\n            /// <summary>\n            /// 1 &lt;= mc &lt;= (1 &lt;&lt; 30), default = 32\n            /// </summary>\n            public uint mMC;\n\n            /// <summary>\n            /// 0 - do not write EOPM, 1 - write EOPM, default = 0\n            /// </summary>\n            public uint mWriteEndMark;\n\n            /// <summary>\n            /// 1 or 2, default = 2\n            /// </summary>\n            public int mNumThreads;\n\n            #endregion\n\n            #region Private Methods\n\n            private CLzmaEncProps()\n            {\n                // was LzmaEncProps_Init\n\n                this.mLevel = 5;\n                this.mDictSize = 0;\n                this.mMC = 0;\n                this.mReduceSize = ~0u;\n                this.mLC = -1;\n                this.mLP = -1;\n                this.mPB = -1;\n                this.mAlgo = -1;\n                this.mFB = -1;\n                this.mBtMode = -1;\n                this.mNumHashBytes = -1;\n                this.mNumThreads = -1;\n                this.mWriteEndMark = 0;\n            }\n\n            #endregion\n\n            #region Public Methods\n\n            public CLzmaEncProps(CLzmaEncProps other)\n            {\n                this.mLevel = other.mLevel;\n                this.mDictSize = other.mDictSize;\n                this.mReduceSize = other.mReduceSize;\n                this.mLC = other.mLC;\n                this.mLP = other.mLP;\n                this.mPB = other.mPB;\n                this.mAlgo = other.mAlgo;\n                this.mFB = other.mFB;\n                this.mBtMode = other.mBtMode;\n                this.mNumHashBytes = other.mNumHashBytes;\n                this.mMC = other.mMC;\n                this.mWriteEndMark = other.mWriteEndMark;\n                this.mNumThreads = other.mNumThreads;\n            }\n\n            public static CLzmaEncProps LzmaEncProps_Init()\n            {\n                return new CLzmaEncProps();\n            }\n\n            public void LzmaEncProps_Normalize()\n            {\n                int level = mLevel;\n                if (level < 0)\n                    level = 5;\n                mLevel = level;\n\n                if (mDictSize == 0)\n                {\n                    if (level <= 5)\n                        mDictSize = (1u << (level * 2 + 14));\n                    else if (level == 6)\n                        mDictSize = (1u << 25);\n                    else\n                        mDictSize = (1u << 26);\n                }\n\n                if (mDictSize > mReduceSize)\n                {\n                    for (int i = 15; i <= 30; i++)\n                    {\n                        if (mReduceSize <= (2u << i))\n                        {\n                            mDictSize = (2u << i);\n                            break;\n                        }\n                        if (mReduceSize <= (3u << i))\n                        {\n                            mDictSize = (3u << i);\n                            break;\n                        }\n                    }\n                }\n\n                if (mLC < 0)\n                    mLC = 3;\n                if (mLP < 0)\n                    mLP = 0;\n                if (mPB < 0)\n                    mPB = 2;\n                if (mAlgo < 0)\n                    mAlgo = (level < 5 ? 0 : 1);\n                if (mFB < 0)\n                    mFB = (level < 7 ? 32 : 64);\n                if (mBtMode < 0)\n                    mBtMode = (mAlgo == 0 ? 0 : 1);\n                if (mNumHashBytes < 0)\n                    mNumHashBytes = 4;\n                if (mMC == 0)\n                    mMC = (16u + ((uint)mFB >> 1)) >> (mBtMode != 0 ? 0 : 1);\n                if (mNumThreads < 0)\n                    mNumThreads =\n#if !_7ZIP_ST\n                        ((mBtMode != 0 && mAlgo != 0) ? 2 : 1);\n#else\n                        1;\n#endif\n            }\n\n            #endregion\n\n            #region Internal Methods\n\n            internal uint LzmaEncProps_GetDictSize()\n            {\n                CLzmaEncProps props = new CLzmaEncProps(this);\n                props.LzmaEncProps_Normalize();\n                return props.mDictSize;\n            }\n\n            #endregion\n        }\n\n\n        /* ---------- CLzmaEncHandle Interface ---------- */\n\n        /* LzmaEnc_* functions can return the following exit codes:\n        Returns:\n          SZ_OK           - OK\n          SZ_ERROR_MEM    - Memory allocation error\n          SZ_ERROR_PARAM  - Incorrect paramater in props\n          SZ_ERROR_WRITE  - Write callback error.\n          SZ_ERROR_PROGRESS - some break from progress callback\n          SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)\n        */\n\n        #region Internal Classes\n\n        internal struct OptimumReps\n        {\n            // number of slots == LZMA_NUM_REPS\n            public uint _0, _1, _2, _3;\n\n            public uint this[uint index]\n            {\n                get\n                {\n                    switch (index)\n                    {\n                        case 0: return _0;\n                        case 1: return _1;\n                        case 2: return _2;\n                        case 3: return _3;\n                        default: throw new InvalidOperationException();\n                    }\n                }\n                set\n                {\n                    switch (index)\n                    {\n                        case 0: _0 = value; break;\n                        case 1: _1 = value; break;\n                        case 2: _2 = value; break;\n                        case 3: _3 = value; break;\n                        default: throw new InvalidOperationException();\n                    }\n                }\n            }\n        }\n\n        internal sealed class COptimal\n        {\n            internal uint mPrice;\n\n            internal uint mState; // CState\n            internal bool mPrev1IsChar;\n            internal bool mPrev2;\n\n            internal uint mPosPrev2;\n            internal uint mBackPrev2;\n\n            internal uint mPosPrev;\n            internal uint mBackPrev;\n            internal OptimumReps mBacks = new OptimumReps();\n\n            internal void MakeAsChar()\n            {\n                mBackPrev = ~0u;\n                mPrev1IsChar = false;\n            }\n\n            internal void MakeAsShortRep()\n            {\n                mBackPrev = 0;\n                mPrev1IsChar = false;\n            }\n\n            internal bool IsShortRep()\n            {\n                return mBackPrev == 0;\n            }\n        }\n\n        internal class CLenEnc\n        {\n            #region Variables\n\n            public ushort mChoice;\n            public ushort mChoice2;\n            public ushort[] mLow = new ushort[CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumLowBits];\n            public ushort[] mMid = new ushort[CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumMidBits];\n            public ushort[] mHigh = new ushort[CLzmaEnc.kLenNumHighSymbols];\n\n            #endregion\n\n            public CLenEnc() { }\n            public CLenEnc(CLenEnc other)\n            {\n                mChoice = other.mChoice;\n                mChoice2 = other.mChoice2;\n                for (int i = 0; i < mLow.Length; i++)\n                    mLow[i] = other.mLow[i];\n                for (int i = 0; i < mMid.Length; i++)\n                    mMid[i] = other.mMid[i];\n                for (int i = 0; i < mHigh.Length; i++)\n                    mHigh[i] = other.mHigh[i];\n            }\n\n            internal void LenEnc_Init()\n            {\n                mChoice = CLzmaEnc.kProbInitValue;\n                mChoice2 = CLzmaEnc.kProbInitValue;\n                for (uint i = 0; i < (CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumLowBits); i++)\n                    mLow[i] = CLzmaEnc.kProbInitValue;\n                for (uint i = 0; i < (CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumMidBits); i++)\n                    mMid[i] = CLzmaEnc.kProbInitValue;\n                for (uint i = 0; i < CLzmaEnc.kLenNumHighSymbols; i++)\n                    mHigh[i] = CLzmaEnc.kProbInitValue;\n            }\n\n            internal void LenEnc_Encode(CRangeEnc rc, uint symbol, uint posState)\n            {\n                if (symbol < CLzmaEnc.kLenNumLowSymbols)\n                {\n                    rc.RangeEnc_EncodeBit(ref mChoice, 0);\n                    CLzmaEnc.RcTree_Encode(rc, P.From(mLow, posState << CLzmaEnc.kLenNumLowBits), CLzmaEnc.kLenNumLowBits, symbol);\n                }\n                else\n                {\n                    rc.RangeEnc_EncodeBit(ref mChoice, 1);\n                    if (symbol < CLzmaEnc.kLenNumLowSymbols + CLzmaEnc.kLenNumMidSymbols)\n                    {\n                        rc.RangeEnc_EncodeBit(ref mChoice2, 0);\n                        CLzmaEnc.RcTree_Encode(rc, P.From(mMid, posState << CLzmaEnc.kLenNumMidBits), CLzmaEnc.kLenNumMidBits, symbol - CLzmaEnc.kLenNumLowSymbols);\n                    }\n                    else\n                    {\n                        rc.RangeEnc_EncodeBit(ref mChoice2, 1);\n                        CLzmaEnc.RcTree_Encode(rc, mHigh, CLzmaEnc.kLenNumHighBits, symbol - CLzmaEnc.kLenNumLowSymbols - CLzmaEnc.kLenNumMidSymbols);\n                    }\n                }\n            }\n\n            internal void LenEnc_SetPrices(uint posState, uint numSymbols, P<uint> prices, P<uint> probPrices)\n            {\n                uint a0 = CLzmaEnc.GET_PRICE_0(probPrices, mChoice);\n                uint a1 = CLzmaEnc.GET_PRICE_1(probPrices, mChoice);\n                uint b0 = a1 + CLzmaEnc.GET_PRICE_0(probPrices, mChoice2);\n                uint b1 = a1 + CLzmaEnc.GET_PRICE_1(probPrices, mChoice2);\n\n                uint i = 0;\n                for (; i < CLzmaEnc.kLenNumLowSymbols; i++)\n                {\n                    if (i >= numSymbols)\n                        return;\n                    prices[i] = a0 + CLzmaEnc.RcTree_GetPrice(P.From(mLow, posState << CLzmaEnc.kLenNumLowBits), CLzmaEnc.kLenNumLowBits, i, probPrices);\n                }\n                for (; i < CLzmaEnc.kLenNumLowSymbols + CLzmaEnc.kLenNumMidSymbols; i++)\n                {\n                    if (i >= numSymbols)\n                        return;\n                    prices[i] = b0 + CLzmaEnc.RcTree_GetPrice(P.From(mMid, posState << CLzmaEnc.kLenNumMidBits), CLzmaEnc.kLenNumMidBits, i - CLzmaEnc.kLenNumLowSymbols, probPrices);\n                }\n                for (; i < numSymbols; i++)\n                    prices[i] = b1 + CLzmaEnc.RcTree_GetPrice(mHigh, CLzmaEnc.kLenNumHighBits, i - (CLzmaEnc.kLenNumLowSymbols + CLzmaEnc.kLenNumMidSymbols), probPrices);\n            }\n        }\n\n        internal class CLenPriceEnc : CLenEnc\n        {\n            internal uint[][] mPrices;\n            internal uint mTableSize;\n            internal uint[] mCounters;\n\n            internal CLenPriceEnc()\n            {\n                mPrices = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX][];\n                for (int i = 0; i < mPrices.Length; i++)\n                    mPrices[i] = new uint[CLzmaEnc.kLenNumSymbolsTotal];\n\n                mCounters = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX];\n            }\n\n            internal CLenPriceEnc(CLenPriceEnc other)\n                : base(other)\n            {\n                mPrices = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX][];\n                for (int i = 0; i < mPrices.Length; i++)\n                {\n                    mPrices[i] = new uint[CLzmaEnc.kLenNumSymbolsTotal];\n                    for (int j = 0; j < CLzmaEnc.kLenNumSymbolsTotal; j++)\n                        mPrices[i][j] = other.mPrices[i][j];\n                }\n\n                mTableSize = other.mTableSize;\n\n                mCounters = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX];\n                for (int i = 0; i < mCounters.Length; i++)\n                    mCounters[i] = other.mCounters[i];\n            }\n\n            private void LenPriceEnc_UpdateTable(uint posState, P<uint> probPrices)\n            {\n                LenEnc_SetPrices(posState, mTableSize, mPrices[posState], probPrices);\n                mCounters[posState] = mTableSize;\n            }\n\n            internal void LenPriceEnc_UpdateTables(uint numPosStates, P<uint> probPrices)\n            {\n                for (uint posState = 0; posState < numPosStates; posState++)\n                    LenPriceEnc_UpdateTable(posState, probPrices);\n            }\n\n            internal void LenEnc_Encode2(CRangeEnc rc, uint symbol, uint posState, bool updatePrice, P<uint> probPrices)\n            {\n                LenEnc_Encode(rc, symbol, posState);\n\n                if (updatePrice)\n                {\n                    if (--mCounters[posState] == 0)\n                        LenPriceEnc_UpdateTable(posState, probPrices);\n                }\n            }\n        }\n\n        internal sealed class CRangeEnc\n        {\n            #region Constants\n\n            private const int kBufferSize = (1 << 16);\n\n            #endregion\n\n            #region Variables\n\n            public uint mRange;\n            public byte mCache;\n            public ulong mLow;\n            public ulong mCacheSize;\n            public P<byte> mBuf;\n            public P<byte> mBufLim;\n            public P<byte> mBufBase;\n            public ISeqOutStream mOutStream;\n            public ulong mProcessed;\n            public SRes mRes;\n\n            #endregion\n\n            internal void RangeEnc_Construct()\n            {\n                mOutStream = null;\n                mBufBase = null;\n            }\n\n            internal ulong RangeEnc_GetProcessed()\n            {\n                return mProcessed + (uint)(mBuf - mBufBase) + mCacheSize;\n            }\n\n            internal bool RangeEnc_Alloc(ISzAlloc alloc)\n            {\n                if (mBufBase == null)\n                {\n                    mBufBase = alloc.AllocBytes(alloc, kBufferSize);\n                    if (mBufBase == null)\n                        return false;\n\n                    mBufLim = mBufBase + kBufferSize;\n                }\n\n                return true;\n            }\n\n            internal void RangeEnc_Free(ISzAlloc alloc)\n            {\n                alloc.FreeBytes(alloc, mBufBase.mBuffer);\n                mBufBase = null;\n            }\n\n            internal void RangeEnc_Init()\n            {\n                /* Stream.Init(); */\n                mLow = 0;\n                mRange = 0xFFFFFFFF;\n                mCacheSize = 1;\n                mCache = 0;\n\n                mBuf = mBufBase;\n\n                mProcessed = 0;\n                mRes = SZ_OK;\n            }\n\n            internal void RangeEnc_FlushStream()\n            {\n                if (mRes != SZ_OK)\n                    return;\n\n                long num = mBuf - mBufBase;\n                if (num != mOutStream.Write(mBufBase, num))\n                    mRes = SZ_ERROR_WRITE;\n\n                mProcessed += (ulong)num;\n                mBuf = mBufBase;\n            }\n\n            internal void RangeEnc_ShiftLow()\n            {\n                if ((uint)mLow < (uint)0xFF000000 || (int)(mLow >> 32) != 0)\n                {\n                    byte temp = mCache;\n                    do\n                    {\n                        P<byte> buf = mBuf;\n                        buf[0] = (byte)(temp + (byte)(mLow >> 32));\n                        buf++;\n                        mBuf = buf;\n                        if (buf == mBufLim)\n                            RangeEnc_FlushStream();\n                        temp = 0xFF;\n                    }\n                    while (--mCacheSize != 0);\n\n                    mCache = (byte)((uint)mLow >> 24);\n                }\n\n                mCacheSize++;\n                mLow = (uint)mLow << 8;\n            }\n\n            internal void RangeEnc_FlushData()\n            {\n                for (int i = 0; i < 5; i++)\n                    RangeEnc_ShiftLow();\n            }\n\n            internal void RangeEnc_EncodeDirectBits(uint value, int numBits)\n            {\n                do\n                {\n                    mRange >>= 1;\n                    mLow += mRange & (0 - ((value >> --numBits) & 1));\n                    if (mRange < CLzmaEnc.kTopValue)\n                    {\n                        mRange <<= 8;\n                        RangeEnc_ShiftLow();\n                    }\n                }\n                while (numBits != 0);\n            }\n\n            internal void RangeEnc_EncodeBit(P<ushort> prob, uint symbol)\n            { RangeEnc_EncodeBit(ref prob.mBuffer[prob.mOffset], symbol); }\n            internal void RangeEnc_EncodeBit(ref ushort prob, uint symbol)\n            {\n                uint temp = prob;\n\n                uint newBound = (mRange >> CLzmaEnc.kNumBitModelTotalBits) * temp;\n                if (symbol == 0)\n                {\n                    mRange = newBound;\n                    temp += (CLzmaEnc.kBitModelTotal - temp) >> CLzmaEnc.kNumMoveBits;\n                }\n                else\n                {\n                    mLow += newBound;\n                    mRange -= newBound;\n                    temp -= temp >> CLzmaEnc.kNumMoveBits;\n                }\n\n                prob = (ushort)temp;\n\n                if (mRange < CLzmaEnc.kTopValue)\n                {\n                    mRange <<= 8;\n                    RangeEnc_ShiftLow();\n                }\n            }\n        }\n\n        internal sealed class CSaveState\n        {\n            #region Variables\n\n            public ushort[] mLitProbs;\n\n            public ushort[][] mIsMatch = CUtils.Init<ushort>(CLzmaEnc.kNumStates, CLzmaEnc.LZMA_NUM_PB_STATES_MAX);\n            public ushort[] mIsRep = new ushort[CLzmaEnc.kNumStates];\n            public ushort[] mIsRepG0 = new ushort[CLzmaEnc.kNumStates];\n            public ushort[] mIsRepG1 = new ushort[CLzmaEnc.kNumStates];\n            public ushort[] mIsRepG2 = new ushort[CLzmaEnc.kNumStates];\n            public ushort[][] mIsRep0Long = CUtils.Init<ushort>(CLzmaEnc.kNumStates, CLzmaEnc.LZMA_NUM_PB_STATES_MAX);\n\n            public ushort[][] mPosSlotEncoder = CUtils.Init<ushort>(CLzmaEnc.kNumLenToPosStates, 1 << CLzmaEnc.kNumPosSlotBits);\n            public ushort[] mPosEncoders = new ushort[CLzmaEnc.kNumFullDistances - CLzmaEnc.kEndPosModelIndex];\n            public ushort[] mPosAlignEncoder = new ushort[1 << CLzmaEnc.kNumAlignBits];\n\n            public CLenPriceEnc mLenEnc = new CLenPriceEnc();\n            public CLenPriceEnc mRepLenEnc = new CLenPriceEnc();\n\n            public OptimumReps mReps = new OptimumReps();\n            public uint mState;\n\n            #endregion\n        }\n\n        #endregion\n\n        public sealed class CLzmaEnc\n        {\n            #region Constants\n\n#if SHOW_STAT\n            private static int ttt = 0;\n#endif\n\n            private const int kBlockSize = 9 << 10;\n            private const int kUnpackBlockSize = 1 << 18;\n            private const int kMatchArraySize = 1 << 21;\n            private const int kMatchRecordMaxSize = ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX);\n\n            private const int kNumMaxDirectBits = 31;\n\n            private const int kNumTopBits = 24;\n            internal const uint kTopValue = 1u << kNumTopBits;\n\n            internal const int kNumBitModelTotalBits = 11;\n            internal const int kBitModelTotal = 1 << kNumBitModelTotalBits;\n            internal const int kNumMoveBits = 5;\n            internal const int kProbInitValue = kBitModelTotal >> 1;\n\n            private const int kNumMoveReducingBits = 4;\n            private const int kNumBitPriceShiftBits = 4;\n            private const int kBitPrice = 1 << kNumBitPriceShiftBits;\n\n            private const int kNumLogBits = (9 + sizeof(long) / 2); // that was sizeof(size_t)\n            private const int kDicLogSizeMaxCompress = ((kNumLogBits - 1) * 2 + 7);\n\n            internal void LzmaEnc_FastPosInit()\n            {\n                mFastPos[0] = 0;\n                mFastPos[1] = 1;\n\n                int i = 2;\n                for (int slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)\n                {\n                    int k = 1 << ((slotFast >> 1) - 1);\n                    for (int j = 0; j < k; j++)\n                        mFastPos[i++] = (byte)slotFast;\n                }\n            }\n\n            private uint BSR2_RET(uint pos)\n            {\n                //return (pos < (1 << (6 + kNumLogBits)))\n                //    ? mFastPos[pos >> 6] + 12u\n                //    : mFastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2u;\n\n                uint i = 6 + ((kNumLogBits - 1) & (0 - ((((1 << (kNumLogBits + 6)) - 1) - pos) >> 31)));\n                return mFastPos[pos >> (int)i] + (i * 2);\n            }\n\n            private byte GetPosSlot1(uint pos)\n            {\n                return mFastPos[pos];\n            }\n\n            private uint GetPosSlot2(uint pos)\n            {\n                return BSR2_RET(pos);\n            }\n\n            private uint GetPosSlot(uint pos)\n            {\n                if (pos < kNumFullDistances)\n                    return mFastPos[pos];\n                else\n                    return BSR2_RET(pos);\n            }\n\n            internal const int LZMA_NUM_REPS = 4;\n\n            private const int kNumOpts = (1 << 12);\n\n            internal const int kNumLenToPosStates = 4;\n            internal const int kNumPosSlotBits = 6;\n            private const int kDicLogSizeMin = 0;\n            private const int kDicLogSizeMax = 32;\n            private const int kDistTableSizeMax = (kDicLogSizeMax * 2);\n\n\n            internal const int kNumAlignBits = 4;\n            private const int kAlignTableSize = (1 << kNumAlignBits);\n            private const int kAlignMask = (kAlignTableSize - 1);\n\n            private const int kStartPosModelIndex = 4;\n            internal const int kEndPosModelIndex = 14;\n            private const int kNumPosModels = (kEndPosModelIndex - kStartPosModelIndex);\n\n            internal const int kNumFullDistances = (1 << (kEndPosModelIndex >> 1));\n\n            private const int LZMA_PB_MAX = 4;\n            private const int LZMA_LC_MAX = 8;\n            private const int LZMA_LP_MAX = 4;\n\n            internal const int LZMA_NUM_PB_STATES_MAX = (1 << LZMA_PB_MAX);\n\n\n            internal const int kLenNumLowBits = 3;\n            internal const int kLenNumLowSymbols = (1 << kLenNumLowBits);\n            internal const int kLenNumMidBits = 3;\n            internal const int kLenNumMidSymbols = (1 << kLenNumMidBits);\n            internal const int kLenNumHighBits = 8;\n            internal const int kLenNumHighSymbols = (1 << kLenNumHighBits);\n\n            internal const int kLenNumSymbolsTotal = (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols);\n\n            private const int LZMA_MATCH_LEN_MIN = 2;\n            private const int LZMA_MATCH_LEN_MAX = (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1);\n\n            internal const int kNumStates = 12;\n\n            private static readonly uint[] kLiteralNextStates = new uint[kNumStates] { 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 4, 5 };\n            private static readonly uint[] kMatchNextStates = new uint[kNumStates] { 7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10 };\n            private static readonly uint[] kRepNextStates = new uint[kNumStates] { 8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11 };\n            private static readonly uint[] kShortRepNextStates = new uint[kNumStates] { 9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11 };\n\n            private static bool IsCharState(uint s)\n            {\n                return s < 7;\n            }\n\n            private static uint GetLenToPosState(uint len)\n            {\n                return (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1);\n            }\n\n            private const int kInfinityPrice = (1 << 30);\n\n            private static void LitEnc_Encode(CRangeEnc p, P<ushort> probs, uint symbol)\n            {\n                symbol |= 0x100;\n                do\n                {\n                    p.RangeEnc_EncodeBit(probs + (symbol >> 8), (symbol >> 7) & 1);\n                    symbol <<= 1;\n                }\n                while (symbol < 0x10000);\n            }\n\n            private static void LitEnc_EncodeMatched(CRangeEnc p, P<ushort> probs, uint symbol, uint matchByte)\n            {\n                uint offs = 0x100;\n                symbol |= 0x100;\n                do\n                {\n                    matchByte <<= 1;\n                    p.RangeEnc_EncodeBit(probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);\n                    symbol <<= 1;\n                    offs &= ~(matchByte ^ symbol);\n                }\n                while (symbol < 0x10000);\n            }\n\n            internal static void LzmaEnc_InitPriceTables(P<uint> probPrices)\n            {\n                for (uint i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))\n                {\n                    const int kCyclesBits = kNumBitPriceShiftBits;\n\n                    uint w = i;\n                    uint bitCount = 0;\n                    for (int j = 0; j < kCyclesBits; j++)\n                    {\n                        w = w * w;\n                        bitCount <<= 1;\n                        while (w >= ((uint)1 << 16))\n                        {\n                            w >>= 1;\n                            bitCount++;\n                        }\n                    }\n\n                    probPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);\n                }\n            }\n\n            internal static uint GET_PRICE(P<uint> probPrices, ushort prob, uint symbol)\n            {\n                //return symbol == 0\n                //    ? GET_PRICE_0(probPrices, prob)\n                //    : GET_PRICE_1(probPrices, prob);\n\n                return probPrices[(prob ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];\n            }\n\n            internal static uint GET_PRICE_0(P<uint> probPrices, ushort prob)\n            {\n                return probPrices[prob >> kNumMoveReducingBits];\n            }\n\n            internal static uint GET_PRICE_1(P<uint> probPrices, ushort prob)\n            {\n                return probPrices[(prob ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits];\n            }\n\n            private static uint LitEnc_GetPrice(P<ushort> probs, uint symbol, P<uint> probPrices)\n            {\n                uint price = 0;\n                symbol |= 0x100;\n                do\n                {\n                    price += GET_PRICE(probPrices, probs[symbol >> 8], (symbol >> 7) & 1);\n                    symbol <<= 1;\n                }\n                while (symbol < 0x10000);\n                return price;\n            }\n\n            private static uint LitEnc_GetPriceMatched(P<ushort> probs, uint symbol, uint matchByte, P<uint> probPrices)\n            {\n                uint price = 0;\n                uint offs = 0x100;\n                symbol |= 0x100;\n                do\n                {\n                    matchByte <<= 1;\n                    price += GET_PRICE(probPrices, probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);\n                    symbol <<= 1;\n                    offs &= ~(matchByte ^ symbol);\n                }\n                while (symbol < 0x10000);\n                return price;\n            }\n\n            internal static void RcTree_Encode(CRangeEnc rc, P<ushort> probs, int numBitLevels, uint symbol)\n            {\n                uint m = 1;\n                for (int i = numBitLevels; i != 0;)\n                {\n                    i--;\n                    uint bit = (symbol >> i) & 1;\n                    rc.RangeEnc_EncodeBit(probs + m, bit);\n                    m = (m << 1) | bit;\n                }\n            }\n\n            private static void RcTree_ReverseEncode(CRangeEnc rc, P<ushort> probs, int numBitLevels, uint symbol)\n            {\n                uint m = 1;\n                for (int i = 0; i < numBitLevels; i++)\n                {\n                    uint bit = symbol & 1;\n                    rc.RangeEnc_EncodeBit(probs + m, bit);\n                    m = (m << 1) | bit;\n                    symbol >>= 1;\n                }\n            }\n\n            internal static uint RcTree_GetPrice(P<ushort> probs, int numBitLevels, uint symbol, P<uint> ProbPrices)\n            {\n                uint price = 0;\n                symbol |= (1u << numBitLevels);\n                while (symbol != 1)\n                {\n                    price += GET_PRICE(ProbPrices, probs[symbol >> 1], symbol & 1);\n                    symbol >>= 1;\n                }\n                return price;\n            }\n\n            private static uint RcTree_ReverseGetPrice(P<ushort> probs, int numBitLevels, uint symbol, P<uint> probPrices)\n            {\n                uint price = 0;\n                uint m = 1;\n                for (int i = numBitLevels; i != 0; i--)\n                {\n                    uint bit = symbol & 1;\n                    symbol >>= 1;\n                    price += GET_PRICE(probPrices, probs[m], bit);\n                    m = (m << 1) | bit;\n                }\n                return price;\n            }\n\n            private P<ushort> LIT_PROBS(uint pos, byte prevByte)\n            {\n                return P.From(mLitProbs, (((pos & mLpMask) << mLC) + ((uint)prevByte >> (8 - mLC))) * 0x300);\n            }\n\n            private static bool ChangePair(uint smallDist, uint bigDist)\n            {\n                return (bigDist >> 7) > smallDist;\n            }\n\n            private sealed class CSeqOutStreamBuf : ISeqOutStream\n            {\n                public P<byte> mData;\n                public long mRem;\n                public bool mOverflow;\n\n                public long Write(P<byte> data, long size)\n                {\n                    if (mRem < size)\n                    {\n                        size = mRem;\n                        mOverflow = true;\n                    }\n\n                    CUtils.memcpy(mData, data, size);\n\n                    mRem -= size;\n                    mData += size;\n                    return size;\n                }\n            }\n\n            #endregion\n\n            #region Variables\n\n            internal IMatchFinder mMatchFinder;\n            internal object mMatchFinderObj;\n\n#if !_7ZIP_ST\n            internal bool mMtMode;\n            internal CMatchFinderMt mMatchFinderMt;\n#endif\n\n            internal CMatchFinder mMatchFinderBase;\n\n            //#if !_7ZIP_ST\n            //public byte[] pad=new byte[128];\n            //#endif\n\n            internal uint mOptimumEndIndex;\n            internal uint mOptimumCurrentIndex;\n\n            internal uint mLongestMatchLength;\n            internal uint mNumPairs;\n            internal uint mNumAvail;\n            internal COptimal[] mOpt = CUtils.Init<COptimal>(kNumOpts, () => new COptimal());\n\n            internal byte[] mFastPos = new byte[1 << kNumLogBits];\n\n            internal uint[] mProbPrices = new uint[kBitModelTotal >> kNumMoveReducingBits];\n            internal uint[] mMatches = new uint[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];\n            internal uint mNumFastBytes;\n            internal uint mAdditionalOffset;\n            internal OptimumReps mReps = new OptimumReps();\n            internal uint mState;\n\n            internal uint[][] mPosSlotPrices = CUtils.Init<uint>(kNumLenToPosStates, kDistTableSizeMax);\n            internal uint[][] mDistancesPrices = CUtils.Init<uint>(kNumLenToPosStates, kNumFullDistances);\n            internal uint[] mAlignPrices = new uint[kAlignTableSize];\n            internal uint mAlignPriceCount;\n\n            internal uint mDistTableSize;\n\n            internal int mLC;\n            internal int mLP;\n            internal int mPB;\n            internal uint mLpMask;\n            internal uint mPbMask;\n\n            internal ushort[] mLitProbs;\n\n            internal ushort[][] mIsMatch = CUtils.Init<ushort>(kNumStates, LZMA_NUM_PB_STATES_MAX);\n            internal ushort[] mIsRep = new ushort[kNumStates];\n            internal ushort[] mIsRepG0 = new ushort[kNumStates];\n            internal ushort[] mIsRepG1 = new ushort[kNumStates];\n            internal ushort[] mIsRepG2 = new ushort[kNumStates];\n            internal ushort[][] mIsRep0Long = CUtils.Init<ushort>(kNumStates, LZMA_NUM_PB_STATES_MAX);\n\n            internal ushort[][] mPosSlotEncoder = CUtils.Init<ushort>(kNumLenToPosStates, 1 << kNumPosSlotBits);\n            internal ushort[] mPosEncoders = new ushort[kNumFullDistances - kEndPosModelIndex];\n            internal ushort[] mPosAlignEncoder = new ushort[1 << kNumAlignBits];\n\n            internal CLenPriceEnc mLenEnc = new CLenPriceEnc();\n            internal CLenPriceEnc mRepLenEnc = new CLenPriceEnc();\n\n            internal int mLcLp;\n\n            internal bool mFastMode;\n\n            internal CRangeEnc mRC = new CRangeEnc();\n\n            internal bool mWriteEndMark;\n            internal ulong mNowPos64;\n            internal uint mMatchPriceCount;\n            internal bool mFinished;\n            internal bool mMultiThread;\n\n            internal SRes mResult;\n            internal uint mDictSize;\n\n            internal bool mNeedInit;\n\n            internal CSaveState mSaveState = new CSaveState();\n\n            #endregion\n\n            #region Public Methods\n\n            public void LzmaEnc_Destroy(ISzAlloc alloc, ISzAlloc allocBig)\n            {\n#if !_7ZIP_ST\n                mMatchFinderMt.MatchFinderMt_Destruct(allocBig);\n#endif\n                mMatchFinderBase.MatchFinder_Free(allocBig);\n                LzmaEnc_FreeLits(alloc);\n                mRC.RangeEnc_Free(alloc);\n                alloc.FreeObject(alloc, this);\n            }\n\n            public SRes LzmaEnc_SetProps(CLzmaEncProps props2)\n            {\n                TR(\"LzmaEnc_SetProps:level\", props2.mLevel);\n                TR(\"LzmaEnc_SetProps:dictSize\", props2.mDictSize);\n                TR(\"LzmaEnc_SetProps:lc\", props2.mLC);\n                TR(\"LzmaEnc_SetProps:lp\", props2.mLP);\n                TR(\"LzmaEnc_SetProps:pb\", props2.mPB);\n                TR(\"LzmaEnc_SetProps:algo\", props2.mAlgo);\n                TR(\"LzmaEnc_SetProps:fb\", props2.mFB);\n                TR(\"LzmaEnc_SetProps:btMode\", props2.mBtMode);\n                TR(\"LzmaEnc_SetProps:numHashBytes\", props2.mNumHashBytes);\n                TR(\"LzmaEnc_SetProps:mc\", props2.mMC);\n                TR(\"LzmaEnc_SetProps:writeEndMark\", props2.mWriteEndMark);\n                TR(\"LzmaEnc_SetProps:numThreads\", props2.mNumThreads);\n\n                CLzmaEncProps props = new CLzmaEncProps(props2);\n                props.LzmaEncProps_Normalize();\n\n                if (props.mLC > LZMA_LC_MAX\n                    || props.mLP > LZMA_LP_MAX\n                    || props.mPB > LZMA_PB_MAX\n                    || props.mDictSize > (1u << kDicLogSizeMaxCompress)\n                    || props.mDictSize > (1u << 30))\n                    return SZ_ERROR_PARAM;\n\n                mDictSize = props.mDictSize;\n\n                uint fb = (uint)props.mFB;\n                if (fb < 5)\n                    fb = 5;\n                if (fb > LZMA_MATCH_LEN_MAX)\n                    fb = LZMA_MATCH_LEN_MAX;\n                mNumFastBytes = fb;\n\n                mLC = props.mLC;\n                mLP = props.mLP;\n                mPB = props.mPB;\n                mFastMode = (props.mAlgo == 0);\n                mMatchFinderBase.mBtMode = (props.mBtMode != 0);\n\n                uint numHashBytes = 4;\n                if (props.mBtMode != 0)\n                {\n                    if (props.mNumHashBytes < 2)\n                        numHashBytes = 2;\n                    else if (props.mNumHashBytes < 4)\n                        numHashBytes = (uint)props.mNumHashBytes;\n                }\n                mMatchFinderBase.mNumHashBytes = numHashBytes;\n\n                mMatchFinderBase.mCutValue = props.mMC;\n\n                mWriteEndMark = (props.mWriteEndMark != 0);\n\n#if !_7ZIP_ST\n                mMultiThread = (props.mNumThreads > 1);\n#endif\n\n                return SZ_OK;\n            }\n\n            public SRes LzmaEnc_WriteProperties(P<byte> props, ref long size)\n            {\n                uint dictSize = mDictSize;\n                if (size < LZMA_PROPS_SIZE)\n                    return SZ_ERROR_PARAM;\n                size = LZMA_PROPS_SIZE;\n                props[0] = (byte)((mPB * 5 + mLP) * 9 + mLC);\n\n                for (int i = 11; i <= 30; i++)\n                {\n                    if (dictSize <= (2u << i))\n                    {\n                        dictSize = (2u << i);\n                        break;\n                    }\n                    if (dictSize <= (3u << i))\n                    {\n                        dictSize = (3u << i);\n                        break;\n                    }\n                }\n\n                for (int i = 0; i < 4; i++)\n                    props[1 + i] = (byte)(dictSize >> (8 * i));\n\n                return SZ_OK;\n            }\n\n            public SRes LzmaEnc_Encode(ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                SRes res;\n                if ((res = LzmaEnc_Prepare(outStream, inStream, alloc, allocBig)) != SZ_OK)\n                    return res;\n\n                return LzmaEnc_Encode2(progress);\n            }\n\n            public SRes LzmaEnc_MemEncode(P<byte> dest, ref long destLen, P<byte> src, long srcLen, bool writeEndMark, ICompressProgress progress, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                CSeqOutStreamBuf outStream = new CSeqOutStreamBuf();\n\n                LzmaEnc_SetInputBuf(src, srcLen);\n\n                outStream.mData = dest;\n                outStream.mRem = destLen;\n                outStream.mOverflow = false;\n\n                mWriteEndMark = writeEndMark;\n\n                mRC.mOutStream = outStream;\n\n                SRes res = LzmaEnc_MemPrepare(src, srcLen, 0, alloc, allocBig);\n                if (res == SZ_OK)\n                    res = LzmaEnc_Encode2(progress);\n\n                destLen -= outStream.mRem;\n                if (outStream.mOverflow)\n                    return SZ_ERROR_OUTPUT_EOF;\n\n                return res;\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            private static void memcpy(ushort[] dst, ushort[] src, int size)\n            {\n                if (dst.Length != src.Length || size != src.Length * 2)\n                    throw new InvalidOperationException();\n\n                Buffer.BlockCopy(src, 0, dst, 0, size);\n            }\n\n            private static void memcpy(uint[] dst, uint[] src, int size)\n            {\n                if (dst.Length != src.Length || size != src.Length * 4)\n                    throw new InvalidOperationException();\n\n                Buffer.BlockCopy(src, 0, dst, 0, size);\n            }\n\n            internal void LzmaEnc_SaveState()\n            {\n                TR(\"LzmaEnc_SaveState\", 0);\n\n                mSaveState.mLenEnc = new CLenPriceEnc(mLenEnc);\n                mSaveState.mRepLenEnc = new CLenPriceEnc(mRepLenEnc);\n                mSaveState.mState = mState;\n\n                for (int i = 0; i < kNumStates; i++)\n                {\n                    memcpy(mSaveState.mIsMatch[i], mIsMatch[i], LZMA_NUM_PB_STATES_MAX * 2);\n                    memcpy(mSaveState.mIsRep0Long[i], mIsRep0Long[i], LZMA_NUM_PB_STATES_MAX * 2);\n                }\n\n                for (int i = 0; i < kNumLenToPosStates; i++)\n                    memcpy(mSaveState.mPosSlotEncoder[i], mPosSlotEncoder[i], (1 << kNumPosSlotBits) * 2);\n\n                memcpy(mSaveState.mIsRep, mIsRep, kNumStates * 2);\n                memcpy(mSaveState.mIsRepG0, mIsRepG0, kNumStates * 2);\n                memcpy(mSaveState.mIsRepG1, mIsRepG1, kNumStates * 2);\n                memcpy(mSaveState.mIsRepG2, mIsRepG2, kNumStates * 2);\n                memcpy(mSaveState.mPosEncoders, mPosEncoders, (kNumFullDistances - kEndPosModelIndex) * 2);\n                memcpy(mSaveState.mPosAlignEncoder, mPosAlignEncoder, (1 << kNumAlignBits) * 2);\n                mSaveState.mReps = mReps;\n                memcpy(mSaveState.mLitProbs, mLitProbs, (0x300 << mLcLp) * 2);\n            }\n\n            internal void LzmaEnc_RestoreState()\n            {\n                TR(\"LzmaEnc_RestoreState\", 0);\n\n                mLenEnc = new CLenPriceEnc(mSaveState.mLenEnc);\n                mRepLenEnc = new CLenPriceEnc(mSaveState.mRepLenEnc);\n                mState = mSaveState.mState;\n\n                for (int i = 0; i < kNumStates; i++)\n                {\n                    memcpy(mIsMatch[i], mSaveState.mIsMatch[i], LZMA_NUM_PB_STATES_MAX * 2);\n                    memcpy(mIsRep0Long[i], mSaveState.mIsRep0Long[i], LZMA_NUM_PB_STATES_MAX * 2);\n                }\n\n                for (int i = 0; i < kNumLenToPosStates; i++)\n                    memcpy(mPosSlotEncoder[i], mSaveState.mPosSlotEncoder[i], (1 << kNumPosSlotBits) * 2);\n\n                memcpy(mIsRep, mSaveState.mIsRep, kNumStates * 2);\n                memcpy(mIsRepG0, mSaveState.mIsRepG0, kNumStates * 2);\n                memcpy(mIsRepG1, mSaveState.mIsRepG1, kNumStates * 2);\n                memcpy(mIsRepG2, mSaveState.mIsRepG2, kNumStates * 2);\n                memcpy(mPosEncoders, mSaveState.mPosEncoders, (kNumFullDistances - kEndPosModelIndex) * 2);\n                memcpy(mPosAlignEncoder, mSaveState.mPosAlignEncoder, (1 << kNumAlignBits) * 2);\n                mReps = mSaveState.mReps;\n                memcpy(mLitProbs, mSaveState.mLitProbs, (0x300 << mLcLp) * 2);\n            }\n\n            private uint GetOptimum(uint position, out uint backRes)\n            {\n                OptimumReps reps = new OptimumReps();\n                P<uint> matches;\n                uint numAvail;\n                uint lenEnd;\n\n                {\n                    if (mOptimumEndIndex != mOptimumCurrentIndex)\n                    {\n                        COptimal opt = mOpt[mOptimumCurrentIndex];\n                        uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;\n                        backRes = opt.mBackPrev;\n                        mOptimumCurrentIndex = opt.mPosPrev;\n                        return lenRes;\n                    }\n\n                    mOptimumCurrentIndex = 0;\n                    mOptimumEndIndex = 0;\n\n                    uint mainLen, numPairs;\n                    if (mAdditionalOffset == 0)\n                    {\n                        mainLen = ReadMatchDistances(out numPairs);\n                    }\n                    else\n                    {\n                        mainLen = mLongestMatchLength;\n                        numPairs = mNumPairs;\n                    }\n\n                    numAvail = mNumAvail;\n                    if (numAvail < 2)\n                    {\n                        backRes = ~0u;\n                        return 1;\n                    }\n                    if (numAvail > LZMA_MATCH_LEN_MAX)\n                        numAvail = LZMA_MATCH_LEN_MAX;\n\n                    P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                    OptimumReps repLens = new OptimumReps();\n                    uint repMaxIndex = 0;\n                    for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                    {\n                        reps[i] = mReps[i];\n                        TR(\"GetOptimum:reps[i]\", reps[i]);\n                        P<byte> data2 = data - (reps[i] + 1);\n                        if (data[0] != data2[0] || data[1] != data2[1])\n                        {\n                            repLens[i] = 0;\n                            continue;\n                        }\n\n                        uint lenTest = 2;\n                        while (lenTest < numAvail && data[lenTest] == data2[lenTest])\n                            lenTest++;\n\n                        repLens[i] = lenTest;\n                        if (lenTest > repLens[repMaxIndex])\n                            repMaxIndex = i;\n                    }\n\n                    if (repLens[repMaxIndex] >= mNumFastBytes)\n                    {\n                        uint lenRes;\n                        backRes = repMaxIndex;\n                        lenRes = repLens[repMaxIndex];\n                        MovePos(lenRes - 1);\n                        return lenRes;\n                    }\n\n                    matches = mMatches;\n                    if (mainLen >= mNumFastBytes)\n                    {\n                        backRes = matches[numPairs - 1] + LZMA_NUM_REPS;\n                        MovePos(mainLen - 1);\n                        return mainLen;\n                    }\n\n                    byte curByte = data[0];\n                    byte matchByte = (data - (reps._0 + 1))[0];\n\n                    if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)\n                    {\n                        backRes = ~0u;\n                        return 1;\n                    }\n\n                    mOpt[0].mState = mState;\n\n                    uint posState = (position & mPbMask);\n\n                    {\n                        P<ushort> probs = LIT_PROBS(position, (data - 1)[0]);\n                        mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +\n                            (!IsCharState(mState) ?\n                              LitEnc_GetPriceMatched(probs, curByte, matchByte, mProbPrices) :\n                              LitEnc_GetPrice(probs, curByte, mProbPrices));\n                    }\n\n                    mOpt[1].MakeAsChar();\n\n                    uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);\n                    uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);\n\n                    if (matchByte == curByte)\n                    {\n                        uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState, posState);\n                        if (shortRepPrice < mOpt[1].mPrice)\n                        {\n                            mOpt[1].mPrice = shortRepPrice;\n                            mOpt[1].MakeAsShortRep();\n                        }\n                    }\n                    lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);\n\n                    if (lenEnd < 2)\n                    {\n                        backRes = mOpt[1].mBackPrev;\n                        return 1;\n                    }\n\n                    mOpt[1].mPosPrev = 0;\n                    mOpt[0].mBacks = reps;\n\n                    uint len = lenEnd;\n                    do { mOpt[len--].mPrice = kInfinityPrice; }\n                    while (len >= 2);\n\n                    for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                    {\n                        uint repLen = repLens[i];\n                        if (repLen < 2)\n                            continue;\n                        uint price = repMatchPrice + GetPureRepPrice(i, mState, posState);\n                        do\n                        {\n                            uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];\n                            COptimal opt = mOpt[repLen];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = 0;\n                                opt.mBackPrev = i;\n                                opt.mPrev1IsChar = false;\n                            }\n                        }\n                        while (--repLen >= 2);\n                    }\n\n                    uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);\n\n                    len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);\n                    if (len <= mainLen)\n                    {\n                        uint offs = 0;\n                        while (len > matches[offs])\n                            offs += 2;\n                        for (; ; len++)\n                        {\n                            uint distance = matches[offs + 1];\n\n                            uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];\n                            uint lenToPosState = GetLenToPosState(len);\n                            if (distance < kNumFullDistances)\n                            {\n                                curAndLenPrice += mDistancesPrices[lenToPosState][distance];\n                            }\n                            else\n                            {\n                                uint slot = GetPosSlot2(distance);\n                                curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];\n                            }\n\n                            COptimal opt = mOpt[len];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = 0;\n                                opt.mBackPrev = distance + LZMA_NUM_REPS;\n                                opt.mPrev1IsChar = false;\n                            }\n                            if (len == matches[offs])\n                            {\n                                offs += 2;\n                                if (offs == numPairs)\n                                    break;\n                            }\n                        }\n                    }\n                }\n\n                uint cur = 0;\n\n#if SHOW_STAT2\n                if(position >= 0)\n                {\n                    Print(\"\\n pos = {0:X4}\", position);\n                    for(uint j = cur; j <= lenEnd; j++)\n                        Print(\"\\nprice[{0:X4}] = {1}\", position - cur + j, mOpt[j].mPrice);\n                }\n#endif\n                //TR(\"GetOptimum::pos\", position);\n                //if(position >= 0)\n                //{\n                //    TR(\"GetOptimum::cur\", cur);\n                //    for(uint j = cur; j <= lenEnd; j++)\n                //        TR(\"GetOptimum::price[i]\", mOpt[j].price);\n                //}\n\n                for (;;)\n                {\n                    cur++;\n                    if (cur == lenEnd)\n                        return Backward(out backRes, cur);\n\n                    uint numPairs;\n                    uint newLen = ReadMatchDistances(out numPairs);\n                    if (newLen >= mNumFastBytes)\n                    {\n                        mNumPairs = numPairs;\n                        mLongestMatchLength = newLen;\n                        return Backward(out backRes, cur);\n                    }\n                    position++;\n\n                    uint state;\n                    COptimal curOpt = mOpt[cur];\n                    uint posPrev = curOpt.mPosPrev;\n                    if (curOpt.mPrev1IsChar)\n                    {\n                        posPrev--;\n                        if (curOpt.mPrev2)\n                        {\n                            state = mOpt[curOpt.mPosPrev2].mState;\n                            if (curOpt.mBackPrev2 < LZMA_NUM_REPS)\n                                state = kRepNextStates[state];\n                            else\n                                state = kMatchNextStates[state];\n                        }\n                        else\n                        {\n                            state = mOpt[posPrev].mState;\n                        }\n                        state = kLiteralNextStates[state];\n                    }\n                    else\n                    {\n                        state = mOpt[posPrev].mState;\n                    }\n                    if (posPrev == cur - 1)\n                    {\n                        if (curOpt.IsShortRep())\n                            state = kShortRepNextStates[state];\n                        else\n                            state = kLiteralNextStates[state];\n                    }\n                    else\n                    {\n                        uint pos;\n                        if (curOpt.mPrev1IsChar && curOpt.mPrev2)\n                        {\n                            posPrev = curOpt.mPosPrev2;\n                            pos = curOpt.mBackPrev2;\n                            state = kRepNextStates[state];\n                        }\n                        else\n                        {\n                            pos = curOpt.mBackPrev;\n                            if (pos < LZMA_NUM_REPS)\n                                state = kRepNextStates[state];\n                            else\n                                state = kMatchNextStates[state];\n                        }\n                        COptimal prevOpt = mOpt[posPrev];\n                        if (pos < LZMA_NUM_REPS)\n                        {\n                            reps._0 = prevOpt.mBacks[pos];\n                            uint i = 1;\n                            for (; i <= pos; i++)\n                                reps[i] = prevOpt.mBacks[i - 1];\n                            for (; i < LZMA_NUM_REPS; i++)\n                                reps[i] = prevOpt.mBacks[i];\n                        }\n                        else\n                        {\n                            reps._0 = pos - LZMA_NUM_REPS;\n                            reps._1 = prevOpt.mBacks._0;\n                            reps._2 = prevOpt.mBacks._1;\n                            reps._3 = prevOpt.mBacks._2;\n                        }\n                    }\n                    curOpt.mState = state;\n                    curOpt.mBacks = reps;\n\n                    uint curPrice = curOpt.mPrice;\n                    bool nextIsChar = false;\n                    P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                    byte curByte = data[0];\n                    byte matchByte = (data - (reps._0 + 1))[0];\n\n                    uint posState = (position & mPbMask);\n\n                    uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);\n                    {\n                        P<ushort> probs = LIT_PROBS(position, data[-1]);\n                        if (!IsCharState(state))\n                            curAnd1Price += LitEnc_GetPriceMatched(probs, curByte, matchByte, mProbPrices);\n                        else\n                            curAnd1Price += LitEnc_GetPrice(probs, curByte, mProbPrices);\n                    }\n\n                    COptimal nextOpt = mOpt[cur + 1];\n\n                    if (curAnd1Price < nextOpt.mPrice)\n                    {\n                        nextOpt.mPrice = curAnd1Price;\n                        nextOpt.mPosPrev = cur;\n                        nextOpt.MakeAsChar();\n                        nextIsChar = true;\n                    }\n\n                    uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);\n                    uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);\n\n                    if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))\n                    {\n                        uint shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);\n                        if (shortRepPrice <= nextOpt.mPrice)\n                        {\n                            nextOpt.mPrice = shortRepPrice;\n                            nextOpt.mPosPrev = cur;\n                            nextOpt.MakeAsShortRep();\n                            nextIsChar = true;\n                        }\n                    }\n\n                    uint numAvailFull = Math.Min(mNumAvail, kNumOpts - 1 - cur);\n                    if (numAvailFull < 2)\n                        continue;\n\n                    numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);\n\n                    if (!nextIsChar && matchByte != curByte) /* speed optimization */\n                    {\n                        /* try Literal + rep0 */\n                        P<byte> data2 = data - (reps._0 + 1);\n                        uint limit = mNumFastBytes + 1;\n                        if (limit > numAvailFull)\n                            limit = numAvailFull;\n\n                        uint temp = 1;\n                        while (temp < limit && data[temp] == data2[temp])\n                            temp++;\n\n                        uint lenTest2 = temp - 1;\n                        if (lenTest2 >= 2)\n                        {\n                            uint state2 = kLiteralNextStates[state];\n                            uint posStateNext = (position + 1) & mPbMask;\n                            uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);\n                            /* for (; lenTest2 >= 2; lenTest2--) */\n                            {\n                                uint offset = cur + 1 + lenTest2;\n                                while (lenEnd < offset)\n                                    mOpt[++lenEnd].mPrice = kInfinityPrice;\n                                uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);\n                                COptimal opt = mOpt[offset];\n                                if (curAndLenPrice < opt.mPrice)\n                                {\n                                    opt.mPrice = curAndLenPrice;\n                                    opt.mPosPrev = cur + 1;\n                                    opt.mBackPrev = 0;\n                                    opt.mPrev1IsChar = true;\n                                    opt.mPrev2 = false;\n                                }\n                            }\n                        }\n                    }\n\n                    uint startLen = 2; /* speed optimization */\n\n                    for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)\n                    {\n                        P<byte> data2 = data - (reps[repIndex] + 1);\n                        if (data[0] != data2[0] || data[1] != data2[1])\n                            continue;\n\n                        uint lenTest = 2;\n                        while (lenTest < numAvail && data[lenTest] == data2[lenTest])\n                            lenTest++;\n\n                        while (lenEnd < cur + lenTest)\n                            mOpt[++lenEnd].mPrice = kInfinityPrice;\n\n                        uint lenTestTemp = lenTest;\n                        uint price = repMatchPrice + GetPureRepPrice(repIndex, state, posState);\n                        do\n                        {\n                            uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];\n                            COptimal opt = mOpt[cur + lenTest];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = cur;\n                                opt.mBackPrev = repIndex;\n                                opt.mPrev1IsChar = false;\n                            }\n                        }\n                        while (--lenTest >= 2);\n                        lenTest = lenTestTemp;\n\n                        if (repIndex == 0)\n                            startLen = lenTest + 1;\n\n                        {\n                            uint lenTest2 = lenTest + 1;\n\n                            uint limit = lenTest2 + mNumFastBytes;\n                            if (limit > numAvailFull)\n                                limit = numAvailFull;\n\n                            while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])\n                                lenTest2++;\n\n                            lenTest2 -= lenTest + 1;\n                            if (lenTest2 >= 2)\n                            {\n                                uint state2 = kRepNextStates[state];\n                                uint posStateNext = (position + lenTest) & mPbMask;\n                                uint curAndLenCharPrice = price\n                                    + mRepLenEnc.mPrices[posState][lenTest - 2]\n                                    + GET_PRICE_0(mIsMatch[state2][posStateNext])\n                                    + LitEnc_GetPriceMatched(\n                                        LIT_PROBS(position + lenTest, data[lenTest - 1]),\n                                        data[lenTest], data2[lenTest], mProbPrices);\n\n                                state2 = kLiteralNextStates[state2];\n                                posStateNext = (position + lenTest + 1) & mPbMask;\n                                uint nextRepMatchPrice = curAndLenCharPrice\n                                    + GET_PRICE_1(mIsMatch[state2][posStateNext])\n                                    + GET_PRICE_1(mIsRep[state2]);\n\n                                /* for (; lenTest2 >= 2; lenTest2--) */\n                                {\n                                    uint offset = cur + lenTest + 1 + lenTest2;\n                                    while (lenEnd < offset)\n                                        mOpt[++lenEnd].mPrice = kInfinityPrice;\n\n                                    uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);\n\n                                    COptimal opt = mOpt[offset];\n                                    if (curAndLenPrice < opt.mPrice)\n                                    {\n                                        opt.mPrice = curAndLenPrice;\n                                        opt.mPosPrev = cur + lenTest + 1;\n                                        opt.mBackPrev = 0;\n                                        opt.mPrev1IsChar = true;\n                                        opt.mPrev2 = true;\n                                        opt.mPosPrev2 = cur;\n                                        opt.mBackPrev2 = repIndex;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */\n                    if (newLen > numAvail)\n                    {\n                        newLen = numAvail;\n                        numPairs = 0;\n                        while (newLen > matches[numPairs])\n                            numPairs += 2;\n                        matches[numPairs] = newLen;\n                        numPairs += 2;\n                    }\n                    if (newLen >= startLen)\n                    {\n                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);\n\n                        while (lenEnd < cur + newLen)\n                            mOpt[++lenEnd].mPrice = kInfinityPrice;\n\n                        uint offs = 0;\n                        while (startLen > matches[offs])\n                            offs += 2;\n\n                        uint curBack = matches[offs + 1];\n                        uint posSlot = GetPosSlot2(curBack);\n                        for (uint lenTest = /*2*/ startLen; ; lenTest++)\n                        {\n                            uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];\n                            uint lenToPosState = GetLenToPosState(lenTest);\n                            if (curBack < kNumFullDistances)\n                                curAndLenPrice += mDistancesPrices[lenToPosState][curBack];\n                            else\n                                curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];\n\n                            COptimal opt = mOpt[cur + lenTest];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = cur;\n                                opt.mBackPrev = curBack + LZMA_NUM_REPS;\n                                opt.mPrev1IsChar = false;\n                            }\n\n                            if (lenTest == matches[offs])\n                            {\n                                /* Try Match + Literal + Rep0 */\n                                P<byte> data2 = data - (curBack + 1);\n                                uint lenTest2 = lenTest + 1;\n                                uint limit = lenTest2 + mNumFastBytes;\n                                uint nextRepMatchPrice;\n                                if (limit > numAvailFull)\n                                    limit = numAvailFull;\n\n                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])\n                                    lenTest2++;\n\n                                lenTest2 -= lenTest + 1;\n                                if (lenTest2 >= 2)\n                                {\n                                    uint state2 = kMatchNextStates[state];\n                                    uint posStateNext = (position + lenTest) & mPbMask;\n                                    uint curAndLenCharPrice = curAndLenPrice\n                                        + GET_PRICE_0(mIsMatch[state2][posStateNext])\n                                        + LitEnc_GetPriceMatched(\n                                            LIT_PROBS(position + lenTest, data[lenTest - 1]),\n                                            data[lenTest], data2[lenTest], mProbPrices);\n\n                                    state2 = kLiteralNextStates[state2];\n                                    posStateNext = (posStateNext + 1) & mPbMask;\n                                    nextRepMatchPrice = curAndLenCharPrice\n                                        + GET_PRICE_1(mIsMatch[state2][posStateNext])\n                                        + GET_PRICE_1(mIsRep[state2]);\n\n                                    /* for (; lenTest2 >= 2; lenTest2--) */\n                                    {\n                                        uint offset = cur + lenTest + 1 + lenTest2;\n                                        uint curAndLenPrice4;\n                                        while (lenEnd < offset)\n                                            mOpt[++lenEnd].mPrice = kInfinityPrice;\n                                        curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);\n                                        COptimal opt4 = mOpt[offset];\n                                        if (curAndLenPrice4 < opt4.mPrice)\n                                        {\n                                            opt4.mPrice = curAndLenPrice4;\n                                            opt4.mPosPrev = cur + lenTest + 1;\n                                            opt4.mBackPrev = 0;\n                                            opt4.mPrev1IsChar = true;\n                                            opt4.mPrev2 = true;\n                                            opt4.mPosPrev2 = cur;\n                                            opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;\n                                        }\n                                    }\n                                }\n\n                                offs += 2;\n                                if (offs == numPairs)\n                                    break;\n\n                                curBack = matches[offs + 1];\n                                if (curBack >= kNumFullDistances)\n                                    posSlot = GetPosSlot2(curBack);\n                            }\n                        }\n                    }\n                }\n            }\n\n            private uint GetOptimumFast(out uint backRes)\n            {\n                uint mainLen, numPairs;\n                if (mAdditionalOffset == 0)\n                {\n                    mainLen = ReadMatchDistances(out numPairs);\n                }\n                else\n                {\n                    TR(\"GetOptimumFast:longestMatchLength\", mLongestMatchLength);\n                    mainLen = mLongestMatchLength;\n                    numPairs = mNumPairs;\n                }\n\n                uint numAvail = mNumAvail;\n                backRes = ~0u;\n                if (numAvail < 2)\n                    return 1;\n                if (numAvail > LZMA_MATCH_LEN_MAX)\n                    numAvail = LZMA_MATCH_LEN_MAX;\n                P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n\n                uint repLen = 0;\n                uint repIndex = 0;\n                for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                {\n                    P<byte> data2 = data - (mReps[i] + 1);\n                    TR(\"GetOptimumFast:reps[i]:a\", mReps[i]);\n                    if (data[0] != data2[0] || data[1] != data2[1])\n                        continue;\n\n                    uint len = 2;\n                    while (len < numAvail && data[len] == data2[len])\n                        len++;\n\n                    if (len >= mNumFastBytes)\n                    {\n                        backRes = i;\n                        MovePos(len - 1);\n                        return len;\n                    }\n\n                    if (len > repLen)\n                    {\n                        repIndex = i;\n                        repLen = len;\n                    }\n                }\n\n                P<uint> matches = mMatches;\n                if (mainLen >= mNumFastBytes)\n                {\n                    backRes = matches[numPairs - 1] + LZMA_NUM_REPS;\n                    MovePos(mainLen - 1);\n                    return mainLen;\n                }\n\n                uint mainDist = 0;\n                if (mainLen >= 2)\n                {\n                    mainDist = matches[numPairs - 1];\n                    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)\n                    {\n                        if (!ChangePair(matches[numPairs - 3], mainDist))\n                            break;\n\n                        numPairs -= 2;\n                        mainLen = matches[numPairs - 2];\n                        mainDist = matches[numPairs - 1];\n                    }\n\n                    if (mainLen == 2 && mainDist >= 0x80)\n                        mainLen = 1;\n                }\n\n                if (repLen >= 2 && (\n                    (repLen + 1 >= mainLen) ||\n                    (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||\n                    (repLen + 3 >= mainLen && mainDist >= (1 << 15))))\n                {\n                    backRes = repIndex;\n                    MovePos(repLen - 1);\n                    return repLen;\n                }\n\n                if (mainLen < 2 || numAvail <= 2)\n                    return 1;\n\n                mLongestMatchLength = ReadMatchDistances(out mNumPairs);\n                if (mLongestMatchLength >= 2)\n                {\n                    uint newDistance = matches[mNumPairs - 1];\n                    if ((mLongestMatchLength >= mainLen && newDistance < mainDist) ||\n                        (mLongestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||\n                        (mLongestMatchLength > mainLen + 1) ||\n                        (mLongestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))\n                        return 1;\n                }\n\n                data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                {\n                    TR(\"GetOptimumFast:reps[i]:b\", mReps[i]);\n                    P<byte> data2 = data - (mReps[i] + 1);\n                    if (data[0] != data2[0] || data[1] != data2[1])\n                        continue;\n\n                    uint limit = mainLen - 1;\n\n                    uint len = 2;\n                    while (len < limit && data[len] == data2[len])\n                        len++;\n\n                    if (len >= limit)\n                        return 1;\n                }\n\n                backRes = mainDist + LZMA_NUM_REPS;\n                MovePos(mainLen - 2);\n                return mainLen;\n            }\n\n            private void WriteEndMarker(uint posState)\n            {\n                TR(\"WriteEndMarker\", posState);\n                mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState], 1);\n                mRC.RangeEnc_EncodeBit(ref mIsRep[mState], 0);\n                mState = kMatchNextStates[mState];\n                uint len = LZMA_MATCH_LEN_MIN;\n                mLenEnc.LenEnc_Encode2(mRC, len - LZMA_MATCH_LEN_MIN, posState, !mFastMode, mProbPrices);\n                RcTree_Encode(mRC, mPosSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);\n                mRC.RangeEnc_EncodeDirectBits(((1u << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);\n                RcTree_ReverseEncode(mRC, mPosAlignEncoder, kNumAlignBits, kAlignMask);\n            }\n\n            private SRes CheckErrors()\n            {\n                if (mResult != SZ_OK)\n                    return mResult;\n\n                if (mRC.mRes != SZ_OK)\n                    mResult = SZ_ERROR_WRITE;\n\n                if (mMatchFinderBase.mResult != SZ_OK)\n                    mResult = SZ_ERROR_READ;\n\n                if (mResult != SZ_OK)\n                    mFinished = true;\n\n                return mResult;\n            }\n\n            private SRes Flush(uint nowPos)\n            {\n                TR(\"Flush\", nowPos);\n\n                /* ReleaseMFStream(); */\n                mFinished = true;\n\n                if (mWriteEndMark)\n                    WriteEndMarker(nowPos & mPbMask);\n\n                mRC.RangeEnc_FlushData();\n                mRC.RangeEnc_FlushStream();\n\n                return CheckErrors();\n            }\n\n            private void FillAlignPrices()\n            {\n                for (uint i = 0; i < kAlignTableSize; i++)\n                    mAlignPrices[i] = RcTree_ReverseGetPrice(mPosAlignEncoder, kNumAlignBits, i, mProbPrices);\n\n                mAlignPriceCount = 0;\n            }\n\n            private void FillDistancesPrices()\n            {\n                uint[] tempPrices = new uint[kNumFullDistances];\n\n                for (uint i = kStartPosModelIndex; i < kNumFullDistances; i++)\n                {\n                    uint posSlot = GetPosSlot1(i);\n                    uint footerBits = ((posSlot >> 1) - 1);\n                    uint @base = ((2u | (posSlot & 1u)) << (int)footerBits);\n                    tempPrices[i] = RcTree_ReverseGetPrice(P.From(mPosEncoders, @base - posSlot - 1), (int)footerBits, i - @base, mProbPrices);\n                }\n\n                for (uint lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)\n                {\n                    P<ushort> encoder = mPosSlotEncoder[lenToPosState];\n                    P<uint> posSlotPrices = mPosSlotPrices[lenToPosState];\n\n                    for (uint posSlot = 0; posSlot < mDistTableSize; posSlot++)\n                        posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, mProbPrices);\n\n                    for (uint posSlot = kEndPosModelIndex; posSlot < mDistTableSize; posSlot++)\n                        posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);\n\n                    {\n                        P<uint> distancesPrices = mDistancesPrices[lenToPosState];\n                        uint i = 0;\n                        for (; i < kStartPosModelIndex; i++)\n                            distancesPrices[i] = posSlotPrices[i];\n                        for (; i < kNumFullDistances; i++)\n                            distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];\n                    }\n                }\n\n                mMatchPriceCount = 0;\n            }\n\n            internal CLzmaEnc() // LzmaEnc_Construct\n            {\n                mRC.RangeEnc_Construct();\n#if !_7ZIP_ST\n                mMatchFinderMt = new CMatchFinderMt();\n                mMatchFinderBase = mMatchFinderMt;\n#else\n                mMatchFinderBase = new CMatchFinder();\n#endif\n                LzmaEnc_SetProps(CLzmaEncProps.LzmaEncProps_Init());\n                LzmaEnc_FastPosInit();\n                LzmaEnc_InitPriceTables(mProbPrices);\n                mLitProbs = null;\n                mSaveState.mLitProbs = null;\n            }\n\n            internal void LzmaEnc_FreeLits(ISzAlloc alloc)\n            {\n                alloc.FreeUInt16(alloc, mLitProbs);\n                alloc.FreeUInt16(alloc, mSaveState.mLitProbs);\n                mLitProbs = null;\n                mSaveState.mLitProbs = null;\n            }\n\n            internal SRes LzmaEnc_CodeOneBlock(bool useLimits, uint maxPackSize, uint maxUnpackSize)\n            {\n                TR(\"CodeOneBlock:useLimits\", useLimits ? 1 : 0);\n                TR(\"CodeOneBlock:maxPackSize\", maxPackSize);\n                TR(\"CodeOneBlock:maxUnpackSize\", maxUnpackSize);\n\n                if (mNeedInit)\n                {\n                    mMatchFinder.Init(mMatchFinderObj);\n                    mNeedInit = false;\n                }\n\n                TR(\"CodeOneBlock:finished\", mFinished ? 1 : 0);\n                if (mFinished)\n                    return mResult;\n\n                SRes res;\n                if ((res = CheckErrors()) != SZ_OK)\n                    return res;\n\n                uint nowPos32 = (uint)mNowPos64;\n                uint startPos32 = nowPos32;\n\n                if (mNowPos64 == 0)\n                {\n                    if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)\n                    {\n                        TRS(\"CodeOneBlock\", \"empty\");\n                        return Flush(nowPos32);\n                    }\n                    uint numPairs;\n                    ReadMatchDistances(out numPairs);\n                    mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][0], 0);\n                    mState = kLiteralNextStates[mState];\n                    byte curByte = mMatchFinder.GetIndexByte(mMatchFinderObj, (int)(-mAdditionalOffset));\n                    LitEnc_Encode(mRC, mLitProbs, curByte);\n                    mAdditionalOffset--;\n                    nowPos32++;\n                }\n\n                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)\n                {\n                    for (;;)\n                    {\n                        uint len, pos;\n                        if (mFastMode)\n                            len = GetOptimumFast(out pos);\n                        else\n                            len = GetOptimum(nowPos32, out pos);\n\n                        TR(\"CodeOneBlock:nowPos32\", nowPos32);\n                        TR(\"CodeOneBlock:len\", len);\n                        TR(\"CodeOneBlock:pos\", pos);\n\n#if SHOW_STAT2\n                        Print(\"\\n pos = {0:X4},   len = {1}   pos = {2}\", nowPos32, len, pos);\n#endif\n\n                        uint posState = nowPos32 & mPbMask;\n                        if (len == 1 && pos == ~0u)\n                        {\n                            mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState], 0);\n                            P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;\n                            byte curByte = data[0];\n                            P<ushort> probs = LIT_PROBS(nowPos32, (data - 1)[0]);\n\n                            if (IsCharState(mState))\n                                LitEnc_Encode(mRC, probs, curByte);\n                            else\n                                LitEnc_EncodeMatched(mRC, probs, curByte, (data - mReps._0 - 1)[0]);\n\n                            mState = kLiteralNextStates[mState];\n                        }\n                        else\n                        {\n                            mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState], 1);\n                            if (pos < LZMA_NUM_REPS)\n                            {\n                                mRC.RangeEnc_EncodeBit(ref mIsRep[mState], 1);\n                                if (pos == 0)\n                                {\n                                    mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState], 0);\n                                    mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState], (len == 1) ? 0u : 1u);\n                                }\n                                else\n                                {\n                                    uint distance = mReps[pos];\n                                    TR(\"CodeOneBlock:push-rep-0\", pos);\n                                    TR(\"CodeOneBlock:push-rep-1\", distance);\n\n                                    mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState], 1);\n\n                                    if (pos == 1)\n                                    {\n                                        mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState], 0);\n                                    }\n                                    else\n                                    {\n                                        mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState], 1);\n                                        mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState], pos - 2);\n                                        if (pos == 3)\n                                            mReps._3 = mReps._2;\n                                        mReps._2 = mReps._1;\n                                    }\n\n                                    mReps._1 = mReps._0;\n                                    mReps._0 = distance;\n                                }\n\n                                if (len == 1)\n                                {\n                                    mState = kShortRepNextStates[mState];\n                                }\n                                else\n                                {\n                                    mRepLenEnc.LenEnc_Encode2(mRC, len - LZMA_MATCH_LEN_MIN, posState, !mFastMode, mProbPrices);\n                                    mState = kRepNextStates[mState];\n                                }\n                            }\n                            else\n                            {\n                                mRC.RangeEnc_EncodeBit(ref mIsRep[mState], 0);\n                                mState = kMatchNextStates[mState];\n                                mLenEnc.LenEnc_Encode2(mRC, len - LZMA_MATCH_LEN_MIN, posState, !mFastMode, mProbPrices);\n                                pos -= LZMA_NUM_REPS;\n                                uint posSlot = GetPosSlot(pos);\n                                RcTree_Encode(mRC, mPosSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);\n\n                                if (posSlot >= kStartPosModelIndex)\n                                {\n                                    int footerBits = (int)((posSlot >> 1) - 1);\n                                    uint @base = ((2 | (posSlot & 1)) << footerBits);\n                                    uint posReduced = pos - @base;\n\n                                    if (posSlot < kEndPosModelIndex)\n                                        RcTree_ReverseEncode(mRC, P.From(mPosEncoders, @base - posSlot - 1), footerBits, posReduced);\n                                    else\n                                    {\n                                        mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits, (footerBits - kNumAlignBits));\n                                        RcTree_ReverseEncode(mRC, mPosAlignEncoder, kNumAlignBits, posReduced & kAlignMask);\n                                        mAlignPriceCount++;\n                                    }\n                                }\n                                TR(\"CodeOneBlock:push-rep-2\", pos);\n                                mReps._3 = mReps._2;\n                                mReps._2 = mReps._1;\n                                mReps._1 = mReps._0;\n                                mReps._0 = pos;\n                                mMatchPriceCount++;\n                            }\n                        }\n\n                        mAdditionalOffset -= len;\n                        nowPos32 += len;\n\n                        if (mAdditionalOffset == 0)\n                        {\n                            if (!mFastMode)\n                            {\n                                if (mMatchPriceCount >= (1 << 7))\n                                    FillDistancesPrices();\n                                if (mAlignPriceCount >= kAlignTableSize)\n                                    FillAlignPrices();\n                            }\n\n                            if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)\n                                break;\n\n                            uint processed = nowPos32 - startPos32;\n                            if (useLimits)\n                            {\n                                if (processed + kNumOpts + 300 >= maxUnpackSize\n                                    || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)\n                                    break;\n                            }\n                            else if (processed >= (1 << 15))\n                            {\n                                mNowPos64 += nowPos32 - startPos32;\n                                TRS(\"CodeOneBlock\", \"chunk\");\n                                TR(\"CodeOneBlock:start\", startPos32);\n                                TR(\"CodeOneBlock:now\", nowPos32);\n                                return CheckErrors();\n                            }\n                        }\n                    }\n                }\n\n                mNowPos64 += nowPos32 - startPos32;\n                TRS(\"CodeOneBlock\", \"done\");\n                return Flush(nowPos32);\n            }\n\n            private const uint kBigHashDicLimit = 1u << 24;\n\n            private SRes LzmaEnc_Alloc(uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                if (!mRC.RangeEnc_Alloc(alloc))\n                    return SZ_ERROR_MEM;\n\n                bool btMode = mMatchFinderBase.mBtMode;\n#if !_7ZIP_ST\n                mMtMode = (mMultiThread && !mFastMode && btMode);\n#endif\n\n                int lclp = mLC + mLP;\n                if (mLitProbs == null || mSaveState.mLitProbs == null || mLcLp != lclp)\n                {\n                    LzmaEnc_FreeLits(alloc);\n                    mLitProbs = alloc.AllocUInt16(alloc, 0x300 << lclp);\n                    mSaveState.mLitProbs = alloc.AllocUInt16(alloc, 0x300 << lclp);\n                    if (mLitProbs == null || mSaveState.mLitProbs == null)\n                    {\n                        LzmaEnc_FreeLits(alloc);\n                        return SZ_ERROR_MEM;\n                    }\n                    mLcLp = lclp;\n                }\n\n                mMatchFinderBase.mBigHash = (mDictSize > kBigHashDicLimit);\n\n                uint beforeSize = kNumOpts;\n                if (beforeSize + mDictSize < keepWindowSize)\n                    beforeSize = keepWindowSize - mDictSize;\n\n#if !_7ZIP_ST\n                if (mMtMode)\n                {\n                    SRes res;\n                    if ((res = mMatchFinderMt.MatchFinderMt_Create(mDictSize, beforeSize, mNumFastBytes, LZMA_MATCH_LEN_MAX, allocBig)) != SZ_OK)\n                        return res;\n\n                    mMatchFinderObj = mMatchFinderMt;\n                    mMatchFinderMt.MatchFinderMt_CreateVTable(out mMatchFinder);\n                }\n                else\n#endif\n                {\n                    if (!mMatchFinderBase.MatchFinder_Create(mDictSize, beforeSize, mNumFastBytes, LZMA_MATCH_LEN_MAX, allocBig))\n                        return SZ_ERROR_MEM;\n\n                    mMatchFinderObj = mMatchFinderBase;\n                    MatchFinder_CreateVTable(mMatchFinderBase, out mMatchFinder);\n                }\n\n                return SZ_OK;\n            }\n\n            internal void LzmaEnc_Init()\n            {\n                TR(\"LzmaEnc_Init\", 0);\n\n                mState = 0;\n                mReps = new OptimumReps();\n\n                mRC.RangeEnc_Init();\n\n                for (uint i = 0; i < kNumStates; i++)\n                {\n                    for (uint j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)\n                    {\n                        mIsMatch[i][j] = kProbInitValue;\n                        mIsRep0Long[i][j] = kProbInitValue;\n                    }\n\n                    mIsRep[i] = kProbInitValue;\n                    mIsRepG0[i] = kProbInitValue;\n                    mIsRepG1[i] = kProbInitValue;\n                    mIsRepG2[i] = kProbInitValue;\n                }\n\n                uint n = 0x300u << (mLP + mLC);\n                for (uint i = 0; i < n; i++)\n                    mLitProbs[i] = kProbInitValue;\n\n                for (uint i = 0; i < kNumLenToPosStates; i++)\n                {\n                    P<ushort> probs = mPosSlotEncoder[i];\n                    for (uint j = 0; j < (1 << kNumPosSlotBits); j++)\n                        probs[j] = kProbInitValue;\n                }\n\n                for (uint i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)\n                    mPosEncoders[i] = kProbInitValue;\n\n                mLenEnc.LenEnc_Init();\n                mRepLenEnc.LenEnc_Init();\n\n                for (uint i = 0; i < (1 << kNumAlignBits); i++)\n                    mPosAlignEncoder[i] = kProbInitValue;\n\n                mOptimumEndIndex = 0;\n                mOptimumCurrentIndex = 0;\n                mAdditionalOffset = 0;\n\n                mPbMask = (1u << mPB) - 1;\n                mLpMask = (1u << mLP) - 1;\n            }\n\n            internal void LzmaEnc_InitPrices()\n            {\n                if (!mFastMode)\n                {\n                    FillDistancesPrices();\n                    FillAlignPrices();\n                }\n\n                uint tableSize = mNumFastBytes + 1 - LZMA_MATCH_LEN_MIN;\n                mLenEnc.mTableSize = tableSize;\n                mRepLenEnc.mTableSize = tableSize;\n                mLenEnc.LenPriceEnc_UpdateTables(1u << mPB, mProbPrices);\n                mRepLenEnc.LenPriceEnc_UpdateTables(1u << mPB, mProbPrices);\n            }\n\n            internal SRes LzmaEnc_AllocAndInit(uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                {\n                    uint i;\n                    for (i = 0; i < (uint)kDicLogSizeMaxCompress; i++)\n                        if (mDictSize <= (1u << (int)i))\n                            break;\n\n                    mDistTableSize = i * 2;\n                }\n\n                mFinished = false;\n                mResult = SZ_OK;\n\n                SRes res;\n                if ((res = LzmaEnc_Alloc(keepWindowSize, alloc, allocBig)) != SZ_OK)\n                    return res;\n\n                LzmaEnc_Init();\n                LzmaEnc_InitPrices();\n                mNowPos64 = 0;\n                return SZ_OK;\n            }\n\n            internal void LzmaEnc_SetInputBuf(P<byte> src, long srcLen)\n            {\n                mMatchFinderBase.mDirectInput = true;\n                mMatchFinderBase.mBufferBase = src;\n                mMatchFinderBase.mDirectInputRem = srcLen;\n            }\n\n            internal SRes LzmaEnc_Prepare(ISeqOutStream outStream, ISeqInStream inStream, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                mMatchFinderBase.mStream = inStream;\n                mNeedInit = true;\n                mRC.mOutStream = outStream;\n                return LzmaEnc_AllocAndInit(0, alloc, allocBig);\n            }\n\n            internal SRes LzmaEnc_PrepareForLzma2(ISeqInStream inStream, uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                mMatchFinderBase.mStream = inStream;\n                mNeedInit = true;\n                return LzmaEnc_AllocAndInit(keepWindowSize, alloc, allocBig);\n            }\n\n            internal SRes LzmaEnc_MemPrepare(P<byte> src, long srcLen, uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                LzmaEnc_SetInputBuf(src, srcLen);\n                mNeedInit = true;\n                return LzmaEnc_AllocAndInit(keepWindowSize, alloc, allocBig);\n            }\n\n            internal void LzmaEnc_Finish()\n            {\n#if !_7ZIP_ST\n                if (mMtMode)\n                    mMatchFinderMt.MatchFinderMt_ReleaseStream();\n#endif\n            }\n\n            internal uint LzmaEnc_GetNumAvailableBytes()\n            {\n                return mMatchFinder.GetNumAvailableBytes(mMatchFinderObj);\n            }\n\n            internal P<byte> LzmaEnc_GetCurBuf()\n            {\n                return mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;\n            }\n\n            internal SRes LzmaEnc_CodeOneMemBlock(bool reInit, P<byte> dest, ref long destLen, uint desiredPackSize, ref uint unpackSize)\n            {\n                CSeqOutStreamBuf outStream = new CSeqOutStreamBuf();\n\n                outStream.mData = dest;\n                outStream.mRem = destLen;\n                outStream.mOverflow = false;\n\n                mWriteEndMark = false;\n                mFinished = false;\n                mResult = SZ_OK;\n\n                if (reInit)\n                    LzmaEnc_Init();\n\n                LzmaEnc_InitPrices();\n                ulong nowPos64 = mNowPos64;\n                mRC.RangeEnc_Init();\n                mRC.mOutStream = outStream;\n\n                SRes res = LzmaEnc_CodeOneBlock(true, desiredPackSize, unpackSize);\n\n                unpackSize = (uint)(mNowPos64 - nowPos64);\n                destLen -= outStream.mRem;\n                if (outStream.mOverflow)\n                    return SZ_ERROR_OUTPUT_EOF;\n\n                return res;\n            }\n\n            private SRes LzmaEnc_Encode2(ICompressProgress progress)\n            {\n                SRes res = SZ_OK;\n                for (;;)\n                {\n                    res = LzmaEnc_CodeOneBlock(false, 0, 0);\n                    if (res != SZ_OK || mFinished)\n                        break;\n\n                    if (progress != null)\n                    {\n                        res = progress.Progress(mNowPos64, mRC.RangeEnc_GetProcessed());\n                        if (res != SZ_OK)\n                        {\n                            res = SZ_ERROR_PROGRESS;\n                            break;\n                        }\n                    }\n                }\n\n                LzmaEnc_Finish();\n                return res;\n            }\n\n            private void MovePos(uint num)\n            {\n#if SHOW_STAT\n                ttt += (int)num;\n                Print(\"\\n MovePos {0}\", num);\n#endif\n                TR(\"MovePos\", num);\n                if (num != 0)\n                {\n                    mAdditionalOffset += num;\n                    mMatchFinder.Skip(mMatchFinderObj, num);\n                }\n            }\n\n            private uint ReadMatchDistances(out uint numDistancePairsRes)\n            {\n                mNumAvail = mMatchFinder.GetNumAvailableBytes(mMatchFinderObj);\n                uint numPairs = mMatchFinder.GetMatches(mMatchFinderObj, mMatches);\n\n#if SHOW_STAT\n                {\n                    Print(\"\\n i = {0} numPairs = {1}    \", ttt, numPairs / 2);\n                    ttt++;\n                    for(uint i = 0; i < numPairs; i += 2)\n                        Print(\"{0:00} {1:000000}   | \", mMatches[i], mMatches[i + 1]);\n                }\n#endif\n\n                {\n                    TR(\"ReadMatchDistances:matches\", numPairs);\n                    for (uint i = 0; i < numPairs; i++)\n                        TR(\"ReadMatchDistances:match[i]\", mMatches[i]);\n                }\n\n                uint lenRes = 0;\n                if (numPairs > 0)\n                {\n                    lenRes = mMatches[numPairs - 2];\n                    if (lenRes == mNumFastBytes)\n                    {\n                        P<byte> pby = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                        uint distance = mMatches[numPairs - 1] + 1;\n\n                        uint numAvail = mNumAvail;\n                        if (numAvail > LZMA_MATCH_LEN_MAX)\n                            numAvail = LZMA_MATCH_LEN_MAX;\n\n                        P<byte> pby2 = pby - distance;\n                        while (lenRes < numAvail && pby[lenRes] == pby2[lenRes])\n                            lenRes++;\n                    }\n                }\n\n                mAdditionalOffset++;\n                numDistancePairsRes = numPairs;\n                TR(\"ReadMatchDistances:lenRes\", lenRes);\n                return lenRes;\n            }\n\n            private uint GetRepLen1Price(uint state, uint posState)\n            {\n                return GET_PRICE_0(mIsRepG0[state])\n                    + GET_PRICE_0(mIsRep0Long[state][posState]);\n            }\n\n            private uint GetPureRepPrice(uint repIndex, uint state, uint posState)\n            {\n                uint price;\n                if (repIndex == 0)\n                {\n                    price = GET_PRICE_0(mIsRepG0[state]);\n                    price += GET_PRICE_1(mIsRep0Long[state][posState]);\n                }\n                else\n                {\n                    price = GET_PRICE_1(mIsRepG0[state]);\n                    if (repIndex == 1)\n                    {\n                        price += GET_PRICE_0(mIsRepG1[state]);\n                    }\n                    else\n                    {\n                        price += GET_PRICE_1(mIsRepG1[state]);\n                        price += GET_PRICE(mIsRepG2[state], repIndex - 2);\n                    }\n                }\n                return price;\n            }\n\n            private uint GetRepPrice(uint repIndex, uint len, uint state, uint posState)\n            {\n                return mRepLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN]\n                    + GetPureRepPrice(repIndex, state, posState);\n            }\n\n            private uint Backward(out uint backRes, uint cur)\n            {\n                uint posMem = mOpt[cur].mPosPrev;\n                uint backMem = mOpt[cur].mBackPrev;\n                mOptimumEndIndex = cur;\n                do\n                {\n                    if (mOpt[cur].mPrev1IsChar)\n                    {\n                        mOpt[posMem].MakeAsChar();\n                        mOpt[posMem].mPosPrev = posMem - 1;\n\n                        if (mOpt[cur].mPrev2)\n                        {\n                            mOpt[posMem - 1].mPrev1IsChar = false;\n                            mOpt[posMem - 1].mPosPrev = mOpt[cur].mPosPrev2;\n                            mOpt[posMem - 1].mBackPrev = mOpt[cur].mBackPrev2;\n                        }\n                    }\n\n                    uint posPrev = posMem;\n                    uint backCur = backMem;\n\n                    backMem = mOpt[posPrev].mBackPrev;\n                    posMem = mOpt[posPrev].mPosPrev;\n\n                    mOpt[posPrev].mBackPrev = backCur;\n                    mOpt[posPrev].mPosPrev = cur;\n                    cur = posPrev;\n                }\n                while (cur != 0);\n                backRes = mOpt[0].mBackPrev;\n                mOptimumCurrentIndex = mOpt[0].mPosPrev;\n                return mOptimumCurrentIndex;\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            private uint GET_PRICE(ushort prob, uint symbol)\n            {\n                return GET_PRICE(mProbPrices, prob, symbol);\n            }\n\n            private uint GET_PRICE_0(ushort prob)\n            {\n                return GET_PRICE_0(mProbPrices, prob);\n            }\n\n            private uint GET_PRICE_1(ushort prob)\n            {\n                return GET_PRICE_1(mProbPrices, prob);\n            }\n\n            #endregion\n        }\n\n        public static CLzmaEnc LzmaEnc_Create(ISzAlloc alloc)\n        {\n#if !DISABLE_TRACE\n            if (!alloc.CheckAllocObject<CLzmaEnc>())\n                return null;\n#endif\n            return new CLzmaEnc();\n        }\n\n        /* ---------- One Call Interface ---------- */\n\n        /* LzmaEncode\n        Return code:\n          SZ_OK               - OK\n          SZ_ERROR_MEM        - Memory allocation error\n          SZ_ERROR_PARAM      - Incorrect paramater\n          SZ_ERROR_OUTPUT_EOF - output buffer overflow\n          SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)\n        */\n\n        public static SRes LzmaEncode(P<byte> dest, ref long destLen, P<byte> src, long srcLen, CLzmaEncProps props, P<byte> propsEncoded, ref long propsSize, bool writeEndMark, ICompressProgress progress, ISzAlloc alloc, ISzAlloc allocBig)\n        {\n            CLzmaEnc encoder = LzmaEnc_Create(alloc);\n            if (encoder == null)\n                return SZ_ERROR_MEM;\n\n            SRes res;\n            res = encoder.LzmaEnc_SetProps(props);\n            if (res == SZ_OK)\n            {\n                res = encoder.LzmaEnc_WriteProperties(propsEncoded, ref propsSize);\n                if (res == SZ_OK)\n                    res = encoder.LzmaEnc_MemEncode(dest, ref destLen, src, srcLen, writeEndMark, progress, alloc, allocBig);\n            }\n\n            encoder.LzmaEnc_Destroy(alloc, allocBig);\n            return res;\n        }\n    }\n    partial class LZMA\n    {\n        /*\n        RAM requirements for LZMA:\n          for compression:   (dictSize * 11.5 + 6 MB) + state_size\n          for decompression: dictSize + state_size\n            state_size = (4 + (1.5 << (lc + lp))) KB\n            by default (lc=3, lp=0), state_size = 16 KB.\n\n        LZMA properties (5 bytes) format\n            Offset Size  Description\n              0     1    lc, lp and pb in encoded form.\n              1     4    dictSize (little endian).\n        */\n\n        /*\n        LzmaCompress\n        ------------\n\n        outPropsSize -\n             In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.\n             Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.\n\n          LZMA Encoder will use defult values for any parameter, if it is\n          -1  for any from: level, loc, lp, pb, fb, numThreads\n           0  for dictSize\n  \n        level - compression level: 0 <= level <= 9;\n\n          level dictSize algo  fb\n            0:    16 KB   0    32\n            1:    64 KB   0    32\n            2:   256 KB   0    32\n            3:     1 MB   0    32\n            4:     4 MB   0    32\n            5:    16 MB   1    32\n            6:    32 MB   1    32\n            7+:   64 MB   1    64\n \n          The default value for \"level\" is 5.\n\n          algo = 0 means fast method\n          algo = 1 means normal method\n\n        dictSize - The dictionary size in bytes. The maximum value is\n                128 MB = (1 << 27) bytes for 32-bit version\n                  1 GB = (1 << 30) bytes for 64-bit version\n             The default value is 16 MB = (1 << 24) bytes.\n             It's recommended to use the dictionary that is larger than 4 KB and\n             that can be calculated as (1 << N) or (3 << N) sizes.\n\n        lc - The number of literal context bits (high bits of previous literal).\n             It can be in the range from 0 to 8. The default value is 3.\n             Sometimes lc=4 gives the gain for big files.\n\n        lp - The number of literal pos bits (low bits of current position for literals).\n             It can be in the range from 0 to 4. The default value is 0.\n             The lp switch is intended for periodical data when the period is equal to 2^lp.\n             For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's\n             better to set lc=0, if you change lp switch.\n\n        pb - The number of pos bits (low bits of current position).\n             It can be in the range from 0 to 4. The default value is 2.\n             The pb switch is intended for periodical data when the period is equal 2^pb.\n\n        fb - Word size (the number of fast bytes).\n             It can be in the range from 5 to 273. The default value is 32.\n             Usually, a big number gives a little bit better compression ratio and\n             slower compression process.\n\n        numThreads - The number of thereads. 1 or 2. The default value is 2.\n             Fast mode (algo = 0) can use only 1 thread.\n\n        Out:\n          destLen  - processed output size\n        Returns:\n          SZ_OK               - OK\n          SZ_ERROR_MEM        - Memory allocation error\n          SZ_ERROR_PARAM      - Incorrect paramater\n          SZ_ERROR_OUTPUT_EOF - output buffer overflow\n          SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)\n        */\n\n        public static SRes LzmaCompress(\n            P<byte> dest, ref long destLen,\n            P<byte> src, long srcLen,\n            P<byte> outProps, ref long outPropsSize, /* *outPropsSize must be = 5 */\n            int level,      /* 0 <= level <= 9, default = 5 */\n            uint dictSize,  /* default = (1 << 24) */\n            int lc,        /* 0 <= lc <= 8, default = 3  */\n            int lp,        /* 0 <= lp <= 4, default = 0  */\n            int pb,        /* 0 <= pb <= 4, default = 2  */\n            int fb,        /* 5 <= fb <= 273, default = 32 */\n            int numThreads) /* 1 or 2, default = 2 */\n        {\n            CLzmaEncProps props = CLzmaEncProps.LzmaEncProps_Init();\n            props.mLevel = level;\n            props.mDictSize = dictSize;\n            props.mLC = lc;\n            props.mLP = lp;\n            props.mPB = pb;\n            props.mFB = fb;\n            props.mNumThreads = numThreads;\n\n            return LzmaEncode(dest, ref destLen, src, srcLen, props, outProps, ref outPropsSize, false, null, ISzAlloc.SmallAlloc, ISzAlloc.BigAlloc);\n        }\n\n        /*\n        LzmaUncompress\n        --------------\n        In:\n          dest     - output data\n          destLen  - output data size\n          src      - input data\n          srcLen   - input data size\n        Out:\n          destLen  - processed output size\n          srcLen   - processed input size\n        Returns:\n          SZ_OK                - OK\n          SZ_ERROR_DATA        - Data error\n          SZ_ERROR_MEM         - Memory allocation arror\n          SZ_ERROR_UNSUPPORTED - Unsupported properties\n          SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)\n        */\n\n        public static SRes LzmaUncompress(\n            P<byte> dest, ref long destLen,\n            P<byte> src, ref long srcLen,\n            P<byte> props, long propsSize)\n        {\n            ELzmaStatus status;\n            return CLzmaDec.LzmaDecode(dest, ref destLen, src, ref srcLen, props, (uint)propsSize, ELzmaFinishMode.LZMA_FINISH_ANY, out status, ISzAlloc.SmallAlloc);\n        }\n    }\n    partial class LZMA\n    {\n        internal sealed class CLoopThread\n        {\n            #region Variables\n\n            public CThread mThread;\n            public CEvent mStartEvent;\n            public CEvent mFinishedEvent;\n            public bool mStop;\n\n            public Action mFunc;\n            //public CMtThread mParam;\n            //public THREAD_FUNC_RET_TYPE mRes;\n\n            #endregion\n\n            #region Private Methods\n\n            private void LoopThreadFunc()\n            {\n                for (;;)\n                {\n                    if (Event_Wait(mStartEvent) != 0)\n                        return; // SZ_ERROR_THREAD;\n\n                    Trace.MatchObjectWait(this, \"LoopThreadFunc\");\n                    if (mStop)\n                    {\n                        Trace.MatchObjectDestroy(this, \"LoopThreadFunc\");\n                        return; // 0;\n                    }\n                    Trace.MatchObjectWait(this, \"LoopThreadFunc\");\n\n                    /* mRes = mFunc(mParam)*/\n                    mFunc();\n\n                    if (Event_Set(mFinishedEvent) != 0)\n                        return; // SZ_ERROR_THREAD;\n                }\n            }\n\n            #endregion\n\n            #region Methods\n\n            internal CLoopThread() // LoopThread_Construct\n            {\n                Thread_Construct(out mThread);\n                Event_Construct(out mStartEvent);\n                Event_Construct(out mFinishedEvent);\n            }\n\n            internal void LoopThread_Close()\n            {\n                Thread_Close(ref mThread);\n                Event_Close(ref mStartEvent);\n                Event_Close(ref mFinishedEvent);\n            }\n\n            internal SRes LoopThread_Create()\n            {\n                Trace.MatchObjectCreate(this, \"LoopThread_Create\");\n                mStop = false;\n                Trace.MatchObjectWait(this, \"LoopThread_Create\");\n\n                SRes res;\n                if ((res = AutoResetEvent_CreateNotSignaled(out mStartEvent)) != SZ_OK)\n                    return res;\n                if ((res = AutoResetEvent_CreateNotSignaled(out mFinishedEvent)) != SZ_OK)\n                    return res;\n                return Thread_Create(out mThread, LoopThreadFunc, \"LZMA 2 Loop Thread\");\n            }\n\n            internal SRes LoopThread_StopAndWait()\n            {\n                Trace.MatchObjectWait(this, \"LoopThread_StopAndWait\");\n                mStop = true;\n                Trace.MatchObjectWait(this, \"LoopThread_StopAndWait\");\n\n                if (Event_Set(mStartEvent) != 0)\n                    return SZ_ERROR_THREAD;\n\n                return Thread_Wait(mThread);\n            }\n\n            internal SRes LoopThread_StartSubThread()\n            {\n                return Event_Set(mStartEvent);\n            }\n\n            internal SRes LoopThread_WaitSubThread()\n            {\n                return Event_Wait(mFinishedEvent);\n            }\n\n            #endregion\n        }\n\n#if !_7ZIP_ST\n        public const int NUM_MT_CODER_THREADS_MAX = 32;\n#else\n        public const int NUM_MT_CODER_THREADS_MAX = 1;\n#endif\n\n        internal sealed class CMtProgress\n        {\n            #region Variables\n\n            internal ulong mTotalInSize;\n            internal ulong mTotalOutSize;\n            internal ICompressProgress mProgress;\n            internal SRes mRes;\n            internal CCriticalSection mCS = new CCriticalSection();\n            internal ulong[] mInSizes = new ulong[NUM_MT_CODER_THREADS_MAX];\n            internal ulong[] mOutSizes = new ulong[NUM_MT_CODER_THREADS_MAX];\n\n            #endregion\n\n            #region Methods\n\n            internal void MtProgress_Init(ICompressProgress progress)\n            {\n                for (uint i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)\n                    mInSizes[i] = mOutSizes[i] = 0;\n\n                mTotalInSize = 0;\n                mTotalOutSize = 0;\n                mProgress = progress;\n                mRes = SZ_OK;\n            }\n\n            internal void MtProgress_Reinit(int index)\n            {\n                mInSizes[index] = 0;\n                mOutSizes[index] = 0;\n            }\n\n            private static void UPDATE_PROGRESS(ulong size, ref ulong prev, ref ulong total)\n            {\n                if (size != ~0ul)\n                {\n                    total += size - prev;\n                    prev = size;\n                }\n            }\n\n            private static SRes Progress(ICompressProgress p, ulong inSize, ulong outSize)\n            {\n                return (p != null && p.Progress(inSize, outSize) != SZ_OK) ? SZ_ERROR_PROGRESS : SZ_OK;\n            }\n\n            public SRes MtProgress_Set(int index, ulong inSize, ulong outSize)\n            {\n                CriticalSection_Enter(mCS);\n                UPDATE_PROGRESS(inSize, ref mInSizes[index], ref mTotalInSize);\n                UPDATE_PROGRESS(outSize, ref mOutSizes[index], ref mTotalOutSize);\n                if (mRes == SZ_OK)\n                    mRes = Progress(mProgress, mTotalInSize, mTotalOutSize);\n                SRes res = mRes;\n                CriticalSection_Leave(mCS);\n                return res;\n            }\n\n            internal void MtProgress_SetError(SRes res)\n            {\n                CriticalSection_Enter(mCS);\n                if (mRes == SZ_OK)\n                    mRes = res;\n                CriticalSection_Leave(mCS);\n            }\n\n            #endregion\n        }\n\n        internal sealed class CMtThread\n        {\n            #region Variables\n\n            internal CMtCoder mMtCoder;\n            internal byte[] mOutBuf;\n            internal long mOutBufSize;\n            internal byte[] mInBuf;\n            internal long mInBufSize;\n            internal int mIndex;\n            internal CLoopThread mThread;\n\n            internal bool mStopReading;\n            internal bool mStopWriting;\n            internal CEvent mCanRead;\n            internal CEvent mCanWrite;\n\n            #endregion\n\n            #region Methods\n\n            internal CMtThread(int index, CMtCoder mtCoder) // CMtThread_Construct\n            {\n                Trace.MatchObjectCreate(this, \"CMtThread_Construct\");\n\n                mIndex = index;\n                mMtCoder = mtCoder;\n                mOutBuf = null;\n                mInBuf = null;\n\n                Event_Construct(out mCanRead);\n                Event_Construct(out mCanWrite);\n\n                mThread = new CLoopThread();\n            }\n\n            internal CMtThread GET_NEXT_THREAD()\n            {\n                int index = mIndex + 1;\n                if (index == mMtCoder.mNumThreads)\n                    index = 0;\n\n                return mMtCoder.mThreads[index];\n            }\n\n            internal SRes MtThread_Process(out bool stop)\n            {\n                stop = true;\n                if (Event_Wait(mCanRead) != 0)\n                    return SZ_ERROR_THREAD;\n\n                CMtThread next = GET_NEXT_THREAD();\n\n                Trace.MatchObjectWait(this, \"MtThread_Process\");\n                if (mStopReading)\n                {\n                    next.mStopReading = true;\n                    Trace.MatchObjectWait(this, \"MtThread_Process\");\n                    return Event_Set(next.mCanRead) == 0 ? SZ_OK : SZ_ERROR_THREAD;\n                }\n                Trace.MatchObjectWait(this, \"MtThread_Process\");\n\n                {\n                    long size = mMtCoder.mBlockSize;\n                    long destSize = mOutBufSize;\n\n                    SRes res;\n                    if ((res = CMtCoder.FullRead(mMtCoder.mInStream, mInBuf, ref size)) != SZ_OK)\n                        return res;\n\n                    stop = (size != mMtCoder.mBlockSize);\n\n                    Trace.MatchObjectWait(this, \"MtThread_Process:2\");\n                    next.mStopReading = stop;\n                    Trace.MatchObjectWait(this, \"MtThread_Process:2\");\n\n                    if (Event_Set(next.mCanRead) != 0)\n                        return SZ_ERROR_THREAD;\n\n                    if ((res = mMtCoder.mMtCallback.Code(mIndex, mOutBuf, ref destSize, mInBuf, size, stop)) != SZ_OK)\n                        return res;\n\n                    mMtCoder.mMtProgress.MtProgress_Reinit(mIndex);\n\n                    if (Event_Wait(mCanWrite) != 0)\n                        return SZ_ERROR_THREAD;\n\n                    Trace.MatchObjectWait(this, \"MtThread_Process:3\");\n                    if (mStopWriting)\n                    {\n                        Trace.MatchObjectWait(this, \"MtThread_Process:3\");\n                        return SZ_ERROR_FAIL;\n                    }\n                    Trace.MatchObjectWait(this, \"MtThread_Process:3\");\n\n                    if (mMtCoder.mOutStream.Write(mOutBuf, destSize) != destSize)\n                        return SZ_ERROR_WRITE;\n\n                    return Event_Set(next.mCanWrite) == 0 ? SZ_OK : SZ_ERROR_THREAD;\n                }\n            }\n\n            internal void ThreadFunc()\n            {\n                for (;;)\n                {\n                    CMtThread next = GET_NEXT_THREAD();\n\n                    bool stop;\n                    SRes res = MtThread_Process(out stop);\n                    if (res != SZ_OK)\n                    {\n                        mMtCoder.MtCoder_SetError(res);\n                        mMtCoder.mMtProgress.MtProgress_SetError(res);\n\n                        Trace.MatchObjectWait(this, \"ThreadFunc\");\n                        next.mStopReading = true;\n                        next.mStopWriting = true;\n                        Trace.MatchObjectWait(this, \"ThreadFunc\");\n\n                        Event_Set(next.mCanRead);\n                        Event_Set(next.mCanWrite);\n                        return; // res;\n                    }\n\n                    if (stop)\n                        return; // 0;\n                }\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            internal void CMtThread_CloseEvents()\n            {\n                Event_Close(ref mCanRead);\n                Event_Close(ref mCanWrite);\n            }\n\n            internal void CMtThread_Destruct()\n            {\n                Trace.MatchObjectDestroy(this, \"CMtThread_Destruct\");\n                CMtThread_CloseEvents();\n\n                if (Thread_WasCreated(mThread.mThread))\n                {\n                    mThread.LoopThread_StopAndWait();\n                    mThread.LoopThread_Close();\n                }\n\n                if (mMtCoder.mAlloc != null)\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mOutBuf);\n\n                mOutBuf = null;\n\n                if (mMtCoder.mAlloc != null)\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mInBuf);\n\n                mInBuf = null;\n            }\n\n            internal SRes CMtThread_Prepare()\n            {\n                if (mInBuf == null || mInBufSize != mMtCoder.mBlockSize)\n                {\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mInBuf);\n                    mInBufSize = mMtCoder.mBlockSize;\n                    mInBuf = IAlloc_AllocBytes(mMtCoder.mAlloc, mInBufSize);\n                    if (mInBuf == null)\n                        return SZ_ERROR_MEM;\n                }\n\n                if (mOutBuf == null || mOutBufSize != mMtCoder.mDestBlockSize)\n                {\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mOutBuf);\n                    mOutBufSize = mMtCoder.mDestBlockSize;\n                    mOutBuf = IAlloc_AllocBytes(mMtCoder.mAlloc, mOutBufSize);\n                    if (mOutBuf == null)\n                        return SZ_ERROR_MEM;\n                }\n\n                Trace.MatchObjectWait(this, \"CMtThread_Prepare\");\n                mStopReading = false;\n                mStopWriting = false;\n                Trace.MatchObjectWait(this, \"CMtThread_Prepare\");\n\n                if (AutoResetEvent_CreateNotSignaled(out mCanRead) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                if (AutoResetEvent_CreateNotSignaled(out mCanWrite) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                return SZ_OK;\n            }\n\n            #endregion\n        }\n\n        internal sealed class CMtCoder\n        {\n            #region Variables\n\n            public long mBlockSize;\n            public long mDestBlockSize;\n            public int mNumThreads;\n\n            public ISeqInStream mInStream;\n            public ISeqOutStream mOutStream;\n            public ICompressProgress mProgress;\n            public ISzAlloc mAlloc;\n\n            public CMtCallbackImp mMtCallback;\n            public CCriticalSection mCS = new CCriticalSection();\n            public SRes mRes;\n\n            public CMtProgress mMtProgress = new CMtProgress();\n            public CMtThread[] mThreads;\n\n            #endregion\n\n            #region Internal Methods\n\n            internal CMtCoder() // MtCoder_Construct\n            {\n                mAlloc = null;\n\n                mThreads = new CMtThread[NUM_MT_CODER_THREADS_MAX];\n                for (int i = 0; i < mThreads.Length; i++)\n                    mThreads[i] = new CMtThread(i, this);\n\n                CriticalSection_Init(out mCS);\n                CriticalSection_Init(out mMtProgress.mCS);\n            }\n\n            internal void MtCoder_Destruct()\n            {\n                for (uint i = 0; i < mThreads.Length; i++)\n                    mThreads[i].CMtThread_Destruct();\n\n                CriticalSection_Delete(mCS);\n                CriticalSection_Delete(mMtProgress.mCS);\n            }\n\n            internal SRes MtCoder_Code()\n            {\n                int numThreads = mNumThreads;\n                SRes res = SZ_OK;\n                mRes = SZ_OK;\n\n                mMtProgress.MtProgress_Init(mProgress);\n\n                for (uint i = 0; i < numThreads; i++)\n                {\n                    if ((res = mThreads[i].CMtThread_Prepare()) != SZ_OK)\n                        return res;\n                }\n\n                for (uint i = 0; i < numThreads; i++)\n                {\n                    CMtThread t = mThreads[i];\n                    CLoopThread lt = t.mThread;\n\n                    if (!Thread_WasCreated(lt.mThread))\n                    {\n                        lt.mFunc = t.ThreadFunc;\n                        if (lt.LoopThread_Create() != SZ_OK)\n                        {\n                            res = SZ_ERROR_THREAD;\n                            break;\n                        }\n                    }\n                }\n\n                if (res == SZ_OK)\n                {\n                    int i;\n                    for (i = 0; i < numThreads; i++)\n                    {\n                        CMtThread t = mThreads[i];\n                        if (t.mThread.LoopThread_StartSubThread() != SZ_OK)\n                        {\n                            res = SZ_ERROR_THREAD;\n                            Trace.MatchObjectWait(mThreads[0], \"MtCoder_Code\");\n                            mThreads[0].mStopReading = true;\n                            Trace.MatchObjectWait(mThreads[0], \"MtCoder_Code\");\n                            break;\n                        }\n                    }\n\n                    Event_Set(mThreads[0].mCanWrite);\n                    Event_Set(mThreads[0].mCanRead);\n\n                    for (int j = 0; j < i; j++)\n                        mThreads[j].mThread.LoopThread_WaitSubThread();\n                }\n\n                for (uint i = 0; i < numThreads; i++)\n                    mThreads[i].CMtThread_CloseEvents();\n\n                return (res == SZ_OK) ? mRes : res;\n            }\n\n            #endregion\n\n            #region Methods\n\n            internal void MtCoder_SetError(SRes res)\n            {\n                CriticalSection_Enter(mCS);\n                if (mRes == SZ_OK)\n                    mRes = res;\n                CriticalSection_Leave(mCS);\n            }\n\n            internal static SRes FullRead(ISeqInStream stream, P<byte> data, ref long processedSize)\n            {\n                long size = processedSize;\n                processedSize = 0;\n                while (size != 0)\n                {\n                    long curSize = size;\n                    SRes res = stream.Read(data, ref curSize);\n                    processedSize += curSize;\n                    data += curSize;\n                    size -= curSize;\n                    if (res != SZ_OK)\n                        return res;\n                    if (curSize == 0)\n                        return SZ_OK;\n                }\n                return SZ_OK;\n            }\n\n            #endregion\n        }\n    }\n    partial class LZMA\n    {\n        #region CThread\n\n        internal sealed class CThread\n        {\n#if BUILD_PORTABLE\n            internal System.Threading.Tasks.Task _task;\n#else\n            internal System.Threading.Thread _thread;\n#endif\n        }\n\n        internal static void Thread_Construct(out CThread p)\n        {\n            p = null;\n        }\n\n        internal static bool Thread_WasCreated(CThread p)\n        {\n            return p != null;\n        }\n\n        internal static void Thread_Close(ref CThread p)\n        {\n            if (p != null)\n            {\n#if !DISABLE_TRACE\n                Trace.MatchThreadClose(p._thread);\n#elif BUILD_PORTABLE\n                p._task.GetAwaiter().GetResult();\n#else\n                p._thread.Join();\n#endif\n            }\n\n            p = null;\n        }\n\n        internal static SRes Thread_Wait(CThread p)\n        {\n#if BUILD_PORTABLE\n            p._task.GetAwaiter().GetResult();\n#else\n            p._thread.Join();\n#endif\n\n#if !DISABLE_TRACE\n            Trace.MatchThreadWait(p._thread);\n#endif\n\n            return TSZ(\"Thread_Wait\");\n        }\n\n        internal static SRes Thread_Create(out CThread p, Action func, string threadName)\n        {\n            p = new CThread();\n#if !DISABLE_TRACE\n            p._thread = Trace.MatchThreadStart(func);\n#elif BUILD_PORTABLE\n            p._task = System.Threading.Tasks.Task.Run(func);\n#else\n            p._thread = new System.Threading.Thread(delegate () { func(); });\n            p._thread.Name = threadName;\n            p._thread.Start();\n#endif\n            return TSZ(\"Thread_Create\");\n        }\n\n        #endregion\n\n        #region CEvent\n\n        // this is a win32 autoreset event\n\n        internal sealed class CEvent\n        {\n#if DISABLE_TRACE\n            public System.Threading.AutoResetEvent Event;\n#endif\n        }\n\n        internal static void Event_Construct(out CEvent p)\n        {\n            p = null;\n        }\n\n        internal static bool Event_IsCreated(CEvent p)\n        {\n            return p != null;\n        }\n\n        internal static void Event_Close(ref CEvent p)\n        {\n            if (p != null)\n            {\n#if !DISABLE_TRACE\n                Trace.MatchObjectDestroy(p, \"Event_Close\");\n#elif BUILD_PORTABLE\n                p.Event.Dispose();\n#else\n                p.Event.Close();\n#endif\n            }\n            p = null;\n        }\n\n        internal static SRes Event_Wait(CEvent p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Event_Wait\");\n#else\n            p.Event.WaitOne();\n#endif\n            return TSZ(\"Event_Wait\");\n        }\n\n        internal static SRes Event_Set(CEvent p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Event_Set\");\n#else\n            p.Event.Set();\n#endif\n            return TSZ(\"Event_Set\");\n        }\n\n        internal static SRes Event_Reset(CEvent p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Event_Reset\");\n#else\n            p.Event.Reset();\n#endif\n            return TSZ(\"Event_Reset\");\n        }\n\n        internal static SRes AutoResetEvent_CreateNotSignaled(out CEvent p)\n        {\n            p = new CEvent();\n#if !DISABLE_TRACE\n            Trace.MatchObjectCreate(p, \"Event_Create\");\n#else\n            p.Event = new System.Threading.AutoResetEvent(false);\n#endif\n            return TSZ(\"Event_Create\");\n        }\n\n        #endregion\n\n        #region CSemaphore\n\n        internal sealed class CSemaphore\n        {\n#if DISABLE_TRACE\n            public System.Threading.Semaphore Semaphore;\n#endif\n        }\n\n        internal static void Semaphore_Construct(out CSemaphore p)\n        {\n            p = null;\n        }\n\n        internal static void Semaphore_Close(ref CSemaphore p)\n        {\n            if (p != null)\n            {\n#if !DISABLE_TRACE\n                Trace.MatchObjectDestroy(p, \"Semaphore_Close\");\n#elif BUILD_PORTABLE\n                p.Semaphore.Dispose();\n#else\n                p.Semaphore.Close();\n#endif\n            }\n\n            p = null;\n        }\n\n        internal static SRes Semaphore_Wait(CSemaphore p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Semaphore_Wait\");\n#else\n            p.Semaphore.WaitOne();\n#endif\n            return TSZ(\"Semaphore_Wait\");\n        }\n\n        internal static SRes Semaphore_Create(out CSemaphore p, uint initCount, uint maxCount)\n        {\n            p = new CSemaphore();\n#if !DISABLE_TRACE\n            Trace.MatchObjectCreate(p, \"Semaphore_Create\");\n            Trace.Match((int)initCount, (int)maxCount);\n#else\n            p.Semaphore = new System.Threading.Semaphore(checked((int)initCount), checked((int)maxCount));\n#endif\n            return TSZ(\"Semaphore_Create\");\n        }\n\n        internal static SRes Semaphore_Release1(CSemaphore p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Semaphore_Release\");\n#else\n            p.Semaphore.Release();\n#endif\n            return TSZ(\"Semaphore_Release\");\n        }\n\n        #endregion\n\n        #region CCriticalSection\n\n        internal sealed class CCriticalSection { }\n\n        internal static SRes CriticalSection_Init(out CCriticalSection p)\n        {\n            p = new CCriticalSection();\n#if !DISABLE_TRACE\n            Trace.MatchObjectCreate(p, \"CriticalSection_Init\");\n#endif\n            return SZ_OK; // never fails in C code either\n        }\n\n        internal static void CriticalSection_Delete(CCriticalSection p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectDestroy(p, \"CriticalSection_Delete\");\n#endif\n        }\n\n        internal static void CriticalSection_Enter(CCriticalSection p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"CriticalSection_Enter\");\n#else\n            System.Threading.Monitor.Enter(p);\n#endif\n        }\n\n        internal static void CriticalSection_Leave(CCriticalSection p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"CriticalSection_Leave\");\n#else\n            System.Threading.Monitor.Exit(p);\n#endif\n        }\n\n        #endregion\n    }\n    partial class LZMA\n    {\n        public struct SRes\n        {\n            private int _code;\n            public SRes(int code) { _code = code; }\n            public override int GetHashCode() { return _code; }\n            public override bool Equals(object obj) { return obj is SRes && ((SRes)obj)._code == _code; }\n            public bool Equals(SRes obj) { return obj._code == _code; }\n            public static bool operator ==(SRes left, SRes right) { return left._code == right._code; }\n            public static bool operator !=(SRes left, SRes right) { return left._code != right._code; }\n            public static bool operator ==(SRes left, int right) { return left._code == right; }\n            public static bool operator !=(SRes left, int right) { return left._code != right; }\n        }\n\n        public static SRes SZ_OK { get { return new SRes(0); } }\n\n        public static SRes SZ_ERROR_DATA { get { return new SRes(1); } }\n        public static SRes SZ_ERROR_MEM { get { return new SRes(2); } }\n        public static SRes SZ_ERROR_CRC { get { return new SRes(3); } }\n        public static SRes SZ_ERROR_UNSUPPORTED { get { return new SRes(4); } }\n        public static SRes SZ_ERROR_PARAM { get { return new SRes(5); } }\n        public static SRes SZ_ERROR_INPUT_EOF { get { return new SRes(6); } }\n        public static SRes SZ_ERROR_OUTPUT_EOF { get { return new SRes(7); } }\n        public static SRes SZ_ERROR_READ { get { return new SRes(8); } }\n        public static SRes SZ_ERROR_WRITE { get { return new SRes(9); } }\n        public static SRes SZ_ERROR_PROGRESS { get { return new SRes(10); } }\n        public static SRes SZ_ERROR_FAIL { get { return new SRes(11); } }\n        public static SRes SZ_ERROR_THREAD { get { return new SRes(12); } }\n\n        public static SRes SZ_ERROR_ARCHIVE { get { return new SRes(16); } }\n        public static SRes SZ_ERROR_NO_ARCHIVE { get { return new SRes(17); } }\n\n        //#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }\n\n        /* The following interfaces use first parameter as pointer to structure */\n\n        /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.\n           (output(*size) < input(*size)) is allowed */\n        public interface ISeqInStream\n        {\n            SRes Read(P<byte> buf, ref long size);\n        }\n\n        public class CSeqInStream : ISeqInStream\n        {\n            private Func<P<byte>, long, long> mCallback;\n\n            public CSeqInStream(Func<P<byte>, long, long> callback)\n            {\n                mCallback = callback;\n            }\n\n            SRes ISeqInStream.Read(P<byte> buf, ref long size)\n            {\n                try { size = mCallback(buf, size); }\n                catch { return SZ_ERROR_READ; }\n                return SZ_OK;\n            }\n        }\n\n        /* Returns: result - the number of actually written bytes.\n           (result < size) means error */\n        public interface ISeqOutStream\n        {\n            long Write(P<byte> buf, long size);\n        }\n\n        public class CSeqOutStream : ISeqOutStream\n        {\n            private Action<P<byte>, long> mCallback;\n\n            public CSeqOutStream(Action<P<byte>, long> callback)\n            {\n                mCallback = callback;\n            }\n\n            long ISeqOutStream.Write(P<byte> buf, long size)\n            {\n                if (size <= 0)\n                {\n                    System.Diagnostics.Debugger.Break();\n                    return -1;\n                }\n\n                try { mCallback(buf, size); }\n                catch { return 0; }\n                return size;\n            }\n        }\n\n        /* Returns: result. (result != SZ_OK) means break.\n           Value (ulong)(long)-1 for size means unknown value. */\n        public interface ICompressProgress\n        {\n            SRes Progress(ulong inSize, ulong outSize);\n        }\n\n        //public delegate object ISzAlloc_Alloc(object p, long size);\n        //public delegate void ISzAlloc_Free(object p, object address); /* address can be null */\n        public sealed class ISzAlloc\n        {\n            public static readonly ISzAlloc BigAlloc = new ISzAlloc(200);\n            public static readonly ISzAlloc SmallAlloc = new ISzAlloc(100);\n\n            private static Dictionary<long, List<byte[]>> Cache1 = new Dictionary<long, List<byte[]>>();\n            private static Dictionary<long, List<ushort[]>> Cache2 = new Dictionary<long, List<ushort[]>>();\n            private static Dictionary<long, List<uint[]>> Cache3 = new Dictionary<long, List<uint[]>>();\n\n            private int mKind;\n\n            private ISzAlloc(int kind)\n            {\n                mKind = kind;\n            }\n\n#if !DISABLE_TRACE\n            internal bool CheckAllocObject<T>()\n            {\n                return true;\n            }\n#endif\n\n            public T AllocObject<T>(object p)\n                where T : class, new()\n            {\n#if !DISABLE_TRACE\n                if (!CheckAllocObject<T>())\n                    return null;\n#endif\n                return new T();\n            }\n\n            public byte[] AllocBytes(object p, long size)\n            {\n                lock (Cache1)\n                {\n                    List<byte[]> cache;\n                    if (Cache1.TryGetValue(size, out cache) && cache.Count > 0)\n                    {\n                        byte[] buffer = cache[cache.Count - 1];\n                        cache.RemoveAt(cache.Count - 1);\n                        return buffer;\n                    }\n                }\n\n                System.Diagnostics.Debug.WriteLine(\"Alloc byte size=\" + size);\n                return new byte[size];\n            }\n\n            public ushort[] AllocUInt16(object p, long size)\n            {\n                lock (Cache2)\n                {\n                    List<ushort[]> cache;\n                    if (Cache2.TryGetValue(size, out cache) && cache.Count > 0)\n                    {\n                        ushort[] buffer = cache[cache.Count - 1];\n                        cache.RemoveAt(cache.Count - 1);\n                        return buffer;\n                    }\n                }\n\n                System.Diagnostics.Debug.WriteLine(\"Alloc ushort size=\" + size);\n                return new ushort[size];\n            }\n\n            public uint[] AllocUInt32(object p, long size)\n            {\n                lock (Cache3)\n                {\n                    List<uint[]> cache;\n                    if (Cache3.TryGetValue(size, out cache) && cache.Count > 0)\n                    {\n                        uint[] buffer = cache[cache.Count - 1];\n                        cache.RemoveAt(cache.Count - 1);\n                        return buffer;\n                    }\n                }\n\n                System.Diagnostics.Debug.WriteLine(\"Alloc uint size=\" + size);\n                return new uint[size];\n            }\n\n            public void FreeObject(object p, object address)\n            {\n                // ignore\n            }\n\n            public void FreeBytes(object p, byte[] buffer)\n            {\n                if (buffer != null)\n                {\n                    lock (Cache1)\n                    {\n                        List<byte[]> cache;\n                        if (!Cache1.TryGetValue(buffer.Length, out cache))\n                            Cache1.Add(buffer.Length, cache = new List<byte[]>());\n\n                        cache.Add(buffer);\n                    }\n                }\n            }\n\n            public void FreeUInt16(object p, ushort[] buffer)\n            {\n                if (buffer != null)\n                {\n                    lock (Cache2)\n                    {\n                        List<ushort[]> cache;\n                        if (!Cache2.TryGetValue(buffer.Length, out cache))\n                            Cache2.Add(buffer.Length, cache = new List<ushort[]>());\n\n                        cache.Add(buffer);\n                    }\n                }\n            }\n\n            public void FreeUInt32(object p, uint[] buffer)\n            {\n                if (buffer != null)\n                {\n                    lock (Cache3)\n                    {\n                        List<uint[]> cache;\n                        if (!Cache3.TryGetValue(buffer.Length, out cache))\n                            Cache3.Add(buffer.Length, cache = new List<uint[]>());\n\n                        cache.Add(buffer);\n                    }\n                }\n            }\n        }\n\n        public static byte[] IAlloc_AllocBytes(object p, long size)\n        {\n            return ((ISzAlloc)p).AllocBytes(p, size);\n        }\n\n        public static uint[] IAlloc_AllocUInt32(object p, long size)\n        {\n            return ((ISzAlloc)p).AllocUInt32(p, size);\n        }\n\n        public static void IAlloc_FreeObject(object p, object a)\n        {\n            ((ISzAlloc)p).FreeObject(p, a);\n        }\n\n        public static void IAlloc_FreeBytes(object p, byte[] a)\n        {\n            ((ISzAlloc)p).FreeBytes(p, a);\n        }\n\n        public static void IAlloc_FreeUInt32(object p, uint[] a)\n        {\n            ((ISzAlloc)p).FreeUInt32(p, a);\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    [SuppressMessage(\"Microsoft.StyleCop.CSharp.NamingRules\", \"SA1305:FieldNamesMustNotUseHungarianNotation\", Justification = \"Using Win32 naming for consistency.\")]\n    [SuppressMessage(\"Microsoft.StyleCop.CSharp.NamingRules\", \"SA1307:AccessibleFieldsMustBeginWithUpperCaseLetter\", Justification = \"Using Win32 naming for consistency.\")]\n    [SuppressMessage(\"Microsoft.StyleCop.CSharp.NamingRules\", \"SA1310:FieldNamesMustNotContainUnderscore\", Justification = \"Using Win32 naming for consistency.\")]\n    [SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1600:Elements must be documented\", Justification = \"Look in Win32 docs.\")]\n    [SuppressMessage(\"StyleCop.CSharp.DocumentationRules\", \"SA1602:Enumeration items must be documented\", Justification = \"Look in Win32 docs.\")]\n    internal static class UnmanagedMethods\n    {\n        public const int CW_USEDEFAULT = unchecked((int)0x80000000);\n\n        public delegate void TimerProc(IntPtr hWnd, uint uMsg, IntPtr nIDEvent, uint dwTime);\n\n        public delegate void TimeCallback(uint uTimerID, uint uMsg, UIntPtr dwUser, UIntPtr dw1, UIntPtr dw2);\n\n        [UnmanagedFunctionPointer(CallingConvention.StdCall)]\n        public delegate void WaitOrTimerCallback(IntPtr lpParameter, bool timerOrWaitFired);\n\n        public delegate IntPtr WndProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);\n\n        public static readonly IntPtr DPI_AWARENESS_CONTEXT_UNAWARE = new IntPtr(-1);\n        public static readonly IntPtr DPI_AWARENESS_CONTEXT_SYSTEM_AWARE = new IntPtr(-2);\n        public static readonly IntPtr DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE = new IntPtr(-3);\n        public static readonly IntPtr DPI_AWARENESS_CONTEXT_PER_MONITOR_AWARE_V2 = new IntPtr(-4);\n\n        public enum Cursor\n        {\n            IDC_ARROW = 32512,\n            IDC_IBEAM = 32513,\n            IDC_WAIT = 32514,\n            IDC_CROSS = 32515,\n            IDC_UPARROW = 32516,\n            IDC_SIZE = 32640,\n            IDC_ICON = 32641,\n            IDC_SIZENWSE = 32642,\n            IDC_SIZENESW = 32643,\n            IDC_SIZEWE = 32644,\n            IDC_SIZENS = 32645,\n            IDC_SIZEALL = 32646,\n            IDC_NO = 32648,\n            IDC_HAND = 32649,\n            IDC_APPSTARTING = 32650,\n            IDC_HELP = 32651\n        }\n\n        public enum MouseActivate : int\n        {\n            MA_ACTIVATE = 1,\n            MA_ACTIVATEANDEAT = 2,\n            MA_NOACTIVATE = 3,\n            MA_NOACTIVATEANDEAT = 4\n        }\n\n        [Flags]\n        public enum SetWindowPosFlags : uint\n        {\n            SWP_ASYNCWINDOWPOS = 0x4000,\n            SWP_DEFERERASE = 0x2000,\n            SWP_DRAWFRAME = 0x0020,\n            SWP_FRAMECHANGED = 0x0020,\n            SWP_HIDEWINDOW = 0x0080,\n            SWP_NOACTIVATE = 0x0010,\n            SWP_NOCOPYBITS = 0x0100,\n            SWP_NOMOVE = 0x0002,\n            SWP_NOOWNERZORDER = 0x0200,\n            SWP_NOREDRAW = 0x0008,\n            SWP_NOREPOSITION = 0x0200,\n            SWP_NOSENDCHANGING = 0x0400,\n            SWP_NOSIZE = 0x0001,\n            SWP_NOZORDER = 0x0004,\n            SWP_SHOWWINDOW = 0x0040,\n\n            SWP_RESIZE = SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER\n        }\n\n        public static class WindowPosZOrder\n        {\n            public static readonly IntPtr HWND_BOTTOM = new IntPtr(1);\n            public static readonly IntPtr HWND_TOP = new IntPtr(0);\n            public static readonly IntPtr HWND_TOPMOST = new IntPtr(-1);\n            public static readonly IntPtr HWND_NOTOPMOST = new IntPtr(-2);\n        }\n\n        public enum SizeCommand\n        {\n            Restored,\n            Minimized,\n            Maximized,\n            MaxShow,\n            MaxHide,\n        }\n\n        public enum ShowWindowCommand\n        {\n            Hide = 0,\n            Normal = 1,\n            ShowMinimized = 2,\n            Maximize = 3,\n            ShowMaximized = 3,\n            ShowNoActivate = 4,\n            Show = 5,\n            Minimize = 6,\n            ShowMinNoActive = 7,\n            ShowNA = 8,\n            Restore = 9,\n            ShowDefault = 10,\n            ForceMinimize = 11\n        }\n\n        public enum SystemMetric\n        {\n            SM_CXSCREEN = 0,  // 0x00\n            SM_CYSCREEN = 1,  // 0x01\n            SM_CXVSCROLL = 2,  // 0x02\n            SM_CYHSCROLL = 3,  // 0x03\n            SM_CYCAPTION = 4,  // 0x04\n            SM_CXBORDER = 5,  // 0x05\n            SM_CYBORDER = 6,  // 0x06\n            SM_CXDLGFRAME = 7,  // 0x07\n            SM_CXFIXEDFRAME = 7,  // 0x07\n            SM_CYDLGFRAME = 8,  // 0x08\n            SM_CYFIXEDFRAME = 8,  // 0x08\n            SM_CYVTHUMB = 9,  // 0x09\n            SM_CXHTHUMB = 10, // 0x0A\n            SM_CXICON = 11, // 0x0B\n            SM_CYICON = 12, // 0x0C\n            SM_CXCURSOR = 13, // 0x0D\n            SM_CYCURSOR = 14, // 0x0E\n            SM_CYMENU = 15, // 0x0F\n            SM_CXFULLSCREEN = 16, // 0x10\n            SM_CYFULLSCREEN = 17, // 0x11\n            SM_CYKANJIWINDOW = 18, // 0x12\n            SM_MOUSEPRESENT = 19, // 0x13\n            SM_CYVSCROLL = 20, // 0x14\n            SM_CXHSCROLL = 21, // 0x15\n            SM_DEBUG = 22, // 0x16\n            SM_SWAPBUTTON = 23, // 0x17\n            SM_CXMIN = 28, // 0x1C\n            SM_CYMIN = 29, // 0x1D\n            SM_CXSIZE = 30, // 0x1E\n            SM_CYSIZE = 31, // 0x1F\n            SM_CXSIZEFRAME = 32, // 0x20\n            SM_CXFRAME = 32, // 0x20\n            SM_CYSIZEFRAME = 33, // 0x21\n            SM_CYFRAME = 33, // 0x21\n            SM_CXMINTRACK = 34, // 0x22\n            SM_CYMINTRACK = 35, // 0x23\n            SM_CXDOUBLECLK = 36, // 0x24\n            SM_CYDOUBLECLK = 37, // 0x25\n            SM_CXICONSPACING = 38, // 0x26\n            SM_CYICONSPACING = 39, // 0x27\n            SM_MENUDROPALIGNMENT = 40, // 0x28\n            SM_PENWINDOWS = 41, // 0x29\n            SM_DBCSENABLED = 42, // 0x2A\n            SM_CMOUSEBUTTONS = 43, // 0x2B\n            SM_SECURE = 44, // 0x2C\n            SM_CXEDGE = 45, // 0x2D\n            SM_CYEDGE = 46, // 0x2E\n            SM_CXMINSPACING = 47, // 0x2F\n            SM_CYMINSPACING = 48, // 0x30\n            SM_CXSMICON = 49, // 0x31\n            SM_CYSMICON = 50, // 0x32\n            SM_CYSMCAPTION = 51, // 0x33\n            SM_CXSMSIZE = 52, // 0x34\n            SM_CYSMSIZE = 53, // 0x35\n            SM_CXMENUSIZE = 54, // 0x36\n            SM_CYMENUSIZE = 55, // 0x37\n            SM_ARRANGE = 56, // 0x38\n            SM_CXMINIMIZED = 57, // 0x39\n            SM_CYMINIMIZED = 58, // 0x3A\n            SM_CXMAXTRACK = 59, // 0x3B\n            SM_CYMAXTRACK = 60, // 0x3C\n            SM_CXMAXIMIZED = 61, // 0x3D\n            SM_CYMAXIMIZED = 62, // 0x3E\n            SM_NETWORK = 63, // 0x3F\n            SM_CLEANBOOT = 67, // 0x43\n            SM_CXDRAG = 68, // 0x44\n            SM_CYDRAG = 69, // 0x45\n            SM_SHOWSOUNDS = 70, // 0x46\n            SM_CXMENUCHECK = 71, // 0x47\n            SM_CYMENUCHECK = 72, // 0x48\n            SM_SLOWMACHINE = 73, // 0x49\n            SM_MIDEASTENABLED = 74, // 0x4A\n            SM_MOUSEWHEELPRESENT = 75, // 0x4B\n            SM_XVIRTUALSCREEN = 76, // 0x4C\n            SM_YVIRTUALSCREEN = 77, // 0x4D\n            SM_CXVIRTUALSCREEN = 78, // 0x4E\n            SM_CYVIRTUALSCREEN = 79, // 0x4F\n            SM_CMONITORS = 80, // 0x50\n            SM_SAMEDISPLAYFORMAT = 81, // 0x51\n            SM_IMMENABLED = 82, // 0x52\n            SM_CXFOCUSBORDER = 83, // 0x53\n            SM_CYFOCUSBORDER = 84, // 0x54\n            SM_TABLETPC = 86, // 0x56\n            SM_MEDIACENTER = 87, // 0x57\n            SM_STARTER = 88, // 0x58\n            SM_SERVERR2 = 89, // 0x59\n            SM_MOUSEHORIZONTALWHEELPRESENT = 91, // 0x5B\n            SM_CXPADDEDBORDER = 92, // 0x5C\n            SM_DIGITIZER = 94, // 0x5E\n            SM_MAXIMUMTOUCHES = 95, // 0x5F\n\n            SM_REMOTESESSION = 0x1000, // 0x1000\n            SM_SHUTTINGDOWN = 0x2000, // 0x2000\n            SM_REMOTECONTROL = 0x2001, // 0x2001\n\n            SM_CONVERTABLESLATEMODE = 0x2003,\n            SM_SYSTEMDOCKED = 0x2004,\n        }\n\n        [Flags]\n        public enum ModifierKeys\n        {\n            MK_CONTROL = 0x0008,\n\n            MK_LBUTTON = 0x0001,\n\n            MK_MBUTTON = 0x0010,\n\n            MK_RBUTTON = 0x0002,\n\n            MK_SHIFT = 0x0004,\n\n            MK_ALT = 0x0020,\n\n            MK_XBUTTON1 = 0x0020,\n\n            MK_XBUTTON2 = 0x0040\n        }\n\n        public enum WindowActivate\n        {\n            WA_INACTIVE,\n            WA_ACTIVE,\n            WA_CLICKACTIVE,\n        }\n\n        public enum HitTestValues\n        {\n            HTERROR = -2,\n            HTTRANSPARENT = -1,\n            HTNOWHERE = 0,\n            HTCLIENT = 1,\n            HTCAPTION = 2,\n            HTSYSMENU = 3,\n            HTGROWBOX = 4,\n            HTMENU = 5,\n            HTHSCROLL = 6,\n            HTVSCROLL = 7,\n            HTMINBUTTON = 8,\n            HTMAXBUTTON = 9,\n            HTLEFT = 10,\n            HTRIGHT = 11,\n            HTTOP = 12,\n            HTTOPLEFT = 13,\n            HTTOPRIGHT = 14,\n            HTBOTTOM = 15,\n            HTBOTTOMLEFT = 16,\n            HTBOTTOMRIGHT = 17,\n            HTBORDER = 18,\n            HTOBJECT = 19,\n            HTCLOSE = 20,\n            HTHELP = 21\n        }\n\n        [Flags]\n        public enum WindowStyles : uint\n        {\n            WS_BORDER = 0x800000,\n            WS_CAPTION = 0xc00000,\n            WS_CHILD = 0x40000000,\n            WS_CLIPCHILDREN = 0x2000000,\n            WS_CLIPSIBLINGS = 0x4000000,\n            WS_DISABLED = 0x8000000,\n            WS_DLGFRAME = 0x400000,\n            WS_GROUP = 0x20000,\n            WS_HSCROLL = 0x100000,\n            WS_MAXIMIZE = 0x1000000,\n            WS_MAXIMIZEBOX = 0x10000,\n            WS_MINIMIZE = 0x20000000,\n            WS_MINIMIZEBOX = 0x20000,\n            WS_OVERLAPPED = 0x0,\n            WS_OVERLAPPEDWINDOW = WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_SIZEFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX,\n            WS_POPUP = 0x80000000u,\n            WS_POPUPWINDOW = WS_POPUP | WS_BORDER | WS_SYSMENU,\n            WS_SIZEFRAME = 0x40000,\n            WS_SYSMENU = 0x80000,\n            WS_TABSTOP = 0x10000,\n            WS_VISIBLE = 0x10000000,\n            WS_VSCROLL = 0x200000,\n            WS_EX_DLGMODALFRAME = 0x00000001,\n            WS_EX_NOPARENTNOTIFY = 0x00000004,\n            WS_EX_TOPMOST = 0x00000008,\n            WS_EX_ACCEPTFILES = 0x00000010,\n            WS_EX_TRANSPARENT = 0x00000020,\n            WS_EX_MDICHILD = 0x00000040,\n            WS_EX_TOOLWINDOW = 0x00000080,\n            WS_EX_WINDOWEDGE = 0x00000100,\n            WS_EX_CLIENTEDGE = 0x00000200,\n            WS_EX_CONTEXTHELP = 0x00000400,\n            WS_EX_RIGHT = 0x00001000,\n            WS_EX_LEFT = 0x00000000,\n            WS_EX_RTLREADING = 0x00002000,\n            WS_EX_LTRREADING = 0x00000000,\n            WS_EX_LEFTSCROLLBAR = 0x00004000,\n            WS_EX_RIGHTSCROLLBAR = 0x00000000,\n            WS_EX_CONTROLPARENT = 0x00010000,\n            WS_EX_STATICEDGE = 0x00020000,\n            WS_EX_APPWINDOW = 0x00040000,\n            WS_EX_OVERLAPPEDWINDOW = WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE,\n            WS_EX_PALETTEWINDOW = WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST,\n            WS_EX_LAYERED = 0x00080000,\n            WS_EX_NOINHERITLAYOUT = 0x00100000,\n            WS_EX_LAYOUTRTL = 0x00400000,\n            WS_EX_COMPOSITED = 0x02000000,\n            WS_EX_NOACTIVATE = 0x08000000\n        }\n\n        [Flags]\n        public enum ClassStyles : uint\n        {\n            CS_VREDRAW = 0x0001,\n            CS_HREDRAW = 0x0002,\n            CS_DBLCLKS = 0x0008,\n            CS_OWNDC = 0x0020,\n            CS_CLASSDC = 0x0040,\n            CS_PARENTDC = 0x0080,\n            CS_NOCLOSE = 0x0200,\n            CS_SAVEBITS = 0x0800,\n            CS_BYTEALIGNCLIENT = 0x1000,\n            CS_BYTEALIGNWINDOW = 0x2000,\n            CS_GLOBALCLASS = 0x4000,\n            CS_IME = 0x00010000,\n            CS_DROPSHADOW = 0x00020000\n        }\n\n        public enum WindowsMessage : uint\n        {\n            WM_NULL = 0x0000,\n            WM_CREATE = 0x0001,\n            WM_DESTROY = 0x0002,\n            WM_MOVE = 0x0003,\n            WM_SIZE = 0x0005,\n            WM_ACTIVATE = 0x0006,\n            WM_SETFOCUS = 0x0007,\n            WM_KILLFOCUS = 0x0008,\n            WM_ENABLE = 0x000A,\n            WM_SETREDRAW = 0x000B,\n            WM_SETTEXT = 0x000C,\n            WM_GETTEXT = 0x000D,\n            WM_GETTEXTLENGTH = 0x000E,\n            WM_PAINT = 0x000F,\n            WM_CLOSE = 0x0010,\n            WM_QUERYENDSESSION = 0x0011,\n            WM_QUERYOPEN = 0x0013,\n            WM_ENDSESSION = 0x0016,\n            WM_QUIT = 0x0012,\n            WM_ERASEBKGND = 0x0014,\n            WM_SYSCOLORCHANGE = 0x0015,\n            WM_SHOWWINDOW = 0x0018,\n            WM_WININICHANGE = 0x001A,\n            WM_SETTINGCHANGE = WM_WININICHANGE,\n            WM_DEVMODECHANGE = 0x001B,\n            WM_ACTIVATEAPP = 0x001C,\n            WM_FONTCHANGE = 0x001D,\n            WM_TIMECHANGE = 0x001E,\n            WM_CANCELMODE = 0x001F,\n            WM_SETCURSOR = 0x0020,\n            WM_MOUSEACTIVATE = 0x0021,\n            WM_CHILDACTIVATE = 0x0022,\n            WM_QUEUESYNC = 0x0023,\n            WM_GETMINMAXINFO = 0x0024,\n            WM_PAINTICON = 0x0026,\n            WM_ICONERASEBKGND = 0x0027,\n            WM_NEXTDLGCTL = 0x0028,\n            WM_SPOOLERSTATUS = 0x002A,\n            WM_DRAWITEM = 0x002B,\n            WM_MEASUREITEM = 0x002C,\n            WM_DELETEITEM = 0x002D,\n            WM_VKEYTOITEM = 0x002E,\n            WM_CHARTOITEM = 0x002F,\n            WM_SETFONT = 0x0030,\n            WM_GETFONT = 0x0031,\n            WM_SETHOTKEY = 0x0032,\n            WM_GETHOTKEY = 0x0033,\n            WM_QUERYDRAGICON = 0x0037,\n            WM_COMPAREITEM = 0x0039,\n            WM_GETOBJECT = 0x003D,\n            WM_COMPACTING = 0x0041,\n            WM_WINDOWPOSCHANGING = 0x0046,\n            WM_WINDOWPOSCHANGED = 0x0047,\n            WM_COPYDATA = 0x004A,\n            WM_CANCELJOURNAL = 0x004B,\n            WM_NOTIFY = 0x004E,\n            WM_INPUTLANGCHANGEREQUEST = 0x0050,\n            WM_INPUTLANGCHANGE = 0x0051,\n            WM_TCARD = 0x0052,\n            WM_HELP = 0x0053,\n            WM_USERCHANGED = 0x0054,\n            WM_NOTIFYFORMAT = 0x0055,\n            WM_CONTEXTMENU = 0x007B,\n            WM_STYLECHANGING = 0x007C,\n            WM_STYLECHANGED = 0x007D,\n            WM_DISPLAYCHANGE = 0x007E,\n            WM_GETICON = 0x007F,\n            WM_SETICON = 0x0080,\n            WM_NCCREATE = 0x0081,\n            WM_NCDESTROY = 0x0082,\n            WM_NCCALCSIZE = 0x0083,\n            WM_NCHITTEST = 0x0084,\n            WM_NCPAINT = 0x0085,\n            WM_NCACTIVATE = 0x0086,\n            WM_GETDLGCODE = 0x0087,\n            WM_SYNCPAINT = 0x0088,\n            WM_NCMOUSEMOVE = 0x00A0,\n            WM_NCLBUTTONDOWN = 0x00A1,\n            WM_NCLBUTTONUP = 0x00A2,\n            WM_NCLBUTTONDBLCLK = 0x00A3,\n            WM_NCRBUTTONDOWN = 0x00A4,\n            WM_NCRBUTTONUP = 0x00A5,\n            WM_NCRBUTTONDBLCLK = 0x00A6,\n            WM_NCMBUTTONDOWN = 0x00A7,\n            WM_NCMBUTTONUP = 0x00A8,\n            WM_NCMBUTTONDBLCLK = 0x00A9,\n            WM_NCXBUTTONDOWN = 0x00AB,\n            WM_NCXBUTTONUP = 0x00AC,\n            WM_NCXBUTTONDBLCLK = 0x00AD,\n            WM_INPUT_DEVICE_CHANGE = 0x00FE,\n            WM_INPUT = 0x00FF,\n            WM_KEYFIRST = 0x0100,\n            WM_KEYDOWN = 0x0100,\n            WM_KEYUP = 0x0101,\n            WM_CHAR = 0x0102,\n            WM_DEADCHAR = 0x0103,\n            WM_SYSKEYDOWN = 0x0104,\n            WM_SYSKEYUP = 0x0105,\n            WM_SYSCHAR = 0x0106,\n            WM_SYSDEADCHAR = 0x0107,\n            WM_UNICHAR = 0x0109,\n            WM_KEYLAST = 0x0109,\n            WM_IME_STARTCOMPOSITION = 0x010D,\n            WM_IME_ENDCOMPOSITION = 0x010E,\n            WM_IME_COMPOSITION = 0x010F,\n            WM_IME_KEYLAST = 0x010F,\n            WM_INITDIALOG = 0x0110,\n            WM_COMMAND = 0x0111,\n            WM_SYSCOMMAND = 0x0112,\n            WM_TIMER = 0x0113,\n            WM_HSCROLL = 0x0114,\n            WM_VSCROLL = 0x0115,\n            WM_INITMENU = 0x0116,\n            WM_INITMENUPOPUP = 0x0117,\n            WM_MENUSELECT = 0x011F,\n            WM_MENUCHAR = 0x0120,\n            WM_ENTERIDLE = 0x0121,\n            WM_MENURBUTTONUP = 0x0122,\n            WM_MENUDRAG = 0x0123,\n            WM_MENUGETOBJECT = 0x0124,\n            WM_UNINITMENUPOPUP = 0x0125,\n            WM_MENUCOMMAND = 0x0126,\n            WM_CHANGEUISTATE = 0x0127,\n            WM_UPDATEUISTATE = 0x0128,\n            WM_QUERYUISTATE = 0x0129,\n            WM_CTLCOLORMSGBOX = 0x0132,\n            WM_CTLCOLOREDIT = 0x0133,\n            WM_CTLCOLORLISTBOX = 0x0134,\n            WM_CTLCOLORBTN = 0x0135,\n            WM_CTLCOLORDLG = 0x0136,\n            WM_CTLCOLORSCROLLBAR = 0x0137,\n            WM_CTLCOLORSTATIC = 0x0138,\n            WM_MOUSEFIRST = 0x0200,\n            WM_MOUSEMOVE = 0x0200,\n            WM_LBUTTONDOWN = 0x0201,\n            WM_LBUTTONUP = 0x0202,\n            WM_LBUTTONDBLCLK = 0x0203,\n            WM_RBUTTONDOWN = 0x0204,\n            WM_RBUTTONUP = 0x0205,\n            WM_RBUTTONDBLCLK = 0x0206,\n            WM_MBUTTONDOWN = 0x0207,\n            WM_MBUTTONUP = 0x0208,\n            WM_MBUTTONDBLCLK = 0x0209,\n            WM_MOUSEWHEEL = 0x020A,\n            WM_XBUTTONDOWN = 0x020B,\n            WM_XBUTTONUP = 0x020C,\n            WM_XBUTTONDBLCLK = 0x020D,\n            WM_MOUSEHWHEEL = 0x020E,\n            WM_MOUSELAST = 0x020E,\n            WM_PARENTNOTIFY = 0x0210,\n            WM_ENTERMENULOOP = 0x0211,\n            WM_EXITMENULOOP = 0x0212,\n            WM_NEXTMENU = 0x0213,\n            WM_SIZING = 0x0214,\n            WM_CAPTURECHANGED = 0x0215,\n            WM_MOVING = 0x0216,\n            WM_POWERBROADCAST = 0x0218,\n            WM_DEVICECHANGE = 0x0219,\n            WM_MDICREATE = 0x0220,\n            WM_MDIDESTROY = 0x0221,\n            WM_MDIACTIVATE = 0x0222,\n            WM_MDIRESTORE = 0x0223,\n            WM_MDINEXT = 0x0224,\n            WM_MDIMAXIMIZE = 0x0225,\n            WM_MDITILE = 0x0226,\n            WM_MDICASCADE = 0x0227,\n            WM_MDIICONARRANGE = 0x0228,\n            WM_MDIGETACTIVE = 0x0229,\n            WM_MDISETMENU = 0x0230,\n            WM_ENTERSIZEMOVE = 0x0231,\n            WM_EXITSIZEMOVE = 0x0232,\n            WM_DROPFILES = 0x0233,\n            WM_MDIREFRESHMENU = 0x0234,\n            WM_IME_SETCONTEXT = 0x0281,\n            WM_IME_NOTIFY = 0x0282,\n            WM_IME_CONTROL = 0x0283,\n            WM_IME_COMPOSITIONFULL = 0x0284,\n            WM_IME_SELECT = 0x0285,\n            WM_IME_CHAR = 0x0286,\n            WM_IME_REQUEST = 0x0288,\n            WM_IME_KEYDOWN = 0x0290,\n            WM_IME_KEYUP = 0x0291,\n            WM_MOUSEHOVER = 0x02A1,\n            WM_MOUSELEAVE = 0x02A3,\n            WM_NCMOUSEHOVER = 0x02A0,\n            WM_NCMOUSELEAVE = 0x02A2,\n            WM_WTSSESSION_CHANGE = 0x02B1,\n            WM_TABLET_FIRST = 0x02c0,\n            WM_TABLET_LAST = 0x02df,\n            WM_DPICHANGED = 0x02E0,\n            WM_CUT = 0x0300,\n            WM_COPY = 0x0301,\n            WM_PASTE = 0x0302,\n            WM_CLEAR = 0x0303,\n            WM_UNDO = 0x0304,\n            WM_RENDERFORMAT = 0x0305,\n            WM_RENDERALLFORMATS = 0x0306,\n            WM_DESTROYCLIPBOARD = 0x0307,\n            WM_DRAWCLIPBOARD = 0x0308,\n            WM_PAINTCLIPBOARD = 0x0309,\n            WM_VSCROLLCLIPBOARD = 0x030A,\n            WM_SIZECLIPBOARD = 0x030B,\n            WM_ASKCBFORMATNAME = 0x030C,\n            WM_CHANGECBCHAIN = 0x030D,\n            WM_HSCROLLCLIPBOARD = 0x030E,\n            WM_QUERYNEWPALETTE = 0x030F,\n            WM_PALETTEISCHANGING = 0x0310,\n            WM_PALETTECHANGED = 0x0311,\n            WM_HOTKEY = 0x0312,\n            WM_PRINT = 0x0317,\n            WM_PRINTCLIENT = 0x0318,\n            WM_APPCOMMAND = 0x0319,\n            WM_THEMECHANGED = 0x031A,\n            WM_CLIPBOARDUPDATE = 0x031D,\n            WM_DWMCOMPOSITIONCHANGED = 0x031E,\n            WM_DWMNCRENDERINGCHANGED = 0x031F,\n            WM_DWMCOLORIZATIONCOLORCHANGED = 0x0320,\n            WM_DWMWINDOWMAXIMIZEDCHANGE = 0x0321,\n            WM_GETTITLEBARINFOEX = 0x033F,\n            WM_HANDHELDFIRST = 0x0358,\n            WM_HANDHELDLAST = 0x035F,\n            WM_AFXFIRST = 0x0360,\n            WM_AFXLAST = 0x037F,\n            WM_PENWINFIRST = 0x0380,\n            WM_PENWINLAST = 0x038F,\n            WM_TOUCH = 0x0240,\n            WM_APP = 0x8000,\n            WM_USER = 0x0400,\n\n            WM_DISPATCH_WORK_ITEM = WM_USER,\n        }\n\n        public enum BitmapCompressionMode : uint\n        {\n            BI_RGB = 0,\n            BI_RLE8 = 1,\n            BI_RLE4 = 2,\n            BI_BITFIELDS = 3,\n            BI_JPEG = 4,\n            BI_PNG = 5\n        }\n\n        public enum DIBColorTable\n        {\n            DIB_RGB_COLORS = 0,     /* color table in RGBs */\n            DIB_PAL_COLORS          /* color table in palette indices */\n        }\n\n        public enum WindowLongParam\n        {\n            GWL_WNDPROC = -4,\n            GWL_HINSTANCE = -6,\n            GWL_HWNDPARENT = -8,\n            GWL_ID = -12,\n            GWL_STYLE = -16,\n            GWL_EXSTYLE = -20,\n            GWL_USERDATA = -21\n        }\n\n        public enum MenuCharParam\n        {\n            MNC_IGNORE = 0,\n            MNC_CLOSE = 1,\n            MNC_EXECUTE = 2,\n            MNC_SELECT = 3\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct RGBQUAD\n        {\n            public byte rgbBlue;\n            public byte rgbGreen;\n            public byte rgbRed;\n            public byte rgbReserved;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct BITMAPINFOHEADER\n        {\n            public uint biSize;\n            public int biWidth;\n            public int biHeight;\n            public ushort biPlanes;\n            public ushort biBitCount;\n            public uint biCompression;\n            public uint biSizeImage;\n            public int biXPelsPerMeter;\n            public int biYPelsPerMeter;\n            public uint biClrUsed;\n            public uint biClrImportant;\n\n            public void Init()\n            {\n                biSize = (uint)Marshal.SizeOf(this);\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct BITMAPINFO\n        {\n            // C# cannot inlay structs in structs so must expand directly here\n            //\n            //[StructLayout(LayoutKind.Sequential)]\n            //public struct BITMAPINFOHEADER\n            //{\n            public uint biSize;\n            public int biWidth;\n            public int biHeight;\n            public ushort biPlanes;\n            public ushort biBitCount;\n            public BitmapCompressionMode biCompression;\n            public uint biSizeImage;\n            public int biXPelsPerMeter;\n            public int biYPelsPerMeter;\n            public uint biClrUsed;\n            public uint biClrImportant;\n            //}\n\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 256)]\n            public uint[] cols;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct MINMAXINFO\n        {\n            public POINT ptReserved;\n            public POINT ptMaxSize;\n            public POINT ptMaxPosition;\n            public POINT ptMinTrackSize;\n            public POINT ptMaxTrackSize;\n        }\n\n        public const int SizeOf_BITMAPINFOHEADER = 40;\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool EnumDisplayMonitors(IntPtr hdc, IntPtr lprcClip,\n                                                      MonitorEnumDelegate lpfnEnum, IntPtr dwData);\n        \n        public delegate bool MonitorEnumDelegate(IntPtr hMonitor, IntPtr hdcMonitor, ref Rect lprcMonitor, IntPtr dwData);\n        \n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern IntPtr GetDC(IntPtr hWnd);\n\n        [DllImport(\"gdi32.dll\")]\n        public static extern int SetDIBitsToDevice(IntPtr hdc, int XDest, int YDest,\n            uint dwWidth, uint dwHeight,\n            int XSrc, int YSrc,\n            uint uStartScan, uint cScanLines,\n           IntPtr lpvBits, [In] ref BITMAPINFO lpbmi, uint fuColorUse);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool ReleaseDC(IntPtr hWnd, IntPtr hDC);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool AdjustWindowRectEx(ref RECT lpRect, uint dwStyle, bool bMenu, uint dwExStyle);\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr BeginPaint(IntPtr hwnd, out PAINTSTRUCT lpPaint);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool ClientToScreen(IntPtr hWnd, ref POINT lpPoint);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern IntPtr CreateWindowEx(\n           int dwExStyle,\n           uint lpClassName,\n           string lpWindowName,\n           uint dwStyle,\n           int x,\n           int y,\n           int nWidth,\n           int nHeight,\n           IntPtr hWndParent,\n           IntPtr hMenu,\n           IntPtr hInstance,\n           IntPtr lpParam);\n\n        [DllImport(\"user32.dll\", EntryPoint = \"DefWindowProcW\")]\n        public static extern IntPtr DefWindowProc(IntPtr hWnd, uint msg, IntPtr wParam, IntPtr lParam);\n\n        [DllImport(\"user32.dll\", EntryPoint = \"DispatchMessageW\")]\n        public static extern IntPtr DispatchMessage(ref MSG lpmsg);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool DestroyWindow(IntPtr hwnd);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool EnableWindow(IntPtr hWnd, bool bEnable);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool EndPaint(IntPtr hWnd, ref PAINTSTRUCT lpPaint);\n\n        [DllImport(\"user32.dll\")]\n        public static extern uint GetCaretBlinkTime();\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool GetClientRect(IntPtr hwnd, out RECT lpRect);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool GetCursorPos(out POINT lpPoint);\n\n        [DllImport(\"user32.dll\")]\n        public static extern uint GetDoubleClickTime();\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool GetKeyboardState(byte[] lpKeyState);\n\n        [DllImport(\"user32.dll\", EntryPoint = \"GetMessageW\")]\n        public static extern sbyte GetMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax);\n\n        [DllImport(\"user32.dll\")]\n        public static extern int GetMessageTime();\n\n        [DllImport(\"kernel32.dll\")]\n        public static extern IntPtr GetModuleHandle(string lpModuleName);\n\n        [DllImport(\"user32.dll\")]\n        public static extern int GetSystemMetrics(SystemMetric smIndex);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern uint GetWindowLongPtr(IntPtr hWnd, int nIndex);\n\n        [DllImport(\"user32.dll\", SetLastError = true, EntryPoint = \"GetWindowLong\")]\n        public static extern uint GetWindowLong32b(IntPtr hWnd, int nIndex);\n\n        public static uint GetWindowLong(IntPtr hWnd, int nIndex)\n        {\n            if(IntPtr.Size == 4)\n            {\n                return GetWindowLong32b(hWnd, nIndex);\n            }\n            else\n            {\n                return GetWindowLongPtr(hWnd, nIndex);\n            }\n        }\n\n        [DllImport(\"user32.dll\", SetLastError = true, EntryPoint = \"SetWindowLong\")]\n        private static extern uint SetWindowLong32b(IntPtr hWnd, int nIndex, uint value);\n\n        [DllImport(\"user32.dll\", SetLastError = true, EntryPoint = \"SetWindowLongPtr\")]\n        private static extern IntPtr SetWindowLong64b(IntPtr hWnd, int nIndex, IntPtr value);\n\n        public static uint SetWindowLong(IntPtr hWnd, int nIndex, uint value)\n        {\n            if (IntPtr.Size == 4)\n            {\n                return SetWindowLong32b(hWnd, nIndex, value);\n            }\n            else\n            {\n                return (uint)SetWindowLong64b(hWnd, nIndex, new IntPtr((uint)value)).ToInt32();\n            }\n        }\n        \n        public static IntPtr SetWindowLongPtr(IntPtr hWnd, int nIndex, IntPtr handle)\n        {\n            if (IntPtr.Size == 4)\n            {\n                return new IntPtr(SetWindowLong32b(hWnd, nIndex, (uint)handle.ToInt32()));\n            }\n            else\n            {\n                return SetWindowLong64b(hWnd, nIndex, handle);\n            }\n        }\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool GetWindowPlacement(IntPtr hWnd, ref WINDOWPLACEMENT lpwndpl);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool GetWindowRect(IntPtr hwnd, out RECT lpRect);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool GetUpdateRect(IntPtr hwnd, out RECT lpRect, bool bErase);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool InvalidateRect(IntPtr hWnd, ref RECT lpRect, bool bErase);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool IsWindowEnabled(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool IsWindowUnicode(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool IsWindowVisible(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool KillTimer(IntPtr hWnd, IntPtr uIDEvent);\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr LoadCursor(IntPtr hInstance, IntPtr lpCursorName);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool PeekMessage(out MSG lpMsg, IntPtr hWnd, uint wMsgFilterMin, uint wMsgFilterMax, uint wRemoveMsg);\n\n        [DllImport(\"user32\")]\n        public static extern IntPtr GetMessageExtraInfo();\n        \n        [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = \"RegisterClassExW\")]\n        public static extern ushort RegisterClassEx(ref WNDCLASSEX lpwcx);\n\n        [DllImport(\"user32.dll\")]\n        public static extern void RegisterTouchWindow(IntPtr hWnd, int flags);\n        \n        [DllImport(\"user32.dll\")]\n        public static extern bool ReleaseCapture();\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool ScreenToClient(IntPtr hWnd, ref POINT lpPoint);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern IntPtr SetActiveWindow(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr SetCapture(IntPtr hWnd);\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr SetTimer(IntPtr hWnd, IntPtr nIDEvent, uint uElapse, TimerProc lpTimerFunc);\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);\n        [DllImport(\"user32.dll\")]\n        public static extern bool SetWindowPos(IntPtr hWnd, IntPtr hWndInsertAfter, int x, int y, int cx, int cy, SetWindowPosFlags uFlags);\n        [DllImport(\"user32.dll\")]\n        public static extern bool SetFocus(IntPtr hWnd);\n        [DllImport(\"user32.dll\")]\n        public static extern bool SetParent(IntPtr hWnd, IntPtr hWndNewParent);\n        [DllImport(\"user32.dll\")]\n        public static extern bool ShowWindow(IntPtr hWnd, ShowWindowCommand nCmdShow);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern IntPtr CreateTimerQueue();\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern bool DeleteTimerQueueEx(IntPtr TimerQueue, IntPtr CompletionEvent);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool CreateTimerQueueTimer(\n            out IntPtr phNewTimer,\n            IntPtr TimerQueue,\n            WaitOrTimerCallback Callback,\n            IntPtr Parameter,\n            uint DueTime,\n            uint Period,\n            uint Flags);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern bool DeleteTimerQueueTimer(IntPtr TimerQueue, IntPtr Timer, IntPtr CompletionEvent);\n\n        [DllImport(\"user32.dll\")]\n        public static extern int ToUnicode(\n            uint virtualKeyCode,\n            uint scanCode,\n            byte[] keyboardState,\n            [Out, MarshalAs(UnmanagedType.LPWStr, SizeConst = 64)]\n            StringBuilder receivingBuffer,\n            int bufferSize,\n            uint flags);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool TrackMouseEvent(ref TRACKMOUSEEVENT lpEventTrack);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool TranslateMessage(ref MSG lpMsg);\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool UnregisterClass(string lpClassName, IntPtr hInstance);\n\n        [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = \"SetWindowTextW\")]\n        public static extern bool SetWindowText(IntPtr hwnd, string lpString);\n\n        public enum ClassLongIndex : int\n        {\n            GCLP_MENUNAME = -8,\n            GCLP_HBRBACKGROUND = -10,\n            GCLP_HCURSOR = -12,\n            GCLP_HICON = -14,\n            GCLP_HMODULE = -16,\n            GCL_CBWNDEXTRA = -18,\n            GCL_CBCLSEXTRA = -20,\n            GCLP_WNDPROC = -24,\n            GCL_STYLE = -26,\n            GCLP_HICONSM = -34,\n            GCW_ATOM = -32\n        }\n\n        [DllImport(\"user32.dll\", EntryPoint = \"SetClassLongPtr\")]\n        private static extern IntPtr SetClassLong64(IntPtr hWnd, ClassLongIndex nIndex, IntPtr dwNewLong);\n\n        [DllImport(\"user32.dll\", EntryPoint = \"SetClassLong\")]\n        private static extern IntPtr SetClassLong32(IntPtr hWnd, ClassLongIndex nIndex, IntPtr dwNewLong);\n\n        public static IntPtr SetClassLong(IntPtr hWnd, ClassLongIndex nIndex, IntPtr dwNewLong)\n        {\n            if (IntPtr.Size == 4)\n            {\n                return SetClassLong32(hWnd, nIndex, dwNewLong);\n            }\n\n            return SetClassLong64(hWnd, nIndex, dwNewLong);\n        }\n\n        public static IntPtr GetClassLongPtr(IntPtr hWnd, int nIndex)\n        {\n            if (IntPtr.Size > 4)\n                return GetClassLongPtr64(hWnd, nIndex);\n            else\n                return new IntPtr(GetClassLongPtr32(hWnd, nIndex));\n        }\n\n        [DllImport(\"user32.dll\", EntryPoint = \"GetClassLong\")]\n        public static extern uint GetClassLongPtr32(IntPtr hWnd, int nIndex);\n\n        [DllImport(\"user32.dll\", EntryPoint = \"GetClassLongPtr\")]\n        public static extern IntPtr GetClassLongPtr64(IntPtr hWnd, int nIndex);\n\n        [DllImport(\"user32.dll\", EntryPoint = \"SetCursor\")]\n        internal static extern IntPtr SetCursor(IntPtr hCursor);\n\n        [DllImport(\"ole32.dll\", PreserveSig = true)]\n        internal static extern int CoCreateInstance(ref Guid clsid,\n            IntPtr ignore1, int ignore2, ref Guid iid, [MarshalAs(UnmanagedType.IUnknown), Out] out object pUnkOuter);\n\n        \n        [DllImport(\"shell32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        internal static extern int SHCreateItemFromParsingName([MarshalAs(UnmanagedType.LPWStr)] string pszPath, IntPtr pbc, ref Guid riid, [MarshalAs(UnmanagedType.Interface)] out IShellItem ppv);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool OpenClipboard(IntPtr hWndOwner);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool CloseClipboard();\n\n        [DllImport(\"user32.dll\")]\n        public static extern bool EmptyClipboard();\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr GetClipboardData(ClipboardFormat uFormat);\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr SetClipboardData(ClipboardFormat uFormat, IntPtr hMem);\n\n        [DllImport(\"kernel32.dll\", ExactSpelling = true)]\n        public static extern IntPtr GlobalLock(IntPtr handle);\n\n        [DllImport(\"kernel32.dll\", ExactSpelling = true)]\n        public static extern bool GlobalUnlock(IntPtr handle);\n\n        [DllImport(\"kernel32.dll\", ExactSpelling = true)]\n        public static extern IntPtr GlobalAlloc(int uFlags, int dwBytes);\n\n        [DllImport(\"kernel32.dll\", ExactSpelling = true)]\n        public static extern IntPtr GlobalFree(IntPtr hMem);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern IntPtr LoadLibrary(string fileName);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Ansi)]\n        public static extern IntPtr GetProcAddress(IntPtr hModule, string lpProcName);\n\n        [DllImport(\"comdlg32.dll\", CharSet = CharSet.Unicode, EntryPoint = \"GetSaveFileNameW\")]\n        public static extern bool GetSaveFileName(IntPtr lpofn);\n\n        [DllImport(\"comdlg32.dll\", CharSet = CharSet.Unicode, EntryPoint = \"GetOpenFileNameW\")]\n        public static extern bool GetOpenFileName(IntPtr lpofn);\n\n        [DllImport(\"comdlg32.dll\")]\n        public static extern int CommDlgExtendedError();\n\n        public static bool ShCoreAvailable => LoadLibrary(\"shcore.dll\") != IntPtr.Zero;\n\n        [DllImport(\"shcore.dll\")]\n        public static extern void SetProcessDpiAwareness(PROCESS_DPI_AWARENESS value);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool SetProcessDpiAwarenessContext(IntPtr dpiAWarenessContext);\n\n        [DllImport(\"shcore.dll\")]\n        public static extern long GetDpiForMonitor(IntPtr hmonitor, MONITOR_DPI_TYPE dpiType, out uint dpiX, out uint dpiY);\n\n        [DllImport(\"shcore.dll\")]\n        public static extern void GetScaleFactorForMonitor(IntPtr hMon, out uint pScale);\n\n        [DllImport(\"user32.dll\", SetLastError = true)]\n        public static extern bool SetProcessDPIAware();\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr MonitorFromPoint(POINT pt, MONITOR dwFlags);\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr MonitorFromRect(RECT rect, MONITOR dwFlags);\n\n        [DllImport(\"user32.dll\")]\n        public static extern IntPtr MonitorFromWindow(IntPtr hwnd, MONITOR dwFlags);\n        \n        [DllImport(\"user32\", EntryPoint = \"GetMonitorInfoW\", ExactSpelling = true, CharSet = CharSet.Unicode)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool GetMonitorInfo([In] IntPtr hMonitor, ref MONITORINFO lpmi);\n\n        [DllImport(\"user32\")]\n        public static extern bool GetTouchInputInfo(\n            IntPtr hTouchInput,\n            uint        cInputs,\n            [Out]TOUCHINPUT[] pInputs,\n            int         cbSize\n        );\n        \n        [DllImport(\"user32\")]\n        public static extern bool CloseTouchInputHandle(IntPtr hTouchInput);\n        \n        [return: MarshalAs(UnmanagedType.Bool)]\n        [DllImport(\"user32.dll\", SetLastError = true, CharSet = CharSet.Unicode, EntryPoint = \"PostMessageW\")]\n        public static extern bool PostMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);\n\n        [DllImport(\"gdi32.dll\")]\n        public static extern int SetDIBitsToDevice(IntPtr hdc, int XDest, int YDest, uint\n                dwWidth, uint dwHeight, int XSrc, int YSrc, uint uStartScan, uint cScanLines,\n            IntPtr lpvBits, [In] ref BITMAPINFOHEADER lpbmi, uint fuColorUse);\n        \n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        public static extern bool CloseHandle(IntPtr hObject);\n        [DllImport(\"gdi32.dll\", SetLastError = true)]\n        public static extern IntPtr CreateDIBSection(IntPtr hDC, ref BITMAPINFOHEADER pBitmapInfo, int un, out IntPtr lplpVoid, IntPtr handle, int dw);\n        [DllImport(\"gdi32.dll\")]\n        public static extern int DeleteObject(IntPtr hObject);\n        [DllImport(\"gdi32.dll\", SetLastError = true)]\n        public static extern IntPtr CreateCompatibleDC(IntPtr hdc);\n        [DllImport(\"gdi32.dll\")]\n        public static extern IntPtr SelectObject(IntPtr hdc, IntPtr hObject);\n\n        [DllImport(\"kernel32.dll\", SetLastError = true)]\n        public static extern IntPtr CreateFileMapping(IntPtr hFile,\n            IntPtr lpFileMappingAttributes,\n            uint flProtect,\n            uint dwMaximumSizeHigh,\n            uint dwMaximumSizeLow,\n            string lpName);\n\n        [DllImport(\"msvcrt.dll\", EntryPoint=\"memcpy\", SetLastError = false, CallingConvention=CallingConvention.Cdecl)]\n        public static extern IntPtr CopyMemory(IntPtr dest, IntPtr src, UIntPtr count); \n        \n        [DllImport(\"ole32.dll\", CharSet = CharSet.Auto, ExactSpelling = true)]\n        public static extern HRESULT RegisterDragDrop(IntPtr hwnd, IDropTarget target);\n        \n        [DllImport(\"ole32.dll\", EntryPoint = \"OleInitialize\")]\n        public static extern HRESULT OleInitialize(IntPtr val);\n\n        [DllImport(\"ole32.dll\", CharSet = CharSet.Auto, ExactSpelling = true)]\n        internal static extern void ReleaseStgMedium(ref STGMEDIUM medium);\n\n        [DllImport(\"user32.dll\", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int GetClipboardFormatName(int format, StringBuilder lpString, int cchMax);\n\n        [DllImport(\"user32.dll\", BestFitMapping = false, CharSet = CharSet.Auto, SetLastError = true)]\n        public static extern int RegisterClipboardFormat(string format);\n\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Auto, ExactSpelling = true, SetLastError = true)]\n        public static extern IntPtr GlobalSize(IntPtr hGlobal);\n\n        [DllImport(\"shell32.dll\", BestFitMapping = false, CharSet = CharSet.Auto)]\n        public static extern int DragQueryFile(IntPtr hDrop, int iFile, StringBuilder lpszFile, int cch);\n\n        [DllImport(\"ole32.dll\", CharSet = CharSet.Auto, ExactSpelling = true, PreserveSig = false)]\n        internal static extern void DoDragDrop(IOleDataObject dataObject, IDropSource dropSource, int allowedEffects, int[] finalEffect);\n\n\n\n        public enum MONITOR\n        {\n            MONITOR_DEFAULTTONULL = 0x00000000,\n            MONITOR_DEFAULTTOPRIMARY = 0x00000001,\n            MONITOR_DEFAULTTONEAREST = 0x00000002,\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct MONITORINFO\n        {\n            public int cbSize;\n            public RECT rcMonitor;\n            public RECT rcWork;\n            public int dwFlags;\n\n            public static MONITORINFO Create()\n            {\n                return new MONITORINFO() { cbSize = Marshal.SizeOf<MONITORINFO>() };\n            }\n\n            public enum MonitorOptions : uint\n            {\n                MONITOR_DEFAULTTONULL = 0x00000000,\n                MONITOR_DEFAULTTOPRIMARY = 0x00000001,\n                MONITOR_DEFAULTTONEAREST = 0x00000002\n            }\n        }\n\n        public enum PROCESS_DPI_AWARENESS\n        {\n            PROCESS_DPI_UNAWARE = 0,\n            PROCESS_SYSTEM_DPI_AWARE = 1,\n            PROCESS_PER_MONITOR_DPI_AWARE = 2\n        }\n\n        public enum MONITOR_DPI_TYPE\n        {\n            MDT_EFFECTIVE_DPI = 0,\n            MDT_ANGULAR_DPI = 1,\n            MDT_RAW_DPI = 2,\n            MDT_DEFAULT = MDT_EFFECTIVE_DPI\n        } \n\n        public enum ClipboardFormat \n        {\n            /// <summary>\n            /// Text format. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the end of the data. Use this format for ANSI text.\n            /// </summary>\n            CF_TEXT = 1,\n            /// <summary>\n            /// A handle to a bitmap\n            /// </summary>\n            CF_BITMAP = 2,\n            /// <summary>\n            /// A memory object containing a BITMAPINFO structure followed by the bitmap bits.\n            /// </summary>\n            CF_DIB = 3,\n            /// <summary>\n            /// Unicode text format. Each line ends with a carriage return/linefeed (CR-LF) combination. A null character signals the end of the data.\n            /// </summary>\n            CF_UNICODETEXT = 13,\n            /// <summary>\n            /// A handle to type HDROP that identifies a list of files. \n            /// </summary>\n            CF_HDROP = 15,\n        }\n\n        public struct MSG\n        {\n            public IntPtr hwnd;\n            public uint message;\n            public IntPtr wParam;\n            public IntPtr lParam;\n            public uint time;\n            public POINT pt;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct PAINTSTRUCT\n        {\n            public IntPtr hdc;\n            public bool fErase;\n            public RECT rcPaint;\n            public bool fRestore;\n            public bool fIncUpdate;\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 32)]\n            public byte[] rgbReserved;\n        }\n\n        public struct POINT\n        {\n            public int X;\n            public int Y;\n        }\n\n        public struct RECT\n        {\n            public int left;\n            public int top;\n            public int right;\n            public int bottom;\n\n            public int Width => right - left;\n            public int Height => bottom - top;\n            public RECT(Rect rect)\n            {\n                left = (int)rect.X;\n                top = (int)rect.Y;\n                right = (int)(rect.X + rect.Width);\n                bottom = (int)(rect.Y + rect.Height);\n            }\n\n            public void Offset(POINT pt)\n            {\n                left += pt.X;\n                right += pt.X;\n                top += pt.Y;\n                bottom += pt.Y;\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct WINDOWPOS\n        {\n            public IntPtr hwnd;\n            public IntPtr hwndInsertAfter;\n            public int x;\n            public int y;\n            public int cx;\n            public int cy;\n            public uint flags;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct NCCALCSIZE_PARAMS\n        {\n            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 3)]\n            public RECT[] rgrc;\n            public WINDOWPOS lppos;\n        }\n\n        public struct TRACKMOUSEEVENT\n        {\n            public int cbSize;\n            public uint dwFlags;\n            public IntPtr hwndTrack;\n            public int dwHoverTime;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct WINDOWPLACEMENT\n        {\n            /// <summary>\n            /// The length of the structure, in bytes. Before calling the GetWindowPlacement or SetWindowPlacement functions, set this member to sizeof(WINDOWPLACEMENT).\n            /// <para>\n            /// GetWindowPlacement and SetWindowPlacement fail if this member is not set correctly.\n            /// </para>\n            /// </summary>\n            public int Length;\n\n            /// <summary>\n            /// Specifies flags that control the position of the minimized window and the method by which the window is restored.\n            /// </summary>\n            public int Flags;\n\n            /// <summary>\n            /// The current show state of the window.\n            /// </summary>\n            public ShowWindowCommand ShowCmd;\n\n            /// <summary>\n            /// The coordinates of the window's upper-left corner when the window is minimized.\n            /// </summary>\n            public POINT MinPosition;\n\n            /// <summary>\n            /// The coordinates of the window's upper-left corner when the window is maximized.\n            /// </summary>\n            public POINT MaxPosition;\n\n            /// <summary>\n            /// The window's coordinates when the window is in the restored position.\n            /// </summary>\n            public RECT NormalPosition;\n\n            /// <summary>\n            /// Gets the default (empty) value.\n            /// </summary>\n            public static WINDOWPLACEMENT Default\n            {\n                get\n                {\n                    WINDOWPLACEMENT result = new WINDOWPLACEMENT();\n                    result.Length = Marshal.SizeOf(result);\n                    return result;\n                }\n            }\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct WNDCLASSEX\n        {\n            public int cbSize;\n            public int style;\n            public WndProc lpfnWndProc;\n            public int cbClsExtra;\n            public int cbWndExtra;\n            public IntPtr hInstance;\n            public IntPtr hIcon;\n            public IntPtr hCursor;\n            public IntPtr hbrBackground;\n            public string lpszMenuName;\n            public string lpszClassName;\n            public IntPtr hIconSm;\n        }\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct TOUCHINPUT\n        {\n            public int X;\n            public int Y;\n            public IntPtr Source;\n            public uint Id;\n            public TouchInputFlags Flags;\n            public int Mask;\n            public uint Time;\n            public IntPtr ExtraInfo;\n            public int CxContact;\n            public int CyContact;\n        }\n\n        [Flags]\n        public enum TouchInputFlags\n        {\n            /// <summary>\n            /// Movement has occurred. Cannot be combined with TOUCHEVENTF_DOWN.\n            /// </summary>\n            TOUCHEVENTF_MOVE = 0x0001,\n\n            /// <summary>\n            /// The corresponding touch point was established through a new contact. Cannot be combined with TOUCHEVENTF_MOVE or TOUCHEVENTF_UP.\n            /// </summary>\n            TOUCHEVENTF_DOWN = 0x0002,\n\n            /// <summary>\n            /// A touch point was removed.\n            /// </summary>\n            TOUCHEVENTF_UP = 0x0004,\n\n            /// <summary>\n            /// A touch point is in range. This flag is used to enable touch hover support on compatible hardware. Applications that do not want support for hover can ignore this flag.\n            /// </summary>\n            TOUCHEVENTF_INRANGE = 0x0008,\n\n            /// <summary>\n            /// Indicates that this TOUCHINPUT structure corresponds to a primary contact point. See the following text for more information on primary touch points.\n            /// </summary>\n            TOUCHEVENTF_PRIMARY = 0x0010,\n\n            /// <summary>\n            /// When received using GetTouchInputInfo, this input was not coalesced.\n            /// </summary>\n            TOUCHEVENTF_NOCOALESCE = 0x0020,\n\n            /// <summary>\n            /// The touch event came from the user's palm.\n            /// </summary>\n            TOUCHEVENTF_PALM = 0x0080\n        }\n\n        [Flags]\n        public enum OpenFileNameFlags\n        {\n            OFN_ALLOWMULTISELECT = 0x00000200,\n            OFN_EXPLORER = 0x00080000,\n            OFN_HIDEREADONLY = 0x00000004,\n            OFN_NOREADONLYRETURN = 0x00008000,\n            OFN_OVERWRITEPROMPT = 0x00000002\n        }\n        \n        public enum HRESULT : uint\n        {\n            S_FALSE = 0x0001,\n            S_OK = 0x0000,\n            E_INVALIDARG = 0x80070057,\n            E_OUTOFMEMORY = 0x8007000E,\n            E_NOTIMPL = 0x80004001,\n            E_UNEXPECTED = 0x8000FFFF\n        }\n\n        public enum Icons\n        {\n            ICON_SMALL = 0,\n            ICON_BIG = 1\n        }\n\n        public const uint SIGDN_FILESYSPATH = 0x80058000;\n\n        [Flags]\n        public enum FOS : uint\n        {\n            FOS_OVERWRITEPROMPT = 0x00000002,\n            FOS_STRICTFILETYPES = 0x00000004,\n            FOS_NOCHANGEDIR = 0x00000008,\n            FOS_PICKFOLDERS = 0x00000020,\n            FOS_FORCEFILESYSTEM = 0x00000040, // Ensure that items returned are filesystem items.\n            FOS_ALLNONSTORAGEITEMS = 0x00000080, // Allow choosing items that have no storage.\n            FOS_NOVALIDATE = 0x00000100,\n            FOS_ALLOWMULTISELECT = 0x00000200,\n            FOS_PATHMUSTEXIST = 0x00000800,\n            FOS_FILEMUSTEXIST = 0x00001000,\n            FOS_CREATEPROMPT = 0x00002000,\n            FOS_SHAREAWARE = 0x00004000,\n            FOS_NOREADONLYRETURN = 0x00008000,\n            FOS_NOTESTFILECREATE = 0x00010000,\n            FOS_HIDEMRUPLACES = 0x00020000,\n            FOS_HIDEPINNEDPLACES = 0x00040000,\n            FOS_NODEREFERENCELINKS = 0x00100000,\n            FOS_DONTADDTORECENT = 0x02000000,\n            FOS_FORCESHOWHIDDEN = 0x10000000,\n            FOS_DEFAULTNOMINIMODE = 0x20000000\n        }\n\n        public static class ShellIds\n        {\n            public static readonly Guid OpenFileDialog = Guid.Parse(\"DC1C5A9C-E88A-4DDE-A5A1-60F82A20AEF7\");\n            public static readonly Guid SaveFileDialog = Guid.Parse(\"C0B4E2F3-BA21-4773-8DBA-335EC946EB8B\");\n            public static readonly Guid IFileDialog = Guid.Parse(\"42F85136-DB7E-439C-85F1-E4075D135FC8\");\n            public static readonly Guid IShellItem = Guid.Parse(\"43826D1E-E718-42EE-BC55-A1E261C37BFE\");\n        }\n\n        [ComImport(), Guid(\"42F85136-DB7E-439C-85F1-E4075D135FC8\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        public interface IFileDialog\n        {\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            [PreserveSig()]\n            uint Show([In, Optional] IntPtr hwndOwner); //IModalWindow\n\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetFileTypes(uint cFileTypes, [In, MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 0)] COMDLG_FILTERSPEC[] rgFilterSpec);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetFileTypeIndex([In] uint iFileType);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetFileTypeIndex(out uint piFileType);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint Advise([In, MarshalAs(UnmanagedType.Interface)] IntPtr pfde, out uint pdwCookie);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint Unadvise([In] uint dwCookie);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetOptions([In] uint fos);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetOptions(out uint fos);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetDefaultFolder([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetFolder([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetFolder([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetCurrentSelection([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetFileName([In, MarshalAs(UnmanagedType.LPWStr)] string pszName);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetFileName([MarshalAs(UnmanagedType.LPWStr)] out string pszName);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetTitle([In, MarshalAs(UnmanagedType.LPWStr)] string pszTitle);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetOkButtonLabel([In, MarshalAs(UnmanagedType.LPWStr)] string pszText);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetFileNameLabel([In, MarshalAs(UnmanagedType.LPWStr)] string pszLabel);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetResult([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint AddPlace([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi, uint fdap);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetDefaultExtension([In, MarshalAs(UnmanagedType.LPWStr)] string pszDefaultExtension);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint Close([MarshalAs(UnmanagedType.Error)] uint hr);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetClientGuid([In] ref Guid guid);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint ClearClientData();\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetFilter([MarshalAs(UnmanagedType.Interface)] IntPtr pFilter);\n\n        }\n\n        [ComImport, Guid(\"d57c7288-d4ad-4768-be02-9d969532d960\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        public interface IFileOpenDialog\n        {\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            [PreserveSig()]\n            uint Show([In, Optional] IntPtr hwndOwner); //IModalWindow \n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetFileTypes([In] uint cFileTypes, [In, MarshalAs(UnmanagedType.LPArray)] IntPtr rgFilterSpec);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetFileTypeIndex([In] uint iFileType);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetFileTypeIndex(out uint piFileType);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint Advise([In, MarshalAs(UnmanagedType.Interface)] IntPtr pfde, out uint pdwCookie);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void Unadvise([In] uint dwCookie);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint SetOptions([In] uint fos);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetOptions(out uint fos);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetDefaultFolder([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetFolder([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetFolder([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetCurrentSelection([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetFileName([In, MarshalAs(UnmanagedType.LPWStr)] string pszName);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetFileName([MarshalAs(UnmanagedType.LPWStr)] out string pszName);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetTitle([In, MarshalAs(UnmanagedType.LPWStr)] string pszTitle);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetOkButtonLabel([In, MarshalAs(UnmanagedType.LPWStr)] string pszText);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetFileNameLabel([In, MarshalAs(UnmanagedType.LPWStr)] string pszLabel);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetResult([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint AddPlace([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi, uint fdap);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetDefaultExtension([In, MarshalAs(UnmanagedType.LPWStr)] string pszDefaultExtension);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void Close([MarshalAs(UnmanagedType.Error)] int hr);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetClientGuid([In] ref Guid guid);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void ClearClientData();\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void SetFilter([MarshalAs(UnmanagedType.Interface)] IntPtr pFilter);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetResults([MarshalAs(UnmanagedType.Interface)] out IShellItemArray ppenum);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetSelectedItems([MarshalAs(UnmanagedType.Interface)] out IShellItemArray ppsai);\n        }\n\n        [ComImport, Guid(\"B63EA76D-1F85-456F-A19C-48159EFA858B\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        public interface IShellItemArray\n        {\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void BindToHandler([In, MarshalAs(UnmanagedType.Interface)] IntPtr pbc, [In] ref Guid rbhid,\n                         [In] ref Guid riid, out IntPtr ppvOut);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetPropertyStore([In] int Flags, [In] ref Guid riid, out IntPtr ppv);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetPropertyDescriptionList([In] ref PROPERTYKEY keyType, [In] ref Guid riid, out IntPtr ppv);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetAttributes([In] SIATTRIBFLAGS dwAttribFlags, [In] uint sfgaoMask, out uint psfgaoAttribs);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetCount(out uint pdwNumItems);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void GetItemAt([In] uint dwIndex, [MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            void EnumItems([MarshalAs(UnmanagedType.Interface)] out IntPtr ppenumShellItems);\n        }\n\n        [StructLayout(LayoutKind.Sequential, Pack = 4)]\n        public struct PROPERTYKEY\n        {\n            public Guid fmtid;\n            public uint pid;\n        }\n\n        public enum SIATTRIBFLAGS\n        {\n            SIATTRIBFLAGS_AND = 1,\n            SIATTRIBFLAGS_APPCOMPAT = 3,\n            SIATTRIBFLAGS_OR = 2\n        }\n\n        [ComImport, Guid(\"43826D1E-E718-42EE-BC55-A1E261C37BFE\"), InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]\n        public interface IShellItem\n        {\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint BindToHandler([In] IntPtr pbc, [In] ref Guid rbhid, [In] ref Guid riid, [Out, MarshalAs(UnmanagedType.Interface)] out IntPtr ppvOut);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetParent([MarshalAs(UnmanagedType.Interface)] out IShellItem ppsi);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetDisplayName([In] uint sigdnName, out IntPtr ppszName);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint GetAttributes([In] uint sfgaoMask, out uint psfgaoAttribs);\n\n            [MethodImpl(MethodImplOptions.InternalCall, MethodCodeType = MethodCodeType.Runtime)]\n            uint Compare([In, MarshalAs(UnmanagedType.Interface)] IShellItem psi, [In] uint hint, out int piOrder);\n\n        }\n\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        public struct COMDLG_FILTERSPEC\n        {\n            [MarshalAs(UnmanagedType.LPWStr)]\n            public string pszName;\n            [MarshalAs(UnmanagedType.LPWStr)]\n            public string pszSpec;\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>Represents the abstract base class from which all implementations of symmetric algorithms must inherit.</summary>\n    [ComVisibleAttribute(true)]\n    public abstract class SymmetricAlgorithm : IDisposable\n    {\n        /// <summary>Represents the block size, in bits, of the cryptographic operation.</summary>\n        protected int BlockSizeValue;\n        /// <summary>Represents the feedback size, in bits, of the cryptographic operation.</summary>\n        protected int FeedbackSizeValue;\n        /// <summary>Represents the initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />) for the symmetric algorithm.</summary>\n        protected byte[] IVValue;\n        /// <summary>Represents the secret key for the symmetric algorithm.</summary>\n        protected byte[] KeyValue;\n        /// <summary>Specifies the block sizes, in bits, that are supported by the symmetric algorithm.</summary>\n        protected KeySizes[] LegalBlockSizesValue;\n        /// <summary>Specifies the key sizes, in bits, that are supported by the symmetric algorithm.</summary>\n        protected KeySizes[] LegalKeySizesValue;\n        /// <summary>Represents the size, in bits, of the secret key used by the symmetric algorithm.</summary>\n        protected int KeySizeValue;\n        /// <summary>Represents the cipher mode used in the symmetric algorithm.</summary>\n        protected CipherMode ModeValue;\n        /// <summary>Represents the padding mode used in the symmetric algorithm.</summary>\n        protected PaddingMode PaddingValue;\n    \n        /// <summary>Gets or sets the block size, in bits, of the cryptographic operation.</summary><returns>The block size, in bits.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The block size is invalid. </exception>\n        public virtual int BlockSize\n        {\n            get { throw new NotImplementedException(); }\n            set { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets or sets the feedback size, in bits, of the cryptographic operation.</summary><returns>The feedback size in bits.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The feedback size is larger than the block size. </exception>\n        public virtual int FeedbackSize\n        {\n            get { throw new NotImplementedException(); }\n            set { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets or sets the initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />) for the symmetric algorithm.</summary><returns>The initialization vector.</returns><exception cref=\"T:System.ArgumentNullException\">An attempt was made to set the initialization vector to null. </exception><exception cref=\"T:System.Security.Cryptography.CryptographicException\">An attempt was made to set the initialization vector to an invalid size. </exception>\n        public virtual byte[] IV\n        {\n            get { throw new NotImplementedException(); }\n            set { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets or sets the secret key for the symmetric algorithm.</summary><returns>The secret key to use for the symmetric algorithm.</returns><exception cref=\"T:System.ArgumentNullException\">An attempt was made to set the key to null. </exception><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The key size is invalid.</exception>\n        public virtual byte[] Key\n        {\n            get { throw new NotImplementedException(); }\n            set { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets the block sizes, in bits, that are supported by the symmetric algorithm.</summary><returns>An array that contains the block sizes supported by the algorithm.</returns>\n        public virtual KeySizes[] LegalBlockSizes\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets the key sizes, in bits, that are supported by the symmetric algorithm.</summary><returns>An array that contains the key sizes supported by the algorithm.</returns>\n        public virtual KeySizes[] LegalKeySizes\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets or sets the size, in bits, of the secret key used by the symmetric algorithm.</summary><returns>The size, in bits, of the secret key used by the symmetric algorithm.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The key size is not valid. </exception>\n        public virtual int KeySize\n        {\n            get { throw new NotImplementedException(); }\n            set { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets or sets the mode for operation of the symmetric algorithm.</summary><returns>The mode for operation of the symmetric algorithm. The default is <see cref=\"F:System.Security.Cryptography.CipherMode.CBC\" />.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The cipher mode is not one of the <see cref=\"T:System.Security.Cryptography.CipherMode\" /> values. </exception>\n        public virtual CipherMode Mode\n        {\n            get { throw new NotImplementedException(); }\n            set { throw new NotImplementedException(); }\n        }\n    \n        /// <summary>Gets or sets the padding mode used in the symmetric algorithm.</summary><returns>The padding mode used in the symmetric algorithm. The default is <see cref=\"F:System.Security.Cryptography.PaddingMode.PKCS7\" />.</returns><exception cref=\"T:System.Security.Cryptography.CryptographicException\">The padding mode is not one of the <see cref=\"T:System.Security.Cryptography.PaddingMode\" /> values. </exception>\n        public virtual PaddingMode Padding\n        {\n            get { throw new NotImplementedException(); }\n            set { throw new NotImplementedException(); }\n        }\n    \n    \n        protected SymmetricAlgorithm()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public void Dispose()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public void Clear()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        /// <summary>Releases the unmanaged resources used by the <see cref=\"T:System.Security.Cryptography.SymmetricAlgorithm\" /> and optionally releases the managed resources.</summary><param name=\"disposing\">true to release both managed and unmanaged resources; false to release only unmanaged resources. </param>\n        protected virtual void Dispose(bool disposing)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        /// <summary>Determines whether the specified key size is valid for the current algorithm.</summary><returns>true if the specified key size is valid for the current algorithm; otherwise, false.</returns><param name=\"bitLength\">The length, in bits, to check for a valid key size. </param>\n        public bool ValidKeySize(int bitLength)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static SymmetricAlgorithm Create()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        /// <summary>Creates the specified cryptographic object used to perform the symmetric algorithm.</summary><returns>A cryptographic object used to perform the symmetric algorithm.</returns><param name=\"algName\">The name of the specific implementation of the <see cref=\"T:System.Security.Cryptography.SymmetricAlgorithm\" /> class to use. </param>\n        public static SymmetricAlgorithm Create(string algName)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public virtual ICryptoTransform CreateEncryptor()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        /// <summary>When overridden in a derived class, creates a symmetric encryptor object with the specified <see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.Key\" /> property and initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />).</summary><returns>A symmetric encryptor object.</returns><param name=\"rgbKey\">The secret key to use for the symmetric algorithm. </param><param name=\"rgbIV\">The initialization vector to use for the symmetric algorithm. </param>\n        public abstract ICryptoTransform CreateEncryptor(byte[] rgbKey, byte[] rgbIV);\n        \n        \n        public virtual ICryptoTransform CreateDecryptor()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        /// <summary>When overridden in a derived class, creates a symmetric decryptor object with the specified <see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.Key\" /> property and initialization vector (<see cref=\"P:System.Security.Cryptography.SymmetricAlgorithm.IV\" />).</summary><returns>A symmetric decryptor object.</returns><param name=\"rgbKey\">The secret key to use for the symmetric algorithm. </param><param name=\"rgbIV\">The initialization vector to use for the symmetric algorithm. </param>\n        public abstract ICryptoTransform CreateDecryptor(byte[] rgbKey, byte[] rgbIV);\n        \n        \n        public abstract void GenerateKey();\n        \n        \n        public abstract void GenerateIV();\n        \n        \n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\t\tinternal abstract partial class FTree<TChild>\n\t\t\twhere TChild : Measured<TChild>, new() {\n\t\t\tprivate sealed class Compound : FTree<TChild> {\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_END = 6;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_MIDDLE_OF_DEEP = 3;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_MIDDLE_OF_LEFT = 1;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_MIDDLE_OF_RIGHT = 5;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_START = 0;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_START_OF_DEEP = 2;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_START_OF_RIGHT = 4;\n\n\t\t\t\tconst int\n\t\t\t\t\tOUTSIDE = 7;\n\n\t\t\t\tpublic FTree<Digit> DeepTree;\n\t\t\t\tpublic Digit LeftDigit;\n\t\t\t\tpublic Digit RightDigit;\n\n\t\t\t\tpublic Compound(Digit leftDigit, FTree<Digit> deepTree, Digit rightDigit, Lineage lineage)\n\t\t\t\t\t: base(leftDigit.Measure + deepTree.Measure + rightDigit.Measure, TreeType.Compound, lineage, 3) {\n\n\t\t\t\t\tleftDigit.AssertNotNull();\n\t\t\t\t\tdeepTree.AssertNotNull();\n\t\t\t\t\trightDigit.AssertNotNull();\n\t\t\t\t\t_mutate(leftDigit, deepTree, rightDigit);\n\t\t\t\t}\n\n\t\t\t\tpublic override Leaf<TValue> this[int index] {\n\t\t\t\t\tget {\n\n\t\t\t\t\t\tindex.AssertEqual(i => i < Measure);\n\n\t\t\t\t\t\tvar m1 = LeftDigit.Measure;\n\t\t\t\t\t\tvar m2 = DeepTree.Measure + m1;\n\n\t\t\t\t\t\tif (index < m1) return LeftDigit[index];\n\t\t\t\t\t\tif (index < m2) return DeepTree[index - m1];\n\t\t\t\t\t\tif (index < Measure) return RightDigit[index - m2];\n\n\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IsFragment {\n\t\t\t\t\tget { return false; }\n\t\t\t\t}\n\n\t\t\t\tpublic override TChild Left {\n\t\t\t\t\tget { return LeftDigit.Left; }\n\t\t\t\t}\n\n\t\t\t\tpublic override TChild Right {\n\t\t\t\t\tget { return RightDigit.Right; }\n\t\t\t\t}\n\n\t\t\t\tpublic override string Print() {\n\t\t\t\t\treturn string.Format(\"[[{0} | {1} | {2}]]\", LeftDigit.Print(), DeepTree.Print(), RightDigit.Print());\n\t\t\t\t}\n\n\t\t\t\tFTree<TChild> CreateCheckNull(Lineage lineage, Digit left = null, FTree<Digit> deep = null, Digit right = null) {\n\t\t\t\t\tvar memberPermutation = left != null ? 1 << 0 : 0;\n\t\t\t\t\tmemberPermutation |= (deep != null && deep.Measure != 0) ? 1 << 1 : 0;\n\t\t\t\t\tmemberPermutation |= right != null ? 1 << 2 : 0;\n\n\t\t\t\t\tswitch (memberPermutation) {\n\t\t\t\t\t\tcase 0 << 0| 0 << 1 | 0 << 2:\n\t\t\t\t\t\t\treturn Empty;\n\t\t\t\t\t\tcase 1 << 0 | 0 << 1 | 0 << 2:\n\t\t\t\t\t\t\treturn new Single(left, lineage);\n\t\t\t\t\t\tcase 1 << 0 | 1 << 1 | 0 << 2:\n\t\t\t\t\t\t\tvar r2 = deep.Right;\n\t\t\t\t\t\t\tvar deep1 = deep.RemoveLast(lineage);\n\n\t\t\t\t\t\t\treturn MutateOrCreate(left, deep1, r2, lineage);\n\t\t\t\t\t\tcase 1 << 0 | 1 << 1 | 1 << 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(left, deep, right, lineage);\n\t\t\t\t\t\tcase 0 << 0 | 1 << 1 | 1 << 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(deep.Left, deep.RemoveFirst(lineage), right, lineage);\n\t\t\t\t\t\tcase 1 << 0 | 0 << 1 | 1 << 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(left, deep, right, lineage);\n\t\t\t\t\t\tcase 0 << 0 | 1 << 1 | 0 << 2:\n\t\t\t\t\t\t\tleft = deep.Left;\n\t\t\t\t\t\t\tdeep = deep.RemoveFirst(lineage);\n\t\t\t\t\t\t\tif (deep.Measure != 0) {\n\t\t\t\t\t\t\t\tright = deep.Right;\n\t\t\t\t\t\t\t\tdeep = deep.RemoveLast(lineage);\n\t\t\t\t\t\t\t\treturn MutateOrCreate(left, deep, right, lineage);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn new Single(left, lineage);\n\t\t\t\t\t\tcase 0 << 0 | 0 << 1 | 1 << 2:\n\t\t\t\t\t\t\treturn new Single(right, lineage);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Explicitly checked all possible tree permutations.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/// <summary>\n\t\t\t\t///     This method will re-initialize this instance using the specified parameters.\n\t\t\t\t/// </summary>\n\t\t\t\tprivate FTree<TChild> _mutate(Digit left, FTree<Digit> deep, Digit right) {\n\t\t\t\t\tLeftDigit = left;\n\t\t\t\t\tDeepTree = deep;\n\t\t\t\t\tRightDigit = right;\n\t\t\t\t\tMeasure = left.Measure + deep.Measure + right.Measure;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\t/// <summary>\n\t\t\t\t///     <para>\n\t\t\t\t///         This method can mutate the current instance and return it, or return a new instance, based on the supplied\n\t\t\t\t///         Lineage.\n\t\t\t\t///     </para>\n\t\t\t\t///     <para>If the current Lineage allows mutation from the specified Lineage, the instance will be MUTATED and returned.</para>\n\t\t\t\t///     <para>Otherwise, the method will return a NEW instance that is a member of the supplied Lineage. </para>\n\t\t\t\t/// </summary>\n\t\t\t\tprivate FTree<TChild> MutateOrCreate(Digit left, FTree<Digit> deep, Digit right, Lineage lineage) {\n\t\t\t\t\tif (_lineage.AllowMutation(lineage)) {\n\t\t\t\t\t\treturn _mutate(left, deep, right);\n\t\t\t\t\t} else return new Compound(left, deep, right, lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> AddFirst(TChild item, Lineage lineage) {\n\t\t\t\t\tFTree<TChild> ret;\n#if ASSERTS\n\t\t\t\t\tvar expectedSize = Measure + item.Measure;\n#endif\n\t\t\t\t\tif (LeftDigit.Size < 4) ret = MutateOrCreate(LeftDigit.AddFirst(item, lineage), DeepTree, RightDigit, lineage);\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar leftmost = new Digit(item, LeftDigit.First, lineage);\n\t\t\t\t\t\tvar rightmost = LeftDigit.RemoveFirst(lineage);\n\t\t\t\t\t\tvar newDeep = DeepTree.AddFirst(rightmost, lineage);\n\t\t\t\t\t\tret = MutateOrCreate(leftmost, newDeep, RightDigit, lineage);\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(expectedSize);\n\t\t\t\t\tret.Left.AssertEqual(item);\n#endif\n\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> AddLast(TChild item, Lineage lineage) {\n#if ASSERTS\n\t\t\t\t\tvar expectedSize = Measure + item.Measure;\n#endif\n\t\t\t\t\tFTree<TChild> ret;\n\t\t\t\t\tif (RightDigit.Size < 4) ret = MutateOrCreate(LeftDigit, DeepTree, RightDigit.AddLast(item, lineage), lineage);\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar rightmost = new Digit(RightDigit.Fourth, item, lineage);\n\t\t\t\t\t\tvar leftmost = RightDigit.RemoveLast(lineage);\n\t\t\t\t\t\tvar newDeep = DeepTree.AddLast(leftmost, lineage);\n\t\t\t\t\t\tret = MutateOrCreate(LeftDigit, newDeep, rightmost, lineage);\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(expectedSize);\n\t\t\t\t\tret.Right.AssertEqual(item);\n#endif\n\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveFirst(Lineage lineage) {\n\t\t\t\t\tFTree<TChild> ret;\n#if ASSERTS\n\t\t\t\t\tvar expected = Measure - Left.Measure;\n#endif\n\n\t\t\t\t\tif (LeftDigit.Size > 1) {\n\t\t\t\t\t\tvar newLeft = LeftDigit.RemoveFirst(lineage);\n\t\t\t\t\t\tret = MutateOrCreate(newLeft, DeepTree, RightDigit, lineage);\n\t\t\t\t\t} else if (DeepTree.Measure > 0) {\n\t\t\t\t\t\tvar newLeft = DeepTree.Left;\n\t\t\t\t\t\tvar newDeep = DeepTree.RemoveFirst(lineage);\n\t\t\t\t\t\tret = MutateOrCreate(newLeft, newDeep, RightDigit, lineage);\n\t\t\t\t\t} else ret = new Single(RightDigit, lineage);\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(expected);\n#endif\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveLast(Lineage lineage) {\n\t\t\t\t\tFTree<TChild> ret;\n#if ASSERTS\n\t\t\t\t\tvar expectedSize = Measure - Right.Measure;\n#endif\n\t\t\t\t\tif (RightDigit.Size > 1) {\n\t\t\t\t\t\tvar newRight = RightDigit.RemoveLast(lineage);\n\t\t\t\t\t\tret = MutateOrCreate(LeftDigit, DeepTree, newRight, lineage);\n\t\t\t\t\t} else if (DeepTree.Measure > 0) {\n\t\t\t\t\t\tvar newRight = DeepTree.Right;\n\t\t\t\t\t\tvar newDeep = DeepTree.RemoveLast(lineage);\n\t\t\t\t\t\tret = MutateOrCreate(LeftDigit, newDeep, newRight, lineage);\n\t\t\t\t\t} else ret = new Single(LeftDigit, lineage);\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(expectedSize);\n#endif\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tpublic override void Split(int index, out FTree<TChild> left, out TChild child, out FTree<TChild> right, Lineage lineage) {\n#if ASSERTS\n\t\t\t\t\tvar oldMeasure = Measure;\n\t\t\t\t\tvar oldValue = this[index];\n\n#endif\n\t\t\t\t\tswitch (WhereIsThisIndex(index)) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_LEFT:\n\t\t\t\t\t\t\tDigit lLeft, lRight;\n\t\t\t\t\t\t\tLeftDigit.Split(index, out lLeft, out child, out lRight, lineage);\n\t\t\t\t\t\t\tindex -= lLeft == null ? 0 : lLeft.Measure;\n\t\t\t\t\t\t\tleft = CreateCheckNull(Lineage.Immutable, lLeft);\n\t\t\t\t\t\t\tright = CreateCheckNull(lineage, lRight, DeepTree, RightDigit);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_DEEP:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_DEEP:\n\t\t\t\t\t\t\tindex -= LeftDigit.Measure;\n\t\t\t\t\t\t\tFTree<Digit> mLeft, mRight;\n\t\t\t\t\t\t\tDigit mCenter;\n\t\t\t\t\t\t\tDeepTree.Split(index, out mLeft, out mCenter, out mRight, lineage);\n\t\t\t\t\t\t\tDigit mcLeft, mcRight;\n\t\t\t\t\t\t\tindex -= mLeft.Measure;\n\t\t\t\t\t\t\tmCenter.Split(index, out mcLeft, out child, out mcRight, lineage);\n\t\t\t\t\t\t\tindex -= mcLeft == null ? 0 : mcLeft.Measure;\n\t\t\t\t\t\t\tleft = CreateCheckNull(Lineage.Immutable, LeftDigit, mLeft, mcLeft);\n\t\t\t\t\t\t\tright = CreateCheckNull(lineage, mcRight, mRight, RightDigit);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_MIDDLE_OF_RIGHT:\n\t\t\t\t\t\tcase IN_START_OF_RIGHT:\n\t\t\t\t\t\t\tDigit rLeft, rRight;\n\t\t\t\t\t\t\tindex -= LeftDigit.Measure + DeepTree.Measure;\n\t\t\t\t\t\t\tRightDigit.Split(index, out rLeft, out child, out rRight, lineage);\n\t\t\t\t\t\t\tindex -= rLeft == null ? 0 : rLeft.Measure;\n\t\t\t\t\t\t\tright = CreateCheckNull(Lineage.Immutable, rRight);\n\t\t\t\t\t\t\tleft = CreateCheckNull(lineage, LeftDigit, DeepTree, rLeft);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_END:\n\t\t\t\t\t\tcase OUTSIDE:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Index didn't match any of the cases.\");\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\toldMeasure.AssertEqual(left.Measure + child.Measure + right.Measure);\n\t\t\t\t\toldValue.AssertEqual(child[index]);\n#endif\n\t\t\t\t}\n\n\t\t\t\tFTree<TChild> FixLeftDigit(Lineage lineage) {\n\t\t\t\t\tif (!LeftDigit.IsFragment) return this;\n\t\t\t\t\tif (DeepTree.Measure == 0) {\n\t\t\t\t\t\tDigit first, last;\n\t\t\t\t\t\tLeftDigit.Fuse(RightDigit, out first, out last, lineage);\n\t\t\t\t\t\treturn CreateCheckNull(lineage, first, DeepTree, last);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar fromDeep = DeepTree.Left;\n\t\t\t\t\t\tvar newDeep = DeepTree.RemoveFirst(lineage);\n\t\t\t\t\t\tDigit first, last;\n\t\t\t\t\t\tLeftDigit.Fuse(fromDeep, out first, out last, lineage);\n\t\t\t\t\t\tif (last == null) return MutateOrCreate(first, newDeep, RightDigit, lineage);\n\t\t\t\t\t\treturn MutateOrCreate(first, newDeep.AddFirst(last, lineage), RightDigit, lineage);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tFTree<TChild> FixRightDigit(Lineage lineage) {\n\t\t\t\t\tif (!RightDigit.IsFragment) return this;\n\t\t\t\t\tFTree<TChild> ret;\n\t\t\t\t\tif (DeepTree.Measure == 0) {\n\t\t\t\t\t\tDigit first, last;\n\t\t\t\t\t\tLeftDigit.Fuse(RightDigit, out first, out last, lineage);\n\t\t\t\t\t\tret = CreateCheckNull(lineage, first, DeepTree, last);\n\t\t\t\t\t\treturn ret;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvar fromDeep = DeepTree.Right;\n\t\t\t\t\t\tvar newDeep = DeepTree.RemoveLast(lineage);\n\t\t\t\t\t\tDigit first, last;\n\t\t\t\t\t\tfromDeep.Fuse(RightDigit, out first, out last, lineage);\n\t\t\t\t\t\tif (last == null) ret = MutateOrCreate(LeftDigit, newDeep, first, lineage);\n\t\t\t\t\t\telse ret = MutateOrCreate(LeftDigit, newDeep.AddLast(first, lineage), last, lineage);\n\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(Measure);\n#endif\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> Insert(int index, Leaf<TValue> leaf, Lineage lineage) {\n\t\t\t\t\tvar whereIsThisIndex = WhereIsThisIndex(index);\n#if ASSERTS\n\t\t\t\t\tvar newMeasure = Measure + 1;\n\t\t\t\t\tvar oldValue = this[index].Value;\n#endif\n\t\t\t\t\tFTree<Digit> newDeep;\n\t\t\t\t\tFTree<TChild> res = null;\n\t\t\t\t\tswitch (whereIsThisIndex) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_LEFT:\n\t\t\t\t\t\t\tDigit leftL, leftR;\n\t\t\t\t\t\t\tLeftDigit.Insert(index, leaf, out leftL, out leftR, lineage);\n\t\t\t\t\t\t\tnewDeep = leftR != null ? DeepTree.AddFirst(leftR, lineage) : DeepTree;\n\t\t\t\t\t\t\tres = MutateOrCreate(leftL, newDeep, RightDigit, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_DEEP:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_DEEP:\n\t\t\t\t\t\t\tif (DeepTree.Measure == 0) goto case IN_START_OF_RIGHT;\n\t\t\t\t\t\t\tnewDeep = DeepTree.Insert(index - LeftDigit.Measure, leaf, lineage);\n\t\t\t\t\t\t\tres = MutateOrCreate(LeftDigit, newDeep, RightDigit, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_RIGHT:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_RIGHT:\n\t\t\t\t\t\t\tDigit rightR;\n\t\t\t\t\t\t\tDigit rightL;\n\t\t\t\t\t\t\tRightDigit.Insert(index - LeftDigit.Measure - DeepTree.Measure, leaf, out rightL, out rightR, lineage);\n\t\t\t\t\t\t\tnewDeep = rightR != null ? DeepTree.AddLast(rightL, lineage) : DeepTree;\n\t\t\t\t\t\t\trightR = rightR ?? rightL;\n\t\t\t\t\t\t\tres = MutateOrCreate(LeftDigit, newDeep, rightR, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tres.Measure.AssertEqual(newMeasure);\n\t\t\t\t\tres[index].Value.AssertEqual(leaf.Value);\n\t\t\t\t\tres[index + 1].Value.AssertEqual(oldValue);\n\n#endif\n\t\t\t\t\treturn res;\n\n\t\t\t\t}\n\n\t\t\t\tpublic override void Iter(Action<Leaf<TValue>> action) {\n#if ASSERTS\n\t\t\t\t\taction.AssertNotNull();\n#endif\n\t\t\t\t\tLeftDigit.Iter(action);\n\t\t\t\t\tDeepTree.Iter(action);\n\t\t\t\t\tRightDigit.Iter(action);\n\t\t\t\t}\n\n\t\t\t\tpublic override void IterBack(Action<Leaf<TValue>> action) {\n#if ASSERTS\n\t\t\t\t\taction.AssertNotNull();\n#endif\n\t\t\t\t\tRightDigit.IterBack(action);\n\t\t\t\t\tDeepTree.IterBack(action);\n\t\t\t\t\tLeftDigit.IterBack(action);\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IterBackWhile(Func<Leaf<TValue>, bool> action) {\n\t\t\t\t\tif (!RightDigit.IterBackWhile(action)) return false;\n\t\t\t\t\tif (!DeepTree.IterBackWhile(action)) return false;\n\t\t\t\t\tif (!LeftDigit.IterBackWhile(action)) return false;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IterWhile(Func<Leaf<TValue>, bool> action) {\n\t\t\t\t\tif (!LeftDigit.IterWhile(action)) return false;\n\t\t\t\t\tif (!DeepTree.IterWhile(action)) return false;\n\t\t\t\t\tif (!RightDigit.IterWhile(action)) return false;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveAt(int index, Lineage lineage) {\n\t\t\t\t\tvar whereIsThisIndex = WhereIsThisIndex(index);\n\t\t\t\t\tDigit newLeft;\n\t\t\t\t\tFTree<TChild> ret = this;\n#if ASSERTS\n\t\t\t\t\tvar newMeasure = Measure - 1;\n\t\t\t\t\tvar expectedAtIndex = index != Measure - 1 ? this[index + 1] : null;\n\t\t\t\t\tvar expectedBeforeIndex = index != 0 ? this[index - 1] : null;\n#endif\n\t\t\t\t\tswitch (whereIsThisIndex) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_LEFT:\n\t\t\t\t\t\t\tif (LeftDigit.IsFragment) {\n\t\t\t\t\t\t\t\tvar fixedTree = FixLeftDigit(lineage);\n\t\t\t\t\t\t\t\tret = fixedTree.RemoveAt(index, lineage);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnewLeft = LeftDigit.Remove(index, lineage);\n\t\t\t\t\t\t\t\tret = CreateCheckNull(lineage, newLeft, DeepTree, RightDigit);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_DEEP:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_DEEP:\n\t\t\t\t\t\t\tif (DeepTree.Measure == 0) goto case IN_START_OF_RIGHT;\n\t\t\t\t\t\t\tvar deep = DeepTree;\n\t\t\t\t\t\t\tFTree<Digit> newDeep;\n\t\t\t\t\t\t\tif (deep.IsFragment) {\n\t\t\t\t\t\t\t\tnewDeep = deep.AddFirst(LeftDigit, lineage);\n\t\t\t\t\t\t\t\tnewDeep = newDeep.RemoveAt(index, lineage);\n\t\t\t\t\t\t\t\tnewLeft = newDeep.Left;\n\t\t\t\t\t\t\t\tnewDeep = newDeep.RemoveFirst(lineage);\n\t\t\t\t\t\t\t\tret = MutateOrCreate(newLeft, newDeep, RightDigit, lineage);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnewDeep = DeepTree.RemoveAt(index - LeftDigit.Measure, lineage);\n\t\t\t\t\t\t\t\tret = CreateCheckNull(lineage, LeftDigit, newDeep, RightDigit);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_RIGHT:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_RIGHT:\n\t\t\t\t\t\t\tif (RightDigit.IsFragment) {\n\t\t\t\t\t\t\t\tvar fixedTree = FixRightDigit(lineage);\n\t\t\t\t\t\t\t\tret = fixedTree.RemoveAt(index, lineage);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tvar newRight = RightDigit.Remove(index - LeftDigit.Measure - DeepTree.Measure, lineage);\n\t\t\t\t\t\t\t\tret = CreateCheckNull(lineage, LeftDigit, DeepTree, newRight);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_END:\n\t\t\t\t\t\tcase OUTSIDE:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all possible index locations already.\");\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(newMeasure);\n\t\t\t\t\tif (expectedAtIndex != null) ret[index].Value.AssertEqual(expectedAtIndex.Value);\n\t\t\t\t\tif (expectedBeforeIndex != null) ret[index-1].Value.AssertEqual(expectedBeforeIndex.Value);\n#endif\n\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> Reverse(Lineage lineage) {\n\t\t\t\t\treturn MutateOrCreate(RightDigit.Reverse(lineage), DeepTree.Reverse(lineage), LeftDigit.Reverse(lineage), lineage);\n\t\t\t\t}\n\n\n\t\t\t\tpublic override FTree<TChild> Update(int index, Leaf<TValue> leaf, Lineage lineage) {\n\t\t\t\t\tvar whereIsThisIndex = WhereIsThisIndex(index);\n\t\t\t\t\tFTree<TChild> ret;\n#if ASSERTS\n\t\t\t\t\tvar oldSize = Measure;\n#endif\n\t\t\t\t\tswitch (whereIsThisIndex) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_LEFT:\n\t\t\t\t\t\t\tvar newLeft = LeftDigit.Update(index, leaf, lineage);\n\t\t\t\t\t\t\tret = MutateOrCreate(newLeft, DeepTree, RightDigit, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_DEEP:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_DEEP:\n\t\t\t\t\t\t\tif (DeepTree.Measure == 0) goto case IN_START_OF_RIGHT;\n\t\t\t\t\t\t\tvar newDeep = DeepTree.Update(index - LeftDigit.Measure, leaf, lineage);\n\t\t\t\t\t\t\tret = MutateOrCreate(LeftDigit, newDeep, RightDigit, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_RIGHT:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_RIGHT:\n\t\t\t\t\t\t\tvar newRight = RightDigit.Update(index - LeftDigit.Measure - DeepTree.Measure, leaf, lineage);\n\t\t\t\t\t\t\tret = MutateOrCreate(LeftDigit, DeepTree, newRight, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(oldSize);\n\t\t\t\t\tret[index].AssertEqual(leaf);\n#endif\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\t/// <summary>\n\t\t\t\t///     Returns 0 if index is 0 (meaning, empty).\n\t\t\t\t///     Returns 1 if index is in left digit\n\t\t\t\t///     Returns 2 if index encompasses the left digit.\n\t\t\t\t///     Returns 3 if he index is in the deep tree.\n\t\t\t\t///     Returns 4 if the index encompasses the left digit + deep tree\n\t\t\t\t///     Returns 5 if the index is in the right digit.\n\t\t\t\t///     Returns 6 if the index encompasses the entire tree.\n\t\t\t\t///     Returns 7 if the index is outside the tree.\n\t\t\t\t/// </summary>\n\t\t\t\t/// <param name=\"index\"> </param>\n\t\t\t\t/// <returns> </returns>\n\t\t\t\tint WhereIsThisIndex(int index) {\n\t\t\t\t\tif (index == 0) return IN_START;\n\t\t\t\t\tif (index < LeftDigit.Measure) return IN_MIDDLE_OF_LEFT;\n\t\t\t\t\tif (index == LeftDigit.Measure) return DeepTree.Measure == 0 ? IN_START_OF_RIGHT : IN_START_OF_DEEP;\n\t\t\t\t\tif (index < LeftDigit.Measure + DeepTree.Measure) return IN_MIDDLE_OF_DEEP;\n\t\t\t\t\tif (index == LeftDigit.Measure + DeepTree.Measure) return IN_START_OF_RIGHT;\n\t\t\t\t\tif (index < Measure) return IN_MIDDLE_OF_RIGHT;\n\t\t\t\t\tif (index == Measure) return IN_END;\n\t\t\t\t\treturn OUTSIDE;\n\t\t\t\t}\n\n\t\t\t\tpublic override FingerTreeElement GetChild(int index) {\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\treturn LeftDigit;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\treturn DeepTree;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn RightDigit;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tabstract partial class FTree<TChild> where TChild : Measured<TChild>, new() {\n\t\t\t//Calling a constructor on a generic type is a very expensive operation!\t\t\t\n\t\t\t/// <summary>\n\t\t\t///     Used as a sort of hack because generic types can't have static methods.\n\t\t\t///     Basically, used to call ConstructTop and ConstructThis.\n\t\t\t/// </summary>\n\t\t\tstatic readonly TChild ExampleChild = new TChild();\n\n\t\t\tinternal sealed partial class Digit : Measured<Digit> {\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_END = 8;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_MIDDLE_OF_1 = 1;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_MIDDLE_OF_2 = 3;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_MIDDLE_OF_3 = 5;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_MIDDLE_OF_4 = 7;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_START = 0;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_START_OF_2 = 2;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_START_OF_3 = 4;\n\n\t\t\t\tconst int\n\t\t\t\t\tIN_START_OF_4 = 6;\n\n\t\t\t\tconst int\n\t\t\t\t\tOUTSIDE = 9;\n\n\t\t\t\tpublic TChild First;\n\t\t\t\tpublic TChild Fourth;\n\t\t\t\tpublic TChild Second;\n\t\t\t\tpublic int Size;\n\t\t\t\tpublic TChild Third;\n\n\t\t\t\tpublic Digit(TChild one, Lineage lineage)\n\t\t\t\t\t: base(one.Measure, lineage, 1, ExampleChild.Nesting + 1) {\n#if ASSERTS\n\n\t\t\t\t\tone.AssertNotNull();\n\t\t\t\t\tone.IsFragment.AssertFalse();\n#endif\n\t\t\t\t\tFirst = one;\n\t\t\t\t\tSize = 1;\n\t\t\t\t}\n\n\t\t\t\tpublic Digit(TChild one, TChild two, Lineage lineage)\n\t\t\t\t\t: base(one.Measure + two.Measure, lineage, 2, ExampleChild.Nesting + 1) {\n#if ASSERTS\n\n\t\t\t\t\tone.AssertNotNull();\n\t\t\t\t\ttwo.AssertNotNull();\n\t\t\t\t\tnew[]{two.IsFragment}.Any(x => x).AssertFalse(); //one can be a fragment as a hack used as part of RemoveAt\n#endif\n\t\t\t\t\tFirst = one;\n\t\t\t\t\tSecond = two;\n\t\t\t\t\tSize = 2;\n\t\t\t\t}\n\n\t\t\t\tpublic Digit(TChild one, TChild two, TChild three, Lineage lineage)\n\t\t\t\t\t: base(one.Measure + two.Measure + three.Measure, lineage, 3, ExampleChild.Nesting + 1) {\n#if ASSERTS\n\t\t\t\t\tAssertEx.AssertAreNotNull(one, two, three);\n\t\t\t\t\tnew[] { one.IsFragment, two.IsFragment, three.IsFragment }.Any(x => x).AssertFalse();\n#endif\n\n\t\t\t\t\tFirst = one;\n\t\t\t\t\tSecond = two;\n\t\t\t\t\tThird = three;\n\t\t\t\t\tSize = 3;\n\t\t\t\t}\n\n\t\t\t\tpublic Digit(TChild one, TChild two, TChild three, TChild four, Lineage lineage)\n\t\t\t\t\t: base(one.Measure + two.Measure + three.Measure + four.Measure, lineage, 4, ExampleChild.Nesting + 1) {\n\n\t\t\t\t\tAssertEx.AssertAreNotNull(one, two, three, four);\n\t\t\t\t\tAssertEx.AssertFalse(new[] { one.IsFragment, two.IsFragment, three.IsFragment, four.IsFragment }.Any(x => x));\n\t\t\t\t\n\n\t\t\t\t\tFirst = one;\n\t\t\t\t\tSecond = two;\n\t\t\t\t\tThird = three;\n\t\t\t\t\tFourth = four;\n\t\t\t\t\tSize = 4;\n\t\t\t\t}\n\n\t\t\t\tpublic Digit()\n\t\t\t\t\t: base(0, Lineage.Immutable, 0, ExampleChild.Nesting + 1) {}\n\n\t\t\t\tpublic override Leaf<TValue> this[int index] {\n\t\t\t\t\tget {\n#if ASSERTS\n\t\t\t\t\t\tindex.AssertEqual(i => i < Measure);\n#endif\n\t\t\t\t\t\tvar m1 = First.Measure;\n\t\t\t\t\t\tif (index < m1) return First[index];\n\t\t\t\t\t\tvar m2 = Second.Measure + m1;\n\t\t\t\t\t\tif (index < m2) return Second[index - m1];\n\t\t\t\t\t\tvar m3 = m2 + Third.Measure;\n\t\t\t\t\t\tif (index < m3) return Third[index - m2];\n\t\t\t\t\t\treturn Fourth[index - m3];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/// <summary>\n\t\t\t\t///     Returns if the digit size is 1. Digit sizes of 1 cannot appear deep in the finger tree.\n\t\t\t\t/// </summary>\n\t\t\t\tpublic override bool IsFragment {\n\t\t\t\t\tget { return Size == 1; }\n\t\t\t\t}\n\n\t\t\t\tpublic TChild Left {\n\t\t\t\t\tget { return First; }\n\t\t\t\t}\n\n\t\t\t\tpublic TChild Right {\n\t\t\t\t\tget {\n\t\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\treturn First;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\treturn Second;\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\treturn Third;\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\treturn Fourth;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tpublic Digit ConstructMult(TValue[] arr, ref int index, int mult, Lineage lin) {\n\t\t\t\t\tvar c = ExampleChild;\n\t\t\t\t\tswitch (mult) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\treturn new Digit(c.Construct3(arr, ref index, lin), lin);\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn new Digit(c.Construct3(arr, ref index, lin), c.Construct3(arr, ref index, lin), lin);\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\treturn new Digit(c.Construct3(arr, ref index, lin), c.Construct3(arr, ref index, lin),\n\t\t\t\t\t\t\t\tc.Construct3(arr, ref index, lin), lin);\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\treturn new Digit(c.Construct3(arr, ref index, lin), c.Construct3(arr, ref index, lin),\n\t\t\t\t\t\t\t\tc.Construct3(arr, ref index, lin), c.Construct3(arr, ref index, lin), lin);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Bad_digit_size(mult);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic override string Print() {\n\t\t\t\t\tstring[] rest;\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\trest = new[] { First.Print() };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\trest = new[] { First.Print(), Second.Print() };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\trest = new[] { First.Print(), Second.Print(), Third.Print() };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\trest = new[] { First.Print(), Second.Print(), Third.Print(), Fourth.Print() };\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t\t}\n\t\t\t\t\tvar joined = String.Join(\", \", rest);\n\t\t\t\t\treturn Measure == Size ? Measure.ToString() : string.Format(\"{2} {0}: ({1})\", Size, Measure, joined);\n\t\t\t\t}\n\n\t\t\t\tpublic override Digit Construct3(TValue[] arr, ref int index, Lineage lin) {\n\t\t\t\t\tvar child = ExampleChild;\n\t\t\t\t\treturn new Digit(child.Construct3(arr, ref index, lin), child.Construct3(arr, ref index, lin),\n\t\t\t\t\t\tchild.Construct3(arr, ref index, lin), lin);\n\t\t\t\t}\n\n\n\n\t\t\t\tpublic override FingerTreeElement GetChild(int index) {\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\treturn First;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\treturn Second;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn Third;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\treturn Fourth;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t//This method is used when we don't know the exact size of the digit we want to create.\n\t\t\t\tpublic Digit CreateCheckNull(Lineage lineage, TChild item1 = null, TChild item2 = null, TChild item3 = null,\n\t\t\t\t\tTChild item4 = null) {\n\t\t\t\t\tvar itemsPresent = item1 != null ? 1 : 0;\n\t\t\t\t\titemsPresent |= item2 != null ? 2 : 0;\n\t\t\t\t\titemsPresent |= item3 != null ? 4 : 0;\n\t\t\t\t\titemsPresent |= item4 != null ? 8 : 0;\n\t\t\t\t\tDigit res;\n\t\t\t\t\tswitch (itemsPresent) {\n\t\t\t\t\t\tcase 0 << 0 | 0 << 1 | 0 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 0 << 1 |  0 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0 << 0 | 1 << 1 | 0 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item2, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0 << 0 | 0 << 1 | 1 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item3, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0 << 0 | 0 << 1 | 0 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 1 << 1 | 0 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, item2, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 1 << 1 | 1 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, item2, item3, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 1 << 1 | 1 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, item2, item3, item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0 << 0 | 1 << 1 | 1 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item2, item3, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0 << 0 | 1 << 1 | 1 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item2, item3, item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0 << 0 | 0 << 1 | 1 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item3, item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 0 << 1 | 1 << 2 | 0 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, item3, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 0 << 1 | 1 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, item3, item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 0 << 0 | 1 << 1 | 0 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item2, item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 0 << 1 | 0 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1 << 0 | 1 << 1 | 0 << 2 | 1 << 3:\n\t\t\t\t\t\t\tres = MutateOrCreate(item1, item2, item4, lineage);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all digit permutations already.\");\n\t\t\t\t\t}\n\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\n\t\t\t\tpublic void Fuse(Digit other, out Digit leftmost, out Digit middle, out Digit rightmost, Lineage lineage) {\n#if ASSERTS\n\t\t\t\t\tother.AssertNotNull();\n#endif\n\t\t\t\t\tvar match = (Size << 3) | other.Size;\n\n\t\t\t\t\tswitch (match) {\n\t\t\t\t\t\tcase 1 << 3 | 1:\n\t\t\t\t\t\t\tleftmost = MutateOrCreate(First, other.First, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\tmiddle = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 1 << 3 | 2:\n\t\t\t\t\t\t\tleftmost = MutateOrCreate(First, other.First, other.Second, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\tmiddle = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 1 << 3 | 3:\n\t\t\t\t\t\t\tleftmost = MutateOrCreate(First, other.First, other.Second, other.Third, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\tmiddle = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 1 << 3 | 4:\n\t\t\t\t\t\t\tleftmost = new Digit(First, other.First, lineage);\n\t\t\t\t\t\t\tmiddle = MutateOrCreate(other.Second, other.Third, other.Fourth, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 2 << 3 | 1:\n\t\t\t\t\t\t\tleftmost = MutateOrCreate(First, Second, other.First, lineage);\n\t\t\t\t\t\t\tmiddle = null;\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 2 << 3 | 2:\n\t\t\t\t\t\tcase 2 << 3 | 3:\n\t\t\t\t\t\tcase 3 << 3 | 2:\n\t\t\t\t\t\tcase 3 << 3 | 3:\n\t\t\t\t\t\t\tleftmost = this;\n\t\t\t\t\t\t\tmiddle = other;\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 2 << 3 | 4:\n\t\t\t\t\t\t\tleftmost = new Digit(First, Second, other.First, lineage);\n\t\t\t\t\t\t\tmiddle = MutateOrCreate(other.Second, other.Third, other.Fourth, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 3 << 3 | 4:\n\t\t\t\t\t\t\tleftmost = this;\n\t\t\t\t\t\t\tmiddle = new Digit(other.First, other.Second, lineage);\n\t\t\t\t\t\t\trightmost = other.MutateOrCreate(other.Third, other.Fourth, lineage);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 3 << 3 | 1:\n\t\t\t\t\t\t\tleftmost = new Digit(First, Second, lineage);\n\t\t\t\t\t\t\tmiddle = MutateOrCreate(Third, other.First, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 4 << 3 | 1:\n\t\t\t\t\t\t\tleftmost = new Digit(First, Second, lineage);\n\t\t\t\t\t\t\tmiddle = MutateOrCreate(Third, Fourth, other.First, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 4 << 3 | 2:\n\t\t\t\t\t\tcase 4 << 3 | 3:\n\t\t\t\t\t\t\tleftmost = new Digit(First, Second, lineage);\n\t\t\t\t\t\t\tmiddle = MutateOrCreate(Third, Fourth, lineage);\n\t\t\t\t\t\t\trightmost = other;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 4 << 3 | 4:\n\t\t\t\t\t\t\tleftmost = new Digit(First, Second, Third, lineage);\n\t\t\t\t\t\t\tmiddle = new Digit(Fourth, other.First, other.Second, lineage);\n\t\t\t\t\t\t\trightmost = other.MutateOrCreate(other.Third, other.Fourth, lineage);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all possible size permutations already.\");\n\t\t\t\t\t}\n\t\t\t\t\t//we should've handled all the cases in the Switch statement. Otherwise, produce this error.\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t/// <summary>\n\t\t\t\t///     This method will re-initialize the current instance with the specified parameters by mutation.\n\t\t\t\t/// </summary>\n\t\t\t\tpublic Digit _mutate(int measure, int size, TChild a, TChild b = null, TChild c = null, TChild d = null) {\n#if ASSERTS\n\t\t\t\t\tvar all = new[] { a, b, c, d };\n\t\t\t\t\tvar notNull = all.Where(x => x != null).ToArray();\n\t\t\t\t\tif (notNull.Length != 2) {\n\t\t\t\t\t\t//a hack allows one of the inner elements to be fragments...\n\t\t\t\t\t\tnotNull.All(x => !x.IsFragment).AssertTrue();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tnotNull[1].IsFragment.AssertFalse(); //this only applies to the 1st element!\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tnotNull.Count().AssertEqual(size);\n\t\t\t\t\tnotNull.Sum(x => x.Measure).AssertEqual(measure);\n\n#endif\n\t\t\t\t\tFirst = a;\n\t\t\t\t\tSecond = b;\n\t\t\t\t\tThird = c;\n\t\t\t\t\tFourth = d;\n\n\t\t\t\t\tMeasure = measure;\n\t\t\t\t\tSize = size;\n\t\t\t\t\tChildCount = size;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tprivate Digit MutateOrCreate(TChild a, Lineage lineage) {\n\t\t\t\t\treturn Lineage.AllowMutation(lineage) ? _mutate(a.Measure, 1, a) : new Digit(a, lineage);\n\t\t\t\t}\n\n\t\t\t\tprivate Digit MutateOrCreate(TChild a, TChild b, Lineage lineage) {\n\t\t\t\t\treturn Lineage.AllowMutation(lineage) ? _mutate(a.Measure + b.Measure, 2, a, b) : new Digit(a, b, lineage);\n\t\t\t\t}\n\n\t\t\t\tprivate Digit MutateOrCreate(TChild a, TChild b, TChild c, Lineage lineage) {\n\t\t\t\t\treturn Lineage.AllowMutation(lineage)\n\t\t\t\t\t\t? _mutate(a.Measure + b.Measure + c.Measure, 3, a, b, c) : new Digit(a, b, c, lineage);\n\t\t\t\t}\n\n\t\t\t\tprivate Digit MutateOrCreate(TChild a, TChild b, TChild c, TChild d, Lineage lineage) {\n\t\t\t\t\treturn Lineage.AllowMutation(lineage)\n\t\t\t\t\t\t? _mutate(a.Measure + b.Measure + c.Measure + d.Measure, 4, a, b, c, d) : new Digit(a, b, c, d, lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic Digit AddFirst(TChild item, Lineage lineage) {\n\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\treturn MutateOrCreate(item, First, lineage);\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(item, First, Second, lineage);\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\treturn MutateOrCreate(item, First, Second, Third, lineage);\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tthrow ImplErrors.Digit_too_large(Size);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t}\n\n\t\t\t\tpublic Digit AddLast(TChild item, Lineage lineage) {\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\treturn MutateOrCreate(First, item, lineage);\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(First, Second, item, lineage);\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\treturn MutateOrCreate(First, Second, Third, item, lineage);\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t}\n\n\t\t\t\tpublic override void Fuse(Digit other, out Digit first, out Digit last, Lineage lineage) {\n\t\t\t\t\tDigit skip;\n\t\t\t\t\tFuse(other, out first, out last, out skip, lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override void Insert(int index, Leaf<TValue> leaf, out Digit leftmost, out Digit rightmost, Lineage lineage) {\n#if ASSERTS\n\t\t\t\t\tleaf.AssertNotNull();\n#endif\n\n\t\t\t\t\tvar whereIsThisIndex = WhereIsThisIndex(index);\n\t\t\t\t\tTChild myLeftmost;\n\t\t\t\t\tTChild myRightmost;\n\t\t\t\t\tleftmost = null;\n\t\t\t\t\trightmost = null;\n\t\t\t\t\tswitch (whereIsThisIndex) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_1:\n\t\t\t\t\t\t\tFirst.Insert(index, leaf, out myLeftmost, out myRightmost, lineage);\n\t\t\t\t\t\t\tif (Size == 4 && myRightmost != null) {\n\n\t\t\t\t\t\t\t\tleftmost = new Digit(myLeftmost, myRightmost, Second, lineage);\n\t\t\t\t\t\t\t\trightmost = MutateOrCreate(Third, Fourth, lineage);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleftmost = myRightmost != null\n\t\t\t\t\t\t\t\t? CreateCheckNull(lineage, myLeftmost, myRightmost, Second, Third)\n\t\t\t\t\t\t\t\t: CreateCheckNull(lineage, myLeftmost, Second, Third, Fourth);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase IN_START_OF_2:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_2:\n\t\t\t\t\t\t\tSecond.Insert(index - First.Measure, leaf, out myLeftmost, out myRightmost, lineage);\n\t\t\t\t\t\t\tif (Size == 4 && myRightmost != null) {\n\t\t\t\t\t\t\t\tleftmost = new Digit(First, myLeftmost, myRightmost, lineage);\n\t\t\t\t\t\t\t\trightmost = MutateOrCreate(Third, Fourth, lineage);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleftmost = myRightmost != null\n\t\t\t\t\t\t\t\t? CreateCheckNull(lineage, First, myLeftmost, myRightmost, Third)\n\t\t\t\t\t\t\t\t: CreateCheckNull(lineage, First, myLeftmost, Third, Fourth);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase IN_START_OF_3:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_3:\n\t\t\t\t\t\t\tThird.Insert(index - First.Measure - Second.Measure, leaf, out myLeftmost, out myRightmost, lineage);\n\t\t\t\t\t\t\tif (Size == 4 && myRightmost != null) {\n\t\t\t\t\t\t\t\tleftmost = new Digit(First, Second, myLeftmost, lineage);\n\t\t\t\t\t\t\t\trightmost = MutateOrCreate(myRightmost, Fourth, lineage);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleftmost =\n\t\t\t\t\t\t\t\tmyRightmost != null\n\t\t\t\t\t\t\t\t\t? CreateCheckNull(lineage, First, Second, myLeftmost, myRightmost)\n\t\t\t\t\t\t\t\t\t: CreateCheckNull(lineage, First, Second, myLeftmost, Fourth);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase IN_START_OF_4:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_4:\n\t\t\t\t\t\t\tFourth.Insert(index - Measure + Fourth.Measure, leaf, out myLeftmost, out myRightmost, lineage);\n\t\t\t\t\t\t\tif (Size == 4 && myRightmost != null) {\n\t\t\t\t\t\t\t\tleftmost = new Digit(First, Second, Third, lineage);\n\t\t\t\t\t\t\t\trightmost = MutateOrCreate(myLeftmost, myRightmost, lineage);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tleftmost = MutateOrCreate(First, Second, Third, myLeftmost, lineage);\n\t\t\t\t\t\t\trightmost = null;\n\t\t\t\t\t\t\treturn;\t\t\t\t\t\t\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"\");\n\t\t\t\t\t}\n\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tpublic override void Iter(Action<Leaf<TValue>> action) {\n#if ASSERTS\n\t\t\t\t\taction.AssertNotNull();\n#endif\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tFirst.Iter(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tFirst.Iter(action);\n\t\t\t\t\t\t\tSecond.Iter(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tFirst.Iter(action);\n\t\t\t\t\t\t\tSecond.Iter(action);\n\t\t\t\t\t\t\tThird.Iter(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tFirst.Iter(action);\n\t\t\t\t\t\t\tSecond.Iter(action);\n\t\t\t\t\t\t\tThird.Iter(action);\n\t\t\t\t\t\t\tFourth.Iter(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all sizes already\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tpublic override void IterBack(Action<Leaf<TValue>> action) {\n#if ASSERTS\n\t\t\t\t\taction.AssertNotNull();\n#endif\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tFirst.IterBack(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tSecond.IterBack(action);\n\t\t\t\t\t\t\tFirst.IterBack(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\tThird.IterBack(action);\n\t\t\t\t\t\t\tSecond.IterBack(action);\n\t\t\t\t\t\t\tFirst.IterBack(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tFourth.IterBack(action);\n\t\t\t\t\t\t\tThird.IterBack(action);\n\t\t\t\t\t\t\tSecond.IterBack(action);\n\t\t\t\t\t\t\tFirst.IterBack(action);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all sizes already\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IterBackWhile(Func<Leaf<TValue>, bool> action) {\n#if ASSERTS\n\t\t\t\t\taction.AssertNotNull();\n#endif\n\t\t\t\t\tif (Fourth != null) if (!Fourth.IterBackWhile(action)) return false;\n\t\t\t\t\tif (Third != null) if (!Third.IterBackWhile(action)) return false;\n\t\t\t\t\tif (Second != null) if (!Second.IterBackWhile(action)) return false;\n\t\t\t\t\treturn First.IterBackWhile(action);\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IterWhile(Func<Leaf<TValue>, bool> action) {\n#if ASSERTS\n\t\t\t\t\taction.AssertNotNull();\n#endif\n\n\t\t\t\t\tif (!First.IterWhile(action)) return false;\n\t\t\t\t\tif (Second == null) return true;\n\t\t\t\t\tif (!Second.IterWhile(action)) return false;\n\t\t\t\t\tif (Third == null) return true;\n\t\t\t\t\tif (!Third.IterWhile(action)) return false;\n\t\t\t\t\tif (Fourth == null) return true;\n\t\t\t\t\treturn Fourth.IterWhile(action);\n\t\t\t\t}\n\n\t\t\t\tpublic Digit RemoveFirst(Lineage lineage) {\n\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tthrow ImplErrors.Digit_too_small(Size);\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(Second, lineage);\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\treturn MutateOrCreate(Second, Third, lineage);\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\treturn MutateOrCreate(Second, Third, Fourth, lineage);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t}\n\n\t\t\t\tpublic Digit RemoveLast(Lineage lineage) {\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(First, lineage);\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\treturn MutateOrCreate(First, Second, lineage);\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\treturn MutateOrCreate(First, Second, Third, lineage);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ImplErrors.Bad_digit_size(Size);\n\t\t\t\t}\n\n\t\t\t\tpublic override Digit Remove(int index, Lineage lineage) {\n\t\t\t\t\tvar whereIsThisIndex = WhereIsThisIndex(index);\n#if ASSERTS\n\t\t\t\t\tSize.AssertUnequal(1);\n#endif\n\t\t\t\t\tTChild res;\n\t\t\t\t\tswitch (whereIsThisIndex) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_1:\n\t\t\t\t\t\t\tres = First.Remove(index, lineage);\n\t\t\t\t\t\t\tif (res != null && res.IsFragment) {\n\t\t\t\t\t\t\t\tTChild left, right;\n\t\t\t\t\t\t\t\tres.Fuse(Second, out left, out right, lineage);\n\t\t\t\t\t\t\t\treturn CreateCheckNull(lineage, left, right, Third, Fourth);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, res, Second, Third, Fourth);\n\t\t\t\t\t\tcase IN_START_OF_2:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_2:\n\t\t\t\t\t\t\tres = Second.Remove(index - First.Measure, lineage);\n\t\t\t\t\t\t\tif (res != null && res.IsFragment) {\n\t\t\t\t\t\t\t\tTChild left, right;\n\t\t\t\t\t\t\t\tFirst.Fuse(res, out left, out right, lineage);\n\t\t\t\t\t\t\t\treturn CreateCheckNull(lineage, left, right, Third, Fourth);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, res, Third, Fourth);\n\t\t\t\t\t\tcase IN_START_OF_3:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_3:\n\t\t\t\t\t\t\tres = Third.Remove(index - First.Measure - Second.Measure, lineage);\n\t\t\t\t\t\t\tif (res != null && res.IsFragment) {\n\t\t\t\t\t\t\t\tTChild left, right;\n\t\t\t\t\t\t\t\tSecond.Fuse(res, out left, out right, lineage);\n\t\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, left, right, Fourth);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, Second, res, Fourth);\n\t\t\t\t\t\tcase IN_START_OF_4:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_4:\n\t\t\t\t\t\t\tres = Fourth.Remove(index - First.Measure - Second.Measure - Third.Measure, lineage);\n\t\t\t\t\t\t\tif (res != null && res.IsFragment) {\n\t\t\t\t\t\t\t\tTChild left, right;\n\t\t\t\t\t\t\t\tThird.Fuse(res, out left, out right, lineage);\n\t\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, Second, left, right);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, Second, Third, res);\n\t\t\t\t\t\tcase IN_END:\n\t\t\t\t\t\tcase OUTSIDE:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all index locations.\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic override Digit Reverse(Lineage lineage) {\n\n\t\t\t\t\tswitch (Size) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\treturn MutateOrCreate(First.Reverse(lineage), lineage);\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\treturn MutateOrCreate(Second.Reverse(lineage), First.Reverse(lineage), lineage);\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\treturn MutateOrCreate(Third.Reverse(lineage), Second.Reverse(lineage), First.Reverse(lineage), lineage);\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\treturn MutateOrCreate(Fourth.Reverse(lineage), Third.Reverse(lineage), Second.Reverse(lineage),\n\t\t\t\t\t\t\t\tFirst.Reverse(lineage), lineage);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all sizes\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tpublic void Split(int index, out Digit left, out TChild center, out Digit right,Lineage lineage) {\n\t\t\t\t\tswitch (WhereIsThisIndex(index)) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_1:\n\t\t\t\t\t\t\tleft = null;\n\t\t\t\t\t\t\tcenter = First;\n\t\t\t\t\t\t\tright = CreateCheckNull(lineage, Second, Third, Fourth);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_2:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_2:\n\t\t\t\t\t\t\tleft = new Digit(First, lineage);\n\t\t\t\t\t\t\tcenter = Second;\n\t\t\t\t\t\t\tright = CreateCheckNull(lineage, Third, Fourth);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_START_OF_3:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_3:\n\t\t\t\t\t\t\tleft = new Digit(First, Second, lineage);\n\t\t\t\t\t\t\tcenter = Third;\n\t\t\t\t\t\t\tright = CreateCheckNull(lineage, Fourth);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_MIDDLE_OF_4:\n\t\t\t\t\t\tcase IN_START_OF_4:\n\t\t\t\t\t\t\tleft =new Digit(First, Second, Third, lineage);\n\t\t\t\t\t\t\tcenter = Fourth;\n\t\t\t\t\t\t\tright = null;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase IN_END:\n\t\t\t\t\t\tcase OUTSIDE:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all index locations.\");\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic override Digit Update(int index, Leaf<TValue> leaf, Lineage lineage) {\n\t\t\t\t\tif (Lineage.AllowMutation(lineage)) return Update_MUTATES(index, leaf);\n#if ASSERTS\n\t\t\t\t\tleaf.AssertNotNull();\n#endif\n\t\t\t\t\tvar whereIsThisIndex = WhereIsThisIndex(index);\n\t\t\t\t\tTChild res;\n\t\t\t\t\tswitch (whereIsThisIndex) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_1:\n\t\t\t\t\t\t\tres = First.Update(index, leaf, lineage);\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, res, Second, Third, Fourth);\n\t\t\t\t\t\tcase IN_START_OF_2:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_2:\n\t\t\t\t\t\t\tres = Second.Update(index - First.Measure, leaf, lineage);\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, res, Third, Fourth);\n\t\t\t\t\t\tcase IN_START_OF_3:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_3:\n\t\t\t\t\t\t\tres = Third.Update(index - First.Measure - Second.Measure, leaf, lineage);\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, Second, res, Fourth);\n\t\t\t\t\t\tcase IN_START_OF_4:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_4:\n\t\t\t\t\t\t\tres = Fourth.Update(index - First.Measure - Second.Measure - Third.Measure, leaf, lineage);\n\t\t\t\t\t\t\treturn CreateCheckNull(lineage, First, Second, Third, res);\n\t\t\t\t\t\tcase IN_END:\n\t\t\t\t\t\tcase OUTSIDE:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all index locations.\");\n\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\tDigit Update_MUTATES(int index, Leaf<TValue> leaf) {\n\t\t\t\t\tvar whereIsThisIndex = WhereIsThisIndex(index);\n\n\t\t\t\t\tswitch (whereIsThisIndex) {\n\t\t\t\t\t\tcase IN_START:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_1:\n\t\t\t\t\t\t\tFirst = First.Update(index, leaf, Lineage);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\tcase IN_START_OF_2:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_2:\n\t\t\t\t\t\t\tSecond = Second.Update(index - First.Measure, leaf, Lineage);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\tcase IN_START_OF_3:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_3:\n\t\t\t\t\t\t\tThird = Third.Update(index - First.Measure - Second.Measure, leaf, Lineage);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\tcase IN_START_OF_4:\n\t\t\t\t\t\tcase IN_MIDDLE_OF_4:\n\t\t\t\t\t\t\tFourth = Fourth.Update(index - First.Measure - Second.Measure - Third.Measure, leaf, Lineage);\n\t\t\t\t\t\t\treturn this;\n\t\t\t\t\t\tcase IN_END:\n\t\t\t\t\t\tcase OUTSIDE:\n\t\t\t\t\t\t\tthrow ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all index locations already.\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t/// <summary>\n\t\t\t\t///     Returns a code telling where is the index located\n\t\t\t\t/// </summary>\n\t\t\t\t/// <param name=\"index\"> </param>\n\t\t\t\t/// <returns> </returns>\n\t\t\t\tint WhereIsThisIndex(int index) {\n#if ASSERTS\n\t\t\t\t\tindex.AssertEqual(i => i < Measure);\n#endif\n\t\t\t\t\tvar measure1 = First.Measure;\n\t\t\t\t\tif (index == 0) return IN_START;\n\t\t\t\t\tif (index < measure1) return IN_MIDDLE_OF_1;\n\t\t\t\t\tif (index == measure1) return IN_START_OF_2;\n\t\t\t\t\tvar measure2 = measure1 + Second.Measure;\n\t\t\t\t\tif (index < measure2) return IN_MIDDLE_OF_2;\n\t\t\t\t\tif (index == measure2) return IN_START_OF_3;\n\t\t\t\t\tvar measure3 = measure2 + Third.Measure;\n\t\t\t\t\tif (index < measure3) return IN_MIDDLE_OF_3;\n\t\t\t\t\tif (index == measure3) return IN_START_OF_4;\n\t\t\t\t\tvar measure4 = measure3 + Fourth.Measure;\n\t\t\t\t\tif (index < measure4) return IN_MIDDLE_OF_4;\n\t\t\t\t\tif (index == measure4) return IN_END;\n\t\t\t\t\tif (index > measure4) return OUTSIDE;\n\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all possible index locations\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tinternal abstract partial class FTree<TChild> where TChild : Measured<TChild>, new() {\n\t\t\tinternal sealed class EmptyTree : FTree<TChild> {\n\t\t\t\tpublic static readonly EmptyTree Instance = new EmptyTree();\n\n\t\t\t\tEmptyTree()\n\t\t\t\t\t: base(0, TreeType.Empty, Lineage.Immutable, 0) {}\n\n\t\t\t\tpublic override Leaf<TValue> this[int index] {\n\t\t\t\t\tget { throw ImplErrors.Invalid_invocation(\"Empty FingerTree\"); }\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IsFragment {\n\t\t\t\t\tget { throw ImplErrors.Invalid_invocation(\"Empty FingerTree\"); }\n\t\t\t\t}\n\n\t\t\t\tpublic override TChild Left {\n\t\t\t\t\tget { throw ImplErrors.Invalid_invocation(\"Empty FingerTree\");}\n\t\t\t\t}\n\n\t\t\t\tpublic override TChild Right {\n\t\t\t\t\tget { throw ImplErrors.Invalid_invocation(\"Empty FingerTree\"); }\n\t\t\t\t}\n\n\t\t\t\tpublic override string Print() {\n\t\t\t\t\treturn \"[[ - ]]\";\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> AddFirst(TChild item, Lineage lineage) {\n\t\t\t\t\treturn new Single(new Digit(item, lineage), lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> AddLast(TChild item, Lineage lineage) {\n\t\t\t\t\treturn new Single(new Digit(item, lineage), lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveFirst(Lineage lineage) {\n\t\t\t\t\tthrow ImplErrors.Invalid_invocation(\"Empty FingerTree\");\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveLast(Lineage lineage) {\n\t\t\t\t\tthrow ImplErrors.Invalid_invocation(\"Empty FingerTree\");\n\t\t\t\t}\n\n\t\t\t\tpublic override void Split(int index, out FTree<TChild> left, out TChild child, out FTree<TChild> right, Lineage lineage) {\n\t\t\t\t\tthrow ImplErrors.Invalid_invocation(\"Empty FingerTree\");\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> Insert(int index, Leaf<TValue> leaf, Lineage lineage) {\n\t\t\t\t\tthrow ImplErrors.Invalid_invocation(\"Empty FingerTree\");\n\t\t\t\t}\n\n\t\t\t\tpublic override void Iter(Action<Leaf<TValue>> action1) {}\n\n\t\t\t\tpublic override void IterBack(Action<Leaf<TValue>> action) {}\n\n\t\t\t\tpublic override bool IterBackWhile(Func<Leaf<TValue>, bool> func) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IterWhile(Func<Leaf<TValue>, bool> func) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveAt(int index, Lineage lineage) {\n\t\t\t\t\tthrow ImplErrors.Invalid_invocation(\"Empty FingerTree\");\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> Reverse(Lineage lineage) {\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\n\t\t\t\tpublic override FTree<TChild> Update(int index, Leaf<TValue> leaf, Lineage lineage) {\n\t\t\t\t\tthrow ImplErrors.Invalid_invocation(\"Empty FingerTree\");\n\t\t\t\t}\n\n\t\t\t\tpublic override FingerTreeElement GetChild(int index) {\n\t\t\t\t\tthrow ImplErrors.Invalid_invocation(\"Empty FingerTree\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinternal abstract partial class FTree<TChild> : FingerTreeElement where TChild : Measured<TChild>, new() {\n\t\t\tpublic static readonly FTree<TChild> Empty = EmptyTree.Instance;\n\t\t\tprivate readonly Lineage _lineage;\n\t\t\tprivate readonly int _kind;\n\t\t\tpublic int Measure;\n\n\t\t\tFTree(int measure, int kind, Lineage lineage, int groupings) : base(groupings) {\n\t\t\t\t_kind = kind;\n\t\t\t\tMeasure = measure;\n\t\t\t\t_lineage = lineage;\n\t\t\t}\n\n\t\t\tpublic abstract Leaf<TValue> this[int index] { get; }\n\n\t\t\tpublic abstract bool IsFragment { get; }\n\n\t\t\t//+ Implementation\n\t\t\t//  Extra performance may be squeezed out by transforming the Left and Right properties,\n\t\t\t//  Which get the left and right values of the FTree\n\t\t\t//  Into readonly fields, as outlined above.\n\n\t\t\tpublic abstract TChild Left { get; }\n\n\t\t\tpublic abstract TChild Right { get; }\n\n\t\t\tpublic bool IsEmpty\n\t\t\t{\n\t\t\t\tget { return Measure == 0; }\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t///     Constructs a finger tree from the specified array, consisting of the elements at [index..index+count)\n\t\t\t///     A lot faster than adding iteratively without lineages, and quite a bit faster than adding iteratively with\n\t\t\t///     lineages.\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"arr\">The arr.</param>\n\t\t\t/// <param name=\"index\">The index.</param>\n\t\t\t/// <param name=\"count\">The count.</param>\n\t\t\t/// <param name=\"lin\">The lineage.</param>\n\t\t\t/// <remarks>\n\t\t\t///\tRelated:  \n\t\t\t/// http://cs.stackexchange.com/questions/41081/guessing-the-structure-of-a-finger-tree-from-the-number-of-elements\n\t\t\t/// <br/>\n\t\t\t/// Algorithm: https://hackage.haskell.org/package/containers-0.4.0.0/docs/src/Data-Sequence.html#applicativeTree\n\t\t\t/// </remarks>\n\t\t\t/// <returns></returns>\n\t\t\tpublic static FTree<TChild> Construct(TValue[] arr, ref int index, int count, Lineage lin) {\n\t\t\t\tvar myChildSize = FastMath.PowN(3, Nesting - 1);\n\t\t\t\tvar divRem = count % myChildSize;\n\t\t\t\tFTree<TChild> ret;\n\t\t\t\tvar digit = ExampleDigit;\n\t\t\t\tint number;\n\t\t\t\tif (divRem == 0 && (number = count / myChildSize) <= 8) {\n\t\t\t\t\tswitch (number) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\treturn Empty;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tvar center = digit.ConstructMult(arr, ref index, number, lin);\n\t\t\t\t\t\t\tret = new Single(center, lin);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\tvar left1 = digit.Construct3(arr, ref index, lin);\n\t\t\t\t\t\t\tvar right1 = digit.ConstructMult(arr, ref index, 2, lin);\n\t\t\t\t\t\t\tret = new Compound(left1, FTree<Digit>.Empty, right1, lin);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 6:\n\t\t\t\t\t\t\tvar left2 = digit.Construct3(arr, ref index, lin);\n\t\t\t\t\t\t\tvar right2 = digit.Construct3(arr, ref index, lin);\n\t\t\t\t\t\t\tret = new Compound(left2, FTree<Digit>.Empty, right2, lin);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 7:\n\t\t\t\t\t\t\tvar left3 = digit.ConstructMult(arr, ref index, 4, lin);\n\t\t\t\t\t\t\tvar right3 = digit.Construct3(arr, ref index, lin);\n\t\t\t\t\t\t\tret = new Compound(left3, FTree<Digit>.Empty, right3, lin);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tvar left4 = digit.ConstructMult(arr, ref index, 4, lin);\n\t\t\t\t\t\t\tvar right4 = digit.ConstructMult(arr, ref index, 4, lin);\n\t\t\t\t\t\t\tret = new Compound(left4, FTree<Digit>.Empty, right4, lin);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"An if statement just checked if number <= 8.\");\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tvar nextChildSize = myChildSize * 3;\n\t\t\t\t\tvar nextDivRem = count % nextChildSize;\n#if ASSERTS\n\t\t\t\t\t//this is guaranteed by previous recursive calls to Construct. count must be divisible by myChildSize\n\t\t\t\t\t//and since nextChildSize = myChildSize * 3, then nextDivRem % myChildSize must be within [0,2].\n\t\t\t\t\t//we maintain this invariant by the next if-else block, which makes sure that the 'count' for the next invocation\n\t\t\t\t\t//really is divisible by nextChildSize. At the topmost level, myChildSize is 1, and nextChildSize is 3. \n\t\t\t\t\t\n\t\t\t\t\t(nextDivRem % myChildSize).AssertBetween(0, 2);\n#endif\n\t\t\t\t\tif (nextDivRem == 0) {\n\t\t\t\t\t\t//If nextDivRem is already divisible by nextChildSize, we should preserve this by removing 2*nextChildSize from it.\n\t\t\t\t\t\t//Since 2*nextChildSize = 0 (mod nextChildSize), the divisibility is preserved.\n\t\t\t\t\t\tvar left = digit.Construct3(arr, ref index, lin);\n\t\t\t\t\t\tvar deep = FTree<Digit>.Construct(arr, ref index, count - (nextChildSize << 1), lin);\n\t\t\t\t\t\tvar right = digit.Construct3(arr, ref index, lin);\n\t\t\t\t\t\tret = new Compound(left, deep, right, lin);\n\t\t\t\t\t} else if (nextDivRem == myChildSize) {\n\t\t\t\t\t\t//In this case, nextDivRem % myChildSize == 1. \n\t\t\t\t\t\t//In order to make sure 'count' is divisible by nextChildSize, we need to remove 1 myChildSize from it.\n\t\t\t\t\t\t//while also filling the current finger tree level. So we remove 7*myChildSize, which is \n\t\t\t\t\t\t//7*myChildSize = myChildSize + 2*nextChildSize = myChildSize (mod nextChildSize)\n\t\t\t\t\t\tvar left = digit.ConstructMult(arr, ref index, 4, lin);\n\t\t\t\t\t\tvar deep = FTree<Digit>.Construct(arr, ref index, count - ((nextChildSize << 1) + myChildSize), lin);\n\t\t\t\t\t\tvar right = digit.Construct3(arr, ref index, lin);\n\t\t\t\t\t\tret = new Compound(left, deep, right, lin);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//like the other cases.\n\t\t\t\t\t\tvar left = digit.ConstructMult(arr, ref index, 4, lin);\n\t\t\t\t\t\tvar deep = FTree<Digit>.Construct(arr, ref index, count - ((nextChildSize << 1) + (myChildSize << 1)), lin);\n\t\t\t\t\t\tvar right = digit.ConstructMult(arr, ref index, 4, lin);\n\t\t\t\t\t\tret = new Compound(left, deep, right, lin);\n\t\t\t\t\t}\n\t\t\t\t}\n#if ASSERTS\n\t\t\t\tret.Measure.AssertEqual(count);\n#endif\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t/// concatenates the two trees together. the supplied lineage cannot be shared by any of the trees, or the result will be corrupt!! <br/>\n\t\t\t/// However, you can reuse the lineage after calling this method.\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"first\">The first.</param>\n\t\t\t/// <param name=\"last\">The last.</param>\n\t\t\t/// <param name=\"lineage\">The lineage.</param>\n\t\t\t/// <returns></returns>\n\t\t\tpublic static FTree<TChild> Concat(FTree<TChild> first, FTree<TChild> last, Lineage lineage) {\n\t\t\t\tvar status = first._kind << 3 | last._kind;\n\t\t\t\tFTree<Digit> newDeep;\n\t\t\t\tswitch (status) {\n\t\t\t\t\t//+ Implementation\n\t\t\t\t\t//This should be farily legible. It is a solution I like to call a 'case table'\n\t\t\t\t\t//Note that TreeType is *not* an enum but a static class with constants.\n\t\t\t\t\t//This is because enums do not support the bitwise << operator.\n\n\t\t\t\t\t/* If either of the trees is empty*/\n\t\t\t\t\tcase TreeType.Empty << 3 | TreeType.Single:\n\t\t\t\t\tcase TreeType.Empty << 3 | TreeType.Compound:\n\t\t\t\t\t\treturn last;\n\t\t\t\t\tcase TreeType.Single << 3 | TreeType.Empty:\n\t\t\t\t\tcase TreeType.Compound << 3 | TreeType.Empty:\n\t\t\t\t\t\treturn first;\n\t\t\t\t\tcase TreeType.Empty << 3 | TreeType.Empty:\n\t\t\t\t\t\treturn first;\n\t\t\t\t\t/* If both are single... we just create a new Compound with their digits.*/\n\t\t\t\t\tcase TreeType.Single << 3 | TreeType.Single:\n\t\t\t\t\t\tvar single1 = (Single) first;\n\t\t\t\t\t\tvar single2 = (Single) last;\n\t\t\t\t\t\treturn new Compound(single1.CenterDigit, FTree<Digit>.Empty,\n\t\t\t\t\t\t\tsingle2.CenterDigit, lineage);\n\t\t\t\t\tcase TreeType.Single << 3 | TreeType.Compound:\n\t\t\t\t\t\tvar asSingle = (Single) first;\n\t\t\t\t\t\tvar asCompound = (Compound) last;\n\t\t\t\t\t\tDigit left, mid, right;\n\t\t\t\t\t\tasSingle.CenterDigit.Fuse(asCompound.LeftDigit, out left, out mid, out right, lineage);\n\t\t\t\t\t\tnewDeep = asCompound.DeepTree;\n\t\t\t\t\t\tif (right != null) {\n\t\t\t\t\t\t\tnewDeep = newDeep.AddFirst(right, lineage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (mid != null) {\n\t\t\t\t\t\t\tnewDeep = newDeep.AddFirst(mid, lineage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Compound(left, newDeep, asCompound.RightDigit, lineage);\n\t\t\t\t\t/* If one is single, we push the digit of the Compound into its Deep.*/\n\t\t\t\t\tcase TreeType.Compound << 3 | TreeType.Single:\n\t\t\t\t\t\tvar rightSingle = (Single) last;\n\t\t\t\t\t\tvar leftCompound = (Compound) first;\n\t\t\t\t\t\tDigit rLeft, rMid, rRight;\n\t\t\t\t\t\tleftCompound.RightDigit.Fuse(rightSingle.CenterDigit, out rLeft, out rMid, out rRight, lineage);\n\t\t\t\t\t\tDigit rDigit;\n\t\t\t\t\t\tnewDeep = leftCompound.DeepTree;\n\t\t\t\t\t\tif (rMid != null) {\n\t\t\t\t\t\t\tnewDeep = newDeep.AddLast(rLeft, lineage);\n\t\t\t\t\t\t\tif (rRight != null) {\n\t\t\t\t\t\t\t\tnewDeep = newDeep.AddLast(rMid, lineage);\n\t\t\t\t\t\t\t\trDigit = rRight;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\trDigit = rMid;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\trDigit = rLeft;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Compound(leftCompound.LeftDigit, newDeep, rDigit, lineage);\n\n\t\t\t\t\t/* This is the most complex case.\n\t\t\t\t * First note that when we have two Compounds, we essentially have two inner digits and two outer digits:\n\t\t\t\t *\t\tA..B ++ C..D => A..D\n\t\t\t\t *\tThe digits B C must somehow be pushed into the FTree, but the digits A D are going to be its left and right digits.\n\t\t\t\t *\tWhat we do with the digits B C is call the function ReformDigitsForConcat on the inner digits\n\t\t\t\t *\tBecause the law is that only digits with 2 or 3 elements can be pushed to become items in the deeper trees\n\t\t\t\t *\tWe need to reform the digits, whatever their current shape, into 2-3 digits.\n\t\t\t\t *\tLook up the function to see how it's done.\n\t\t\t\t */\n\t\t\t\t\tcase TreeType.Compound << 3 | TreeType.Compound:\n\t\t\t\t\t\tDigit leftmost;\n\t\t\t\t\t\tDigit middle;\n\t\t\t\t\t\tDigit rightmost;\n\t\t\t\t\t\tvar compound1 = (Compound) first;\n\t\t\t\t\t\tvar compound2 = (Compound) last;\n\t\t\t\t\t\tvar innerLeft = compound1.RightDigit;\n\t\t\t\t\t\tvar innerRight = compound2.LeftDigit;\n\t\t\t\t\t\tinnerLeft.Fuse(innerRight, out leftmost, out middle, out rightmost, lineage);\n\t\t\t\t\t\tFTree<Digit> deep;\n\t\t\t\t\t\tif (compound1.Measure > compound2.Measure)\n\t\t\t\t\t\t\t//We want to push the small tree into the large one. \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeep = compound1.DeepTree;\n\t\t\t\t\t\t\tif (leftmost != null) deep = deep.AddLast(leftmost, lineage);\n\t\t\t\t\t\t\tif (middle != null) deep = deep.AddLast(middle, lineage);\n\t\t\t\t\t\t\tif (rightmost != null) deep = deep.AddLast(rightmost, lineage);\n\t\t\t\t\t\t\tdeep = FTree<Digit>.Concat(deep, compound2.DeepTree, lineage);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdeep = compound2.DeepTree;\n\t\t\t\t\t\t\tif (rightmost != null) deep = deep.AddFirst(rightmost, lineage);\n\t\t\t\t\t\t\tif (middle != null) deep = deep.AddFirst(middle, lineage);\n\t\t\t\t\t\t\tif (leftmost != null) deep = deep.AddFirst(leftmost, lineage);\n\t\t\t\t\t\t\tdeep = FTree<Digit>.Concat(compound1.DeepTree, deep, lineage);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn new Compound(compound1.LeftDigit, deep, compound2.RightDigit, lineage);\n\t\t\t\t}\n\t\t\t\tthrow ImplErrors.Invalid_execution_path(\"Checked all permutations of finger tree concatenation.\");\n\t\t\t}\n\n\t\t\tpublic abstract string Print();\n\n\t\t\tpublic FTree<TChild> AddFirstList(FTree<TChild> list, Lineage lineage) {\n\t\t\t\treturn Concat(list, this, lineage);\n\t\t\t}\n\n\t\t\t/// <summary>\n\t\t\t///     Adds an item to the start (the left) of the finger tree..\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"item\">The item.</param>\n\t\t\t/// <param name=\"lineage\">The lineage.</param>\n\t\t\t/// <returns></returns>\n\t\t\tpublic abstract FTree<TChild> AddFirst(TChild item, Lineage lineage);\n\n\t\t\t/// <summary>\n\t\t\t///     Concats the specified ftree to the end of this one. If the lineage is shared by either of the trees, the result is corrupt!\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"list\">The list.</param>\n\t\t\t/// <param name=\"lineage\">The lineage.</param>\n\t\t\t/// <returns></returns>\n\t\t\tpublic FTree<TChild> AddLastList(FTree<TChild> list, Lineage lineage) {\n\t\t\t\treturn Concat(this, list, lineage);\n\t\t\t}\n\n\t\t\tpublic abstract FTree<TChild> AddLast(TChild item, Lineage lineage);\n\n\t\t\tpublic abstract FTree<TChild> RemoveFirst(Lineage lineage);\n\n\t\t\tpublic abstract FTree<TChild> RemoveLast(Lineage lineage);\n\n\t\t\tpublic abstract void Split(int index, out FTree<TChild> left, out TChild child, out FTree<TChild> right, Lineage lineage);\n\n\t\t\tpublic abstract FTree<TChild> Insert(int index, Leaf<TValue> leaf, Lineage lineage);\n\n\t\t\tpublic abstract void Iter(Action<Leaf<TValue>> action);\n\n\t\t\tpublic abstract void IterBack(Action<Leaf<TValue>> action);\n\n\t\t\tpublic abstract bool IterBackWhile(Func<Leaf<TValue>, bool> func);\n\n\t\t\tpublic abstract bool IterWhile(Func<Leaf<TValue>, bool> func);\n\n\t\t\t/// <summary>\n\t\t\t/// Splits the finger tree right before the specified index.\n\t\t\t/// </summary>\n\t\t\t/// <param name=\"index\">The index.</param>\n\t\t\t/// <param name=\"left\">The left.</param>\n\t\t\t/// <param name=\"right\">The right.</param>\n\t\t\t/// <param name=\"lineage\">The lineage.</param>\n\t\t\tpublic void Split(int index, out FTree<TChild> left, out FTree<TChild> right, Lineage lineage) {\n\t\t\t\tif (index == Measure) {\n\t\t\t\t\tleft = this;\n\t\t\t\t\tright = Empty;\n\t\t\t\t\treturn;\n\t\t\t\t}\n#if ASSERTS\n\t\t\t\tvar oldValue = this[index];\n\t\t\t\tvar oldFirst = Left;\n\t\t\t\tvar oldLast = Right;\n#endif\n\t\t\t\tTChild center;\n\t\t\t\tSplit(index, out left, out center, out right, lineage);\n\t\t\t\tright = right.AddFirst(center, lineage);\n#if ASSERTS\n\t\t\t\tcenter[0].AssertEqual(oldValue);\n\t\t\t\tif (left.Measure != 0) {\n\t\t\t\t\tleft.Left.AssertEqual(oldFirst);\n\t\t\t\t}\n\t\t\t\tif (right.Measure != 0) {\n\t\t\t\t\tright.Right.AssertEqual(oldLast);\n\t\t\t\t}\n#endif\n\t\t\t}\n\n\t\t\tpublic abstract FTree<TChild> RemoveAt(int index, Lineage lineage);\n\n\t\t\tpublic abstract FTree<TChild> Reverse(Lineage lineage);\n\n\t\t\tpublic abstract FTree<TChild> Update(int index, Leaf<TValue> leaf, Lineage lineage);\n\n\t\t\tstatic readonly Digit ExampleDigit = new Digit();\n\t\t\tpublic static int Nesting = ExampleDigit.Nesting;\n\t\t}\n\t\tinternal abstract partial class FTree<TChild> where TChild : Measured<TChild>, new() {\n\t\t\tprivate sealed class Single : FTree<TChild> {\n\t\t\t\tpublic Digit CenterDigit;\n\n\t\t\t\tpublic Single(Digit centerDigit, Lineage lineage)\n\t\t\t\t\t: base(centerDigit.Measure, TreeType.Single, lineage, 1) {\n\t\t\t\t\tCenterDigit = centerDigit;\n\t\t\t\t}\n\n\t\t\t\tpublic override Leaf<TValue> this[int index] {\n\t\t\t\t\tget {\n\t\t\t\t\t\tvar r = CenterDigit[index];\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IsFragment {\n\t\t\t\t\tget { return CenterDigit.IsFragment; }\n\t\t\t\t}\n\n\t\t\t\tpublic override TChild Left {\n\t\t\t\t\tget { return CenterDigit.Left; }\n\t\t\t\t}\n\n\t\t\t\tpublic override TChild Right {\n\t\t\t\t\tget { return CenterDigit.Right; }\n\t\t\t\t}\n\n\t\t\t\tpublic override string Print() {\n\t\t\t\t\treturn string.Format(\"[[{0}]]\", CenterDigit.Print());\n\t\t\t\t}\n\n\t\t\t\tFTree<TChild> _mutate(Digit digit) {\n\t\t\t\t\tCenterDigit = digit;\n\t\t\t\t\tMeasure = digit.Measure;\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\n\t\t\t\tprivate FTree<TChild> MutateOrCreate(Digit digit, Lineage lineage) {\n\t\t\t\t\treturn _lineage.AllowMutation(lineage) ? _mutate(digit) : new Single(digit, lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> AddFirst(TChild item, Lineage lineage) {\n\t\t\t\t\tFTree<TChild> ret;\n#if ASSERTS\n\t\t\t\t\tvar expected = Measure + item.Measure;\n#endif\n\t\t\t\t\tif (CenterDigit.Size < 4) ret = MutateOrCreate(CenterDigit.AddFirst(item, lineage), lineage);\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar leftmost = new Digit(item, CenterDigit.First, lineage);\n\t\t\t\t\t\tvar rightmost = CenterDigit.RemoveFirst(lineage);\n\t\t\t\t\t\tret = new Compound(leftmost, FTree<Digit>.Empty, rightmost, lineage);\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(expected);\n\t\t\t\t\tret.Left.AssertEqual(item);\n#endif\n\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> AddLast(TChild item, Lineage lineage) {\n#if ASSERTS\n\t\t\t\t\tvar expected = Measure + item.Measure;\n#endif\n\t\t\t\t\tFTree<TChild> ret;\n\t\t\t\t\tif (CenterDigit.Size < 4) ret = new Single(CenterDigit.AddLast(item, lineage), lineage);\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar rightmost = new Digit(CenterDigit.Fourth, item, lineage);\n\t\t\t\t\t\tvar leftmost = CenterDigit.RemoveLast(lineage);\n\n\t\t\t\t\t\tret = new Compound(leftmost, FTree<Digit>.Empty, rightmost, lineage);\n\t\t\t\t\t}\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(expected);\n\t\t\t\t\tret.Right.AssertEqual(item);\n#endif\n\t\t\t\t\treturn ret;\n\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveFirst(Lineage lineage) {\n\t\t\t\t\tFTree<TChild> ret;\n#if ASSERTS\n\t\t\t\t\tvar expected = Measure - Left.Measure;\n\t\t\t\t\tvar expectedFirst = Measure > 1 ? CenterDigit.Second : null;\n#endif\n\t\t\t\t\tif (CenterDigit.Size > 1) {\n\t\t\t\t\t\tvar newDigit = CenterDigit.RemoveFirst(lineage);\n\t\t\t\t\t\tret = MutateOrCreate(newDigit, lineage);\n\t\t\t\t\t} else ret = Empty;\n#if ASSERTS\n\t\t\t\t\tret.Measure.AssertEqual(expected);\n\t\t\t\t\tif (expectedFirst != null) ret.Left.AssertEqual(expectedFirst);\n#endif\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveLast(Lineage lineage) {\n\t\t\t\t\tif (CenterDigit.Size > 1) {\n\t\t\t\t\t\tvar newDigit = CenterDigit.RemoveLast(lineage);\n\t\t\t\t\t\treturn MutateOrCreate(newDigit, lineage);\n\t\t\t\t\t}\n\t\t\t\t\treturn Empty;\n\t\t\t\t}\n\n\t\t\t\tpublic override void Split(int index, out FTree<TChild> left, out TChild center, out FTree<TChild> right, Lineage lineage) {\n\t\t\t\t\tDigit leftDigit, rightDigit;\n\t\t\t\t\tCenterDigit.Split(index, out leftDigit, out center, out rightDigit, lineage);\n\t\t\t\t\tleft = leftDigit == null ? Empty : new Single(leftDigit, lineage);\n\t\t\t\t\tright = rightDigit == null ? Empty : new Single(rightDigit, lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> Insert(int index, Leaf<TValue> leaf, Lineage lineage) {\n\t\t\t\t\tDigit leftmost, rightmost;\n\t\t\t\t\tCenterDigit.Insert(index, leaf, out leftmost, out rightmost, lineage);\n\t\t\t\t\tif (rightmost == null) return MutateOrCreate(leftmost, lineage);\n\t\t\t\t\treturn new Compound(leftmost, FTree<Digit>.Empty, rightmost, lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override void Iter(Action<Leaf<TValue>> action) {\n\t\t\t\t\tCenterDigit.Iter(action);\n\t\t\t\t}\n\n\t\t\t\tpublic override void IterBack(Action<Leaf<TValue>> action) {\n\t\t\t\t\tCenterDigit.IterBack(action);\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IterBackWhile(Func<Leaf<TValue>, bool> func) {\n\t\t\t\t\treturn CenterDigit.IterBackWhile(func);\n\t\t\t\t}\n\n\t\t\t\tpublic override bool IterWhile(Func<Leaf<TValue>, bool> func) {\n\t\t\t\t\treturn CenterDigit.IterWhile(func);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> RemoveAt(int index, Lineage lineage) {\n\t\t\t\t\tif (CenterDigit.Measure == 1 && index == 0) return EmptyTree.Instance;\n#if ASSERTS\n\t\t\t\t\tCenterDigit.IsFragment.AssertEqual(false);\n#endif\n\n\t\t\t\t\tvar res = CenterDigit.Remove(index, lineage);\n\t\t\t\t\tif (res == null) return Empty;\n\t\t\t\t\treturn MutateOrCreate(res, lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> Reverse(Lineage lineage) {\n\t\t\t\t\treturn new Single(CenterDigit.Reverse(lineage), lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FTree<TChild> Update(int index, Leaf<TValue> leaf, Lineage lineage) {\n\t\t\t\t\treturn new Single(CenterDigit.Update(index, leaf, lineage), lineage);\n\t\t\t\t}\n\n\t\t\t\tpublic override FingerTreeElement GetChild(int index) {\n\t\t\t\t\tif (index != 0) throw ImplErrors.Arg_out_of_range(\"index\", index);\n\t\t\t\t\treturn CenterDigit;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tabstract partial class FTree<TChild> where TChild : Measured<TChild>, new() {\n\t\t\tprivate static class TreeType {\n\t\t\t\tpublic const int Compound = 3;\n\t\t\t\tpublic const int Empty = 1;\n\t\t\t\tpublic const int Single = 2;\n\t\t\t}\n\t\t}\n", "label": "MultifacetedAbstraction"}
{"text": "    internal static partial class LZMA\n    {\n        /* #define SHOW_STAT */\n        /* #define SHOW_STAT2 */\n        /* #define SHOW_DEBUG_INFO */\n        /* #define PROTOTYPE */\n\n        [System.Diagnostics.Conditional(\"SHOW_DEBUG_INFO\")]\n        internal static void DebugPrint(string format, params object[] args)\n        {\n#if BUILD_TESTING\n            System.Diagnostics.Debug.Write(String.Format(format, args));\n#endif\n        }\n\n        internal static void Print(string format, params object[] args)\n        {\n#if BUILD_TESTING\n            System.Diagnostics.Debug.Write(String.Format(format, args));\n#endif\n        }\n    }\n    partial class LZMA\n    {\n        internal class CMatchFinder\n        {\n            #region Constants\n\n            internal const int kEmptyHashValue = 0;\n            internal const uint kMaxValForNormalize = 0xFFFFFFFF;\n            internal const uint kNormalizeStepMin = 1u << 10; // it must be power of 2\n            internal const uint kNormalizeMask = ~(kNormalizeStepMin - 1u);\n            internal const uint kMaxHistorySize = (3u << 30);\n\n            internal const int kStartMaxLen = 3;\n\n            #endregion\n\n            #region Variables\n\n            public P<byte> mBuffer;\n            public uint mPos;\n            public uint mPosLimit;\n            public uint mStreamPos;\n            public uint mLenLimit;\n\n            public uint mCyclicBufferPos;\n            public uint mCyclicBufferSize; // it must be = (historySize + 1)\n\n            public uint mMatchMaxLen;\n            public uint[] mHash;\n            public P<uint> mSon;\n            public uint mHashMask;\n            public uint mCutValue;\n\n            public P<byte> mBufferBase;\n            public ISeqInStream mStream;\n            public bool mStreamEndWasReached;\n\n            public uint mBlockSize;\n            public uint mKeepSizeBefore;\n            public uint mKeepSizeAfter;\n\n            public uint mNumHashBytes;\n            public bool mDirectInput;\n            public long mDirectInputRem;\n            public bool mBtMode;\n            public bool mBigHash;\n            public uint mHistorySize;\n            public uint mFixedHashSize;\n            public uint mHashSizeSum;\n            public uint mNumSons;\n            public SRes mResult;\n\n            #endregion\n\n            internal CMatchFinder()\n            {\n                TR(\"MatchFinder_Construct\", 0);\n\n                mBufferBase = null;\n                mDirectInput = false;\n                mHash = null;\n                mCutValue = 32;\n                mBtMode = true;\n                mNumHashBytes = 4;\n                mBigHash = false;\n            }\n\n            internal bool MatchFinder_NeedMove()\n            {\n                if (mDirectInput)\n                    return false;\n\n                // if (p.streamEndWasReached) return false;\n                return mBufferBase + mBlockSize - mBuffer <= mKeepSizeAfter;\n            }\n\n            internal P<byte> MatchFinder_GetPointerToCurrentPos()\n            {\n                return mBuffer;\n            }\n\n            internal void MatchFinder_MoveBlock()\n            {\n                // Note: source and destination memory regions may overlap!\n                CUtils.memmove(mBufferBase, mBuffer - mKeepSizeBefore, mStreamPos - mPos + mKeepSizeBefore);\n                mBuffer = mBufferBase + mKeepSizeBefore;\n            }\n\n            internal void MatchFinder_ReadIfRequired()\n            {\n                if (!mStreamEndWasReached && mKeepSizeAfter >= mStreamPos - mPos)\n                    MatchFinder_ReadBlock();\n            }\n\n            private void LzInWindow_Free(ISzAlloc alloc)\n            {\n                if (!mDirectInput)\n                {\n                    alloc.FreeBytes(alloc, mBufferBase.mBuffer);\n                    mBufferBase = null;\n                }\n            }\n\n            // keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G)\n            private bool LzInWindow_Create(uint keepSizeReserv, ISzAlloc alloc)\n            {\n                uint blockSize = mKeepSizeBefore + mKeepSizeAfter + keepSizeReserv;\n\n                if (mDirectInput)\n                {\n                    mBlockSize = blockSize;\n                    return true;\n                }\n\n                if (mBufferBase == null || mBlockSize != blockSize)\n                {\n                    LzInWindow_Free(alloc);\n                    mBlockSize = blockSize;\n                    mBufferBase = alloc.AllocBytes(alloc, (long)blockSize);\n                }\n\n                return mBufferBase != null;\n            }\n\n            internal byte MatchFinder_GetIndexByte(int index)\n            {\n                return mBuffer[index];\n            }\n\n            internal uint MatchFinder_GetNumAvailableBytes()\n            {\n                return mStreamPos - mPos;\n            }\n\n            internal void MatchFinder_ReduceOffsets(uint subValue)\n            {\n                mPosLimit -= subValue;\n                mPos -= subValue;\n                mStreamPos -= subValue;\n            }\n\n            private void MatchFinder_ReadBlock()\n            {\n                if (mStreamEndWasReached || mResult != SZ_OK)\n                    return;\n\n                if (mDirectInput)\n                {\n                    uint curSize = 0xFFFFFFFF - mStreamPos;\n                    if (curSize > mDirectInputRem)\n                        curSize = (uint)mDirectInputRem;\n\n                    mDirectInputRem -= curSize;\n                    mStreamPos += curSize;\n                    if (mDirectInputRem == 0)\n                        mStreamEndWasReached = true;\n\n                    return;\n                }\n\n                for (;;)\n                {\n                    P<byte> dest = mBuffer + (mStreamPos - mPos);\n                    long size = mBufferBase + mBlockSize - dest;\n                    if (size == 0)\n                        return;\n\n                    mResult = mStream.Read(dest, ref size);\n                    if (mResult != SZ_OK)\n                        return;\n\n                    if (size == 0)\n                    {\n                        mStreamEndWasReached = true;\n                        return;\n                    }\n\n                    mStreamPos += (uint)size;\n                    if (mStreamPos - mPos > mKeepSizeAfter)\n                        return;\n                }\n            }\n\n            private void MatchFinder_CheckAndMoveAndRead()\n            {\n                if (MatchFinder_NeedMove())\n                    MatchFinder_MoveBlock();\n\n                MatchFinder_ReadBlock();\n            }\n\n            private void MatchFinder_FreeThisClassMemory(ISzAlloc alloc)\n            {\n                alloc.FreeUInt32(alloc, mHash);\n                mHash = null;\n            }\n\n            internal void MatchFinder_Free(ISzAlloc alloc)\n            {\n                MatchFinder_FreeThisClassMemory(alloc);\n                LzInWindow_Free(alloc);\n            }\n\n            private static uint[] AllocRefs(uint num, ISzAlloc alloc)\n            {\n                long sizeInBytes = (long)num * sizeof(uint);\n                if (sizeInBytes / sizeof(uint) != num)\n                    return null;\n\n                return alloc.AllocUInt32(alloc, num);\n            }\n\n            // Conditions:\n            //     historySize <= 3 GB\n            //     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB\n            internal bool MatchFinder_Create(uint historySize, uint keepAddBufferBefore, uint matchMaxLen, uint keepAddBufferAfter, ISzAlloc alloc)\n            {\n                if (historySize > kMaxHistorySize)\n                {\n                    MatchFinder_Free(alloc);\n                    return false;\n                }\n\n                uint sizeReserv = historySize >> 1;\n                if (historySize > ((uint)2 << 30))\n                    sizeReserv = historySize >> 2;\n                sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);\n\n                mKeepSizeBefore = historySize + keepAddBufferBefore + 1;\n                mKeepSizeAfter = matchMaxLen + keepAddBufferAfter;\n\n                // we need one additional byte, since we use MoveBlock after pos++ and before dictionary using\n                if (LzInWindow_Create(sizeReserv, alloc))\n                {\n                    uint newCyclicBufferSize = historySize + 1;\n                    uint hs;\n\n                    mMatchMaxLen = matchMaxLen;\n\n                    {\n                        mFixedHashSize = 0;\n\n                        if (mNumHashBytes == 2)\n                        {\n                            hs = (1 << 16) - 1;\n                        }\n                        else\n                        {\n                            hs = historySize - 1;\n                            hs |= (hs >> 1);\n                            hs |= (hs >> 2);\n                            hs |= (hs >> 4);\n                            hs |= (hs >> 8);\n                            hs >>= 1;\n                            hs |= 0xFFFF; // don't change it! It's required for Deflate\n                            if (hs > (1 << 24))\n                            {\n                                if (mNumHashBytes == 3)\n                                    hs = (1 << 24) - 1;\n                                else\n                                    hs >>= 1;\n                            }\n                        }\n\n                        mHashMask = hs;\n                        hs++;\n\n                        if (mNumHashBytes > 2)\n                            mFixedHashSize += kHash2Size;\n                        if (mNumHashBytes > 3)\n                            mFixedHashSize += kHash3Size;\n                        if (mNumHashBytes > 4)\n                            mFixedHashSize += kHash4Size;\n\n                        hs += mFixedHashSize;\n                    }\n\n                    {\n                        uint prevSize = mHashSizeSum + mNumSons;\n\n                        mHistorySize = historySize;\n                        mHashSizeSum = hs;\n                        mCyclicBufferSize = newCyclicBufferSize;\n                        mNumSons = (mBtMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);\n\n                        uint newSize = mHashSizeSum + mNumSons;\n                        if (mHash != null && prevSize == newSize)\n                            return true;\n\n                        MatchFinder_FreeThisClassMemory(alloc);\n\n                        mHash = AllocRefs(newSize, alloc);\n                        if (mHash != null)\n                        {\n                            mSon = P.From(mHash, mHashSizeSum);\n                            return true;\n                        }\n                    }\n                }\n\n                MatchFinder_Free(alloc);\n                return false;\n            }\n\n            private void MatchFinder_SetLimits()\n            {\n                uint limit = kMaxValForNormalize - mPos;\n                uint limit2 = mCyclicBufferSize - mCyclicBufferPos;\n                if (limit2 < limit)\n                    limit = limit2;\n                limit2 = mStreamPos - mPos;\n                if (limit2 <= mKeepSizeAfter)\n                {\n                    if (limit2 > 0)\n                        limit2 = 1;\n                }\n                else\n                {\n                    limit2 -= mKeepSizeAfter;\n                }\n                if (limit2 < limit)\n                    limit = limit2;\n                uint lenLimit = mStreamPos - mPos;\n                if (lenLimit > mMatchMaxLen)\n                    lenLimit = mMatchMaxLen;\n                mLenLimit = lenLimit;\n                mPosLimit = mPos + limit;\n            }\n\n            internal void MatchFinder_Init()\n            {\n                //for(uint i = 0; i < mHashSizeSum; i++)\n                //    mHash[i] = kEmptyHashValue;\n                Array.Clear(mHash, 0, (int)mHashSizeSum);\n\n                mCyclicBufferPos = 0;\n                mBuffer = mBufferBase;\n                mPos = mCyclicBufferSize;\n                mStreamPos = mCyclicBufferSize;\n                mResult = SZ_OK;\n                mStreamEndWasReached = false;\n                MatchFinder_ReadBlock();\n                MatchFinder_SetLimits();\n            }\n\n            private uint MatchFinder_GetSubValue()\n            {\n                return (mPos - mHistorySize - 1) & kNormalizeMask;\n            }\n\n            internal static void MatchFinder_Normalize3(uint subValue, P<uint> items, uint numItems)\n            {\n                for (uint i = 0; i < numItems; i++)\n                {\n                    uint value = items[i];\n                    if (value <= subValue)\n                        value = kEmptyHashValue;\n                    else\n                        value -= subValue;\n                    items[i] = value;\n                }\n            }\n\n            private void MatchFinder_Normalize()\n            {\n                uint subValue = MatchFinder_GetSubValue();\n                MatchFinder_Normalize3(subValue, mHash, mHashSizeSum + mNumSons);\n                MatchFinder_ReduceOffsets(subValue);\n            }\n\n            private void MatchFinder_CheckLimits()\n            {\n                if (mPos == kMaxValForNormalize)\n                    MatchFinder_Normalize();\n\n                if (!mStreamEndWasReached && mKeepSizeAfter == mStreamPos - mPos)\n                    MatchFinder_CheckAndMoveAndRead();\n\n                if (mCyclicBufferPos == mCyclicBufferSize)\n                    mCyclicBufferPos = 0;\n\n                MatchFinder_SetLimits();\n            }\n\n            private static P<uint> Hc_GetMatchesSpec(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue, P<uint> distances, uint maxLen)\n            {\n                son[_cyclicBufferPos] = curMatch;\n\n                for (;;)\n                {\n                    uint delta = pos - curMatch;\n                    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n                        return distances;\n\n                    P<byte> pb = cur - delta;\n                    curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];\n                    if (pb[maxLen] == cur[maxLen] && pb[0] == cur[0])\n                    {\n                        uint len = 0;\n                        while (++len != lenLimit)\n                            if (pb[len] != cur[len])\n                                break;\n\n                        if (maxLen < len)\n                        {\n                            distances[0] = maxLen = len;\n                            distances++;\n                            distances[0] = delta - 1;\n                            distances++;\n                            if (len == lenLimit)\n                                return distances;\n                        }\n                    }\n                }\n            }\n\n            internal static P<uint> GetMatchesSpec1(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue, P<uint> distances, uint maxLen)\n            {\n                P<uint> ptr0 = son + (_cyclicBufferPos << 1) + 1;\n                P<uint> ptr1 = son + (_cyclicBufferPos << 1);\n                uint len0 = 0;\n                uint len1 = 0;\n\n                for (;;)\n                {\n                    uint delta = pos - curMatch;\n                    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n                    {\n                        ptr0[0] = ptr1[0] = CMatchFinder.kEmptyHashValue;\n                        return distances;\n                    }\n\n                    P<uint> pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);\n                    P<byte> pb = cur - delta;\n                    uint len = (len0 < len1 ? len0 : len1);\n\n                    if (pb[len] == cur[len])\n                    {\n                        if (++len != lenLimit && pb[len] == cur[len])\n                            while (++len != lenLimit)\n                                if (pb[len] != cur[len])\n                                    break;\n\n                        if (maxLen < len)\n                        {\n                            distances[0] = maxLen = len;\n                            distances++;\n                            distances[0] = delta - 1;\n                            distances++;\n\n                            if (len == lenLimit)\n                            {\n                                ptr1[0] = pair[0];\n                                ptr0[0] = pair[1];\n                                return distances;\n                            }\n                        }\n                    }\n\n                    if (pb[len] < cur[len])\n                    {\n                        ptr1[0] = curMatch;\n                        ptr1 = pair + 1;\n                        curMatch = ptr1[0];\n                        len1 = len;\n                    }\n                    else\n                    {\n                        ptr0[0] = curMatch;\n                        ptr0 = pair;\n                        curMatch = ptr0[0];\n                        len0 = len;\n                    }\n                }\n            }\n\n            private static void SkipMatchesSpec(uint lenLimit, uint curMatch, uint pos, P<byte> cur, P<uint> son, uint _cyclicBufferPos, uint _cyclicBufferSize, uint cutValue)\n            {\n                P<uint> ptr0 = son + (_cyclicBufferPos << 1) + 1;\n                P<uint> ptr1 = son + (_cyclicBufferPos << 1);\n                uint len0 = 0;\n                uint len1 = 0;\n\n                for (;;)\n                {\n                    uint delta = pos - curMatch;\n                    if (cutValue-- == 0 || delta >= _cyclicBufferSize)\n                    {\n                        ptr0[0] = ptr1[0] = CMatchFinder.kEmptyHashValue;\n                        return;\n                    }\n\n                    P<uint> pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);\n                    P<byte> pb = cur - delta;\n                    uint len = (len0 < len1 ? len0 : len1);\n\n                    if (pb[len] == cur[len])\n                    {\n                        while (++len != lenLimit)\n                            if (pb[len] != cur[len])\n                                break;\n\n                        if (len == lenLimit)\n                        {\n                            ptr1[0] = pair[0];\n                            ptr0[0] = pair[1];\n                            return;\n                        }\n                    }\n\n                    if (pb[len] < cur[len])\n                    {\n                        ptr1[0] = curMatch;\n                        ptr1 = pair + 1;\n                        curMatch = ptr1[0];\n                        len1 = len;\n                    }\n                    else\n                    {\n                        ptr0[0] = curMatch;\n                        ptr0 = pair;\n                        curMatch = ptr0[0];\n                        len0 = len;\n                    }\n                }\n            }\n\n            private void MatchFinder_MovePos()\n            {\n                mCyclicBufferPos++;\n                mBuffer++;\n                mPos++;\n\n                if (mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n            }\n\n            internal uint Bt2_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 2)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n                uint hashValue = cur[0] | ((uint)cur[1] << 8);\n                uint curMatch = mHash[hashValue];\n                mHash[hashValue] = mPos;\n\n                uint offset = 0;\n                offset = (uint)(GetMatchesSpec1(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, 1) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n\n                if (++mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal uint Bt3_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 3)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;\n\n                uint delta2 = mPos - mHash[hash2Value];\n                uint curMatch = mHash[kFix3HashSize + hashValue];\n\n                mHash[hash2Value] = mPos;\n                mHash[kFix3HashSize + hashValue] = mPos;\n\n                uint maxLen = 2;\n                uint offset = 0;\n\n                if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])\n                {\n                    while (maxLen != lenLimit)\n                    {\n                        if (cur[maxLen - delta2] != cur[maxLen])\n                            break;\n\n                        maxLen++;\n                    }\n\n                    distances[0] = maxLen;\n                    distances[1] = delta2 - 1;\n                    offset = 2;\n\n                    if (maxLen == lenLimit)\n                    {\n                        SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                        mCyclicBufferPos++;\n                        mBuffer++;\n\n                        if (++mPos == mPosLimit)\n                            MatchFinder_CheckLimits();\n\n                        return offset;\n                    }\n                }\n\n                offset = (uint)(GetMatchesSpec1(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, maxLen) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n\n                if (++mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal uint Bt4_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 4)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                uint delta2 = mPos - mHash[hash2Value];\n                uint delta3 = mPos - mHash[kFix3HashSize + hash3Value];\n                uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                mHash[hash2Value] = mPos;\n                mHash[kFix3HashSize + hash3Value] = mPos;\n                mHash[kFix4HashSize + hashValue] = mPos;\n\n                uint maxLen = 1;\n                uint offset = 0;\n\n                if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])\n                {\n                    distances[0] = maxLen = 2;\n                    distances[1] = delta2 - 1;\n                    offset = 2;\n                }\n\n                if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])\n                {\n                    maxLen = 3;\n                    distances[offset + 1] = delta3 - 1;\n                    offset += 2;\n                    delta2 = delta3;\n                }\n\n                if (offset != 0)\n                {\n                    while (maxLen != lenLimit && cur[maxLen - delta2] == cur[maxLen])\n                        maxLen++;\n\n                    distances[offset - 2] = maxLen;\n\n                    if (maxLen == lenLimit)\n                    {\n                        SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n                        mCyclicBufferPos++;\n                        mBuffer++;\n\n                        if (++mPos == mPosLimit)\n                            MatchFinder_CheckLimits();\n\n                        return offset;\n                    }\n                }\n\n                if (maxLen < 3)\n                    maxLen = 3;\n\n                offset = (uint)(GetMatchesSpec1(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, maxLen) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n\n                if (++mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal uint Hc4_MatchFinder_GetMatches(P<uint> distances)\n            {\n                uint lenLimit = mLenLimit;\n                if (lenLimit < 4)\n                {\n                    MatchFinder_MovePos();\n                    return 0;\n                }\n\n                P<byte> cur = mBuffer;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                uint delta2 = mPos - mHash[hash2Value];\n                uint delta3 = mPos - mHash[kFix3HashSize + hash3Value];\n                uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                mHash[hash2Value] = mPos;\n                mHash[kFix3HashSize + hash3Value] = mPos;\n                mHash[kFix4HashSize + hashValue] = mPos;\n\n                uint maxLen = 1;\n                uint offset = 0;\n\n                if (delta2 < mCyclicBufferSize && cur[-delta2] == cur[0])\n                {\n                    TR(\"Hc4_MatchFinder_GetMatches:a1\", maxLen);\n                    TR(\"Hc4_MatchFinder_GetMatches:a2\", delta2);\n                    distances[0] = maxLen = 2;\n                    distances[1] = delta2 - 1;\n                    offset = 2;\n                }\n\n                if (delta2 != delta3 && delta3 < mCyclicBufferSize && cur[-delta3] == cur[0])\n                {\n                    TR(\"Hc4_MatchFinder_GetMatches:b1\", offset);\n                    TR(\"Hc4_MatchFinder_GetMatches:b2\", delta3);\n                    maxLen = 3;\n                    distances[offset + 1] = delta3 - 1;\n                    offset += 2;\n                    delta2 = delta3;\n                }\n\n                if (offset != 0)\n                {\n                    while (maxLen != lenLimit && cur[maxLen - delta2] == cur[maxLen])\n                        maxLen++;\n\n                    TR(\"Hc4_MatchFinder_GetMatches:c1\", offset);\n                    TR(\"Hc4_MatchFinder_GetMatches:c2\", maxLen);\n\n                    distances[offset - 2] = maxLen;\n\n                    if (maxLen == lenLimit)\n                    {\n                        TR(\"Hc4_MatchFinder_GetMatches:d\", curMatch);\n                        mSon[mCyclicBufferPos] = curMatch;\n                        mCyclicBufferPos++;\n                        mBuffer++;\n                        mPos++;\n                        if (mPos == mPosLimit)\n                            MatchFinder_CheckLimits();\n                        return offset;\n                    }\n                }\n\n                if (maxLen < 3)\n                    maxLen = 3;\n\n                offset = (uint)(Hc_GetMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue, distances + offset, maxLen) - distances);\n\n                mCyclicBufferPos++;\n                mBuffer++;\n                mPos++;\n\n                if (mPos == mPosLimit)\n                    MatchFinder_CheckLimits();\n\n                return offset;\n            }\n\n            internal void Bt2_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 2)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint hashValue = cur[0] | ((uint)cur[1] << 8);\n\n                    uint curMatch = mHash[hashValue];\n\n                    mHash[hashValue] = mPos;\n\n                    SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n\n            internal void Bt3_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 3)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint temp = cur[0].CRC() ^ cur[1];\n                    uint hash2Value = temp & (kHash2Size - 1);\n                    uint hashValue = (temp ^ ((uint)cur[2] << 8)) & mHashMask;\n\n                    uint curMatch = mHash[kFix3HashSize + hashValue];\n\n                    mHash[hash2Value] = mPos;\n                    mHash[kFix3HashSize + hashValue] = mPos;\n\n                    SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n\n            internal void Bt4_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 4)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint temp = cur[0].CRC() ^ cur[1];\n                    uint hash2Value = temp & (kHash2Size - 1);\n                    uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                    uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                    uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                    mHash[hash2Value] = mPos;\n                    mHash[kFix3HashSize + hash3Value] = mPos;\n                    mHash[kFix4HashSize + hashValue] = mPos;\n\n                    SkipMatchesSpec(lenLimit, curMatch, mPos, mBuffer, mSon, mCyclicBufferPos, mCyclicBufferSize, mCutValue);\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n\n            internal void Hc4_MatchFinder_Skip(uint num)\n            {\n                do\n                {\n                    uint lenLimit = mLenLimit;\n                    if (lenLimit < 4)\n                    {\n                        MatchFinder_MovePos();\n                        continue;\n                    }\n\n                    P<byte> cur = mBuffer;\n                    uint temp = cur[0].CRC() ^ cur[1];\n                    uint hash2Value = temp & (kHash2Size - 1);\n                    uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                    uint hashValue = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & mHashMask;\n\n                    uint curMatch = mHash[kFix4HashSize + hashValue];\n\n                    mHash[hash2Value] = mPos;\n                    mHash[kFix3HashSize + hash3Value] = mPos;\n                    mHash[kFix4HashSize + hashValue] = mPos;\n\n                    mSon[mCyclicBufferPos] = curMatch;\n\n                    mCyclicBufferPos++;\n                    mBuffer++;\n\n                    if (++mPos == mPosLimit)\n                        MatchFinder_CheckLimits();\n                }\n                while (--num != 0);\n            }\n        }\n\n        // Conditions:\n        //    GetNumAvailableBytes must be called before each GetMatchLen.\n        //    GetPointerToCurrentPos result must be used only before any other function\n\n        internal interface IMatchFinder\n        {\n            void Init(object p);\n            byte GetIndexByte(object p, Int32 index);\n            uint GetNumAvailableBytes(object p);\n            P<byte> GetPointerToCurrentPos(object p);\n            uint GetMatches(object p, P<uint> distances);\n            void Skip(object p, uint num);\n        }\n\n        internal static void MatchFinder_CreateVTable(CMatchFinder p, out IMatchFinder vTable)\n        {\n            TR(\"MatchFinder_CreateVTable\", p.mNumHashBytes);\n            if (!p.mBtMode)\n                vTable = new MatchFinderHc4();\n            else if (p.mNumHashBytes == 2)\n                vTable = new MatchFinderBt2();\n            else if (p.mNumHashBytes == 3)\n                vTable = new MatchFinderBt3();\n            else\n                vTable = new MatchFinderBt4();\n        }\n\n        private abstract class MatchFinderBase : IMatchFinder\n        {\n            public void Init(object p)\n            {\n                ((CMatchFinder)p).MatchFinder_Init();\n            }\n\n            public byte GetIndexByte(object p, int index)\n            {\n                return ((CMatchFinder)p).MatchFinder_GetIndexByte(index);\n            }\n\n            public uint GetNumAvailableBytes(object p)\n            {\n                return ((CMatchFinder)p).MatchFinder_GetNumAvailableBytes();\n            }\n\n            public P<byte> GetPointerToCurrentPos(object p)\n            {\n                return ((CMatchFinder)p).MatchFinder_GetPointerToCurrentPos();\n            }\n\n            public abstract uint GetMatches(object p, P<uint> distances);\n            public abstract void Skip(object p, uint num);\n        }\n\n        private sealed class MatchFinderHc4 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Hc4_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Hc4_MatchFinder_Skip(num);\n            }\n        }\n\n        private sealed class MatchFinderBt2 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Bt2_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Bt2_MatchFinder_Skip(num);\n            }\n        }\n\n        private sealed class MatchFinderBt3 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Bt3_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Bt3_MatchFinder_Skip(num);\n            }\n        }\n\n        private sealed class MatchFinderBt4 : MatchFinderBase\n        {\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return ((CMatchFinder)p).Bt4_MatchFinder_GetMatches(distances);\n            }\n\n            public override void Skip(object p, uint num)\n            {\n                ((CMatchFinder)p).Bt4_MatchFinder_Skip(num);\n            }\n        }\n    }\n    partial class LZMA\n    {\n        internal const int kMtHashBlockSize = (1 << 13);\n        internal const int kMtHashNumBlocks = (1 << 3);\n        internal const int kMtHashNumBlocksMask = (kMtHashNumBlocks - 1);\n\n        internal const int kMtBtBlockSize = (1 << 14);\n        internal const int kMtBtNumBlocks = (1 << 6);\n        internal const int kMtBtNumBlocksMask = (kMtBtNumBlocks - 1);\n\n        private const uint kMtMaxValForNormalize = 0xFFFFFFFF;\n        private const int kEmptyHashValue = 0;\n\n        private const int kHashBufferSize = (kMtHashBlockSize * kMtHashNumBlocks);\n        private const int kBtBufferSize = (kMtBtBlockSize * kMtBtNumBlocks);\n\n        internal sealed class CMtSync\n        {\n            #region Variables\n\n            internal bool mWasCreated;\n            internal bool mNeedStart;\n            internal bool mExit;\n            internal bool mStopWriting;\n\n            internal CThread mThread;\n            internal CEvent mCanStart;\n            internal CEvent mWasStarted;\n            internal CEvent mWasStopped;\n            internal CSemaphore mFreeSemaphore;\n            internal CSemaphore mFilledSemaphore;\n            internal bool mCsWasInitialized;\n            internal bool mCsWasEntered;\n            internal CCriticalSection mCS;\n            internal uint mNumProcessedBlocks;\n\n            #endregion\n\n            #region Methods\n\n            internal void MtSync_Construct()\n            {\n                mWasCreated = false;\n                mCsWasInitialized = false;\n                mCsWasEntered = false;\n                Thread_Construct(out mThread);\n                Event_Construct(out mCanStart);\n                Event_Construct(out mWasStarted);\n                Event_Construct(out mWasStopped);\n                Semaphore_Construct(out mFreeSemaphore);\n                Semaphore_Construct(out mFilledSemaphore);\n            }\n\n            internal void MtSync_GetNextBlock()\n            {\n                if (mNeedStart)\n                {\n                    mNumProcessedBlocks = 1;\n                    mNeedStart = false;\n\n                    Trace.MatchObjectWait(this, \"MtSync_GetNextBlock:start\");\n                    mStopWriting = false;\n                    Trace.MatchObjectWait(this, \"MtSync_GetNextBlock:start\");\n\n                    mExit = false;\n                    Event_Reset(mWasStarted);\n                    Event_Reset(mWasStopped);\n                    Event_Set(mCanStart);\n                    Event_Wait(mWasStarted);\n                }\n                else\n                {\n                    CriticalSection_Leave(mCS);\n                    mCsWasEntered = false;\n                    mNumProcessedBlocks++;\n                    Semaphore_Release1(mFreeSemaphore);\n                }\n                Semaphore_Wait(mFilledSemaphore);\n                CriticalSection_Enter(mCS);\n                mCsWasEntered = true;\n            }\n\n            /* MtSync_StopWriting must be called if Writing was started */\n\n            internal void MtSync_StopWriting()\n            {\n                uint myNumBlocks = mNumProcessedBlocks;\n                if (!Thread_WasCreated(mThread) || mNeedStart)\n                    return;\n\n                Trace.MatchObjectWait(this, \"MtSync_StopWriting:stop\");\n                mStopWriting = true;\n                Trace.MatchObjectWait(this, \"MtSync_StopWriting:stop\");\n\n                if (mCsWasEntered)\n                {\n                    CriticalSection_Leave(mCS);\n                    mCsWasEntered = false;\n                }\n\n                Semaphore_Release1(mFreeSemaphore);\n\n                Event_Wait(mWasStopped);\n\n                while (myNumBlocks++ != mNumProcessedBlocks)\n                {\n                    Semaphore_Wait(mFilledSemaphore);\n                    Semaphore_Release1(mFreeSemaphore);\n                }\n\n                mNeedStart = true;\n            }\n\n            internal void MtSync_Destruct()\n            {\n                if (Thread_WasCreated(mThread))\n                {\n                    MtSync_StopWriting();\n                    mExit = true;\n                    if (mNeedStart)\n                        Event_Set(mCanStart);\n                    Thread_Wait(mThread);\n                    Thread_Close(ref mThread);\n                }\n\n                if (mCsWasInitialized)\n                {\n                    CriticalSection_Delete(mCS);\n                    mCsWasInitialized = false;\n                }\n\n                Event_Close(ref mCanStart);\n                Event_Close(ref mWasStarted);\n                Event_Close(ref mWasStopped);\n                Semaphore_Close(ref mFreeSemaphore);\n                Semaphore_Close(ref mFilledSemaphore);\n\n                if (mWasCreated)\n                    Trace.MatchObjectDestroy(this, \"MtSync_Destruct\");\n\n                mWasCreated = false;\n            }\n\n            private SRes MtSync_Create2(Action startAddress, string threadName, uint numBlocks)\n            {\n                if (mWasCreated)\n                    return SZ_OK;\n\n                Trace.MatchObjectCreate(this, \"MtSync_Create2\");\n\n                if (CriticalSection_Init(out mCS) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                mCsWasInitialized = true;\n\n                if (AutoResetEvent_CreateNotSignaled(out mCanStart) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                if (AutoResetEvent_CreateNotSignaled(out mWasStarted) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                if (AutoResetEvent_CreateNotSignaled(out mWasStopped) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                if (Semaphore_Create(out mFreeSemaphore, numBlocks, numBlocks) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                if (Semaphore_Create(out mFilledSemaphore, 0, numBlocks) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                mNeedStart = true;\n\n                if (Thread_Create(out mThread, startAddress, threadName) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n                mWasCreated = true;\n\n                return SZ_OK;\n            }\n\n            internal SRes MtSync_Create(Action startAddress, string threadName, uint numBlocks)\n            {\n                SRes res = MtSync_Create2(startAddress, threadName, numBlocks);\n                if (res != SZ_OK)\n                    MtSync_Destruct();\n                return res;\n            }\n\n            #endregion\n        }\n\n        internal interface IMatchFinderMt : IMatchFinder\n        {\n            /* LZ */\n            P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances);\n\n            /* Hash */\n            void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads);\n        }\n\n        internal class CMatchFinderMt\n            : CMatchFinder /* Hash */\n        {\n            #region Variables\n\n            internal IMatchFinderMt mInterface;\n\n            /* LZ */\n            internal P<byte> mPointerToCurPos;\n            internal P<uint> mBtBuf;\n            internal uint mBtBufPos;\n            internal uint mBtBufPosLimit;\n            internal uint mLzPos;\n            internal uint mBtNumAvailBytes;\n\n            internal uint[] mLocalHash;\n            internal uint mLocalFixedHashSize;\n            internal uint mLocalHistorySize;\n\n            /* LZ + BT */\n            internal CMtSync mBtSync = new CMtSync();\n\n            /* BT */\n            internal uint[] mHashBuf;\n            internal uint mHashBufPos;\n            internal uint mHashBufPosLimit;\n            internal uint mHashNumAvail;\n\n            internal P<uint> mLocalSon;\n            internal uint mLocalMatchMaxLen;\n            internal uint mLocalNumHashBytes;\n            internal uint mLocalPos;\n            internal P<byte> mLocalBuffer;\n            internal uint mLocalCyclicBufferPos;\n            internal uint mLocalCyclicBufferSize; // it must be historySize + 1\n            internal uint mLocalCutValue;\n\n            /* BT + Hash */\n            internal CMtSync mHashSync = new CMtSync();\n\n            #endregion\n\n            #region Methods\n\n            internal CMatchFinderMt()\n            {\n                TR(\"MatchFinderMt_Construct\", 0);\n\n                mHashBuf = null;\n                mHashSync.MtSync_Construct();\n                mBtSync.MtSync_Construct();\n            }\n\n            internal void MatchFinderMt_GetNextBlock_Hash()\n            {\n                mHashSync.MtSync_GetNextBlock();\n                mHashBufPosLimit = mHashBufPos = ((mHashSync.mNumProcessedBlocks - 1) & kMtHashNumBlocksMask) * kMtHashBlockSize;\n                mHashBufPosLimit += mHashBuf[mHashBufPos++];\n                mHashNumAvail = mHashBuf[mHashBufPos++];\n            }\n\n            internal void MatchFinderMt_Destruct(ISzAlloc alloc)\n            {\n                mHashSync.MtSync_Destruct();\n                mBtSync.MtSync_Destruct();\n                alloc.FreeUInt32(alloc, mHashBuf);\n                mHashBuf = null;\n            }\n\n            /* ReleaseStream is required to finish multithreading */\n            internal void MatchFinderMt_ReleaseStream()\n            {\n                mBtSync.MtSync_StopWriting();\n            }\n\n            #endregion\n\n            private void MatchFinderMt_Normalize()\n            {\n                CMatchFinder.MatchFinder_Normalize3(mLzPos - mLocalHistorySize - 1, mLocalHash, mLocalFixedHashSize);\n                mLzPos = mLocalHistorySize + 1;\n            }\n\n            internal void MatchFinderMt_GetNextBlock_Bt()\n            {\n                mBtSync.MtSync_GetNextBlock();\n                uint blockIndex = (mBtSync.mNumProcessedBlocks - 1) & kMtBtNumBlocksMask;\n                mBtBufPos = blockIndex * kMtBtBlockSize;\n                mBtBufPosLimit = mBtBufPos;\n                mBtBufPosLimit += mBtBuf[mBtBufPos++];\n                mBtNumAvailBytes = mBtBuf[mBtBufPos++];\n                if (mLzPos >= kMtMaxValForNormalize - kMtBtBlockSize)\n                    MatchFinderMt_Normalize();\n            }\n\n            internal P<byte> MatchFinderMt_GetPointerToCurrentPos()\n            {\n                return mPointerToCurPos;\n            }\n\n            internal uint MatchFinderMt_GetNumAvailableBytes()\n            {\n                TR(\"MatchFinderMt_GetNumAvailableBytes\", mBtBufPos);\n                if (mBtBufPos == mBtBufPosLimit)\n                    MatchFinderMt_GetNextBlock_Bt();\n\n                TR(\"MatchFinderMt_GetNumAvailableBytes\", mBtNumAvailBytes);\n                return mBtNumAvailBytes;\n            }\n\n            internal byte MatchFinderMt_GetIndexByte(int index)\n            {\n                return mPointerToCurPos[index];\n            }\n\n            #region More Methods. Not sure if the are right in this class.\n\n            internal void HashThreadFunc()\n            {\n                CMtSync p = mHashSync;\n                for (;;)\n                {\n                    uint numProcessedBlocks = 0;\n                    Event_Wait(p.mCanStart);\n                    Event_Set(p.mWasStarted);\n                    for (;;)\n                    {\n                        if (p.mExit)\n                            return;\n\n                        Trace.MatchObjectWait(p, \"HashThreadFunc:stop\");\n                        if (p.mStopWriting)\n                        {\n                            Trace.MatchObjectWait(p, \"HashThreadFunc:stop\");\n                            p.mNumProcessedBlocks = numProcessedBlocks;\n                            Event_Set(p.mWasStopped);\n                            break;\n                        }\n                        Trace.MatchObjectWait(p, \"HashThreadFunc:stop\");\n\n                        if (base.MatchFinder_NeedMove())\n                        {\n                            CriticalSection_Enter(mBtSync.mCS);\n                            CriticalSection_Enter(mHashSync.mCS);\n                            {\n                                P<byte> beforePtr = base.MatchFinder_GetPointerToCurrentPos();\n                                base.MatchFinder_MoveBlock();\n                                P<byte> afterPtr = base.MatchFinder_GetPointerToCurrentPos();\n                                mPointerToCurPos -= beforePtr - afterPtr;\n                                mLocalBuffer -= beforePtr - afterPtr;\n                            }\n                            CriticalSection_Leave(mBtSync.mCS);\n                            CriticalSection_Leave(mHashSync.mCS);\n                            continue;\n                        }\n\n                        Semaphore_Wait(p.mFreeSemaphore);\n\n                        base.MatchFinder_ReadIfRequired();\n                        if (base.mPos > (kMtMaxValForNormalize - kMtHashBlockSize))\n                        {\n                            uint subValue = (base.mPos - base.mHistorySize - 1);\n                            base.MatchFinder_ReduceOffsets(subValue);\n                            CMatchFinder.MatchFinder_Normalize3(subValue, P.From(base.mHash, base.mFixedHashSize), base.mHashMask + 1);\n                        }\n\n                        P<uint> heads = P.From(mHashBuf, ((numProcessedBlocks++) & kMtHashNumBlocksMask) * kMtHashBlockSize);\n                        uint num = base.mStreamPos - base.mPos;\n                        heads[0] = 2;\n                        heads[1] = num;\n                        if (num >= base.mNumHashBytes)\n                        {\n                            num = num - base.mNumHashBytes + 1;\n                            if (num > kMtHashBlockSize - 2)\n                                num = kMtHashBlockSize - 2;\n                            mInterface.GetHeadsFunc(base.mBuffer, base.mPos, P.From(base.mHash, base.mFixedHashSize), base.mHashMask, heads + 2, num);\n                            heads[0] += num;\n                        }\n                        base.mPos += num;\n                        base.mBuffer += num;\n\n                        Semaphore_Release1(p.mFilledSemaphore);\n                    }\n                }\n            }\n\n            internal void BtGetMatches(P<uint> distances)\n            {\n                uint numProcessed = 0;\n                uint curPos = 2;\n                uint limit = kMtBtBlockSize - (mLocalMatchMaxLen * 2);\n\n                distances[1] = mHashNumAvail;\n\n                while (curPos < limit)\n                {\n                    if (mHashBufPos == mHashBufPosLimit)\n                    {\n                        MatchFinderMt_GetNextBlock_Hash();\n                        distances[1] = numProcessed + mHashNumAvail;\n\n                        if (mHashNumAvail >= mLocalNumHashBytes)\n                            continue;\n\n                        while (mHashNumAvail != 0)\n                        {\n                            distances[curPos++] = 0;\n                            mHashNumAvail--;\n                        }\n\n                        break;\n                    }\n                    {\n                        TR(\"BtGetMatches:cyclicBufferPos0\", mLocalCyclicBufferPos);\n\n                        uint size = mHashBufPosLimit - mHashBufPos;\n                        uint lenLimit = mLocalMatchMaxLen;\n                        uint pos = mLocalPos;\n                        uint cyclicBufferPos = mLocalCyclicBufferPos;\n\n                        if (lenLimit >= mHashNumAvail)\n                            lenLimit = mHashNumAvail;\n\n                        {\n                            uint size2 = mHashNumAvail - lenLimit + 1;\n                            if (size2 < size)\n                                size = size2;\n\n                            size2 = mLocalCyclicBufferSize - cyclicBufferPos;\n                            if (size2 < size)\n                                size = size2;\n                        }\n\n                        while (curPos < limit && size-- != 0)\n                        {\n                            P<uint> startDistances = distances + curPos;\n                            uint num = (uint)(CMatchFinder.GetMatchesSpec1(lenLimit, pos - mHashBuf[mHashBufPos++],\n                                pos, mLocalBuffer, mLocalSon, cyclicBufferPos, mLocalCyclicBufferSize, mLocalCutValue,\n                                startDistances + 1, mLocalNumHashBytes - 1) - startDistances);\n                            TR(\"GetMatchesSpec1\", num);\n                            startDistances[0] = num - 1;\n                            curPos += num;\n                            cyclicBufferPos++;\n                            pos++;\n                            mLocalBuffer++;\n                        }\n\n                        numProcessed += pos - mLocalPos;\n                        mHashNumAvail -= pos - mLocalPos;\n                        mLocalPos = pos;\n\n                        if (cyclicBufferPos == mLocalCyclicBufferSize)\n                            cyclicBufferPos = 0;\n\n                        mLocalCyclicBufferPos = cyclicBufferPos;\n\n                        TR(\"BtGetMatches:cyclicBufferPos1\", mLocalCyclicBufferPos);\n                    }\n                }\n\n                distances[0] = curPos;\n            }\n\n            internal void BtFillBlock(uint globalBlockIndex)\n            {\n                CMtSync sync = mHashSync;\n                if (!sync.mNeedStart)\n                {\n                    CriticalSection_Enter(sync.mCS);\n                    sync.mCsWasEntered = true;\n                }\n\n                BtGetMatches(mBtBuf + (globalBlockIndex & kMtBtNumBlocksMask) * kMtBtBlockSize);\n\n                if (mLocalPos > kMtMaxValForNormalize - kMtBtBlockSize)\n                {\n                    uint subValue = mLocalPos - mLocalCyclicBufferSize;\n                    CMatchFinder.MatchFinder_Normalize3(subValue, mLocalSon, mLocalCyclicBufferSize * 2);\n                    mLocalPos -= subValue;\n                }\n\n                if (!sync.mNeedStart)\n                {\n                    CriticalSection_Leave(sync.mCS);\n                    sync.mCsWasEntered = false;\n                }\n            }\n\n            internal void BtThreadFunc()\n            {\n                CMtSync p = mBtSync;\n                for (;;)\n                {\n                    Event_Wait(p.mCanStart);\n                    Event_Set(p.mWasStarted);\n\n                    uint blockIndex = 0;\n                    for (;;)\n                    {\n                        if (p.mExit)\n                            return;\n\n                        Trace.MatchObjectWait(p, \"BtThreadFunc:stop\");\n                        if (p.mStopWriting)\n                        {\n                            Trace.MatchObjectWait(p, \"BtThreadFunc:stop\");\n                            p.mNumProcessedBlocks = blockIndex;\n                            mHashSync.MtSync_StopWriting();\n                            Event_Set(p.mWasStopped);\n                            break;\n                        }\n                        Trace.MatchObjectWait(p, \"BtThreadFunc:stop\");\n\n                        Semaphore_Wait(p.mFreeSemaphore);\n                        BtFillBlock(blockIndex++);\n                        Semaphore_Release1(p.mFilledSemaphore);\n                    }\n                }\n            }\n\n            internal SRes MatchFinderMt_Create(uint historySize, uint keepAddBufferBefore, uint matchMaxLen, uint keepAddBufferAfter, ISzAlloc alloc)\n            {\n                mLocalHistorySize = historySize;\n\n                if (kMtBtBlockSize <= matchMaxLen * 4)\n                    return SZ_ERROR_PARAM;\n\n                if (mHashBuf == null)\n                {\n                    mHashBuf = alloc.AllocUInt32(alloc, kHashBufferSize + kBtBufferSize);\n                    if (mHashBuf == null)\n                        return SZ_ERROR_MEM;\n\n                    mBtBuf = P.From(mHashBuf, kHashBufferSize);\n                }\n\n                keepAddBufferBefore += (kHashBufferSize + kBtBufferSize);\n                keepAddBufferAfter += kMtHashBlockSize;\n\n                if (!base.MatchFinder_Create(historySize, keepAddBufferBefore, matchMaxLen, keepAddBufferAfter, alloc))\n                    return SZ_ERROR_MEM;\n\n                SRes res;\n                if ((res = mHashSync.MtSync_Create(HashThreadFunc, \"LZMA Hash Thread\", kMtHashNumBlocks)) != SZ_OK)\n                    return res;\n                if ((res = mBtSync.MtSync_Create(BtThreadFunc, \"LZMA BT Thread\", kMtBtNumBlocks)) != SZ_OK)\n                    return res;\n                return SZ_OK;\n            }\n\n            internal void MatchFinderMt_CreateVTable(out IMatchFinder vTable)\n            {\n                // Careful: don't use this.mNumHashBytes - it hasn't been initialized yet!\n                TR(\"MatchFinderMt_CreateVTable\", base.mNumHashBytes);\n                switch (base.mNumHashBytes)\n                {\n                    case 2:\n                        vTable = mInterface = new MatchFinderMt2();\n                        break;\n                    case 3:\n                        vTable = mInterface = new MatchFinderMt3();\n                        break;\n                    default:\n#if PROTOTYPE\n                    vTable = mInterface = new MatchFinderMt5();\n                    break;\n                case 4:\n#endif\n                        if (base.mBigHash)\n                            vTable = mInterface = new MatchFinderMt4b();\n                        else\n                            vTable = mInterface = new MatchFinderMt4a();\n                        break;\n                }\n            }\n\n            #endregion\n        }\n\n        private abstract class MatchFinderMtBase : IMatchFinderMt\n        {\n            public virtual void Init(object p)\n            {\n                MatchFinderMt_Init((CMatchFinderMt)p);\n            }\n\n            public virtual byte GetIndexByte(object p, int index)\n            {\n                return ((CMatchFinderMt)p).MatchFinderMt_GetIndexByte(index);\n            }\n\n            public virtual uint GetNumAvailableBytes(object p)\n            {\n                return ((CMatchFinderMt)p).MatchFinderMt_GetNumAvailableBytes();\n            }\n\n            public virtual P<byte> GetPointerToCurrentPos(object p)\n            {\n                return ((CMatchFinderMt)p).MatchFinderMt_GetPointerToCurrentPos();\n            }\n\n            public virtual uint GetMatches(object p, P<uint> distances)\n            {\n                return MatchFinderMt_GetMatches((CMatchFinderMt)p, distances);\n            }\n\n            public abstract void Skip(object p, uint num);\n            public abstract P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances);\n            public abstract void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads);\n\n            /* Call it after ReleaseStream / SetStream */\n            private static void MatchFinderMt_Init(CMatchFinderMt p)\n            {\n                CMatchFinder mf = p;\n\n                p.mBtBufPos = p.mBtBufPosLimit = 0;\n                p.mHashBufPos = p.mHashBufPosLimit = 0;\n                mf.MatchFinder_Init();\n                p.mPointerToCurPos = mf.MatchFinder_GetPointerToCurrentPos();\n                p.mBtNumAvailBytes = 0;\n                p.mLzPos = p.mLocalHistorySize + 1;\n\n                p.mLocalHash = mf.mHash;\n                p.mLocalFixedHashSize = mf.mFixedHashSize;\n\n                p.mLocalSon = mf.mSon;\n                p.mLocalMatchMaxLen = mf.mMatchMaxLen;\n                p.mLocalNumHashBytes = mf.mNumHashBytes;\n                p.mLocalPos = mf.mPos;\n                p.mLocalBuffer = mf.mBuffer;\n                p.mLocalCyclicBufferPos = mf.mCyclicBufferPos;\n                p.mLocalCyclicBufferSize = mf.mCyclicBufferSize;\n                p.mLocalCutValue = mf.mCutValue;\n            }\n\n            private static uint MatchFinderMt_GetMatches(CMatchFinderMt p, P<uint> distances)\n            {\n                TR(\"MatchFinderMt_GetMatches\", p.mBtBufPos);\n                P<uint> btBuf = p.mBtBuf + p.mBtBufPos;\n                uint len = btBuf[0];\n                btBuf++;\n                p.mBtBufPos += 1 + len;\n\n                if (len == 0)\n                {\n                    if (p.mBtNumAvailBytes-- >= 4)\n                        len = (uint)(p.mInterface.MixMatchesFunc(p, p.mLzPos - p.mLocalHistorySize, distances) - distances);\n                }\n                else\n                {\n                    // Condition: there are matches in btBuf with length < p.numHashBytes\n                    p.mBtNumAvailBytes--;\n                    P<uint> distances2 = p.mInterface.MixMatchesFunc(p, p.mLzPos - btBuf[1], distances);\n\n                    do\n                    {\n                        distances2[0] = btBuf[0];\n                        distances2++;\n                        btBuf++;\n\n                        distances2[0] = btBuf[0];\n                        distances2++;\n                        btBuf++;\n\n                        len -= 2;\n                    }\n                    while (len != 0);\n\n                    len = (uint)(distances2 - distances);\n                }\n\n                p.mLzPos++;\n                p.mPointerToCurPos++;\n                return len;\n            }\n        }\n\n        private sealed class MatchFinderMt2 : MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt0_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override uint GetMatches(object p, P<uint> distances)\n            {\n                return MatchFinderMt2_GetMatches((CMatchFinderMt)p, distances);\n            }\n\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = buffer[0] | ((uint)buffer[1] << 8);\n                    TR(\"GetHeads2\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                throw new InvalidOperationException(); // was a NULL delegate\n            }\n\n            private static void MatchFinderMt0_Skip(CMatchFinderMt p, uint num)\n            {\n                do\n                {\n                    if (p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    p.mBtNumAvailBytes--;\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while (--num != 0);\n            }\n\n            private static uint MatchFinderMt2_GetMatches(CMatchFinderMt p, P<uint> distances)\n            {\n                P<uint> btBuf = p.mBtBuf + p.mBtBufPos;\n                uint len = btBuf[0];\n                btBuf++;\n                p.mBtBufPos += 1 + len;\n                p.mBtNumAvailBytes--;\n\n                for (uint i = 0; i < len; i += 2)\n                {\n                    distances[0] = btBuf[0];\n                    distances++;\n                    btBuf++;\n\n                    distances[0] = btBuf[0];\n                    distances++;\n                    btBuf++;\n                }\n\n                p.mLzPos++;\n                p.mPointerToCurPos++;\n                return len;\n            }\n        }\n\n        private sealed class MatchFinderMt3 : MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt2_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8)) & hashMask;\n                    TR(\"GetHeads3\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                return MixMatches2((CMatchFinderMt)p, matchMinPos, distances);\n            }\n\n            private static P<uint> MixMatches2(CMatchFinderMt p, uint matchMinPos, P<uint> distances)\n            {\n                uint[] hash = p.mLocalHash;\n                P<byte> cur = p.mPointerToCurPos;\n                uint lzPos = p.mLzPos;\n                uint hash2Value = (cur[0].CRC() ^ cur[1]) & (kHash2Size - 1);\n\n                uint curMatch2 = hash[hash2Value];\n                hash[hash2Value] = lzPos;\n\n                if (curMatch2 >= matchMinPos && cur[(long)curMatch2 - lzPos] == cur[0])\n                {\n                    distances[0] = 2;\n                    distances++;\n                    distances[0] = lzPos - curMatch2 - 1;\n                    distances++;\n                }\n\n                return distances;\n            }\n\n            private static void MatchFinderMt2_Skip(CMatchFinderMt p, uint num)\n            {\n                do\n                {\n                    if (p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    if (p.mBtNumAvailBytes-- >= 2)\n                    {\n                        P<byte> cur = p.mPointerToCurPos;\n                        uint[] hash = p.mLocalHash;\n                        uint hash2Value = (cur[0].CRC() ^ cur[1]) & (kHash2Size - 1);\n                        hash[hash2Value] = p.mLzPos;\n                    }\n\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while (--num != 0);\n            }\n        }\n\n        private abstract class MatchFinderMt4 : MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt3_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                return MixMatches3((CMatchFinderMt)p, matchMinPos, distances);\n            }\n\n            private static P<uint> MixMatches3(CMatchFinderMt p, uint matchMinPos, P<uint> distances)\n            {\n                uint[] hash = p.mLocalHash;\n                P<byte> cur = p.mPointerToCurPos;\n                uint lzPos = p.mLzPos;\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n\n                uint curMatch2 = hash[hash2Value];\n                uint curMatch3 = hash[kFix3HashSize + hash3Value];\n\n                hash[hash2Value] = lzPos;\n                hash[kFix3HashSize + hash3Value] = lzPos;\n\n                if (curMatch2 >= matchMinPos && cur[curMatch2 - lzPos] == cur[0])\n                {\n                    distances[1] = lzPos - curMatch2 - 1;\n\n                    if (cur[curMatch2 - lzPos + 2] == cur[2])\n                    {\n                        distances[0] = 3;\n                        return distances + 2;\n                    }\n\n                    distances[0] = 2;\n                    distances += 2;\n                }\n\n                if (curMatch3 >= matchMinPos && cur[curMatch3 - lzPos] == cur[0])\n                {\n                    distances[0] = 3;\n                    distances++;\n\n                    distances[0] = lzPos - curMatch3 - 1;\n                    distances++;\n                }\n\n                return distances;\n            }\n\n            private static void MatchFinderMt3_Skip(CMatchFinderMt p, uint num)\n            {\n                do\n                {\n                    if (p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    if (p.mBtNumAvailBytes-- >= 3)\n                    {\n                        P<byte> cur = p.mPointerToCurPos;\n                        uint[] hash = p.mLocalHash;\n                        uint temp = cur[0].CRC() ^ cur[1];\n                        uint hash2Value = temp & (kHash2Size - 1);\n                        uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                        hash[kFix3HashSize + hash3Value] = p.mLzPos;\n                        hash[hash2Value] = p.mLzPos;\n                    }\n\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while (--num != 0);\n            }\n        }\n\n        private sealed class MatchFinderMt4a : MatchFinderMt4\n        {\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5)) & hashMask;\n                    TR(\"GetHeads4\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n        }\n\n        private sealed class MatchFinderMt4b : MatchFinderMt4\n        {\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                while (numHeads != 0)\n                {\n                    uint value = (buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ ((uint)buffer[3] << 16)) & hashMask;\n                    TR(\"GetHeads4b\", value);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                    numHeads--;\n                }\n            }\n        }\n\n#if PROTOTYPE\n        private sealed class MatchFinderMt5: MatchFinderMtBase\n        {\n            public override void Skip(object p, uint num)\n            {\n                MatchFinderMt4_Skip((CMatchFinderMt)p, num);\n            }\n\n            public override void GetHeadsFunc(P<byte> buffer, uint pos, P<uint> hash, uint hashMask, P<uint> heads, uint numHeads)\n            {\n                for(; numHeads != 0; numHeads--)\n                {\n                    uint value = ((buffer[0].CRC() ^ buffer[1] ^ ((uint)buffer[2] << 8) ^ (buffer[3].CRC() << 5) ^ (buffer[4].CRC() << 3)) & hashMask);\n                    buffer++;\n                    heads[0] = pos - hash[value];\n                    heads++;\n                    hash[value] = pos++;\n                }\n            }\n\n            public override P<uint> MixMatchesFunc(object p, uint matchMinPos, P<uint> distances)\n            {\n                return MixMatches4((CMatchFinderMt)p, matchMinPos, distances);\n            }\n\n            private static void MatchFinderMt4_Skip(CMatchFinderMt p, uint count)\n            {\n                do\n                {\n                    if(p.mBtBufPos == p.mBtBufPosLimit)\n                        p.MatchFinderMt_GetNextBlock_Bt();\n\n                    if(p.mBtNumAvailBytes-- >= 4)\n                    {\n                        P<byte> cur = p.mPointerToCurPos;\n                        uint[] hash = p.mHash;\n                        uint temp = cur[0].CRC() ^ cur[1];\n                        uint hash2Value = temp & (kHash2Size - 1);\n                        uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                        uint hash4Value = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & (kHash4Size - 1);\n                        hash[kFix4HashSize + hash4Value] = p.mLzPos;\n                        hash[kFix3HashSize + hash3Value] = p.mLzPos;\n                        hash[hash2Value] = p.mLzPos;\n                    }\n\n                    p.mLzPos++;\n                    p.mPointerToCurPos++;\n                    p.mBtBufPos += p.mBtBuf[p.mBtBufPos] + 1;\n                }\n                while(--count != 0);\n            }\n\n            private static P<uint> MixMatches4(CMatchFinderMt p, uint matchMinPos, P<uint> distances)\n            {\n                uint[] hash = p.mHash;\n                P<byte> cur = p.mPointerToCurPos;\n                uint lzPos = p.mLzPos;\n\n                uint temp = cur[0].CRC() ^ cur[1];\n                uint hash2Value = temp & (kHash2Size - 1);\n                uint hash3Value = (temp ^ ((uint)cur[2] << 8)) & (kHash3Size - 1);\n                uint hash4Value = (temp ^ ((uint)cur[2] << 8) ^ (cur[3].CRC() << 5)) & (kHash4Size - 1);\n\n                uint curMatch2 = hash[hash2Value];\n                uint curMatch3 = hash[kFix3HashSize + hash3Value];\n                uint curMatch4 = hash[kFix4HashSize + hash4Value];\n\n                hash[hash2Value] = lzPos;\n                hash[kFix3HashSize + hash3Value] = lzPos;\n                hash[kFix4HashSize + hash4Value] = lzPos;\n\n                if(curMatch2 >= matchMinPos && cur[(long)curMatch2 - lzPos] == cur[0])\n                {\n                    distances[1] = lzPos - curMatch2 - 1;\n                    if(cur[(long)curMatch2 - lzPos + 2] == cur[2])\n                    {\n                        distances[0] = (cur[(long)curMatch2 - lzPos + 3] == cur[3]) ? 4u : 3u;\n                        return distances + 2;\n                    }\n\n                    distances[0] = 2;\n                    distances += 2;\n                }\n\n                if(curMatch3 >= matchMinPos && cur[(long)curMatch3 - lzPos] == cur[0])\n                {\n                    distances[1] = lzPos - curMatch3 - 1;\n                    if(cur[(long)curMatch3 - lzPos + 3] == cur[3])\n                    {\n                        distances[0] = 4;\n                        return distances + 2;\n                    }\n\n                    distances[0] = 3;\n                    distances += 2;\n                }\n\n                if(curMatch4 >= matchMinPos\n                    && cur[(long)curMatch4 - lzPos] == cur[0]\n                    && cur[(long)curMatch4 - lzPos + 3] == cur[3])\n                {\n                    distances[0] = 4;\n                    distances++;\n\n                    distances[0] = lzPos - curMatch4 - 1;\n                    distances++;\n                }\n\n                return distances;\n            }\n        }\n#endif\n    }\n    partial class LZMA\n    {\n        internal const int kHash2Size = (1 << 10);\n        internal const int kHash3Size = (1 << 16);\n        internal const int kHash4Size = (1 << 20);\n\n        internal const int kFix3HashSize = (kHash2Size);\n        internal const int kFix4HashSize = (kHash2Size + kHash3Size);\n        internal const int kFix5HashSize = (kHash2Size + kHash3Size + kHash4Size);\n    }\n    partial class LZMA\n    {\n        public sealed class CLzma2Dec\n        {\n            #region Constants\n\n            /*\n            00000000  -  EOS\n            00000001 U U  -  Uncompressed Reset Dic\n            00000010 U U  -  Uncompressed No Reset\n            100uuuuu U U P P  -  LZMA no reset\n            101uuuuu U U P P  -  LZMA reset state\n            110uuuuu U U P P S  -  LZMA reset state + new prop\n            111uuuuu U U P P S  -  LZMA reset state + new prop + reset dic\n\n              u, U - Unpack Size\n              P - Pack Size\n              S - Props\n            */\n\n            private const int LZMA2_CONTROL_LZMA = (1 << 7);\n            private const int LZMA2_CONTROL_COPY_NO_RESET = 2;\n            private const int LZMA2_CONTROL_COPY_RESET_DIC = 1;\n            private const int LZMA2_CONTROL_EOF = 0;\n\n            private const int LZMA2_LCLP_MAX = 4;\n\n            private enum Lzma2State\n            {\n                Control,\n                Unpack0,\n                Unpack1,\n                Pack0,\n                Pack1,\n                Prop,\n                Data,\n                DataCont,\n                Finished,\n                Error,\n            }\n\n            #endregion\n\n            #region Variables\n\n            internal CLzmaDec mDecoder = new CLzmaDec();\n            internal uint mPackSize;\n            internal uint mUnpackSize;\n            private Lzma2State mState;\n            private byte mControl;\n            private bool mNeedInitDic;\n            private bool mNeedInitState;\n            private bool mNeedInitProp;\n\n            #endregion\n\n            #region Private Methods\n\n            private bool IsUncompressedState()\n            {\n                return (mControl & LZMA2_CONTROL_LZMA) == 0;\n            }\n\n            private int GetLzmaMode()\n            {\n                return (mControl >> 5) & 3;\n            }\n\n            private static bool IsThereProp(int mode)\n            {\n                return mode >= 2;\n            }\n\n            private static uint DicSizeFromProp(byte p)\n            {\n                return (2u | (p & 1u)) << ((p >> 1) + 11);\n            }\n\n            private static SRes Lzma2Dec_GetOldProps(byte prop, P<byte> props)\n            {\n                if (prop > 40)\n                    return SZ_ERROR_UNSUPPORTED;\n\n                uint dicSize = (prop == 40) ? 0xFFFFFFFF : DicSizeFromProp(prop);\n                props[0] = (byte)LZMA2_LCLP_MAX;\n                props[1] = (byte)(dicSize);\n                props[2] = (byte)(dicSize >> 8);\n                props[3] = (byte)(dicSize >> 16);\n                props[4] = (byte)(dicSize >> 24);\n                return SZ_OK;\n            }\n\n            private Lzma2State Lzma2Dec_UpdateState(byte b)\n            {\n                switch (mState)\n                {\n                    case Lzma2State.Control:\n                        mControl = b;\n                        TR(\"Lzma2Dec_UpdateState:1\", checked((int)mDecoder.mDicPos));\n                        TR(\"Lzma2Dec_UpdateState:2\", b);\n                        DebugPrint(\"\\n {0:X4} \", mDecoder.mDicPos);\n                        DebugPrint(\" {0:X2}\", b);\n\n                        if (mControl == 0)\n                            return Lzma2State.Finished;\n\n                        if (IsUncompressedState())\n                        {\n                            if ((mControl & 0x7F) > 2)\n                                return Lzma2State.Error;\n\n                            mUnpackSize = 0;\n                        }\n                        else\n                        {\n                            mUnpackSize = (uint)(mControl & 0x1F) << 16;\n                        }\n\n                        return Lzma2State.Unpack0;\n\n                    case Lzma2State.Unpack0:\n                        mUnpackSize |= (uint)b << 8;\n                        return Lzma2State.Unpack1;\n\n                    case Lzma2State.Unpack1:\n                        mUnpackSize |= (uint)b;\n                        mUnpackSize++;\n\n                        TR(\"Lzma2Dec_UpdateState:3\", mUnpackSize);\n                        DebugPrint(\" {0:00000000}\", mUnpackSize);\n\n                        if (IsUncompressedState())\n                            return Lzma2State.Data;\n                        else\n                            return Lzma2State.Pack0;\n\n                    case Lzma2State.Pack0:\n                        mPackSize = (uint)b << 8;\n                        return Lzma2State.Pack1;\n\n                    case Lzma2State.Pack1:\n                        mPackSize |= (uint)b;\n                        mPackSize++;\n\n                        TR(\"Lzma2Dec_UpdateState:4\", mPackSize);\n                        DebugPrint(\" {0:00000000}\", mPackSize);\n\n                        if (IsThereProp(GetLzmaMode()))\n                            return Lzma2State.Prop;\n                        else if (mNeedInitProp)\n                            return Lzma2State.Error;\n                        else\n                            return Lzma2State.Data;\n\n                    case Lzma2State.Prop:\n                        if (b >= (9 * 5 * 5))\n                            return Lzma2State.Error;\n\n                        int lc = b % 9;\n                        b /= 9;\n                        mDecoder.mProp.mPB = b / 5;\n                        int lp = b % 5;\n\n                        if (lc + lp > LZMA2_LCLP_MAX)\n                            return Lzma2State.Error;\n\n                        mDecoder.mProp.mLC = lc;\n                        mDecoder.mProp.mLP = lp;\n                        mNeedInitProp = false;\n                        return Lzma2State.Data;\n\n                    default:\n                        return Lzma2State.Error;\n                }\n            }\n\n            private static void LzmaDec_UpdateWithUncompressed(CLzmaDec p, P<byte> src, long size)\n            {\n                CUtils.memcpy(p.mDic + p.mDicPos, src, size);\n                p.mDicPos += size;\n                if (p.mCheckDicSize == 0 && p.mProp.mDicSize - p.mProcessedPos <= size)\n                    p.mCheckDicSize = p.mProp.mDicSize;\n                p.mProcessedPos += (uint)size;\n            }\n\n            #endregion\n\n            #region Header\n\n            public void Lzma2Dec_Construct()\n            {\n                mDecoder.LzmaDec_Construct();\n            }\n\n            public void Lzma2Dec_FreeProbs(ISzAlloc alloc)\n            {\n                mDecoder.LzmaDec_FreeProbs(alloc);\n            }\n\n            public void Lzma2Dec_Free(ISzAlloc alloc)\n            {\n                mDecoder.LzmaDec_Free(alloc);\n            }\n\n            public SRes Lzma2Dec_AllocateProbs(byte prop, ISzAlloc alloc)\n            {\n                byte[] props = new byte[LZMA_PROPS_SIZE];\n\n                SRes res;\n                if ((res = Lzma2Dec_GetOldProps(prop, props)) != SZ_OK)\n                    return res;\n\n                return mDecoder.LzmaDec_AllocateProbs(props, LZMA_PROPS_SIZE, alloc);\n            }\n\n            public SRes Lzma2Dec_Allocate(byte prop, ISzAlloc alloc)\n            {\n                byte[] props = new byte[LZMA_PROPS_SIZE];\n\n                SRes res;\n                if ((res = Lzma2Dec_GetOldProps(prop, props)) != SZ_OK)\n                    return res;\n\n                return mDecoder.LzmaDec_Allocate(props, LZMA_PROPS_SIZE, alloc);\n            }\n\n            public void Lzma2Dec_Init()\n            {\n                mState = Lzma2State.Control;\n                mNeedInitDic = true;\n                mNeedInitState = true;\n                mNeedInitProp = true;\n                mDecoder.LzmaDec_Init();\n            }\n\n            /*\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen or dicLimit).\n              LZMA_FINISH_ANY - use smallest number of input bytes\n              LZMA_FINISH_END - read EndOfStream marker after decoding\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n                  LZMA_STATUS_NEEDS_MORE_INPUT\n              SZ_ERROR_DATA - Data error\n            */\n\n            public SRes Lzma2Dec_DecodeToDic(long dicLimit, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long inSize = srcLen;\n                srcLen = 0;\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                while (mState != Lzma2State.Finished)\n                {\n                    long dicPos = mDecoder.mDicPos;\n                    if (mState == Lzma2State.Error)\n                        return SZ_ERROR_DATA;\n\n                    if (dicPos == dicLimit && finishMode == ELzmaFinishMode.LZMA_FINISH_ANY)\n                    {\n                        status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                        return SZ_OK;\n                    }\n\n                    if (mState != Lzma2State.Data && mState != Lzma2State.DataCont)\n                    {\n                        if (srcLen == inSize)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                            return SZ_OK;\n                        }\n                        srcLen++;\n                        mState = Lzma2Dec_UpdateState(src[0]);\n                        src++;\n                        continue;\n                    }\n\n                    long destSizeCur = dicLimit - dicPos;\n                    long srcSizeCur = inSize - srcLen;\n                    ELzmaFinishMode curFinishMode = ELzmaFinishMode.LZMA_FINISH_ANY;\n\n                    if (mUnpackSize <= destSizeCur)\n                    {\n                        destSizeCur = mUnpackSize;\n                        curFinishMode = ELzmaFinishMode.LZMA_FINISH_END;\n                    }\n\n                    if (IsUncompressedState())\n                    {\n                        if (srcLen == inSize)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                            return SZ_OK;\n                        }\n\n                        if (mState == Lzma2State.Data)\n                        {\n                            bool initDic = (mControl == LZMA2_CONTROL_COPY_RESET_DIC);\n                            if (initDic)\n                                mNeedInitProp = mNeedInitState = true;\n                            else if (mNeedInitDic)\n                                return SZ_ERROR_DATA;\n\n                            mNeedInitDic = false;\n                            mDecoder.LzmaDec_InitDicAndState(initDic, false);\n                        }\n\n                        if (srcSizeCur > destSizeCur)\n                            srcSizeCur = destSizeCur;\n\n                        if (srcSizeCur == 0)\n                            return SZ_ERROR_DATA;\n\n                        LzmaDec_UpdateWithUncompressed(mDecoder, src, srcSizeCur);\n\n                        src += srcSizeCur;\n                        srcLen += srcSizeCur;\n                        mUnpackSize -= (uint)srcSizeCur;\n                        mState = (mUnpackSize == 0) ? Lzma2State.Control : Lzma2State.DataCont;\n                    }\n                    else\n                    {\n                        long outSizeProcessed;\n\n                        if (mState == Lzma2State.Data)\n                        {\n                            int mode = GetLzmaMode();\n                            bool initDic = (mode == 3);\n                            bool initState = (mode > 0);\n                            if ((!initDic && mNeedInitDic) || (!initState && mNeedInitState))\n                                return SZ_ERROR_DATA;\n\n                            mDecoder.LzmaDec_InitDicAndState(initDic, initState);\n                            mNeedInitDic = false;\n                            mNeedInitState = false;\n                            mState = Lzma2State.DataCont;\n                        }\n\n                        if (srcSizeCur > mPackSize)\n                            srcSizeCur = mPackSize;\n\n                        SRes res = mDecoder.LzmaDec_DecodeToDic(dicPos + destSizeCur, src, ref srcSizeCur, curFinishMode, out status);\n\n                        src += srcSizeCur;\n                        srcLen += srcSizeCur;\n                        mPackSize -= (uint)srcSizeCur;\n\n                        outSizeProcessed = mDecoder.mDicPos - dicPos;\n                        mUnpackSize -= (uint)outSizeProcessed;\n\n                        if (res != SZ_OK)\n                            return res;\n\n                        if (status == ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT)\n                            return res;\n\n                        if (srcSizeCur == 0 && outSizeProcessed == 0)\n                        {\n                            if (status != ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK || mUnpackSize != 0 || mPackSize != 0)\n                                return SZ_ERROR_DATA;\n\n                            mState = Lzma2State.Control;\n                        }\n\n                        if (status == ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK)\n                            status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                    }\n                }\n\n                status = ELzmaStatus.LZMA_STATUS_FINISHED_WITH_MARK;\n                return SZ_OK;\n            }\n\n            public SRes Lzma2Dec_DecodeToBuf(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                srcLen = 0;\n                destLen = 0;\n\n                for (;;)\n                {\n                    if (mDecoder.mDicPos == mDecoder.mDicBufSize)\n                        mDecoder.mDicPos = 0;\n\n                    long outSizeCur;\n                    ELzmaFinishMode curFinishMode;\n                    long dicPos = mDecoder.mDicPos;\n                    if (outSize > mDecoder.mDicBufSize - dicPos)\n                    {\n                        outSizeCur = mDecoder.mDicBufSize;\n                        curFinishMode = ELzmaFinishMode.LZMA_FINISH_ANY;\n                    }\n                    else\n                    {\n                        outSizeCur = dicPos + outSize;\n                        curFinishMode = finishMode;\n                    }\n\n                    long srcSizeCur = inSize;\n                    SRes res = Lzma2Dec_DecodeToDic(outSizeCur, src, ref srcSizeCur, curFinishMode, out status);\n                    src += srcSizeCur;\n                    inSize -= srcSizeCur;\n                    srcLen += srcSizeCur;\n                    outSizeCur = mDecoder.mDicPos - dicPos;\n                    CUtils.memcpy(dest, mDecoder.mDic + dicPos, outSizeCur);\n                    dest += outSizeCur;\n                    outSize -= outSizeCur;\n                    destLen += outSizeCur;\n\n                    if (res != 0)\n                        return res;\n\n                    if (outSizeCur == 0 || outSize == 0)\n                        return SZ_OK;\n                }\n            }\n\n            #endregion\n\n            #region Public Static Methods\n\n            /*\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen).\n              LZMA_FINISH_ANY - use smallest number of input bytes\n              LZMA_FINISH_END - read EndOfStream marker after decoding\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n              SZ_ERROR_DATA - Data error\n              SZ_ERROR_MEM  - Memory allocation error\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n              SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).\n            */\n\n            public static SRes Lzma2Decode(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, byte prop, ELzmaFinishMode finishMode, out ELzmaStatus status, ISzAlloc alloc)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                destLen = 0;\n                srcLen = 0;\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                CLzma2Dec p = new CLzma2Dec();\n                p.Lzma2Dec_Construct();\n                SRes res;\n                if ((res = p.Lzma2Dec_AllocateProbs(prop, alloc)) != SZ_OK)\n                    return res;\n                p.mDecoder.mDic = dest;\n                p.mDecoder.mDicBufSize = outSize;\n                p.Lzma2Dec_Init();\n                srcLen = inSize;\n                res = p.Lzma2Dec_DecodeToDic(outSize, src, ref srcLen, finishMode, out status);\n                destLen = p.mDecoder.mDicPos;\n                if (res == SZ_OK && status == ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT)\n                    res = SZ_ERROR_INPUT_EOF;\n                p.Lzma2Dec_FreeProbs(alloc);\n                return res;\n            }\n\n            #endregion\n        }\n    }\n    partial class LZMA\n    {\n        public sealed class CLzma2EncProps\n        {\n            #region Variables\n\n            public CLzmaEncProps mLzmaProps;\n            public long mBlockSize;\n            public int mNumBlockThreads;\n            public int mNumTotalThreads;\n\n            #endregion\n\n            #region Methods\n\n            public CLzma2EncProps() { }\n            public CLzma2EncProps(CLzma2EncProps other)\n            {\n                mLzmaProps = new CLzmaEncProps(other.mLzmaProps);\n                mBlockSize = other.mBlockSize;\n                mNumBlockThreads = other.mNumBlockThreads;\n                mNumTotalThreads = other.mNumTotalThreads;\n            }\n\n            public void Lzma2EncProps_Init()\n            {\n                mLzmaProps = CLzmaEncProps.LzmaEncProps_Init();\n                mNumTotalThreads = -1;\n                mNumBlockThreads = -1;\n                mBlockSize = 0;\n            }\n\n            public void Lzma2EncProps_Normalize()\n            {\n                CLzmaEncProps normalizedLzmaProps = new CLzmaEncProps(mLzmaProps);\n                normalizedLzmaProps.LzmaEncProps_Normalize();\n                int tempThreadsNormalized = normalizedLzmaProps.mNumThreads;\n                int tempThreads = mLzmaProps.mNumThreads;\n                int tempBlockThreads = mNumBlockThreads;\n                int tempTotalThreads = mNumTotalThreads;\n\n                if (tempBlockThreads > NUM_MT_CODER_THREADS_MAX)\n                    tempBlockThreads = NUM_MT_CODER_THREADS_MAX;\n\n                if (tempTotalThreads <= 0)\n                {\n                    if (tempBlockThreads <= 0)\n                        tempBlockThreads = 1;\n\n                    tempTotalThreads = tempThreadsNormalized * tempBlockThreads;\n                }\n                else if (tempBlockThreads <= 0)\n                {\n                    tempBlockThreads = tempTotalThreads / tempThreadsNormalized;\n\n                    if (tempBlockThreads == 0)\n                    {\n                        tempThreads = 1;\n                        tempBlockThreads = tempTotalThreads;\n                    }\n\n                    if (tempBlockThreads > NUM_MT_CODER_THREADS_MAX)\n                        tempBlockThreads = NUM_MT_CODER_THREADS_MAX;\n                }\n                else if (tempThreads <= 0)\n                {\n                    tempThreads = tempTotalThreads / tempBlockThreads;\n                    if (tempThreads == 0)\n                        tempThreads = 1;\n                }\n                else\n                {\n                    tempTotalThreads = tempThreadsNormalized * tempBlockThreads;\n                }\n\n                mLzmaProps.mNumThreads = tempThreads;\n                mNumBlockThreads = tempBlockThreads;\n                mNumTotalThreads = tempTotalThreads;\n                mLzmaProps.LzmaEncProps_Normalize();\n\n                if (mBlockSize == 0)\n                {\n                    uint dictSize = mLzmaProps.mDictSize;\n                    long blockSize = (long)dictSize << 2;\n\n                    const uint kMinSize = 1 << 20;\n                    const uint kMaxSize = 1 << 28;\n\n                    if (blockSize < kMinSize)\n                        blockSize = kMinSize;\n\n                    if (blockSize > kMaxSize)\n                        blockSize = kMaxSize;\n\n                    if (blockSize < dictSize)\n                        blockSize = dictSize;\n\n                    mBlockSize = blockSize;\n                }\n            }\n\n            #endregion\n        }\n\n        internal sealed class CLzma2EncInternal\n        {\n            #region Constants\n\n            private const int LZMA2_CONTROL_LZMA = (1 << 7);\n            private const int LZMA2_CONTROL_COPY_NO_RESET = 2;\n            private const int LZMA2_CONTROL_COPY_RESET_DIC = 1;\n            private const int LZMA2_CONTROL_EOF = 0;\n\n            private const int LZMA2_PACK_SIZE_MAX = (1 << 16);\n            private const int LZMA2_COPY_CHUNK_SIZE = LZMA2_PACK_SIZE_MAX;\n            private const int LZMA2_UNPACK_SIZE_MAX = (1 << 21);\n            internal const int LZMA2_KEEP_WINDOW_SIZE = LZMA2_UNPACK_SIZE_MAX;\n\n            private const int LZMA2_CHUNK_SIZE_COMPRESSED_MAX = ((1 << 16) + 16);\n\n            #endregion\n\n            #region Variables\n\n            internal CLzmaEnc mEnc;\n            internal ulong mSrcPos;\n            internal byte mProps;\n            internal bool mNeedInitState;\n            internal bool mNeedInitProp;\n\n            #endregion\n\n            #region Internal Methods\n\n            internal SRes Lzma2EncInt_Init(CLzma2EncProps props)\n            {\n                byte[] propsEncoded = new byte[LZMA_PROPS_SIZE];\n                long propsSize = LZMA_PROPS_SIZE;\n\n                SRes res;\n                if ((res = mEnc.LzmaEnc_SetProps(props.mLzmaProps)) != SZ_OK)\n                    return res;\n\n                if ((res = mEnc.LzmaEnc_WriteProperties(propsEncoded, ref propsSize)) != SZ_OK)\n                    return res;\n\n                mSrcPos = 0;\n                mProps = propsEncoded[0];\n                mNeedInitState = true;\n                mNeedInitProp = true;\n                return SZ_OK;\n            }\n\n            internal SRes Lzma2EncInt_EncodeSubblock(P<byte> outBuf, ref long packSizeRes, ISeqOutStream outStream)\n            {\n                long packSizeLimit = packSizeRes;\n                long packSize = packSizeLimit;\n                uint unpackSize = LZMA2_UNPACK_SIZE_MAX;\n                uint lzHeaderSize = 5u + (mNeedInitProp ? 1u : 0u);\n\n                packSizeRes = 0;\n                if (packSize < lzHeaderSize)\n                    return SZ_ERROR_OUTPUT_EOF;\n                packSize -= lzHeaderSize;\n\n                mEnc.LzmaEnc_SaveState();\n                SRes res = mEnc.LzmaEnc_CodeOneMemBlock(mNeedInitState, outBuf + lzHeaderSize, ref packSize, LZMA2_PACK_SIZE_MAX, ref unpackSize);\n\n                TR(\"Lzma2EncInt_EncodeSubblock:packSize\", checked((int)packSize));\n                TR(\"Lzma2EncInt_EncodeSubblock:unpackSize\", unpackSize);\n                DebugPrint(\"\\npackSize = {0:0000000} unpackSize = {1:0000000}  \", packSize, unpackSize);\n\n                if (unpackSize == 0)\n                    return res;\n\n                bool useCopyBlock;\n                if (res == SZ_OK)\n                    useCopyBlock = (packSize + 2 >= unpackSize || packSize > (1 << 16));\n                else\n                {\n                    if (res != SZ_ERROR_OUTPUT_EOF)\n                        return res;\n                    res = SZ_OK;\n                    useCopyBlock = true;\n                }\n\n                if (useCopyBlock)\n                {\n                    long destPos = 0;\n                    DebugPrint(\"################# COPY           \");\n\n                    while (unpackSize > 0)\n                    {\n                        uint u = (unpackSize < LZMA2_COPY_CHUNK_SIZE) ? unpackSize : LZMA2_COPY_CHUNK_SIZE;\n                        if (packSizeLimit - destPos < u + 3)\n                            return SZ_ERROR_OUTPUT_EOF;\n\n                        outBuf[destPos++] = (byte)(mSrcPos == 0 ? LZMA2_CONTROL_COPY_RESET_DIC : LZMA2_CONTROL_COPY_NO_RESET);\n                        outBuf[destPos++] = (byte)((u - 1) >> 8);\n                        outBuf[destPos++] = (byte)(u - 1);\n\n                        CUtils.memcpy(outBuf + destPos, mEnc.LzmaEnc_GetCurBuf() - unpackSize, u);\n\n                        unpackSize -= u;\n                        destPos += u;\n                        mSrcPos += u;\n\n                        if (outStream != null)\n                        {\n                            packSizeRes += destPos;\n                            if (outStream.Write(outBuf, destPos) != destPos)\n                                return SZ_ERROR_WRITE;\n                            destPos = 0;\n                        }\n                        else\n                        {\n                            packSizeRes = destPos;\n                        }\n\n                        /* needInitState = true; */\n                    }\n\n                    mEnc.LzmaEnc_RestoreState();\n                    return SZ_OK;\n                }\n                else\n                {\n                    long destPos = 0;\n                    uint u = unpackSize - 1;\n                    uint pm = (uint)(packSize - 1);\n\n                    uint mode;\n                    if (mSrcPos == 0)\n                        mode = 3;\n                    else if (!mNeedInitState)\n                        mode = 0;\n                    else if (!mNeedInitProp)\n                        mode = 1;\n                    else\n                        mode = 2;\n\n                    DebugPrint(\"               \");\n\n                    outBuf[destPos++] = (byte)(LZMA2_CONTROL_LZMA | (mode << 5) | ((u >> 16) & 0x1F));\n                    outBuf[destPos++] = (byte)(u >> 8);\n                    outBuf[destPos++] = (byte)u;\n                    outBuf[destPos++] = (byte)(pm >> 8);\n                    outBuf[destPos++] = (byte)pm;\n\n                    if (mNeedInitProp)\n                        outBuf[destPos++] = mProps;\n\n                    mNeedInitProp = false;\n                    mNeedInitState = false;\n                    destPos += packSize;\n                    mSrcPos += unpackSize;\n\n                    if (outStream != null && outStream.Write(outBuf, destPos) != destPos)\n                        return SZ_ERROR_WRITE;\n\n                    packSizeRes = destPos;\n                    return SZ_OK;\n                }\n            }\n\n            private static SRes Progress(ICompressProgress p, ulong inSize, ulong outSize)\n            {\n                return (p != null && p.Progress(inSize, outSize) != SZ_OK) ? SZ_ERROR_PROGRESS : SZ_OK;\n            }\n\n            internal SRes Lzma2Enc_EncodeMt1(CLzma2Enc mainEncoder, ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress)\n            {\n                ulong packTotal = 0;\n                SRes res = SZ_OK;\n\n                if (mainEncoder.mOutBuf == null)\n                {\n                    mainEncoder.mOutBuf = IAlloc_AllocBytes(mainEncoder.mAlloc, LZMA2_CHUNK_SIZE_COMPRESSED_MAX);\n                    if (mainEncoder.mOutBuf == null)\n                        return SZ_ERROR_MEM;\n                }\n\n                if ((res = Lzma2EncInt_Init(mainEncoder.mProps)) != SZ_OK)\n                    return res;\n\n                if ((res = mEnc.LzmaEnc_PrepareForLzma2(inStream, LZMA2_KEEP_WINDOW_SIZE, mainEncoder.mAlloc, mainEncoder.mAllocBig)) != SZ_OK)\n                    return res;\n\n                for (;;)\n                {\n                    long packSize = LZMA2_CHUNK_SIZE_COMPRESSED_MAX;\n                    res = Lzma2EncInt_EncodeSubblock(mainEncoder.mOutBuf, ref packSize, outStream);\n                    if (res != SZ_OK)\n                        break;\n                    packTotal += (ulong)packSize;\n                    res = Progress(progress, mSrcPos, packTotal);\n                    if (res != SZ_OK)\n                        break;\n                    if (packSize == 0)\n                        break;\n                }\n\n                mEnc.LzmaEnc_Finish();\n\n                if (res == SZ_OK)\n                {\n                    if (outStream.Write(new byte[] { 0 }, 1) != 1)\n                        return SZ_ERROR_WRITE;\n                }\n\n                return res;\n            }\n\n            #endregion\n        }\n\n        /* ---------- CLzmaEnc2Handle Interface ---------- */\n\n        /* Lzma2Enc_* functions can return the following exit codes:\n        Returns:\n          SZ_OK           - OK\n          SZ_ERROR_MEM    - Memory allocation error\n          SZ_ERROR_PARAM  - Incorrect paramater in props\n          SZ_ERROR_WRITE  - Write callback error\n          SZ_ERROR_PROGRESS - some break from progress callback\n          SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)\n        */\n\n        public sealed class CLzma2Enc\n        {\n            private const int LZMA2_LCLP_MAX = 4;\n\n            #region Variables\n\n            internal CLzma2EncProps mProps = new CLzma2EncProps();\n\n            internal byte[] mOutBuf;\n\n            internal ISzAlloc mAlloc;\n            internal ISzAlloc mAllocBig;\n\n            internal CLzma2EncInternal[] mCoders;\n\n#if !_7ZIP_ST\n            internal CMtCoder mMtCoder;\n#endif\n\n            #endregion\n\n            #region Public Methods\n\n            public CLzma2Enc(ISzAlloc alloc, ISzAlloc allocBig) // Lzma2Enc_Create\n            {\n                Trace.AllocSmallObject(\"CLzma2Enc\", alloc);\n\n                mProps.Lzma2EncProps_Init();\n                mProps.Lzma2EncProps_Normalize();\n                mOutBuf = null;\n                mAlloc = alloc;\n                mAllocBig = allocBig;\n\n                mCoders = new CLzma2EncInternal[NUM_MT_CODER_THREADS_MAX];\n                for (int i = 0; i < mCoders.Length; i++)\n                {\n                    mCoders[i] = new CLzma2EncInternal();\n                    mCoders[i].mEnc = null;\n                }\n\n#if !_7ZIP_ST\n                mMtCoder = new CMtCoder();\n#endif\n            }\n\n            public void Lzma2Enc_Destroy()\n            {\n                for (uint i = 0; i < mCoders.Length; i++)\n                {\n                    CLzma2EncInternal t = mCoders[i];\n                    if (t.mEnc != null)\n                    {\n                        t.mEnc.LzmaEnc_Destroy(mAlloc, mAllocBig);\n                        t.mEnc = null;\n                    }\n                }\n\n#if !_7ZIP_ST\n                mMtCoder.MtCoder_Destruct();\n#endif\n\n                IAlloc_FreeBytes(mAlloc, mOutBuf);\n                IAlloc_FreeObject(mAlloc, this);\n            }\n\n            public SRes Lzma2Enc_SetProps(CLzma2EncProps props)\n            {\n                TR(\"Lzma2Enc_SetProps:level\", props.mLzmaProps.mLevel);\n                TR(\"Lzma2Enc_SetProps:dictSize\", props.mLzmaProps.mDictSize);\n                TR(\"Lzma2Enc_SetProps:lc\", props.mLzmaProps.mLC);\n                TR(\"Lzma2Enc_SetProps:lp\", props.mLzmaProps.mLP);\n                TR(\"Lzma2Enc_SetProps:pb\", props.mLzmaProps.mPB);\n                TR(\"Lzma2Enc_SetProps:algo\", props.mLzmaProps.mAlgo);\n                TR(\"Lzma2Enc_SetProps:fb\", props.mLzmaProps.mFB);\n                TR(\"Lzma2Enc_SetProps:btMode\", props.mLzmaProps.mBtMode);\n                TR(\"Lzma2Enc_SetProps:numHashBytes\", props.mLzmaProps.mNumHashBytes);\n                TR(\"Lzma2Enc_SetProps:mc\", props.mLzmaProps.mMC);\n                TR(\"Lzma2Enc_SetProps:writeEndMark\", props.mLzmaProps.mWriteEndMark);\n                TR(\"Lzma2Enc_SetProps:numThreads\", props.mLzmaProps.mNumThreads);\n                TR(\"Lzma2Enc_SetProps:blockSize\", checked((int)props.mBlockSize));\n                TR(\"Lzma2Enc_SetProps:numBlockThreads\", props.mNumBlockThreads);\n                TR(\"Lzma2Enc_SetProps:numTotalThreads\", props.mNumTotalThreads);\n\n                CLzmaEncProps lzmaProps = new CLzmaEncProps(props.mLzmaProps);\n                lzmaProps.LzmaEncProps_Normalize();\n                if (lzmaProps.mLC + lzmaProps.mLP > LZMA2_LCLP_MAX)\n                    return SZ_ERROR_PARAM;\n\n                mProps = new CLzma2EncProps(props);\n                mProps.Lzma2EncProps_Normalize();\n                return SZ_OK;\n            }\n\n            private static uint LZMA2_DIC_SIZE_FROM_PROP(int p)\n            {\n                return (uint)(2 | (p & 1)) << (p / 2 + 11);\n            }\n\n            public byte Lzma2Enc_WriteProperties()\n            {\n                uint dicSize = mProps.mLzmaProps.LzmaEncProps_GetDictSize();\n\n                int i = 0;\n                while (i < 40 && dicSize > LZMA2_DIC_SIZE_FROM_PROP(i))\n                    i++;\n\n                TR(\"Lzma2Enc_WriteProperties\", i);\n                return (byte)i;\n            }\n\n            public SRes Lzma2Enc_Encode(ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress)\n            {\n                for (int i = 0; i < mProps.mNumBlockThreads; i++)\n                {\n                    CLzma2EncInternal t = mCoders[i];\n                    if (t.mEnc == null)\n                    {\n                        t.mEnc = LzmaEnc_Create(mAlloc);\n                        if (t.mEnc == null)\n                            return SZ_ERROR_MEM;\n                    }\n                }\n\n#if !_7ZIP_ST\n                if (mProps.mNumBlockThreads <= 1)\n#endif\n                    return mCoders[0].Lzma2Enc_EncodeMt1(this, outStream, inStream, progress);\n\n#if !_7ZIP_ST\n                mMtCoder.mProgress = progress;\n                mMtCoder.mInStream = inStream;\n                mMtCoder.mOutStream = outStream;\n                mMtCoder.mAlloc = mAlloc;\n                mMtCoder.mMtCallback = new CMtCallbackImp(this);\n\n                mMtCoder.mBlockSize = mProps.mBlockSize;\n                mMtCoder.mDestBlockSize = mProps.mBlockSize + (mProps.mBlockSize >> 10) + 16;\n                mMtCoder.mNumThreads = mProps.mNumBlockThreads;\n\n                return mMtCoder.MtCoder_Code();\n#endif\n            }\n\n            #endregion\n        }\n\n#if !_7ZIP_ST\n        internal sealed class CMtCallbackImp\n        {\n            #region Implementation\n\n            private CLzma2Enc mLzma2Enc;\n\n            internal CMtCallbackImp(CLzma2Enc enc)\n            {\n                mLzma2Enc = enc;\n            }\n\n            internal SRes Code(int index, P<byte> dest, ref long destSize, P<byte> src, long srcSize, bool finished)\n            {\n                CLzma2EncInternal p = mLzma2Enc.mCoders[index];\n\n                SRes res = SZ_OK;\n                long destLim = destSize;\n                destSize = 0;\n\n                if (srcSize != 0)\n                {\n                    if ((res = p.Lzma2EncInt_Init(mLzma2Enc.mProps)) != SZ_OK)\n                        return res;\n\n                    if ((res = p.mEnc.LzmaEnc_MemPrepare(src, srcSize, CLzma2EncInternal.LZMA2_KEEP_WINDOW_SIZE, mLzma2Enc.mAlloc, mLzma2Enc.mAllocBig)) != SZ_OK)\n                        return res;\n\n                    while (p.mSrcPos < (ulong)srcSize)\n                    {\n                        long packSize = destLim - destSize;\n\n                        res = p.Lzma2EncInt_EncodeSubblock(dest + destSize, ref packSize, null);\n                        if (res != SZ_OK)\n                            break;\n\n                        destSize += packSize;\n\n                        if (packSize == 0)\n                        {\n                            res = SZ_ERROR_FAIL;\n                            break;\n                        }\n\n                        if (mLzma2Enc.mMtCoder.mMtProgress.MtProgress_Set(index, p.mSrcPos, (ulong)destSize) != SZ_OK)\n                        {\n                            res = SZ_ERROR_PROGRESS;\n                            break;\n                        }\n                    }\n\n                    p.mEnc.LzmaEnc_Finish();\n                    if (res != SZ_OK)\n                        return res;\n                }\n\n                if (finished)\n                {\n                    if (destSize == destLim)\n                        return SZ_ERROR_OUTPUT_EOF;\n\n                    dest[destSize++] = 0;\n                }\n\n                return res;\n            }\n\n            #endregion\n        }\n#endif\n    }\n    partial class LZMA\n    {\n        /* ---------- LZMA Properties ---------- */\n\n        public sealed class CLzmaProps\n        {\n            private const int LZMA_DIC_MIN = (1 << 12);\n\n            #region Variables\n\n            public int mLC;\n            public int mLP;\n            public int mPB;\n            public uint mDicSize;\n\n            #endregion\n\n            #region Methods\n\n            public CLzmaProps() { }\n            public CLzmaProps(CLzmaProps other)\n            {\n                this.mLC = other.mLC;\n                this.mLP = other.mLP;\n                this.mPB = other.mPB;\n                this.mDicSize = other.mDicSize;\n            }\n\n            /* LzmaProps_Decode - decodes properties\n            Returns:\n              SZ_OK\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n            */\n\n            public SRes LzmaProps_Decode(P<byte> data, uint size)\n            {\n                if (size < LZMA_PROPS_SIZE)\n                    return SZ_ERROR_UNSUPPORTED;\n\n                uint dicSize = data[1] | ((uint)data[2] << 8) | ((uint)data[3] << 16) | ((uint)data[4] << 24);\n                if (dicSize < LZMA_DIC_MIN)\n                    dicSize = LZMA_DIC_MIN;\n                mDicSize = dicSize;\n\n                byte d = data[0];\n                if (d >= (9 * 5 * 5))\n                    return SZ_ERROR_UNSUPPORTED;\n\n                mLC = d % 9;\n                d /= 9;\n                mPB = d / 5;\n                mLP = d % 5;\n\n                return SZ_OK;\n            }\n\n            #endregion\n        }\n\n\n        /* ---------- LZMA Decoder state ---------- */\n\n        /* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.\n           Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */\n\n        public const int LZMA_REQUIRED_INPUT_MAX = 20;\n\n        public sealed class CLzmaDec\n        {\n            #region Constants\n\n            private enum ELzmaDummy\n            {\n                DUMMY_ERROR, /* unexpected end of input stream */\n                DUMMY_LIT,\n                DUMMY_MATCH,\n                DUMMY_REP,\n            }\n\n            private const int kNumTopBits = 24;\n            private const uint kTopValue = (1u << kNumTopBits);\n\n            private const int kNumBitModelTotalBits = 11;\n            private const int kBitModelTotal = (1 << kNumBitModelTotalBits);\n            private const int kNumMoveBits = 5;\n\n            private const int RC_INIT_SIZE = 5;\n\n            private const int kNumPosBitsMax = 4;\n            private const int kNumPosStatesMax = (1 << kNumPosBitsMax);\n\n            private const int kLenNumLowBits = 3;\n            private const int kLenNumLowSymbols = (1 << kLenNumLowBits);\n            private const int kLenNumMidBits = 3;\n            private const int kLenNumMidSymbols = (1 << kLenNumMidBits);\n            private const int kLenNumHighBits = 8;\n            private const int kLenNumHighSymbols = (1 << kLenNumHighBits);\n\n            private const int kLenChoice = 0;\n            private const int kLenChoice2 = (kLenChoice + 1);\n            private const int kLenLow = (kLenChoice2 + 1);\n            private const int kLenMid = (kLenLow + (kNumPosStatesMax << kLenNumLowBits));\n            private const int kLenHigh = (kLenMid + (kNumPosStatesMax << kLenNumMidBits));\n            private const int kNumLenProbs = (kLenHigh + kLenNumHighSymbols);\n\n\n            private const int kNumStates = 12;\n            private const uint kNumLitStates = 7;\n\n            private const int kStartPosModelIndex = 4;\n            private const int kEndPosModelIndex = 14;\n            private const int kNumFullDistances = (1 << (kEndPosModelIndex >> 1));\n\n            private const int kNumPosSlotBits = 6;\n            private const int kNumLenToPosStates = 4;\n\n            private const int kNumAlignBits = 4;\n            private const int kAlignTableSize = (1 << kNumAlignBits);\n\n            private const int kMatchMinLen = 2;\n            private const int kMatchSpecLenStart = (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols);\n\n            private const int kIsMatch = 0;\n            private const int kIsRep = (kIsMatch + (kNumStates << kNumPosBitsMax));\n            private const int kIsRepG0 = (kIsRep + kNumStates);\n            private const int kIsRepG1 = (kIsRepG0 + kNumStates);\n            private const int kIsRepG2 = (kIsRepG1 + kNumStates);\n            private const int kIsRep0Long = (kIsRepG2 + kNumStates);\n            private const int kPosSlot = (kIsRep0Long + (kNumStates << kNumPosBitsMax));\n            private const int kSpecPos = (kPosSlot + (kNumLenToPosStates << kNumPosSlotBits));\n            private const int kAlign = (kSpecPos + kNumFullDistances - kEndPosModelIndex);\n            private const int kLenCoder = (kAlign + kAlignTableSize);\n            private const int kRepLenCoder = (kLenCoder + kNumLenProbs);\n            private const int kLiteral = (kRepLenCoder + kNumLenProbs);\n\n            private const uint LZMA_BASE_SIZE = 1846;\n            private const uint LZMA_LIT_SIZE = 768;\n\n            #endregion\n\n            #region Variables\n\n            internal CLzmaProps mProp = new CLzmaProps();\n            internal ushort[] mProbs;\n            internal P<byte> mDic;\n            internal P<byte> mBuf;\n            internal uint mRange, mCode;\n            internal long mDicPos;\n            internal long mDicBufSize;\n            internal uint mProcessedPos;\n            internal uint mCheckDicSize;\n            internal uint mState;\n            internal uint[] mReps = new uint[4];\n            internal uint mRemainLen;\n            internal bool mNeedFlush;\n            internal bool mNeedInitState;\n            internal uint mNumProbs;\n            internal uint mTempBufSize;\n            internal byte[] mTempBuf = new byte[LZMA_REQUIRED_INPUT_MAX];\n\n            #endregion\n\n            #region Public Methods\n\n            public void LzmaDec_Construct()\n            {\n                //#if Literal != LZMA_BASE_SIZE\n                //StopCompilingDueBUG\n                //#endif\n\n                mDic = null;\n                mProbs = null;\n            }\n\n            public void LzmaDec_Init()\n            {\n                mDicPos = 0;\n                LzmaDec_InitDicAndState(true, true);\n            }\n\n            /* ---------- Interfaces ---------- */\n\n            /* There are 3 levels of interfaces:\n                 1) Dictionary Interface\n                 2) Buffer Interface\n                 3) One Call Interface\n               You can select any of these interfaces, but don't mix functions from different\n               groups for same object. */\n\n\n            /* There are two variants to allocate state for Dictionary Interface:\n                 1) LzmaDec_Allocate / LzmaDec_Free\n                 2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs\n               You can use variant 2, if you set dictionary buffer manually.\n               For Buffer Interface you must always use variant 1.\n\n            LzmaDec_Allocate* can return:\n              SZ_OK\n              SZ_ERROR_MEM         - Memory allocation error\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n            */\n\n            public SRes LzmaDec_AllocateProbs(P<byte> props, uint propsSize, ISzAlloc alloc)\n            {\n                SRes res;\n                CLzmaProps propNew = new CLzmaProps();\n                if ((res = propNew.LzmaProps_Decode(props, propsSize)) != SZ_OK) return res;\n                if ((res = LzmaDec_AllocateProbs2(propNew, alloc)) != SZ_OK) return res;\n                mProp = new CLzmaProps(propNew);\n                return SZ_OK;\n            }\n\n            public void LzmaDec_FreeProbs(ISzAlloc alloc)\n            {\n                alloc.FreeUInt16(alloc, mProbs);\n                mProbs = null;\n            }\n\n            public SRes LzmaDec_Allocate(P<byte> props, uint propsSize, ISzAlloc alloc)\n            {\n                CLzmaProps propNew = new CLzmaProps();\n\n                SRes res;\n                if ((res = propNew.LzmaProps_Decode(props, propsSize)) != SZ_OK)\n                    return res;\n\n                if ((res = LzmaDec_AllocateProbs2(propNew, alloc)) != SZ_OK)\n                    return res;\n\n                long dicBufSize = propNew.mDicSize;\n                if (mDic == null || dicBufSize != mDicBufSize)\n                {\n                    LzmaDec_FreeDict(alloc);\n                    mDic = alloc.AllocBytes(alloc, dicBufSize);\n                    if (mDic == null)\n                    {\n                        LzmaDec_FreeProbs(alloc);\n                        return SZ_ERROR_MEM;\n                    }\n                }\n\n                mDicBufSize = dicBufSize;\n                mProp = new CLzmaProps(propNew);\n                return SZ_OK;\n            }\n\n            public void LzmaDec_Free(ISzAlloc alloc)\n            {\n                LzmaDec_FreeProbs(alloc);\n                LzmaDec_FreeDict(alloc);\n            }\n\n            /* ---------- Dictionary Interface ---------- */\n\n            /* You can use it, if you want to eliminate the overhead for data copying from\n               dictionary to some other external buffer.\n               You must work with CLzmaDec variables directly in this interface.\n\n               STEPS:\n                 LzmaDec_Constr()\n                 LzmaDec_Allocate()\n                 for (each new stream)\n                 {\n                   LzmaDec_Init()\n                   while (it needs more decompression)\n                   {\n                     LzmaDec_DecodeToDic()\n                     use data from CLzmaDec::dic and update CLzmaDec::dicPos\n                   }\n                 }\n                 LzmaDec_Free()\n            */\n\n            /* LzmaDec_DecodeToDic\n   \n               The decoding to internal dictionary buffer (CLzmaDec::dic).\n               You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!\n\n            finishMode:\n              It has meaning only if the decoding reaches output limit (dicLimit).\n              LZMA_FINISH_ANY - Decode just dicLimit bytes.\n              LZMA_FINISH_END - Stream must be finished after dicLimit.\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n                  LZMA_STATUS_NEEDS_MORE_INPUT\n                  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK\n              SZ_ERROR_DATA - Data error\n            */\n\n            public SRes LzmaDec_DecodeToDic(long dicLimit, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long inSize = srcLen;\n                srcLen = 0;\n\n                LzmaDec_WriteRem(dicLimit);\n\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                while (mRemainLen != kMatchSpecLenStart)\n                {\n                    if (mNeedFlush)\n                    {\n                        while (inSize > 0 && mTempBufSize < RC_INIT_SIZE)\n                        {\n                            mTempBuf[mTempBufSize] = src[0];\n                            mTempBufSize++;\n                            src++;\n                            srcLen++;\n                            inSize--;\n                        }\n\n                        if (mTempBufSize < RC_INIT_SIZE)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                            return SZ_OK;\n                        }\n\n                        if (mTempBuf[0] != 0)\n                            return SZ_ERROR_DATA;\n\n                        LzmaDec_InitRc(mTempBuf);\n                        mTempBufSize = 0;\n                    }\n\n                    bool checkEndMarkNow = false;\n\n                    if (mDicPos >= dicLimit)\n                    {\n                        if (mRemainLen == 0 && mCode == 0)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;\n                            return SZ_OK;\n                        }\n\n                        if (finishMode == ELzmaFinishMode.LZMA_FINISH_ANY)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                            return SZ_OK;\n                        }\n\n                        if (mRemainLen != 0)\n                        {\n                            status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                            return SZ_ERROR_DATA;\n                        }\n\n                        checkEndMarkNow = true;\n                    }\n\n                    if (mNeedInitState)\n                        LzmaDec_InitStateReal();\n\n                    if (mTempBufSize == 0)\n                    {\n                        P<byte> bufLimit;\n                        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)\n                        {\n                            ELzmaDummy dummyRes = LzmaDec_TryDummy(src, inSize);\n\n                            if (dummyRes == ELzmaDummy.DUMMY_ERROR)\n                            {\n                                CUtils.memcpy(mTempBuf, src, inSize);\n                                mTempBufSize = (uint)inSize;\n                                srcLen += inSize;\n                                status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                                return SZ_OK;\n                            }\n\n                            if (checkEndMarkNow && dummyRes != ELzmaDummy.DUMMY_MATCH)\n                            {\n                                status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                                return SZ_ERROR_DATA;\n                            }\n\n                            bufLimit = src;\n                        }\n                        else\n                        {\n                            bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;\n                        }\n\n                        mBuf = src;\n\n                        if (LzmaDec_DecodeReal2(dicLimit, bufLimit) != 0)\n                            return SZ_ERROR_DATA;\n\n                        long processed = mBuf - src;\n                        srcLen += processed;\n                        src += processed;\n                        inSize -= processed;\n                    }\n                    else\n                    {\n                        uint rem = mTempBufSize;\n                        uint lookAhead = 0;\n\n                        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)\n                            mTempBuf[rem++] = src[lookAhead++];\n\n                        mTempBufSize = rem;\n\n                        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)\n                        {\n                            ELzmaDummy dummyRes = LzmaDec_TryDummy(mTempBuf, rem);\n\n                            if (dummyRes == ELzmaDummy.DUMMY_ERROR)\n                            {\n                                srcLen += lookAhead;\n                                status = ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT;\n                                return SZ_OK;\n                            }\n\n                            if (checkEndMarkNow && dummyRes != ELzmaDummy.DUMMY_MATCH)\n                            {\n                                status = ELzmaStatus.LZMA_STATUS_NOT_FINISHED;\n                                return SZ_ERROR_DATA;\n                            }\n                        }\n\n                        mBuf = mTempBuf;\n\n                        if (LzmaDec_DecodeReal2(dicLimit, mBuf) != 0)\n                            return SZ_ERROR_DATA;\n\n                        lookAhead -= rem - (uint)(mBuf - mTempBuf);\n                        srcLen += lookAhead;\n                        src += lookAhead;\n                        inSize -= lookAhead;\n                        mTempBufSize = 0;\n                    }\n                }\n\n                if (mCode != 0)\n                    return SZ_ERROR_DATA;\n\n                status = ELzmaStatus.LZMA_STATUS_FINISHED_WITH_MARK;\n                return SZ_OK;\n            }\n\n\n            /* ---------- Buffer Interface ---------- */\n\n            /* It's zlib-like interface.\n               See LzmaDec_DecodeToDic description for information about STEPS and return results,\n               but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need\n               to work with CLzmaDec variables manually.\n\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen).\n              LZMA_FINISH_ANY - Decode just destLen bytes.\n              LZMA_FINISH_END - Stream must be finished after (*destLen).\n            */\n\n            public SRes LzmaDec_DecodeToBuf(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, ELzmaFinishMode finishMode, out ELzmaStatus status)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                srcLen = destLen = 0;\n                for (;;)\n                {\n                    long inSizeCur = inSize;\n\n                    if (mDicPos == mDicBufSize)\n                        mDicPos = 0;\n                    long dicPos = mDicPos;\n\n                    long outSizeCur;\n                    ELzmaFinishMode curFinishMode;\n                    if (outSize > mDicBufSize - dicPos)\n                    {\n                        outSizeCur = mDicBufSize;\n                        curFinishMode = ELzmaFinishMode.LZMA_FINISH_ANY;\n                    }\n                    else\n                    {\n                        outSizeCur = dicPos + outSize;\n                        curFinishMode = finishMode;\n                    }\n\n                    SRes res = LzmaDec_DecodeToDic(outSizeCur, src, ref inSizeCur, curFinishMode, out status);\n                    src += inSizeCur;\n                    inSize -= inSizeCur;\n                    srcLen += inSizeCur;\n                    outSizeCur = mDicPos - dicPos;\n                    CUtils.memcpy(dest, mDic + dicPos, outSizeCur);\n                    dest += outSizeCur;\n                    outSize -= outSizeCur;\n                    destLen += outSizeCur;\n                    if (res != SZ_OK)\n                        return res;\n                    if (outSizeCur == 0 || outSize == 0)\n                        return SZ_OK;\n                }\n            }\n\n\n            /* ---------- One Call Interface ---------- */\n\n            /* LzmaDecode\n\n            finishMode:\n              It has meaning only if the decoding reaches output limit (*destLen).\n              LZMA_FINISH_ANY - Decode just destLen bytes.\n              LZMA_FINISH_END - Stream must be finished after (*destLen).\n\n            Returns:\n              SZ_OK\n                status:\n                  LZMA_STATUS_FINISHED_WITH_MARK\n                  LZMA_STATUS_NOT_FINISHED\n                  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK\n              SZ_ERROR_DATA - Data error\n              SZ_ERROR_MEM  - Memory allocation error\n              SZ_ERROR_UNSUPPORTED - Unsupported properties\n              SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).\n            */\n\n            public static SRes LzmaDecode(P<byte> dest, ref long destLen, P<byte> src, ref long srcLen, P<byte> propData, uint propSize, ELzmaFinishMode finishMode, out ELzmaStatus status, ISzAlloc alloc)\n            {\n                long outSize = destLen;\n                long inSize = srcLen;\n                destLen = 0;\n                srcLen = 0;\n                status = ELzmaStatus.LZMA_STATUS_NOT_SPECIFIED;\n\n                if (inSize < RC_INIT_SIZE)\n                    return SZ_ERROR_INPUT_EOF;\n\n                CLzmaDec decoder = new CLzmaDec();\n                decoder.LzmaDec_Construct();\n\n                SRes res;\n                if ((res = decoder.LzmaDec_AllocateProbs(propData, propSize, alloc)) != SZ_OK)\n                    return res;\n\n                decoder.mDic = dest;\n                decoder.mDicBufSize = outSize;\n                decoder.LzmaDec_Init();\n                srcLen = inSize;\n\n                res = decoder.LzmaDec_DecodeToDic(outSize, src, ref srcLen, finishMode, out status);\n\n                destLen = decoder.mDicPos;\n\n                if (res == SZ_OK && status == ELzmaStatus.LZMA_STATUS_NEEDS_MORE_INPUT)\n                    res = SZ_ERROR_INPUT_EOF;\n\n                decoder.LzmaDec_FreeProbs(alloc);\n                return res;\n            }\n\n            #endregion\n\n            #region Internal Methods\n\n            internal void LzmaDec_InitDicAndState(bool initDic, bool initState)\n            {\n                mNeedFlush = true;\n                mRemainLen = 0;\n                mTempBufSize = 0;\n\n                if (initDic)\n                {\n                    mProcessedPos = 0;\n                    mCheckDicSize = 0;\n                    mNeedInitState = true;\n                }\n\n                if (initState)\n                    mNeedInitState = true;\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            /* First LZMA-symbol is always decoded.\n            And it decodes new LZMA-symbols while (buf < bufLimit), but \"buf\" is without last normalization\n            Out:\n              Result:\n                SZ_OK - OK\n                SZ_ERROR_DATA - Error\n              p.remainLen:\n                < kMatchSpecLenStart : normal remain\n                = kMatchSpecLenStart : finished\n                = kMatchSpecLenStart + 1 : Flush marker\n                = kMatchSpecLenStart + 2 : State Init Marker\n            */\n\n            private SRes LzmaDec_DecodeReal(long limit, P<byte> bufLimit)\n            {\n                P<ushort> probs = mProbs;\n\n                uint state = mState;\n                uint rep0 = mReps[0];\n                uint rep1 = mReps[1];\n                uint rep2 = mReps[2];\n                uint rep3 = mReps[3];\n                uint pbMask = (1u << mProp.mPB) - 1;\n                uint lpMask = (1u << mProp.mLP) - 1;\n                int lc = mProp.mLC;\n\n                P<byte> dic = mDic;\n                long dicBufSize = mDicBufSize;\n                long dicPos = mDicPos;\n\n                uint processedPos = mProcessedPos;\n                uint checkDicSize = mCheckDicSize;\n                uint len = 0;\n\n                P<byte> buf = mBuf;\n                uint range = mRange;\n                uint code = mCode;\n\n                do\n                {\n                    uint bound;\n                    uint ttt;\n                    uint posState = processedPos & pbMask;\n\n                    P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;\n                    if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                    {\n                        _UPDATE_0(prob, ttt, bound, ref range);\n                        prob = probs + kLiteral;\n                        if (checkDicSize != 0 || processedPos != 0)\n                            prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc)\n                                + (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));\n\n                        uint symbol;\n                        if (state < kNumLitStates)\n                        {\n                            state -= (state < 4) ? state : 3;\n                            symbol = 1;\n                            do { _GET_BIT(prob + symbol, ref symbol, out ttt, out bound, ref range, ref code, ref buf); }\n                            while (symbol < 0x100);\n                        }\n                        else\n                        {\n                            uint matchByte = mDic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];\n                            uint offs = 0x100;\n                            state -= (state < 10) ? 3u : 6u;\n                            symbol = 1;\n                            do\n                            {\n                                uint bit;\n                                P<ushort> probLit;\n                                matchByte <<= 1;\n                                bit = (matchByte & offs);\n                                probLit = prob + offs + bit + symbol;\n                                if (_GET_BIT2(probLit, ref symbol, out ttt, out bound, ref range, ref code, ref buf))\n                                    offs &= bit;\n                                else\n                                    offs &= ~bit;\n                            }\n                            while (symbol < 0x100);\n                        }\n                        dic[dicPos++] = (byte)symbol;\n                        processedPos++;\n                        continue;\n                    }\n                    else\n                    {\n                        _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                        prob = probs + kIsRep + state;\n                        if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                        {\n                            _UPDATE_0(prob, ttt, bound, ref range);\n                            state += kNumStates;\n                            prob = probs + kLenCoder;\n                        }\n                        else\n                        {\n                            _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                            if (checkDicSize == 0 && processedPos == 0)\n                                return SZ_ERROR_DATA;\n                            prob = probs + kIsRepG0 + state;\n                            if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                            {\n                                _UPDATE_0(prob, ttt, bound, ref range);\n                                prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;\n                                if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                                {\n                                    _UPDATE_0(prob, ttt, bound, ref range);\n                                    dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];\n                                    dicPos++;\n                                    processedPos++;\n                                    state = state < kNumLitStates ? 9u : 11u;\n                                    continue;\n                                }\n                                _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                            }\n                            else\n                            {\n                                uint distance;\n                                _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                                prob = probs + kIsRepG1 + state;\n                                if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                                {\n                                    _UPDATE_0(prob, ttt, bound, ref range);\n                                    distance = rep1;\n                                }\n                                else\n                                {\n                                    _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                                    prob = probs + kIsRepG2 + state;\n                                    if (_IF_BIT_0(prob, out ttt, out bound, ref range, ref code, ref buf))\n                                    {\n                                        _UPDATE_0(prob, ttt, bound, ref range);\n                                        distance = rep2;\n                                    }\n                                    else\n                                    {\n                                        _UPDATE_1(prob, ttt, bound, ref range, ref code);\n                                        distance = rep3;\n                                        rep3 = rep2;\n                                    }\n                                    rep2 = rep1;\n                                }\n                                rep1 = rep0;\n                                rep0 = distance;\n                            }\n                            state = state < kNumLitStates ? 8u : 11u;\n                            prob = probs + kRepLenCoder;\n                        }\n                        {\n                            uint limit2, offset;\n                            P<ushort> probLen = prob + kLenChoice;\n                            if (_IF_BIT_0(probLen, out ttt, out bound, ref range, ref code, ref buf))\n                            {\n                                _UPDATE_0(probLen, ttt, bound, ref range);\n                                probLen = prob + kLenLow + (posState << kLenNumLowBits);\n                                offset = 0;\n                                limit2 = (1 << kLenNumLowBits);\n                            }\n                            else\n                            {\n                                _UPDATE_1(probLen, ttt, bound, ref range, ref code);\n                                probLen = prob + kLenChoice2;\n                                if (_IF_BIT_0(probLen, out ttt, out bound, ref range, ref code, ref buf))\n                                {\n                                    _UPDATE_0(probLen, ttt, bound, ref range);\n                                    probLen = prob + kLenMid + (posState << kLenNumMidBits);\n                                    offset = kLenNumLowSymbols;\n                                    limit2 = (1 << kLenNumMidBits);\n                                }\n                                else\n                                {\n                                    _UPDATE_1(probLen, ttt, bound, ref range, ref code);\n                                    probLen = prob + kLenHigh;\n                                    offset = kLenNumLowSymbols + kLenNumMidSymbols;\n                                    limit2 = (1 << kLenNumHighBits);\n                                }\n                            }\n                            _TREE_DECODE(probLen, limit2, out len, out ttt, out bound, ref range, ref code, ref buf);\n                            len += offset;\n                        }\n\n                        if (state >= kNumStates)\n                        {\n                            uint distance;\n                            prob = probs + kPosSlot +\n                                ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);\n                            _TREE_6_DECODE(prob, out distance, out ttt, out bound, ref range, ref code, ref buf);\n                            if (distance >= kStartPosModelIndex)\n                            {\n                                uint posSlot = (uint)distance;\n                                int numDirectBits = (int)(((distance >> 1) - 1));\n                                distance = (2 | (distance & 1));\n                                if (posSlot < kEndPosModelIndex)\n                                {\n                                    distance <<= numDirectBits;\n                                    prob = probs + kSpecPos + distance - posSlot - 1;\n                                    {\n                                        uint mask = 1;\n                                        uint i = 1;\n                                        do\n                                        {\n                                            if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf))\n                                                distance |= mask;\n                                            mask <<= 1;\n                                        }\n                                        while (--numDirectBits != 0);\n                                    }\n                                }\n                                else\n                                {\n                                    numDirectBits -= kNumAlignBits;\n                                    do\n                                    {\n                                        _NORMALIZE(ref range, ref code, ref buf);\n                                        range >>= 1;\n\n                                        {\n                                            uint t;\n                                            code -= range;\n                                            t = (0 - ((uint)code >> 31)); /* (uint)((Int32)code >> 31) */\n                                            distance = (distance << 1) + (t + 1);\n                                            code += range & t;\n                                        }\n                                        /*\n                                        distance <<= 1;\n                                        if (code >= range)\n                                        {\n                                          code -= range;\n                                          distance |= 1;\n                                        }\n                                        */\n                                    }\n                                    while (--numDirectBits != 0);\n                                    prob = probs + kAlign;\n                                    distance <<= kNumAlignBits;\n                                    {\n                                        uint i = 1;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 1;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 2;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 4;\n                                        if (_GET_BIT2(prob + i, ref i, out ttt, out bound, ref range, ref code, ref buf)) distance |= 8;\n                                    }\n                                    if (distance == (uint)0xFFFFFFFF)\n                                    {\n                                        len += kMatchSpecLenStart;\n                                        state -= kNumStates;\n                                        break;\n                                    }\n                                }\n                            }\n                            rep3 = rep2;\n                            rep2 = rep1;\n                            rep1 = rep0;\n                            rep0 = distance + 1;\n                            if (checkDicSize == 0)\n                            {\n                                if (distance >= processedPos)\n                                    return SZ_ERROR_DATA;\n                            }\n                            else if (distance >= checkDicSize)\n                                return SZ_ERROR_DATA;\n                            state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3u;\n                        }\n\n                        len += kMatchMinLen;\n\n                        if (limit == dicPos)\n                            return SZ_ERROR_DATA;\n                        {\n                            long rem = limit - dicPos;\n                            uint curLen = ((rem < len) ? (uint)rem : len);\n                            long pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);\n\n                            processedPos += curLen;\n\n                            len -= curLen;\n                            if (pos + curLen <= dicBufSize)\n                            {\n                                P<byte> dest = dic + dicPos;\n                                long src = (long)pos - (long)dicPos;\n                                P<byte> lim = dest + curLen;\n                                dicPos += curLen;\n                                do { dest[0] = dest[src]; }\n                                while (++dest != lim);\n                            }\n                            else\n                            {\n                                do\n                                {\n                                    dic[dicPos++] = dic[pos];\n                                    if (++pos == dicBufSize)\n                                        pos = 0;\n                                }\n                                while (--curLen != 0);\n                            }\n                        }\n                    }\n                }\n                while (dicPos < limit && buf < bufLimit);\n                _NORMALIZE(ref range, ref code, ref buf);\n                mBuf = buf;\n                mRange = range;\n                mCode = code;\n                mRemainLen = len;\n                mDicPos = dicPos;\n                mProcessedPos = processedPos;\n                mReps[0] = rep0;\n                mReps[1] = rep1;\n                mReps[2] = rep2;\n                mReps[3] = rep3;\n                mState = state;\n\n                return SZ_OK;\n            }\n\n            private void LzmaDec_WriteRem(long limit)\n            {\n                if (mRemainLen != 0 && mRemainLen < kMatchSpecLenStart)\n                {\n                    P<byte> dic = mDic;\n                    long dicPos = mDicPos;\n                    long dicBufSize = mDicBufSize;\n                    uint len = mRemainLen;\n                    uint rep0 = mReps[0];\n                    if (limit - dicPos < len)\n                        len = (uint)(limit - dicPos);\n\n                    if (mCheckDicSize == 0 && mProp.mDicSize - mProcessedPos <= len)\n                        mCheckDicSize = mProp.mDicSize;\n\n                    mProcessedPos += len;\n                    mRemainLen -= len;\n\n                    while (len != 0)\n                    {\n                        len--;\n                        dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];\n                        dicPos++;\n                    }\n\n                    mDicPos = dicPos;\n                }\n            }\n\n            private SRes LzmaDec_DecodeReal2(long limit, P<byte> bufLimit)\n            {\n                do\n                {\n                    long limit2 = limit;\n                    if (mCheckDicSize == 0)\n                    {\n                        uint rem = mProp.mDicSize - mProcessedPos;\n                        if (limit - mDicPos > rem)\n                            limit2 = mDicPos + rem;\n                    }\n\n                    SRes res;\n                    if ((res = LzmaDec_DecodeReal(limit2, bufLimit)) != SZ_OK)\n                        return res;\n\n                    if (mProcessedPos >= mProp.mDicSize)\n                        mCheckDicSize = mProp.mDicSize;\n\n                    LzmaDec_WriteRem(limit);\n                }\n                while (mDicPos < limit && mBuf < bufLimit && mRemainLen < kMatchSpecLenStart);\n\n                if (mRemainLen > kMatchSpecLenStart)\n                    mRemainLen = kMatchSpecLenStart;\n\n                return SZ_OK;\n            }\n\n            private ELzmaDummy LzmaDec_TryDummy(P<byte> buf, long inSize)\n            {\n                uint range = mRange;\n                uint code = mCode;\n                P<byte> bufLimit = buf + inSize;\n                P<ushort> probs = mProbs;\n                uint state = mState;\n                ELzmaDummy res;\n\n                {\n                    bool xxx;\n\n                    uint bound;\n                    uint ttt;\n                    uint posState = mProcessedPos & ((1u << mProp.mPB) - 1);\n\n                    P<ushort> prob = probs + kIsMatch + (state << kNumPosBitsMax) + posState;\n                    if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                        return ELzmaDummy.DUMMY_ERROR;\n                    if (xxx)\n                    {\n                        _UPDATE_0_CHECK(bound, ref range);\n\n                        /* if (bufLimit - buf >= 7) return DUMMY_LIT; */\n\n                        prob = probs + kLiteral;\n                        if (mCheckDicSize != 0 || mProcessedPos != 0)\n                            prob += LZMA_LIT_SIZE *\n                                (((mProcessedPos & ((1 << mProp.mLP) - 1)) << mProp.mLC) +\n                                (mDic[(mDicPos == 0 ? mDicBufSize : mDicPos) - 1] >> (8 - mProp.mLC)));\n\n                        if (state < kNumLitStates)\n                        {\n                            uint symbol = 1;\n                            do\n                            {\n                                if (!_GET_BIT_CHECK(prob + symbol, ref symbol, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                            }\n                            while (symbol < 0x100);\n                        }\n                        else\n                        {\n                            uint matchByte = mDic[mDicPos - mReps[0] + (mDicPos < mReps[0] ? mDicBufSize : 0)];\n                            uint offs = 0x100;\n                            uint symbol = 1;\n                            do\n                            {\n                                matchByte <<= 1;\n                                uint bit = matchByte & offs;\n                                P<ushort> probLit = prob + offs + bit + symbol;\n                                if (!_GET_BIT2_CHECK(probLit, ref symbol, delegate { offs &= ~bit; }, delegate { offs &= bit; }, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                            }\n                            while (symbol < 0x100);\n                        }\n                        res = ELzmaDummy.DUMMY_LIT;\n                    }\n                    else\n                    {\n                        uint len;\n                        _UPDATE_1_CHECK(bound, ref range, ref code);\n\n                        prob = probs + kIsRep + state;\n                        if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                            return ELzmaDummy.DUMMY_ERROR;\n                        if (xxx)\n                        {\n                            _UPDATE_0_CHECK(bound, ref range);\n                            state = 0;\n                            prob = probs + kLenCoder;\n                            res = ELzmaDummy.DUMMY_MATCH;\n                        }\n                        else\n                        {\n                            _UPDATE_1_CHECK(bound, ref range, ref code);\n                            res = ELzmaDummy.DUMMY_REP;\n                            prob = probs + kIsRepG0 + state;\n                            if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            if (xxx)\n                            {\n                                _UPDATE_0_CHECK(bound, ref range);\n                                prob = probs + kIsRep0Long + (state << kNumPosBitsMax) + posState;\n                                if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                                if (xxx)\n                                {\n                                    _UPDATE_0_CHECK(bound, ref range);\n                                    if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                                        return ELzmaDummy.DUMMY_ERROR;\n                                    return ELzmaDummy.DUMMY_REP;\n                                }\n                                else\n                                {\n                                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                                }\n                            }\n                            else\n                            {\n                                _UPDATE_1_CHECK(bound, ref range, ref code);\n                                prob = probs + kIsRepG1 + state;\n                                if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                                if (xxx)\n                                {\n                                    _UPDATE_0_CHECK(bound, ref range);\n                                }\n                                else\n                                {\n                                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                                    prob = probs + kIsRepG2 + state;\n                                    if (!_IF_BIT_0_CHECK(out xxx, prob, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                        return ELzmaDummy.DUMMY_ERROR;\n                                    if (xxx)\n                                    {\n                                        _UPDATE_0_CHECK(bound, ref range);\n                                    }\n                                    else\n                                    {\n                                        _UPDATE_1_CHECK(bound, ref range, ref code);\n                                    }\n                                }\n                            }\n                            state = kNumStates;\n                            prob = probs + kRepLenCoder;\n                        }\n                        {\n                            uint limit, offset;\n                            P<ushort> probLen = prob + kLenChoice;\n                            if (!_IF_BIT_0_CHECK(out xxx, probLen, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            if (xxx)\n                            {\n                                _UPDATE_0_CHECK(bound, ref range);\n                                probLen = prob + kLenLow + (posState << kLenNumLowBits);\n                                offset = 0;\n                                limit = 1 << kLenNumLowBits;\n                            }\n                            else\n                            {\n                                _UPDATE_1_CHECK(bound, ref range, ref code);\n                                probLen = prob + kLenChoice2;\n                                if (!_IF_BIT_0_CHECK(out xxx, probLen, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                                    return ELzmaDummy.DUMMY_ERROR;\n                                if (xxx)\n                                {\n                                    _UPDATE_0_CHECK(bound, ref range);\n                                    probLen = prob + kLenMid + (posState << kLenNumMidBits);\n                                    offset = kLenNumLowSymbols;\n                                    limit = 1 << kLenNumMidBits;\n                                }\n                                else\n                                {\n                                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                                    probLen = prob + kLenHigh;\n                                    offset = kLenNumLowSymbols + kLenNumMidSymbols;\n                                    limit = 1 << kLenNumHighBits;\n                                }\n                            }\n                            if (!_TREE_DECODE_CHECK(probLen, limit, out len, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            len += offset;\n                        }\n\n                        if (state < 4)\n                        {\n                            prob = probs + kPosSlot + ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);\n                            uint posSlot;\n                            if (!_TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, out posSlot, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                return ELzmaDummy.DUMMY_ERROR;\n                            if (posSlot >= kStartPosModelIndex)\n                            {\n                                int numDirectBits = (((int)posSlot >> 1) - 1);\n\n                                /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */\n\n                                if (posSlot < kEndPosModelIndex)\n                                {\n                                    prob = probs + kSpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;\n                                }\n                                else\n                                {\n                                    numDirectBits -= kNumAlignBits;\n                                    do\n                                    {\n                                        if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                                            return ELzmaDummy.DUMMY_ERROR;\n\n                                        range >>= 1;\n\n                                        //code -= range & (((code - range) >> 31) - 1);\n                                        if (code >= range)\n                                            code -= range;\n                                    }\n                                    while (--numDirectBits != 0);\n                                    prob = probs + kAlign;\n                                    numDirectBits = kNumAlignBits;\n                                }\n                                {\n                                    uint i = 1;\n                                    do\n                                    {\n                                        if (!_GET_BIT_CHECK(prob + i, ref i, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                                            return ELzmaDummy.DUMMY_ERROR;\n                                    }\n                                    while (--numDirectBits != 0);\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                    return ELzmaDummy.DUMMY_ERROR;\n                return res;\n            }\n\n            private void LzmaDec_InitRc(P<byte> data)\n            {\n                mCode = ((uint)data[1] << 24) | ((uint)data[2] << 16) | ((uint)data[3] << 8) | ((uint)data[4]);\n                mRange = 0xFFFFFFFF;\n                mNeedFlush = false;\n            }\n\n            private void LzmaDec_InitStateReal()\n            {\n                uint numProbs = kLiteral + (LZMA_LIT_SIZE << (mProp.mLC + mProp.mLP));\n                for (uint i = 0; i < numProbs; i++)\n                    mProbs[i] = kBitModelTotal >> 1;\n                mReps[0] = 1;\n                mReps[1] = 1;\n                mReps[2] = 1;\n                mReps[3] = 1;\n                mState = 0;\n                mNeedInitState = false;\n            }\n\n            private void LzmaDec_FreeDict(ISzAlloc alloc)\n            {\n                alloc.FreeBytes(alloc, mDic.mBuffer);\n                mDic = null;\n            }\n\n            private SRes LzmaDec_AllocateProbs2(CLzmaProps propNew, ISzAlloc alloc)\n            {\n                uint numProbs = LzmaProps_GetNumProbs(propNew);\n                if (mProbs == null || numProbs != mNumProbs)\n                {\n                    LzmaDec_FreeProbs(alloc);\n                    mProbs = alloc.AllocUInt16(alloc, numProbs);\n                    mNumProbs = numProbs;\n                    if (mProbs == null)\n                        return SZ_ERROR_MEM;\n                }\n                return SZ_OK;\n            }\n\n            #endregion\n\n            #region Macros\n\n            private static void _NORMALIZE(ref uint range, ref uint code, ref P<byte> buf)\n            {\n                if (range < kTopValue)\n                {\n                    range <<= 8;\n                    code = (code << 8) | buf[0];\n                    buf++;\n                }\n            }\n\n            private static bool _IF_BIT_0(P<ushort> p, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                ttt = p[0];\n                _NORMALIZE(ref range, ref code, ref buf);\n                bound = (range >> kNumBitModelTotalBits) * ttt;\n                return code < bound;\n            }\n\n            private static void _UPDATE_0(P<ushort> p, uint ttt, uint bound, ref uint range)\n            {\n                range = bound;\n                p[0] = (ushort)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));\n            }\n\n            private static void _UPDATE_1(P<ushort> p, uint ttt, uint bound, ref uint range, ref uint code)\n            {\n                range -= bound;\n                code -= bound;\n                p[0] = (ushort)(ttt - (ttt >> kNumMoveBits));\n            }\n\n            private static bool _GET_BIT2(P<ushort> p, ref uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                if (_IF_BIT_0(p, out ttt, out bound, ref range, ref code, ref buf))\n                {\n                    _UPDATE_0(p, ttt, bound, ref range);\n                    i = (i + i);\n                    return false; // bit == 0\n                }\n                else\n                {\n                    _UPDATE_1(p, ttt, bound, ref range, ref code);\n                    i = (i + i) + 1;\n                    return true; // bit == 1\n                }\n            }\n\n            private static void _GET_BIT(P<ushort> p, ref uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                _GET_BIT2(p, ref i, out ttt, out bound, ref range, ref code, ref buf);\n            }\n\n            private static void _TREE_GET_BIT(P<ushort> probs, ref uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                _GET_BIT(probs + i, ref i, out ttt, out bound, ref range, ref code, ref buf);\n            }\n\n            private static void _TREE_DECODE(P<ushort> probs, uint limit, out uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                i = 1;\n                do { _TREE_GET_BIT(probs, ref i, out ttt, out bound, ref range, ref code, ref buf); }\n                while (i < limit);\n                i -= limit;\n            }\n\n            /* #define _LZMA_SIZE_OPT */\n\n#if _LZMA_SIZE_OPT\n            //#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)\n#else\n            //#define TREE_6_DECODE(probs, i) \\\n            //  { i = 1; \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  TREE_GET_BIT(probs, i); \\\n            //  i -= 0x40; }\n#endif\n\n            private static void _TREE_6_DECODE(P<ushort> probs, out uint i, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf)\n            {\n                _TREE_DECODE(probs, 1 << 6, out i, out ttt, out bound, ref range, ref code, ref buf);\n            }\n\n            private static bool _NORMALIZE_CHECK(ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                if (range < kTopValue)\n                {\n                    if (buf >= bufLimit)\n                        return false; // ELzmaDummy.DUMMY_ERROR;\n\n                    range <<= 8;\n                    code = (code << 8) | buf[0];\n                    buf++;\n                }\n\n                return true;\n            }\n\n            private static bool _IF_BIT_0_CHECK(out bool result, P<ushort> p, out uint ttt, out uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                ttt = p[0];\n                if (!_NORMALIZE_CHECK(ref range, ref code, ref buf, bufLimit))\n                {\n                    result = false;\n                    bound = 0;\n                    return false;\n                }\n                bound = (range >> kNumBitModelTotalBits) * ttt;\n                result = code < bound;\n                return true;\n            }\n\n            private static void _UPDATE_0_CHECK(uint bound, ref uint range)\n            {\n                range = bound;\n            }\n\n            private static void _UPDATE_1_CHECK(uint bound, ref uint range, ref uint code)\n            {\n                range -= bound;\n                code -= bound;\n            }\n\n            private static bool _GET_BIT2_CHECK(P<ushort> p, ref uint i, Action A0, Action A1, out uint ttt, ref uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                bool xxx;\n                if (!_IF_BIT_0_CHECK(out xxx, p, out ttt, out bound, ref range, ref code, ref buf, bufLimit))\n                    return false;\n                if (xxx)\n                {\n                    _UPDATE_0_CHECK(bound, ref range);\n                    i = (i + i);\n                    A0();\n                }\n                else\n                {\n                    _UPDATE_1_CHECK(bound, ref range, ref code);\n                    i = (i + i) + 1;\n                    A1();\n                }\n                return true;\n            }\n\n            private static bool _GET_BIT_CHECK(P<ushort> p, ref uint i, out uint ttt, ref uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                return _GET_BIT2_CHECK(p, ref i, delegate { }, delegate { }, out ttt, ref bound, ref range, ref code, ref buf, bufLimit);\n            }\n\n            private static bool _TREE_DECODE_CHECK(P<ushort> probs, uint limit, out uint i, out uint ttt, ref uint bound, ref uint range, ref uint code, ref P<byte> buf, P<byte> bufLimit)\n            {\n                i = 1;\n                do\n                {\n                    if (!_GET_BIT_CHECK(probs + i, ref i, out ttt, ref bound, ref range, ref code, ref buf, bufLimit))\n                        return false;\n                }\n                while (i < limit);\n                i -= limit;\n                return true;\n            }\n\n            private static uint LzmaProps_GetNumProbs(CLzmaProps p)\n            {\n                return LZMA_BASE_SIZE + (LZMA_LIT_SIZE << (p.mLC + p.mLP));\n            }\n\n            #endregion\n        }\n\n        /* There are two types of LZMA streams:\n             0) Stream with end mark. That end mark adds about 6 bytes to compressed size.\n             1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */\n\n        public enum ELzmaFinishMode\n        {\n            LZMA_FINISH_ANY,   /* finish at any point */\n            LZMA_FINISH_END    /* block must be finished at the end */\n        }\n\n        /* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!\n\n           You must use LZMA_FINISH_END, when you know that current output buffer\n           covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.\n\n           If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,\n           and output value of destLen will be less than output buffer size limit.\n           You can check status result also.\n\n           You can use multiple checks to test data integrity after full decompression:\n             1) Check Result and \"status\" variable.\n             2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.\n             3) Check that output(srcLen) = compressedSize, if you know real compressedSize.\n                You must use correct finish mode in that case. */\n\n        public enum ELzmaStatus\n        {\n            LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */\n            LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */\n            LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */\n            LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */\n            LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */\n        }\n\n        /* ELzmaStatus is used only as output value for function call */\n    }\n    partial class LZMA\n    {\n        public const int LZMA_PROPS_SIZE = 5;\n\n        public sealed class CLzmaEncProps\n        {\n            #region Variables\n\n            /// <summary>\n            /// 0 &lt;= level &lt;= 9\n            /// </summary>\n            public int mLevel;\n\n            /// <summary>\n            /// (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 27) for 32-bit version <para/>\n            /// (1 &lt;&lt; 12) &lt;= dictSize &lt;= (1 &lt;&lt; 30) for 64-bit version <para/>\n            /// default = (1 &lt;&lt; 24)\n            /// </summary>\n            public uint mDictSize;\n\n            /// <summary>\n            /// Estimated size of data that will be compressed. default = 0xFFFFFFFF.\n            /// Encoder uses this value to reduce dictionary size\n            /// </summary>\n            public uint mReduceSize;\n\n            /// <summary>\n            /// 0 &lt;= lc &lt;= 8, default = 3\n            /// </summary>\n            public int mLC;\n\n            /// <summary>\n            /// 0 &lt;= lp &lt;= 4, default = 0\n            /// </summary>\n            public int mLP;\n\n            /// <summary>\n            /// 0 &lt;= pb &lt;= 4, default = 2\n            /// </summary>\n            public int mPB;\n\n            /// <summary>\n            /// 0 - fast, 1 - normal, default = 1\n            /// </summary>\n            public int mAlgo;\n\n            /// <summary>\n            /// 5 &lt;= fb &lt;= 273, default = 32\n            /// </summary>\n            public int mFB;\n\n            /// <summary>\n            /// 0 - hashChain Mode, 1 - binTree mode - normal, default = 1\n            /// </summary>\n            public int mBtMode;\n\n            /// <summary>\n            /// 2, 3 or 4, default = 4\n            /// </summary>\n            public int mNumHashBytes;\n\n            /// <summary>\n            /// 1 &lt;= mc &lt;= (1 &lt;&lt; 30), default = 32\n            /// </summary>\n            public uint mMC;\n\n            /// <summary>\n            /// 0 - do not write EOPM, 1 - write EOPM, default = 0\n            /// </summary>\n            public uint mWriteEndMark;\n\n            /// <summary>\n            /// 1 or 2, default = 2\n            /// </summary>\n            public int mNumThreads;\n\n            #endregion\n\n            #region Private Methods\n\n            private CLzmaEncProps()\n            {\n                // was LzmaEncProps_Init\n\n                this.mLevel = 5;\n                this.mDictSize = 0;\n                this.mMC = 0;\n                this.mReduceSize = ~0u;\n                this.mLC = -1;\n                this.mLP = -1;\n                this.mPB = -1;\n                this.mAlgo = -1;\n                this.mFB = -1;\n                this.mBtMode = -1;\n                this.mNumHashBytes = -1;\n                this.mNumThreads = -1;\n                this.mWriteEndMark = 0;\n            }\n\n            #endregion\n\n            #region Public Methods\n\n            public CLzmaEncProps(CLzmaEncProps other)\n            {\n                this.mLevel = other.mLevel;\n                this.mDictSize = other.mDictSize;\n                this.mReduceSize = other.mReduceSize;\n                this.mLC = other.mLC;\n                this.mLP = other.mLP;\n                this.mPB = other.mPB;\n                this.mAlgo = other.mAlgo;\n                this.mFB = other.mFB;\n                this.mBtMode = other.mBtMode;\n                this.mNumHashBytes = other.mNumHashBytes;\n                this.mMC = other.mMC;\n                this.mWriteEndMark = other.mWriteEndMark;\n                this.mNumThreads = other.mNumThreads;\n            }\n\n            public static CLzmaEncProps LzmaEncProps_Init()\n            {\n                return new CLzmaEncProps();\n            }\n\n            public void LzmaEncProps_Normalize()\n            {\n                int level = mLevel;\n                if (level < 0)\n                    level = 5;\n                mLevel = level;\n\n                if (mDictSize == 0)\n                {\n                    if (level <= 5)\n                        mDictSize = (1u << (level * 2 + 14));\n                    else if (level == 6)\n                        mDictSize = (1u << 25);\n                    else\n                        mDictSize = (1u << 26);\n                }\n\n                if (mDictSize > mReduceSize)\n                {\n                    for (int i = 15; i <= 30; i++)\n                    {\n                        if (mReduceSize <= (2u << i))\n                        {\n                            mDictSize = (2u << i);\n                            break;\n                        }\n                        if (mReduceSize <= (3u << i))\n                        {\n                            mDictSize = (3u << i);\n                            break;\n                        }\n                    }\n                }\n\n                if (mLC < 0)\n                    mLC = 3;\n                if (mLP < 0)\n                    mLP = 0;\n                if (mPB < 0)\n                    mPB = 2;\n                if (mAlgo < 0)\n                    mAlgo = (level < 5 ? 0 : 1);\n                if (mFB < 0)\n                    mFB = (level < 7 ? 32 : 64);\n                if (mBtMode < 0)\n                    mBtMode = (mAlgo == 0 ? 0 : 1);\n                if (mNumHashBytes < 0)\n                    mNumHashBytes = 4;\n                if (mMC == 0)\n                    mMC = (16u + ((uint)mFB >> 1)) >> (mBtMode != 0 ? 0 : 1);\n                if (mNumThreads < 0)\n                    mNumThreads =\n#if !_7ZIP_ST\n                        ((mBtMode != 0 && mAlgo != 0) ? 2 : 1);\n#else\n                        1;\n#endif\n            }\n\n            #endregion\n\n            #region Internal Methods\n\n            internal uint LzmaEncProps_GetDictSize()\n            {\n                CLzmaEncProps props = new CLzmaEncProps(this);\n                props.LzmaEncProps_Normalize();\n                return props.mDictSize;\n            }\n\n            #endregion\n        }\n\n\n        /* ---------- CLzmaEncHandle Interface ---------- */\n\n        /* LzmaEnc_* functions can return the following exit codes:\n        Returns:\n          SZ_OK           - OK\n          SZ_ERROR_MEM    - Memory allocation error\n          SZ_ERROR_PARAM  - Incorrect paramater in props\n          SZ_ERROR_WRITE  - Write callback error.\n          SZ_ERROR_PROGRESS - some break from progress callback\n          SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)\n        */\n\n        #region Internal Classes\n\n        internal struct OptimumReps\n        {\n            // number of slots == LZMA_NUM_REPS\n            public uint _0, _1, _2, _3;\n\n            public uint this[uint index]\n            {\n                get\n                {\n                    switch (index)\n                    {\n                        case 0: return _0;\n                        case 1: return _1;\n                        case 2: return _2;\n                        case 3: return _3;\n                        default: throw new InvalidOperationException();\n                    }\n                }\n                set\n                {\n                    switch (index)\n                    {\n                        case 0: _0 = value; break;\n                        case 1: _1 = value; break;\n                        case 2: _2 = value; break;\n                        case 3: _3 = value; break;\n                        default: throw new InvalidOperationException();\n                    }\n                }\n            }\n        }\n\n        internal sealed class COptimal\n        {\n            internal uint mPrice;\n\n            internal uint mState; // CState\n            internal bool mPrev1IsChar;\n            internal bool mPrev2;\n\n            internal uint mPosPrev2;\n            internal uint mBackPrev2;\n\n            internal uint mPosPrev;\n            internal uint mBackPrev;\n            internal OptimumReps mBacks = new OptimumReps();\n\n            internal void MakeAsChar()\n            {\n                mBackPrev = ~0u;\n                mPrev1IsChar = false;\n            }\n\n            internal void MakeAsShortRep()\n            {\n                mBackPrev = 0;\n                mPrev1IsChar = false;\n            }\n\n            internal bool IsShortRep()\n            {\n                return mBackPrev == 0;\n            }\n        }\n\n        internal class CLenEnc\n        {\n            #region Variables\n\n            public ushort mChoice;\n            public ushort mChoice2;\n            public ushort[] mLow = new ushort[CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumLowBits];\n            public ushort[] mMid = new ushort[CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumMidBits];\n            public ushort[] mHigh = new ushort[CLzmaEnc.kLenNumHighSymbols];\n\n            #endregion\n\n            public CLenEnc() { }\n            public CLenEnc(CLenEnc other)\n            {\n                mChoice = other.mChoice;\n                mChoice2 = other.mChoice2;\n                for (int i = 0; i < mLow.Length; i++)\n                    mLow[i] = other.mLow[i];\n                for (int i = 0; i < mMid.Length; i++)\n                    mMid[i] = other.mMid[i];\n                for (int i = 0; i < mHigh.Length; i++)\n                    mHigh[i] = other.mHigh[i];\n            }\n\n            internal void LenEnc_Init()\n            {\n                mChoice = CLzmaEnc.kProbInitValue;\n                mChoice2 = CLzmaEnc.kProbInitValue;\n                for (uint i = 0; i < (CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumLowBits); i++)\n                    mLow[i] = CLzmaEnc.kProbInitValue;\n                for (uint i = 0; i < (CLzmaEnc.LZMA_NUM_PB_STATES_MAX << CLzmaEnc.kLenNumMidBits); i++)\n                    mMid[i] = CLzmaEnc.kProbInitValue;\n                for (uint i = 0; i < CLzmaEnc.kLenNumHighSymbols; i++)\n                    mHigh[i] = CLzmaEnc.kProbInitValue;\n            }\n\n            internal void LenEnc_Encode(CRangeEnc rc, uint symbol, uint posState)\n            {\n                if (symbol < CLzmaEnc.kLenNumLowSymbols)\n                {\n                    rc.RangeEnc_EncodeBit(ref mChoice, 0);\n                    CLzmaEnc.RcTree_Encode(rc, P.From(mLow, posState << CLzmaEnc.kLenNumLowBits), CLzmaEnc.kLenNumLowBits, symbol);\n                }\n                else\n                {\n                    rc.RangeEnc_EncodeBit(ref mChoice, 1);\n                    if (symbol < CLzmaEnc.kLenNumLowSymbols + CLzmaEnc.kLenNumMidSymbols)\n                    {\n                        rc.RangeEnc_EncodeBit(ref mChoice2, 0);\n                        CLzmaEnc.RcTree_Encode(rc, P.From(mMid, posState << CLzmaEnc.kLenNumMidBits), CLzmaEnc.kLenNumMidBits, symbol - CLzmaEnc.kLenNumLowSymbols);\n                    }\n                    else\n                    {\n                        rc.RangeEnc_EncodeBit(ref mChoice2, 1);\n                        CLzmaEnc.RcTree_Encode(rc, mHigh, CLzmaEnc.kLenNumHighBits, symbol - CLzmaEnc.kLenNumLowSymbols - CLzmaEnc.kLenNumMidSymbols);\n                    }\n                }\n            }\n\n            internal void LenEnc_SetPrices(uint posState, uint numSymbols, P<uint> prices, P<uint> probPrices)\n            {\n                uint a0 = CLzmaEnc.GET_PRICE_0(probPrices, mChoice);\n                uint a1 = CLzmaEnc.GET_PRICE_1(probPrices, mChoice);\n                uint b0 = a1 + CLzmaEnc.GET_PRICE_0(probPrices, mChoice2);\n                uint b1 = a1 + CLzmaEnc.GET_PRICE_1(probPrices, mChoice2);\n\n                uint i = 0;\n                for (; i < CLzmaEnc.kLenNumLowSymbols; i++)\n                {\n                    if (i >= numSymbols)\n                        return;\n                    prices[i] = a0 + CLzmaEnc.RcTree_GetPrice(P.From(mLow, posState << CLzmaEnc.kLenNumLowBits), CLzmaEnc.kLenNumLowBits, i, probPrices);\n                }\n                for (; i < CLzmaEnc.kLenNumLowSymbols + CLzmaEnc.kLenNumMidSymbols; i++)\n                {\n                    if (i >= numSymbols)\n                        return;\n                    prices[i] = b0 + CLzmaEnc.RcTree_GetPrice(P.From(mMid, posState << CLzmaEnc.kLenNumMidBits), CLzmaEnc.kLenNumMidBits, i - CLzmaEnc.kLenNumLowSymbols, probPrices);\n                }\n                for (; i < numSymbols; i++)\n                    prices[i] = b1 + CLzmaEnc.RcTree_GetPrice(mHigh, CLzmaEnc.kLenNumHighBits, i - (CLzmaEnc.kLenNumLowSymbols + CLzmaEnc.kLenNumMidSymbols), probPrices);\n            }\n        }\n\n        internal class CLenPriceEnc : CLenEnc\n        {\n            internal uint[][] mPrices;\n            internal uint mTableSize;\n            internal uint[] mCounters;\n\n            internal CLenPriceEnc()\n            {\n                mPrices = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX][];\n                for (int i = 0; i < mPrices.Length; i++)\n                    mPrices[i] = new uint[CLzmaEnc.kLenNumSymbolsTotal];\n\n                mCounters = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX];\n            }\n\n            internal CLenPriceEnc(CLenPriceEnc other)\n                : base(other)\n            {\n                mPrices = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX][];\n                for (int i = 0; i < mPrices.Length; i++)\n                {\n                    mPrices[i] = new uint[CLzmaEnc.kLenNumSymbolsTotal];\n                    for (int j = 0; j < CLzmaEnc.kLenNumSymbolsTotal; j++)\n                        mPrices[i][j] = other.mPrices[i][j];\n                }\n\n                mTableSize = other.mTableSize;\n\n                mCounters = new uint[CLzmaEnc.LZMA_NUM_PB_STATES_MAX];\n                for (int i = 0; i < mCounters.Length; i++)\n                    mCounters[i] = other.mCounters[i];\n            }\n\n            private void LenPriceEnc_UpdateTable(uint posState, P<uint> probPrices)\n            {\n                LenEnc_SetPrices(posState, mTableSize, mPrices[posState], probPrices);\n                mCounters[posState] = mTableSize;\n            }\n\n            internal void LenPriceEnc_UpdateTables(uint numPosStates, P<uint> probPrices)\n            {\n                for (uint posState = 0; posState < numPosStates; posState++)\n                    LenPriceEnc_UpdateTable(posState, probPrices);\n            }\n\n            internal void LenEnc_Encode2(CRangeEnc rc, uint symbol, uint posState, bool updatePrice, P<uint> probPrices)\n            {\n                LenEnc_Encode(rc, symbol, posState);\n\n                if (updatePrice)\n                {\n                    if (--mCounters[posState] == 0)\n                        LenPriceEnc_UpdateTable(posState, probPrices);\n                }\n            }\n        }\n\n        internal sealed class CRangeEnc\n        {\n            #region Constants\n\n            private const int kBufferSize = (1 << 16);\n\n            #endregion\n\n            #region Variables\n\n            public uint mRange;\n            public byte mCache;\n            public ulong mLow;\n            public ulong mCacheSize;\n            public P<byte> mBuf;\n            public P<byte> mBufLim;\n            public P<byte> mBufBase;\n            public ISeqOutStream mOutStream;\n            public ulong mProcessed;\n            public SRes mRes;\n\n            #endregion\n\n            internal void RangeEnc_Construct()\n            {\n                mOutStream = null;\n                mBufBase = null;\n            }\n\n            internal ulong RangeEnc_GetProcessed()\n            {\n                return mProcessed + (uint)(mBuf - mBufBase) + mCacheSize;\n            }\n\n            internal bool RangeEnc_Alloc(ISzAlloc alloc)\n            {\n                if (mBufBase == null)\n                {\n                    mBufBase = alloc.AllocBytes(alloc, kBufferSize);\n                    if (mBufBase == null)\n                        return false;\n\n                    mBufLim = mBufBase + kBufferSize;\n                }\n\n                return true;\n            }\n\n            internal void RangeEnc_Free(ISzAlloc alloc)\n            {\n                alloc.FreeBytes(alloc, mBufBase.mBuffer);\n                mBufBase = null;\n            }\n\n            internal void RangeEnc_Init()\n            {\n                /* Stream.Init(); */\n                mLow = 0;\n                mRange = 0xFFFFFFFF;\n                mCacheSize = 1;\n                mCache = 0;\n\n                mBuf = mBufBase;\n\n                mProcessed = 0;\n                mRes = SZ_OK;\n            }\n\n            internal void RangeEnc_FlushStream()\n            {\n                if (mRes != SZ_OK)\n                    return;\n\n                long num = mBuf - mBufBase;\n                if (num != mOutStream.Write(mBufBase, num))\n                    mRes = SZ_ERROR_WRITE;\n\n                mProcessed += (ulong)num;\n                mBuf = mBufBase;\n            }\n\n            internal void RangeEnc_ShiftLow()\n            {\n                if ((uint)mLow < (uint)0xFF000000 || (int)(mLow >> 32) != 0)\n                {\n                    byte temp = mCache;\n                    do\n                    {\n                        P<byte> buf = mBuf;\n                        buf[0] = (byte)(temp + (byte)(mLow >> 32));\n                        buf++;\n                        mBuf = buf;\n                        if (buf == mBufLim)\n                            RangeEnc_FlushStream();\n                        temp = 0xFF;\n                    }\n                    while (--mCacheSize != 0);\n\n                    mCache = (byte)((uint)mLow >> 24);\n                }\n\n                mCacheSize++;\n                mLow = (uint)mLow << 8;\n            }\n\n            internal void RangeEnc_FlushData()\n            {\n                for (int i = 0; i < 5; i++)\n                    RangeEnc_ShiftLow();\n            }\n\n            internal void RangeEnc_EncodeDirectBits(uint value, int numBits)\n            {\n                do\n                {\n                    mRange >>= 1;\n                    mLow += mRange & (0 - ((value >> --numBits) & 1));\n                    if (mRange < CLzmaEnc.kTopValue)\n                    {\n                        mRange <<= 8;\n                        RangeEnc_ShiftLow();\n                    }\n                }\n                while (numBits != 0);\n            }\n\n            internal void RangeEnc_EncodeBit(P<ushort> prob, uint symbol)\n            { RangeEnc_EncodeBit(ref prob.mBuffer[prob.mOffset], symbol); }\n            internal void RangeEnc_EncodeBit(ref ushort prob, uint symbol)\n            {\n                uint temp = prob;\n\n                uint newBound = (mRange >> CLzmaEnc.kNumBitModelTotalBits) * temp;\n                if (symbol == 0)\n                {\n                    mRange = newBound;\n                    temp += (CLzmaEnc.kBitModelTotal - temp) >> CLzmaEnc.kNumMoveBits;\n                }\n                else\n                {\n                    mLow += newBound;\n                    mRange -= newBound;\n                    temp -= temp >> CLzmaEnc.kNumMoveBits;\n                }\n\n                prob = (ushort)temp;\n\n                if (mRange < CLzmaEnc.kTopValue)\n                {\n                    mRange <<= 8;\n                    RangeEnc_ShiftLow();\n                }\n            }\n        }\n\n        internal sealed class CSaveState\n        {\n            #region Variables\n\n            public ushort[] mLitProbs;\n\n            public ushort[][] mIsMatch = CUtils.Init<ushort>(CLzmaEnc.kNumStates, CLzmaEnc.LZMA_NUM_PB_STATES_MAX);\n            public ushort[] mIsRep = new ushort[CLzmaEnc.kNumStates];\n            public ushort[] mIsRepG0 = new ushort[CLzmaEnc.kNumStates];\n            public ushort[] mIsRepG1 = new ushort[CLzmaEnc.kNumStates];\n            public ushort[] mIsRepG2 = new ushort[CLzmaEnc.kNumStates];\n            public ushort[][] mIsRep0Long = CUtils.Init<ushort>(CLzmaEnc.kNumStates, CLzmaEnc.LZMA_NUM_PB_STATES_MAX);\n\n            public ushort[][] mPosSlotEncoder = CUtils.Init<ushort>(CLzmaEnc.kNumLenToPosStates, 1 << CLzmaEnc.kNumPosSlotBits);\n            public ushort[] mPosEncoders = new ushort[CLzmaEnc.kNumFullDistances - CLzmaEnc.kEndPosModelIndex];\n            public ushort[] mPosAlignEncoder = new ushort[1 << CLzmaEnc.kNumAlignBits];\n\n            public CLenPriceEnc mLenEnc = new CLenPriceEnc();\n            public CLenPriceEnc mRepLenEnc = new CLenPriceEnc();\n\n            public OptimumReps mReps = new OptimumReps();\n            public uint mState;\n\n            #endregion\n        }\n\n        #endregion\n\n        public sealed class CLzmaEnc\n        {\n            #region Constants\n\n#if SHOW_STAT\n            private static int ttt = 0;\n#endif\n\n            private const int kBlockSize = 9 << 10;\n            private const int kUnpackBlockSize = 1 << 18;\n            private const int kMatchArraySize = 1 << 21;\n            private const int kMatchRecordMaxSize = ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX);\n\n            private const int kNumMaxDirectBits = 31;\n\n            private const int kNumTopBits = 24;\n            internal const uint kTopValue = 1u << kNumTopBits;\n\n            internal const int kNumBitModelTotalBits = 11;\n            internal const int kBitModelTotal = 1 << kNumBitModelTotalBits;\n            internal const int kNumMoveBits = 5;\n            internal const int kProbInitValue = kBitModelTotal >> 1;\n\n            private const int kNumMoveReducingBits = 4;\n            private const int kNumBitPriceShiftBits = 4;\n            private const int kBitPrice = 1 << kNumBitPriceShiftBits;\n\n            private const int kNumLogBits = (9 + sizeof(long) / 2); // that was sizeof(size_t)\n            private const int kDicLogSizeMaxCompress = ((kNumLogBits - 1) * 2 + 7);\n\n            internal void LzmaEnc_FastPosInit()\n            {\n                mFastPos[0] = 0;\n                mFastPos[1] = 1;\n\n                int i = 2;\n                for (int slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)\n                {\n                    int k = 1 << ((slotFast >> 1) - 1);\n                    for (int j = 0; j < k; j++)\n                        mFastPos[i++] = (byte)slotFast;\n                }\n            }\n\n            private uint BSR2_RET(uint pos)\n            {\n                //return (pos < (1 << (6 + kNumLogBits)))\n                //    ? mFastPos[pos >> 6] + 12u\n                //    : mFastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2u;\n\n                uint i = 6 + ((kNumLogBits - 1) & (0 - ((((1 << (kNumLogBits + 6)) - 1) - pos) >> 31)));\n                return mFastPos[pos >> (int)i] + (i * 2);\n            }\n\n            private byte GetPosSlot1(uint pos)\n            {\n                return mFastPos[pos];\n            }\n\n            private uint GetPosSlot2(uint pos)\n            {\n                return BSR2_RET(pos);\n            }\n\n            private uint GetPosSlot(uint pos)\n            {\n                if (pos < kNumFullDistances)\n                    return mFastPos[pos];\n                else\n                    return BSR2_RET(pos);\n            }\n\n            internal const int LZMA_NUM_REPS = 4;\n\n            private const int kNumOpts = (1 << 12);\n\n            internal const int kNumLenToPosStates = 4;\n            internal const int kNumPosSlotBits = 6;\n            private const int kDicLogSizeMin = 0;\n            private const int kDicLogSizeMax = 32;\n            private const int kDistTableSizeMax = (kDicLogSizeMax * 2);\n\n\n            internal const int kNumAlignBits = 4;\n            private const int kAlignTableSize = (1 << kNumAlignBits);\n            private const int kAlignMask = (kAlignTableSize - 1);\n\n            private const int kStartPosModelIndex = 4;\n            internal const int kEndPosModelIndex = 14;\n            private const int kNumPosModels = (kEndPosModelIndex - kStartPosModelIndex);\n\n            internal const int kNumFullDistances = (1 << (kEndPosModelIndex >> 1));\n\n            private const int LZMA_PB_MAX = 4;\n            private const int LZMA_LC_MAX = 8;\n            private const int LZMA_LP_MAX = 4;\n\n            internal const int LZMA_NUM_PB_STATES_MAX = (1 << LZMA_PB_MAX);\n\n\n            internal const int kLenNumLowBits = 3;\n            internal const int kLenNumLowSymbols = (1 << kLenNumLowBits);\n            internal const int kLenNumMidBits = 3;\n            internal const int kLenNumMidSymbols = (1 << kLenNumMidBits);\n            internal const int kLenNumHighBits = 8;\n            internal const int kLenNumHighSymbols = (1 << kLenNumHighBits);\n\n            internal const int kLenNumSymbolsTotal = (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols);\n\n            private const int LZMA_MATCH_LEN_MIN = 2;\n            private const int LZMA_MATCH_LEN_MAX = (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1);\n\n            internal const int kNumStates = 12;\n\n            private static readonly uint[] kLiteralNextStates = new uint[kNumStates] { 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 4, 5 };\n            private static readonly uint[] kMatchNextStates = new uint[kNumStates] { 7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10 };\n            private static readonly uint[] kRepNextStates = new uint[kNumStates] { 8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11 };\n            private static readonly uint[] kShortRepNextStates = new uint[kNumStates] { 9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11 };\n\n            private static bool IsCharState(uint s)\n            {\n                return s < 7;\n            }\n\n            private static uint GetLenToPosState(uint len)\n            {\n                return (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1);\n            }\n\n            private const int kInfinityPrice = (1 << 30);\n\n            private static void LitEnc_Encode(CRangeEnc p, P<ushort> probs, uint symbol)\n            {\n                symbol |= 0x100;\n                do\n                {\n                    p.RangeEnc_EncodeBit(probs + (symbol >> 8), (symbol >> 7) & 1);\n                    symbol <<= 1;\n                }\n                while (symbol < 0x10000);\n            }\n\n            private static void LitEnc_EncodeMatched(CRangeEnc p, P<ushort> probs, uint symbol, uint matchByte)\n            {\n                uint offs = 0x100;\n                symbol |= 0x100;\n                do\n                {\n                    matchByte <<= 1;\n                    p.RangeEnc_EncodeBit(probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);\n                    symbol <<= 1;\n                    offs &= ~(matchByte ^ symbol);\n                }\n                while (symbol < 0x10000);\n            }\n\n            internal static void LzmaEnc_InitPriceTables(P<uint> probPrices)\n            {\n                for (uint i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))\n                {\n                    const int kCyclesBits = kNumBitPriceShiftBits;\n\n                    uint w = i;\n                    uint bitCount = 0;\n                    for (int j = 0; j < kCyclesBits; j++)\n                    {\n                        w = w * w;\n                        bitCount <<= 1;\n                        while (w >= ((uint)1 << 16))\n                        {\n                            w >>= 1;\n                            bitCount++;\n                        }\n                    }\n\n                    probPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);\n                }\n            }\n\n            internal static uint GET_PRICE(P<uint> probPrices, ushort prob, uint symbol)\n            {\n                //return symbol == 0\n                //    ? GET_PRICE_0(probPrices, prob)\n                //    : GET_PRICE_1(probPrices, prob);\n\n                return probPrices[(prob ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];\n            }\n\n            internal static uint GET_PRICE_0(P<uint> probPrices, ushort prob)\n            {\n                return probPrices[prob >> kNumMoveReducingBits];\n            }\n\n            internal static uint GET_PRICE_1(P<uint> probPrices, ushort prob)\n            {\n                return probPrices[(prob ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits];\n            }\n\n            private static uint LitEnc_GetPrice(P<ushort> probs, uint symbol, P<uint> probPrices)\n            {\n                uint price = 0;\n                symbol |= 0x100;\n                do\n                {\n                    price += GET_PRICE(probPrices, probs[symbol >> 8], (symbol >> 7) & 1);\n                    symbol <<= 1;\n                }\n                while (symbol < 0x10000);\n                return price;\n            }\n\n            private static uint LitEnc_GetPriceMatched(P<ushort> probs, uint symbol, uint matchByte, P<uint> probPrices)\n            {\n                uint price = 0;\n                uint offs = 0x100;\n                symbol |= 0x100;\n                do\n                {\n                    matchByte <<= 1;\n                    price += GET_PRICE(probPrices, probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);\n                    symbol <<= 1;\n                    offs &= ~(matchByte ^ symbol);\n                }\n                while (symbol < 0x10000);\n                return price;\n            }\n\n            internal static void RcTree_Encode(CRangeEnc rc, P<ushort> probs, int numBitLevels, uint symbol)\n            {\n                uint m = 1;\n                for (int i = numBitLevels; i != 0;)\n                {\n                    i--;\n                    uint bit = (symbol >> i) & 1;\n                    rc.RangeEnc_EncodeBit(probs + m, bit);\n                    m = (m << 1) | bit;\n                }\n            }\n\n            private static void RcTree_ReverseEncode(CRangeEnc rc, P<ushort> probs, int numBitLevels, uint symbol)\n            {\n                uint m = 1;\n                for (int i = 0; i < numBitLevels; i++)\n                {\n                    uint bit = symbol & 1;\n                    rc.RangeEnc_EncodeBit(probs + m, bit);\n                    m = (m << 1) | bit;\n                    symbol >>= 1;\n                }\n            }\n\n            internal static uint RcTree_GetPrice(P<ushort> probs, int numBitLevels, uint symbol, P<uint> ProbPrices)\n            {\n                uint price = 0;\n                symbol |= (1u << numBitLevels);\n                while (symbol != 1)\n                {\n                    price += GET_PRICE(ProbPrices, probs[symbol >> 1], symbol & 1);\n                    symbol >>= 1;\n                }\n                return price;\n            }\n\n            private static uint RcTree_ReverseGetPrice(P<ushort> probs, int numBitLevels, uint symbol, P<uint> probPrices)\n            {\n                uint price = 0;\n                uint m = 1;\n                for (int i = numBitLevels; i != 0; i--)\n                {\n                    uint bit = symbol & 1;\n                    symbol >>= 1;\n                    price += GET_PRICE(probPrices, probs[m], bit);\n                    m = (m << 1) | bit;\n                }\n                return price;\n            }\n\n            private P<ushort> LIT_PROBS(uint pos, byte prevByte)\n            {\n                return P.From(mLitProbs, (((pos & mLpMask) << mLC) + ((uint)prevByte >> (8 - mLC))) * 0x300);\n            }\n\n            private static bool ChangePair(uint smallDist, uint bigDist)\n            {\n                return (bigDist >> 7) > smallDist;\n            }\n\n            private sealed class CSeqOutStreamBuf : ISeqOutStream\n            {\n                public P<byte> mData;\n                public long mRem;\n                public bool mOverflow;\n\n                public long Write(P<byte> data, long size)\n                {\n                    if (mRem < size)\n                    {\n                        size = mRem;\n                        mOverflow = true;\n                    }\n\n                    CUtils.memcpy(mData, data, size);\n\n                    mRem -= size;\n                    mData += size;\n                    return size;\n                }\n            }\n\n            #endregion\n\n            #region Variables\n\n            internal IMatchFinder mMatchFinder;\n            internal object mMatchFinderObj;\n\n#if !_7ZIP_ST\n            internal bool mMtMode;\n            internal CMatchFinderMt mMatchFinderMt;\n#endif\n\n            internal CMatchFinder mMatchFinderBase;\n\n            //#if !_7ZIP_ST\n            //public byte[] pad=new byte[128];\n            //#endif\n\n            internal uint mOptimumEndIndex;\n            internal uint mOptimumCurrentIndex;\n\n            internal uint mLongestMatchLength;\n            internal uint mNumPairs;\n            internal uint mNumAvail;\n            internal COptimal[] mOpt = CUtils.Init<COptimal>(kNumOpts, () => new COptimal());\n\n            internal byte[] mFastPos = new byte[1 << kNumLogBits];\n\n            internal uint[] mProbPrices = new uint[kBitModelTotal >> kNumMoveReducingBits];\n            internal uint[] mMatches = new uint[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];\n            internal uint mNumFastBytes;\n            internal uint mAdditionalOffset;\n            internal OptimumReps mReps = new OptimumReps();\n            internal uint mState;\n\n            internal uint[][] mPosSlotPrices = CUtils.Init<uint>(kNumLenToPosStates, kDistTableSizeMax);\n            internal uint[][] mDistancesPrices = CUtils.Init<uint>(kNumLenToPosStates, kNumFullDistances);\n            internal uint[] mAlignPrices = new uint[kAlignTableSize];\n            internal uint mAlignPriceCount;\n\n            internal uint mDistTableSize;\n\n            internal int mLC;\n            internal int mLP;\n            internal int mPB;\n            internal uint mLpMask;\n            internal uint mPbMask;\n\n            internal ushort[] mLitProbs;\n\n            internal ushort[][] mIsMatch = CUtils.Init<ushort>(kNumStates, LZMA_NUM_PB_STATES_MAX);\n            internal ushort[] mIsRep = new ushort[kNumStates];\n            internal ushort[] mIsRepG0 = new ushort[kNumStates];\n            internal ushort[] mIsRepG1 = new ushort[kNumStates];\n            internal ushort[] mIsRepG2 = new ushort[kNumStates];\n            internal ushort[][] mIsRep0Long = CUtils.Init<ushort>(kNumStates, LZMA_NUM_PB_STATES_MAX);\n\n            internal ushort[][] mPosSlotEncoder = CUtils.Init<ushort>(kNumLenToPosStates, 1 << kNumPosSlotBits);\n            internal ushort[] mPosEncoders = new ushort[kNumFullDistances - kEndPosModelIndex];\n            internal ushort[] mPosAlignEncoder = new ushort[1 << kNumAlignBits];\n\n            internal CLenPriceEnc mLenEnc = new CLenPriceEnc();\n            internal CLenPriceEnc mRepLenEnc = new CLenPriceEnc();\n\n            internal int mLcLp;\n\n            internal bool mFastMode;\n\n            internal CRangeEnc mRC = new CRangeEnc();\n\n            internal bool mWriteEndMark;\n            internal ulong mNowPos64;\n            internal uint mMatchPriceCount;\n            internal bool mFinished;\n            internal bool mMultiThread;\n\n            internal SRes mResult;\n            internal uint mDictSize;\n\n            internal bool mNeedInit;\n\n            internal CSaveState mSaveState = new CSaveState();\n\n            #endregion\n\n            #region Public Methods\n\n            public void LzmaEnc_Destroy(ISzAlloc alloc, ISzAlloc allocBig)\n            {\n#if !_7ZIP_ST\n                mMatchFinderMt.MatchFinderMt_Destruct(allocBig);\n#endif\n                mMatchFinderBase.MatchFinder_Free(allocBig);\n                LzmaEnc_FreeLits(alloc);\n                mRC.RangeEnc_Free(alloc);\n                alloc.FreeObject(alloc, this);\n            }\n\n            public SRes LzmaEnc_SetProps(CLzmaEncProps props2)\n            {\n                TR(\"LzmaEnc_SetProps:level\", props2.mLevel);\n                TR(\"LzmaEnc_SetProps:dictSize\", props2.mDictSize);\n                TR(\"LzmaEnc_SetProps:lc\", props2.mLC);\n                TR(\"LzmaEnc_SetProps:lp\", props2.mLP);\n                TR(\"LzmaEnc_SetProps:pb\", props2.mPB);\n                TR(\"LzmaEnc_SetProps:algo\", props2.mAlgo);\n                TR(\"LzmaEnc_SetProps:fb\", props2.mFB);\n                TR(\"LzmaEnc_SetProps:btMode\", props2.mBtMode);\n                TR(\"LzmaEnc_SetProps:numHashBytes\", props2.mNumHashBytes);\n                TR(\"LzmaEnc_SetProps:mc\", props2.mMC);\n                TR(\"LzmaEnc_SetProps:writeEndMark\", props2.mWriteEndMark);\n                TR(\"LzmaEnc_SetProps:numThreads\", props2.mNumThreads);\n\n                CLzmaEncProps props = new CLzmaEncProps(props2);\n                props.LzmaEncProps_Normalize();\n\n                if (props.mLC > LZMA_LC_MAX\n                    || props.mLP > LZMA_LP_MAX\n                    || props.mPB > LZMA_PB_MAX\n                    || props.mDictSize > (1u << kDicLogSizeMaxCompress)\n                    || props.mDictSize > (1u << 30))\n                    return SZ_ERROR_PARAM;\n\n                mDictSize = props.mDictSize;\n\n                uint fb = (uint)props.mFB;\n                if (fb < 5)\n                    fb = 5;\n                if (fb > LZMA_MATCH_LEN_MAX)\n                    fb = LZMA_MATCH_LEN_MAX;\n                mNumFastBytes = fb;\n\n                mLC = props.mLC;\n                mLP = props.mLP;\n                mPB = props.mPB;\n                mFastMode = (props.mAlgo == 0);\n                mMatchFinderBase.mBtMode = (props.mBtMode != 0);\n\n                uint numHashBytes = 4;\n                if (props.mBtMode != 0)\n                {\n                    if (props.mNumHashBytes < 2)\n                        numHashBytes = 2;\n                    else if (props.mNumHashBytes < 4)\n                        numHashBytes = (uint)props.mNumHashBytes;\n                }\n                mMatchFinderBase.mNumHashBytes = numHashBytes;\n\n                mMatchFinderBase.mCutValue = props.mMC;\n\n                mWriteEndMark = (props.mWriteEndMark != 0);\n\n#if !_7ZIP_ST\n                mMultiThread = (props.mNumThreads > 1);\n#endif\n\n                return SZ_OK;\n            }\n\n            public SRes LzmaEnc_WriteProperties(P<byte> props, ref long size)\n            {\n                uint dictSize = mDictSize;\n                if (size < LZMA_PROPS_SIZE)\n                    return SZ_ERROR_PARAM;\n                size = LZMA_PROPS_SIZE;\n                props[0] = (byte)((mPB * 5 + mLP) * 9 + mLC);\n\n                for (int i = 11; i <= 30; i++)\n                {\n                    if (dictSize <= (2u << i))\n                    {\n                        dictSize = (2u << i);\n                        break;\n                    }\n                    if (dictSize <= (3u << i))\n                    {\n                        dictSize = (3u << i);\n                        break;\n                    }\n                }\n\n                for (int i = 0; i < 4; i++)\n                    props[1 + i] = (byte)(dictSize >> (8 * i));\n\n                return SZ_OK;\n            }\n\n            public SRes LzmaEnc_Encode(ISeqOutStream outStream, ISeqInStream inStream, ICompressProgress progress, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                SRes res;\n                if ((res = LzmaEnc_Prepare(outStream, inStream, alloc, allocBig)) != SZ_OK)\n                    return res;\n\n                return LzmaEnc_Encode2(progress);\n            }\n\n            public SRes LzmaEnc_MemEncode(P<byte> dest, ref long destLen, P<byte> src, long srcLen, bool writeEndMark, ICompressProgress progress, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                CSeqOutStreamBuf outStream = new CSeqOutStreamBuf();\n\n                LzmaEnc_SetInputBuf(src, srcLen);\n\n                outStream.mData = dest;\n                outStream.mRem = destLen;\n                outStream.mOverflow = false;\n\n                mWriteEndMark = writeEndMark;\n\n                mRC.mOutStream = outStream;\n\n                SRes res = LzmaEnc_MemPrepare(src, srcLen, 0, alloc, allocBig);\n                if (res == SZ_OK)\n                    res = LzmaEnc_Encode2(progress);\n\n                destLen -= outStream.mRem;\n                if (outStream.mOverflow)\n                    return SZ_ERROR_OUTPUT_EOF;\n\n                return res;\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            private static void memcpy(ushort[] dst, ushort[] src, int size)\n            {\n                if (dst.Length != src.Length || size != src.Length * 2)\n                    throw new InvalidOperationException();\n\n                Buffer.BlockCopy(src, 0, dst, 0, size);\n            }\n\n            private static void memcpy(uint[] dst, uint[] src, int size)\n            {\n                if (dst.Length != src.Length || size != src.Length * 4)\n                    throw new InvalidOperationException();\n\n                Buffer.BlockCopy(src, 0, dst, 0, size);\n            }\n\n            internal void LzmaEnc_SaveState()\n            {\n                TR(\"LzmaEnc_SaveState\", 0);\n\n                mSaveState.mLenEnc = new CLenPriceEnc(mLenEnc);\n                mSaveState.mRepLenEnc = new CLenPriceEnc(mRepLenEnc);\n                mSaveState.mState = mState;\n\n                for (int i = 0; i < kNumStates; i++)\n                {\n                    memcpy(mSaveState.mIsMatch[i], mIsMatch[i], LZMA_NUM_PB_STATES_MAX * 2);\n                    memcpy(mSaveState.mIsRep0Long[i], mIsRep0Long[i], LZMA_NUM_PB_STATES_MAX * 2);\n                }\n\n                for (int i = 0; i < kNumLenToPosStates; i++)\n                    memcpy(mSaveState.mPosSlotEncoder[i], mPosSlotEncoder[i], (1 << kNumPosSlotBits) * 2);\n\n                memcpy(mSaveState.mIsRep, mIsRep, kNumStates * 2);\n                memcpy(mSaveState.mIsRepG0, mIsRepG0, kNumStates * 2);\n                memcpy(mSaveState.mIsRepG1, mIsRepG1, kNumStates * 2);\n                memcpy(mSaveState.mIsRepG2, mIsRepG2, kNumStates * 2);\n                memcpy(mSaveState.mPosEncoders, mPosEncoders, (kNumFullDistances - kEndPosModelIndex) * 2);\n                memcpy(mSaveState.mPosAlignEncoder, mPosAlignEncoder, (1 << kNumAlignBits) * 2);\n                mSaveState.mReps = mReps;\n                memcpy(mSaveState.mLitProbs, mLitProbs, (0x300 << mLcLp) * 2);\n            }\n\n            internal void LzmaEnc_RestoreState()\n            {\n                TR(\"LzmaEnc_RestoreState\", 0);\n\n                mLenEnc = new CLenPriceEnc(mSaveState.mLenEnc);\n                mRepLenEnc = new CLenPriceEnc(mSaveState.mRepLenEnc);\n                mState = mSaveState.mState;\n\n                for (int i = 0; i < kNumStates; i++)\n                {\n                    memcpy(mIsMatch[i], mSaveState.mIsMatch[i], LZMA_NUM_PB_STATES_MAX * 2);\n                    memcpy(mIsRep0Long[i], mSaveState.mIsRep0Long[i], LZMA_NUM_PB_STATES_MAX * 2);\n                }\n\n                for (int i = 0; i < kNumLenToPosStates; i++)\n                    memcpy(mPosSlotEncoder[i], mSaveState.mPosSlotEncoder[i], (1 << kNumPosSlotBits) * 2);\n\n                memcpy(mIsRep, mSaveState.mIsRep, kNumStates * 2);\n                memcpy(mIsRepG0, mSaveState.mIsRepG0, kNumStates * 2);\n                memcpy(mIsRepG1, mSaveState.mIsRepG1, kNumStates * 2);\n                memcpy(mIsRepG2, mSaveState.mIsRepG2, kNumStates * 2);\n                memcpy(mPosEncoders, mSaveState.mPosEncoders, (kNumFullDistances - kEndPosModelIndex) * 2);\n                memcpy(mPosAlignEncoder, mSaveState.mPosAlignEncoder, (1 << kNumAlignBits) * 2);\n                mReps = mSaveState.mReps;\n                memcpy(mLitProbs, mSaveState.mLitProbs, (0x300 << mLcLp) * 2);\n            }\n\n            private uint GetOptimum(uint position, out uint backRes)\n            {\n                OptimumReps reps = new OptimumReps();\n                P<uint> matches;\n                uint numAvail;\n                uint lenEnd;\n\n                {\n                    if (mOptimumEndIndex != mOptimumCurrentIndex)\n                    {\n                        COptimal opt = mOpt[mOptimumCurrentIndex];\n                        uint lenRes = opt.mPosPrev - mOptimumCurrentIndex;\n                        backRes = opt.mBackPrev;\n                        mOptimumCurrentIndex = opt.mPosPrev;\n                        return lenRes;\n                    }\n\n                    mOptimumCurrentIndex = 0;\n                    mOptimumEndIndex = 0;\n\n                    uint mainLen, numPairs;\n                    if (mAdditionalOffset == 0)\n                    {\n                        mainLen = ReadMatchDistances(out numPairs);\n                    }\n                    else\n                    {\n                        mainLen = mLongestMatchLength;\n                        numPairs = mNumPairs;\n                    }\n\n                    numAvail = mNumAvail;\n                    if (numAvail < 2)\n                    {\n                        backRes = ~0u;\n                        return 1;\n                    }\n                    if (numAvail > LZMA_MATCH_LEN_MAX)\n                        numAvail = LZMA_MATCH_LEN_MAX;\n\n                    P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                    OptimumReps repLens = new OptimumReps();\n                    uint repMaxIndex = 0;\n                    for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                    {\n                        reps[i] = mReps[i];\n                        TR(\"GetOptimum:reps[i]\", reps[i]);\n                        P<byte> data2 = data - (reps[i] + 1);\n                        if (data[0] != data2[0] || data[1] != data2[1])\n                        {\n                            repLens[i] = 0;\n                            continue;\n                        }\n\n                        uint lenTest = 2;\n                        while (lenTest < numAvail && data[lenTest] == data2[lenTest])\n                            lenTest++;\n\n                        repLens[i] = lenTest;\n                        if (lenTest > repLens[repMaxIndex])\n                            repMaxIndex = i;\n                    }\n\n                    if (repLens[repMaxIndex] >= mNumFastBytes)\n                    {\n                        uint lenRes;\n                        backRes = repMaxIndex;\n                        lenRes = repLens[repMaxIndex];\n                        MovePos(lenRes - 1);\n                        return lenRes;\n                    }\n\n                    matches = mMatches;\n                    if (mainLen >= mNumFastBytes)\n                    {\n                        backRes = matches[numPairs - 1] + LZMA_NUM_REPS;\n                        MovePos(mainLen - 1);\n                        return mainLen;\n                    }\n\n                    byte curByte = data[0];\n                    byte matchByte = (data - (reps._0 + 1))[0];\n\n                    if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)\n                    {\n                        backRes = ~0u;\n                        return 1;\n                    }\n\n                    mOpt[0].mState = mState;\n\n                    uint posState = (position & mPbMask);\n\n                    {\n                        P<ushort> probs = LIT_PROBS(position, (data - 1)[0]);\n                        mOpt[1].mPrice = GET_PRICE_0(mIsMatch[mState][posState]) +\n                            (!IsCharState(mState) ?\n                              LitEnc_GetPriceMatched(probs, curByte, matchByte, mProbPrices) :\n                              LitEnc_GetPrice(probs, curByte, mProbPrices));\n                    }\n\n                    mOpt[1].MakeAsChar();\n\n                    uint matchPrice = GET_PRICE_1(mIsMatch[mState][posState]);\n                    uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[mState]);\n\n                    if (matchByte == curByte)\n                    {\n                        uint shortRepPrice = repMatchPrice + GetRepLen1Price(mState, posState);\n                        if (shortRepPrice < mOpt[1].mPrice)\n                        {\n                            mOpt[1].mPrice = shortRepPrice;\n                            mOpt[1].MakeAsShortRep();\n                        }\n                    }\n                    lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);\n\n                    if (lenEnd < 2)\n                    {\n                        backRes = mOpt[1].mBackPrev;\n                        return 1;\n                    }\n\n                    mOpt[1].mPosPrev = 0;\n                    mOpt[0].mBacks = reps;\n\n                    uint len = lenEnd;\n                    do { mOpt[len--].mPrice = kInfinityPrice; }\n                    while (len >= 2);\n\n                    for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                    {\n                        uint repLen = repLens[i];\n                        if (repLen < 2)\n                            continue;\n                        uint price = repMatchPrice + GetPureRepPrice(i, mState, posState);\n                        do\n                        {\n                            uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][repLen - 2];\n                            COptimal opt = mOpt[repLen];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = 0;\n                                opt.mBackPrev = i;\n                                opt.mPrev1IsChar = false;\n                            }\n                        }\n                        while (--repLen >= 2);\n                    }\n\n                    uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[mState]);\n\n                    len = ((repLens._0 >= 2) ? repLens._0 + 1 : 2);\n                    if (len <= mainLen)\n                    {\n                        uint offs = 0;\n                        while (len > matches[offs])\n                            offs += 2;\n                        for (; ; len++)\n                        {\n                            uint distance = matches[offs + 1];\n\n                            uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN];\n                            uint lenToPosState = GetLenToPosState(len);\n                            if (distance < kNumFullDistances)\n                            {\n                                curAndLenPrice += mDistancesPrices[lenToPosState][distance];\n                            }\n                            else\n                            {\n                                uint slot = GetPosSlot2(distance);\n                                curAndLenPrice += mAlignPrices[distance & kAlignMask] + mPosSlotPrices[lenToPosState][slot];\n                            }\n\n                            COptimal opt = mOpt[len];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = 0;\n                                opt.mBackPrev = distance + LZMA_NUM_REPS;\n                                opt.mPrev1IsChar = false;\n                            }\n                            if (len == matches[offs])\n                            {\n                                offs += 2;\n                                if (offs == numPairs)\n                                    break;\n                            }\n                        }\n                    }\n                }\n\n                uint cur = 0;\n\n#if SHOW_STAT2\n                if(position >= 0)\n                {\n                    Print(\"\\n pos = {0:X4}\", position);\n                    for(uint j = cur; j <= lenEnd; j++)\n                        Print(\"\\nprice[{0:X4}] = {1}\", position - cur + j, mOpt[j].mPrice);\n                }\n#endif\n                //TR(\"GetOptimum::pos\", position);\n                //if(position >= 0)\n                //{\n                //    TR(\"GetOptimum::cur\", cur);\n                //    for(uint j = cur; j <= lenEnd; j++)\n                //        TR(\"GetOptimum::price[i]\", mOpt[j].price);\n                //}\n\n                for (;;)\n                {\n                    cur++;\n                    if (cur == lenEnd)\n                        return Backward(out backRes, cur);\n\n                    uint numPairs;\n                    uint newLen = ReadMatchDistances(out numPairs);\n                    if (newLen >= mNumFastBytes)\n                    {\n                        mNumPairs = numPairs;\n                        mLongestMatchLength = newLen;\n                        return Backward(out backRes, cur);\n                    }\n                    position++;\n\n                    uint state;\n                    COptimal curOpt = mOpt[cur];\n                    uint posPrev = curOpt.mPosPrev;\n                    if (curOpt.mPrev1IsChar)\n                    {\n                        posPrev--;\n                        if (curOpt.mPrev2)\n                        {\n                            state = mOpt[curOpt.mPosPrev2].mState;\n                            if (curOpt.mBackPrev2 < LZMA_NUM_REPS)\n                                state = kRepNextStates[state];\n                            else\n                                state = kMatchNextStates[state];\n                        }\n                        else\n                        {\n                            state = mOpt[posPrev].mState;\n                        }\n                        state = kLiteralNextStates[state];\n                    }\n                    else\n                    {\n                        state = mOpt[posPrev].mState;\n                    }\n                    if (posPrev == cur - 1)\n                    {\n                        if (curOpt.IsShortRep())\n                            state = kShortRepNextStates[state];\n                        else\n                            state = kLiteralNextStates[state];\n                    }\n                    else\n                    {\n                        uint pos;\n                        if (curOpt.mPrev1IsChar && curOpt.mPrev2)\n                        {\n                            posPrev = curOpt.mPosPrev2;\n                            pos = curOpt.mBackPrev2;\n                            state = kRepNextStates[state];\n                        }\n                        else\n                        {\n                            pos = curOpt.mBackPrev;\n                            if (pos < LZMA_NUM_REPS)\n                                state = kRepNextStates[state];\n                            else\n                                state = kMatchNextStates[state];\n                        }\n                        COptimal prevOpt = mOpt[posPrev];\n                        if (pos < LZMA_NUM_REPS)\n                        {\n                            reps._0 = prevOpt.mBacks[pos];\n                            uint i = 1;\n                            for (; i <= pos; i++)\n                                reps[i] = prevOpt.mBacks[i - 1];\n                            for (; i < LZMA_NUM_REPS; i++)\n                                reps[i] = prevOpt.mBacks[i];\n                        }\n                        else\n                        {\n                            reps._0 = pos - LZMA_NUM_REPS;\n                            reps._1 = prevOpt.mBacks._0;\n                            reps._2 = prevOpt.mBacks._1;\n                            reps._3 = prevOpt.mBacks._2;\n                        }\n                    }\n                    curOpt.mState = state;\n                    curOpt.mBacks = reps;\n\n                    uint curPrice = curOpt.mPrice;\n                    bool nextIsChar = false;\n                    P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                    byte curByte = data[0];\n                    byte matchByte = (data - (reps._0 + 1))[0];\n\n                    uint posState = (position & mPbMask);\n\n                    uint curAnd1Price = curPrice + GET_PRICE_0(mIsMatch[state][posState]);\n                    {\n                        P<ushort> probs = LIT_PROBS(position, data[-1]);\n                        if (!IsCharState(state))\n                            curAnd1Price += LitEnc_GetPriceMatched(probs, curByte, matchByte, mProbPrices);\n                        else\n                            curAnd1Price += LitEnc_GetPrice(probs, curByte, mProbPrices);\n                    }\n\n                    COptimal nextOpt = mOpt[cur + 1];\n\n                    if (curAnd1Price < nextOpt.mPrice)\n                    {\n                        nextOpt.mPrice = curAnd1Price;\n                        nextOpt.mPosPrev = cur;\n                        nextOpt.MakeAsChar();\n                        nextIsChar = true;\n                    }\n\n                    uint matchPrice = curPrice + GET_PRICE_1(mIsMatch[state][posState]);\n                    uint repMatchPrice = matchPrice + GET_PRICE_1(mIsRep[state]);\n\n                    if (matchByte == curByte && !(nextOpt.mPosPrev < cur && nextOpt.mBackPrev == 0))\n                    {\n                        uint shortRepPrice = repMatchPrice + GetRepLen1Price(state, posState);\n                        if (shortRepPrice <= nextOpt.mPrice)\n                        {\n                            nextOpt.mPrice = shortRepPrice;\n                            nextOpt.mPosPrev = cur;\n                            nextOpt.MakeAsShortRep();\n                            nextIsChar = true;\n                        }\n                    }\n\n                    uint numAvailFull = Math.Min(mNumAvail, kNumOpts - 1 - cur);\n                    if (numAvailFull < 2)\n                        continue;\n\n                    numAvail = (numAvailFull <= mNumFastBytes ? numAvailFull : mNumFastBytes);\n\n                    if (!nextIsChar && matchByte != curByte) /* speed optimization */\n                    {\n                        /* try Literal + rep0 */\n                        P<byte> data2 = data - (reps._0 + 1);\n                        uint limit = mNumFastBytes + 1;\n                        if (limit > numAvailFull)\n                            limit = numAvailFull;\n\n                        uint temp = 1;\n                        while (temp < limit && data[temp] == data2[temp])\n                            temp++;\n\n                        uint lenTest2 = temp - 1;\n                        if (lenTest2 >= 2)\n                        {\n                            uint state2 = kLiteralNextStates[state];\n                            uint posStateNext = (position + 1) & mPbMask;\n                            uint nextRepMatchPrice = curAnd1Price + GET_PRICE_1(mIsMatch[state2][posStateNext]) + GET_PRICE_1(mIsRep[state2]);\n                            /* for (; lenTest2 >= 2; lenTest2--) */\n                            {\n                                uint offset = cur + 1 + lenTest2;\n                                while (lenEnd < offset)\n                                    mOpt[++lenEnd].mPrice = kInfinityPrice;\n                                uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);\n                                COptimal opt = mOpt[offset];\n                                if (curAndLenPrice < opt.mPrice)\n                                {\n                                    opt.mPrice = curAndLenPrice;\n                                    opt.mPosPrev = cur + 1;\n                                    opt.mBackPrev = 0;\n                                    opt.mPrev1IsChar = true;\n                                    opt.mPrev2 = false;\n                                }\n                            }\n                        }\n                    }\n\n                    uint startLen = 2; /* speed optimization */\n\n                    for (uint repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)\n                    {\n                        P<byte> data2 = data - (reps[repIndex] + 1);\n                        if (data[0] != data2[0] || data[1] != data2[1])\n                            continue;\n\n                        uint lenTest = 2;\n                        while (lenTest < numAvail && data[lenTest] == data2[lenTest])\n                            lenTest++;\n\n                        while (lenEnd < cur + lenTest)\n                            mOpt[++lenEnd].mPrice = kInfinityPrice;\n\n                        uint lenTestTemp = lenTest;\n                        uint price = repMatchPrice + GetPureRepPrice(repIndex, state, posState);\n                        do\n                        {\n                            uint curAndLenPrice = price + mRepLenEnc.mPrices[posState][lenTest - 2];\n                            COptimal opt = mOpt[cur + lenTest];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = cur;\n                                opt.mBackPrev = repIndex;\n                                opt.mPrev1IsChar = false;\n                            }\n                        }\n                        while (--lenTest >= 2);\n                        lenTest = lenTestTemp;\n\n                        if (repIndex == 0)\n                            startLen = lenTest + 1;\n\n                        {\n                            uint lenTest2 = lenTest + 1;\n\n                            uint limit = lenTest2 + mNumFastBytes;\n                            if (limit > numAvailFull)\n                                limit = numAvailFull;\n\n                            while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])\n                                lenTest2++;\n\n                            lenTest2 -= lenTest + 1;\n                            if (lenTest2 >= 2)\n                            {\n                                uint state2 = kRepNextStates[state];\n                                uint posStateNext = (position + lenTest) & mPbMask;\n                                uint curAndLenCharPrice = price\n                                    + mRepLenEnc.mPrices[posState][lenTest - 2]\n                                    + GET_PRICE_0(mIsMatch[state2][posStateNext])\n                                    + LitEnc_GetPriceMatched(\n                                        LIT_PROBS(position + lenTest, data[lenTest - 1]),\n                                        data[lenTest], data2[lenTest], mProbPrices);\n\n                                state2 = kLiteralNextStates[state2];\n                                posStateNext = (position + lenTest + 1) & mPbMask;\n                                uint nextRepMatchPrice = curAndLenCharPrice\n                                    + GET_PRICE_1(mIsMatch[state2][posStateNext])\n                                    + GET_PRICE_1(mIsRep[state2]);\n\n                                /* for (; lenTest2 >= 2; lenTest2--) */\n                                {\n                                    uint offset = cur + lenTest + 1 + lenTest2;\n                                    while (lenEnd < offset)\n                                        mOpt[++lenEnd].mPrice = kInfinityPrice;\n\n                                    uint curAndLenPrice = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);\n\n                                    COptimal opt = mOpt[offset];\n                                    if (curAndLenPrice < opt.mPrice)\n                                    {\n                                        opt.mPrice = curAndLenPrice;\n                                        opt.mPosPrev = cur + lenTest + 1;\n                                        opt.mBackPrev = 0;\n                                        opt.mPrev1IsChar = true;\n                                        opt.mPrev2 = true;\n                                        opt.mPosPrev2 = cur;\n                                        opt.mBackPrev2 = repIndex;\n                                    }\n                                }\n                            }\n                        }\n                    }\n\n                    /* for (uint lenTest = 2; lenTest <= newLen; lenTest++) */\n                    if (newLen > numAvail)\n                    {\n                        newLen = numAvail;\n                        numPairs = 0;\n                        while (newLen > matches[numPairs])\n                            numPairs += 2;\n                        matches[numPairs] = newLen;\n                        numPairs += 2;\n                    }\n                    if (newLen >= startLen)\n                    {\n                        uint normalMatchPrice = matchPrice + GET_PRICE_0(mIsRep[state]);\n\n                        while (lenEnd < cur + newLen)\n                            mOpt[++lenEnd].mPrice = kInfinityPrice;\n\n                        uint offs = 0;\n                        while (startLen > matches[offs])\n                            offs += 2;\n\n                        uint curBack = matches[offs + 1];\n                        uint posSlot = GetPosSlot2(curBack);\n                        for (uint lenTest = /*2*/ startLen; ; lenTest++)\n                        {\n                            uint curAndLenPrice = normalMatchPrice + mLenEnc.mPrices[posState][lenTest - LZMA_MATCH_LEN_MIN];\n                            uint lenToPosState = GetLenToPosState(lenTest);\n                            if (curBack < kNumFullDistances)\n                                curAndLenPrice += mDistancesPrices[lenToPosState][curBack];\n                            else\n                                curAndLenPrice += mPosSlotPrices[lenToPosState][posSlot] + mAlignPrices[curBack & kAlignMask];\n\n                            COptimal opt = mOpt[cur + lenTest];\n                            if (curAndLenPrice < opt.mPrice)\n                            {\n                                opt.mPrice = curAndLenPrice;\n                                opt.mPosPrev = cur;\n                                opt.mBackPrev = curBack + LZMA_NUM_REPS;\n                                opt.mPrev1IsChar = false;\n                            }\n\n                            if (lenTest == matches[offs])\n                            {\n                                /* Try Match + Literal + Rep0 */\n                                P<byte> data2 = data - (curBack + 1);\n                                uint lenTest2 = lenTest + 1;\n                                uint limit = lenTest2 + mNumFastBytes;\n                                uint nextRepMatchPrice;\n                                if (limit > numAvailFull)\n                                    limit = numAvailFull;\n\n                                while (lenTest2 < limit && data[lenTest2] == data2[lenTest2])\n                                    lenTest2++;\n\n                                lenTest2 -= lenTest + 1;\n                                if (lenTest2 >= 2)\n                                {\n                                    uint state2 = kMatchNextStates[state];\n                                    uint posStateNext = (position + lenTest) & mPbMask;\n                                    uint curAndLenCharPrice = curAndLenPrice\n                                        + GET_PRICE_0(mIsMatch[state2][posStateNext])\n                                        + LitEnc_GetPriceMatched(\n                                            LIT_PROBS(position + lenTest, data[lenTest - 1]),\n                                            data[lenTest], data2[lenTest], mProbPrices);\n\n                                    state2 = kLiteralNextStates[state2];\n                                    posStateNext = (posStateNext + 1) & mPbMask;\n                                    nextRepMatchPrice = curAndLenCharPrice\n                                        + GET_PRICE_1(mIsMatch[state2][posStateNext])\n                                        + GET_PRICE_1(mIsRep[state2]);\n\n                                    /* for (; lenTest2 >= 2; lenTest2--) */\n                                    {\n                                        uint offset = cur + lenTest + 1 + lenTest2;\n                                        uint curAndLenPrice4;\n                                        while (lenEnd < offset)\n                                            mOpt[++lenEnd].mPrice = kInfinityPrice;\n                                        curAndLenPrice4 = nextRepMatchPrice + GetRepPrice(0, lenTest2, state2, posStateNext);\n                                        COptimal opt4 = mOpt[offset];\n                                        if (curAndLenPrice4 < opt4.mPrice)\n                                        {\n                                            opt4.mPrice = curAndLenPrice4;\n                                            opt4.mPosPrev = cur + lenTest + 1;\n                                            opt4.mBackPrev = 0;\n                                            opt4.mPrev1IsChar = true;\n                                            opt4.mPrev2 = true;\n                                            opt4.mPosPrev2 = cur;\n                                            opt4.mBackPrev2 = curBack + LZMA_NUM_REPS;\n                                        }\n                                    }\n                                }\n\n                                offs += 2;\n                                if (offs == numPairs)\n                                    break;\n\n                                curBack = matches[offs + 1];\n                                if (curBack >= kNumFullDistances)\n                                    posSlot = GetPosSlot2(curBack);\n                            }\n                        }\n                    }\n                }\n            }\n\n            private uint GetOptimumFast(out uint backRes)\n            {\n                uint mainLen, numPairs;\n                if (mAdditionalOffset == 0)\n                {\n                    mainLen = ReadMatchDistances(out numPairs);\n                }\n                else\n                {\n                    TR(\"GetOptimumFast:longestMatchLength\", mLongestMatchLength);\n                    mainLen = mLongestMatchLength;\n                    numPairs = mNumPairs;\n                }\n\n                uint numAvail = mNumAvail;\n                backRes = ~0u;\n                if (numAvail < 2)\n                    return 1;\n                if (numAvail > LZMA_MATCH_LEN_MAX)\n                    numAvail = LZMA_MATCH_LEN_MAX;\n                P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n\n                uint repLen = 0;\n                uint repIndex = 0;\n                for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                {\n                    P<byte> data2 = data - (mReps[i] + 1);\n                    TR(\"GetOptimumFast:reps[i]:a\", mReps[i]);\n                    if (data[0] != data2[0] || data[1] != data2[1])\n                        continue;\n\n                    uint len = 2;\n                    while (len < numAvail && data[len] == data2[len])\n                        len++;\n\n                    if (len >= mNumFastBytes)\n                    {\n                        backRes = i;\n                        MovePos(len - 1);\n                        return len;\n                    }\n\n                    if (len > repLen)\n                    {\n                        repIndex = i;\n                        repLen = len;\n                    }\n                }\n\n                P<uint> matches = mMatches;\n                if (mainLen >= mNumFastBytes)\n                {\n                    backRes = matches[numPairs - 1] + LZMA_NUM_REPS;\n                    MovePos(mainLen - 1);\n                    return mainLen;\n                }\n\n                uint mainDist = 0;\n                if (mainLen >= 2)\n                {\n                    mainDist = matches[numPairs - 1];\n                    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)\n                    {\n                        if (!ChangePair(matches[numPairs - 3], mainDist))\n                            break;\n\n                        numPairs -= 2;\n                        mainLen = matches[numPairs - 2];\n                        mainDist = matches[numPairs - 1];\n                    }\n\n                    if (mainLen == 2 && mainDist >= 0x80)\n                        mainLen = 1;\n                }\n\n                if (repLen >= 2 && (\n                    (repLen + 1 >= mainLen) ||\n                    (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||\n                    (repLen + 3 >= mainLen && mainDist >= (1 << 15))))\n                {\n                    backRes = repIndex;\n                    MovePos(repLen - 1);\n                    return repLen;\n                }\n\n                if (mainLen < 2 || numAvail <= 2)\n                    return 1;\n\n                mLongestMatchLength = ReadMatchDistances(out mNumPairs);\n                if (mLongestMatchLength >= 2)\n                {\n                    uint newDistance = matches[mNumPairs - 1];\n                    if ((mLongestMatchLength >= mainLen && newDistance < mainDist) ||\n                        (mLongestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||\n                        (mLongestMatchLength > mainLen + 1) ||\n                        (mLongestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))\n                        return 1;\n                }\n\n                data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                for (uint i = 0; i < LZMA_NUM_REPS; i++)\n                {\n                    TR(\"GetOptimumFast:reps[i]:b\", mReps[i]);\n                    P<byte> data2 = data - (mReps[i] + 1);\n                    if (data[0] != data2[0] || data[1] != data2[1])\n                        continue;\n\n                    uint limit = mainLen - 1;\n\n                    uint len = 2;\n                    while (len < limit && data[len] == data2[len])\n                        len++;\n\n                    if (len >= limit)\n                        return 1;\n                }\n\n                backRes = mainDist + LZMA_NUM_REPS;\n                MovePos(mainLen - 2);\n                return mainLen;\n            }\n\n            private void WriteEndMarker(uint posState)\n            {\n                TR(\"WriteEndMarker\", posState);\n                mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState], 1);\n                mRC.RangeEnc_EncodeBit(ref mIsRep[mState], 0);\n                mState = kMatchNextStates[mState];\n                uint len = LZMA_MATCH_LEN_MIN;\n                mLenEnc.LenEnc_Encode2(mRC, len - LZMA_MATCH_LEN_MIN, posState, !mFastMode, mProbPrices);\n                RcTree_Encode(mRC, mPosSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);\n                mRC.RangeEnc_EncodeDirectBits(((1u << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);\n                RcTree_ReverseEncode(mRC, mPosAlignEncoder, kNumAlignBits, kAlignMask);\n            }\n\n            private SRes CheckErrors()\n            {\n                if (mResult != SZ_OK)\n                    return mResult;\n\n                if (mRC.mRes != SZ_OK)\n                    mResult = SZ_ERROR_WRITE;\n\n                if (mMatchFinderBase.mResult != SZ_OK)\n                    mResult = SZ_ERROR_READ;\n\n                if (mResult != SZ_OK)\n                    mFinished = true;\n\n                return mResult;\n            }\n\n            private SRes Flush(uint nowPos)\n            {\n                TR(\"Flush\", nowPos);\n\n                /* ReleaseMFStream(); */\n                mFinished = true;\n\n                if (mWriteEndMark)\n                    WriteEndMarker(nowPos & mPbMask);\n\n                mRC.RangeEnc_FlushData();\n                mRC.RangeEnc_FlushStream();\n\n                return CheckErrors();\n            }\n\n            private void FillAlignPrices()\n            {\n                for (uint i = 0; i < kAlignTableSize; i++)\n                    mAlignPrices[i] = RcTree_ReverseGetPrice(mPosAlignEncoder, kNumAlignBits, i, mProbPrices);\n\n                mAlignPriceCount = 0;\n            }\n\n            private void FillDistancesPrices()\n            {\n                uint[] tempPrices = new uint[kNumFullDistances];\n\n                for (uint i = kStartPosModelIndex; i < kNumFullDistances; i++)\n                {\n                    uint posSlot = GetPosSlot1(i);\n                    uint footerBits = ((posSlot >> 1) - 1);\n                    uint @base = ((2u | (posSlot & 1u)) << (int)footerBits);\n                    tempPrices[i] = RcTree_ReverseGetPrice(P.From(mPosEncoders, @base - posSlot - 1), (int)footerBits, i - @base, mProbPrices);\n                }\n\n                for (uint lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)\n                {\n                    P<ushort> encoder = mPosSlotEncoder[lenToPosState];\n                    P<uint> posSlotPrices = mPosSlotPrices[lenToPosState];\n\n                    for (uint posSlot = 0; posSlot < mDistTableSize; posSlot++)\n                        posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, mProbPrices);\n\n                    for (uint posSlot = kEndPosModelIndex; posSlot < mDistTableSize; posSlot++)\n                        posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);\n\n                    {\n                        P<uint> distancesPrices = mDistancesPrices[lenToPosState];\n                        uint i = 0;\n                        for (; i < kStartPosModelIndex; i++)\n                            distancesPrices[i] = posSlotPrices[i];\n                        for (; i < kNumFullDistances; i++)\n                            distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];\n                    }\n                }\n\n                mMatchPriceCount = 0;\n            }\n\n            internal CLzmaEnc() // LzmaEnc_Construct\n            {\n                mRC.RangeEnc_Construct();\n#if !_7ZIP_ST\n                mMatchFinderMt = new CMatchFinderMt();\n                mMatchFinderBase = mMatchFinderMt;\n#else\n                mMatchFinderBase = new CMatchFinder();\n#endif\n                LzmaEnc_SetProps(CLzmaEncProps.LzmaEncProps_Init());\n                LzmaEnc_FastPosInit();\n                LzmaEnc_InitPriceTables(mProbPrices);\n                mLitProbs = null;\n                mSaveState.mLitProbs = null;\n            }\n\n            internal void LzmaEnc_FreeLits(ISzAlloc alloc)\n            {\n                alloc.FreeUInt16(alloc, mLitProbs);\n                alloc.FreeUInt16(alloc, mSaveState.mLitProbs);\n                mLitProbs = null;\n                mSaveState.mLitProbs = null;\n            }\n\n            internal SRes LzmaEnc_CodeOneBlock(bool useLimits, uint maxPackSize, uint maxUnpackSize)\n            {\n                TR(\"CodeOneBlock:useLimits\", useLimits ? 1 : 0);\n                TR(\"CodeOneBlock:maxPackSize\", maxPackSize);\n                TR(\"CodeOneBlock:maxUnpackSize\", maxUnpackSize);\n\n                if (mNeedInit)\n                {\n                    mMatchFinder.Init(mMatchFinderObj);\n                    mNeedInit = false;\n                }\n\n                TR(\"CodeOneBlock:finished\", mFinished ? 1 : 0);\n                if (mFinished)\n                    return mResult;\n\n                SRes res;\n                if ((res = CheckErrors()) != SZ_OK)\n                    return res;\n\n                uint nowPos32 = (uint)mNowPos64;\n                uint startPos32 = nowPos32;\n\n                if (mNowPos64 == 0)\n                {\n                    if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)\n                    {\n                        TRS(\"CodeOneBlock\", \"empty\");\n                        return Flush(nowPos32);\n                    }\n                    uint numPairs;\n                    ReadMatchDistances(out numPairs);\n                    mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][0], 0);\n                    mState = kLiteralNextStates[mState];\n                    byte curByte = mMatchFinder.GetIndexByte(mMatchFinderObj, (int)(-mAdditionalOffset));\n                    LitEnc_Encode(mRC, mLitProbs, curByte);\n                    mAdditionalOffset--;\n                    nowPos32++;\n                }\n\n                if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) != 0)\n                {\n                    for (;;)\n                    {\n                        uint len, pos;\n                        if (mFastMode)\n                            len = GetOptimumFast(out pos);\n                        else\n                            len = GetOptimum(nowPos32, out pos);\n\n                        TR(\"CodeOneBlock:nowPos32\", nowPos32);\n                        TR(\"CodeOneBlock:len\", len);\n                        TR(\"CodeOneBlock:pos\", pos);\n\n#if SHOW_STAT2\n                        Print(\"\\n pos = {0:X4},   len = {1}   pos = {2}\", nowPos32, len, pos);\n#endif\n\n                        uint posState = nowPos32 & mPbMask;\n                        if (len == 1 && pos == ~0u)\n                        {\n                            mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState], 0);\n                            P<byte> data = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;\n                            byte curByte = data[0];\n                            P<ushort> probs = LIT_PROBS(nowPos32, (data - 1)[0]);\n\n                            if (IsCharState(mState))\n                                LitEnc_Encode(mRC, probs, curByte);\n                            else\n                                LitEnc_EncodeMatched(mRC, probs, curByte, (data - mReps._0 - 1)[0]);\n\n                            mState = kLiteralNextStates[mState];\n                        }\n                        else\n                        {\n                            mRC.RangeEnc_EncodeBit(ref mIsMatch[mState][posState], 1);\n                            if (pos < LZMA_NUM_REPS)\n                            {\n                                mRC.RangeEnc_EncodeBit(ref mIsRep[mState], 1);\n                                if (pos == 0)\n                                {\n                                    mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState], 0);\n                                    mRC.RangeEnc_EncodeBit(ref mIsRep0Long[mState][posState], (len == 1) ? 0u : 1u);\n                                }\n                                else\n                                {\n                                    uint distance = mReps[pos];\n                                    TR(\"CodeOneBlock:push-rep-0\", pos);\n                                    TR(\"CodeOneBlock:push-rep-1\", distance);\n\n                                    mRC.RangeEnc_EncodeBit(ref mIsRepG0[mState], 1);\n\n                                    if (pos == 1)\n                                    {\n                                        mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState], 0);\n                                    }\n                                    else\n                                    {\n                                        mRC.RangeEnc_EncodeBit(ref mIsRepG1[mState], 1);\n                                        mRC.RangeEnc_EncodeBit(ref mIsRepG2[mState], pos - 2);\n                                        if (pos == 3)\n                                            mReps._3 = mReps._2;\n                                        mReps._2 = mReps._1;\n                                    }\n\n                                    mReps._1 = mReps._0;\n                                    mReps._0 = distance;\n                                }\n\n                                if (len == 1)\n                                {\n                                    mState = kShortRepNextStates[mState];\n                                }\n                                else\n                                {\n                                    mRepLenEnc.LenEnc_Encode2(mRC, len - LZMA_MATCH_LEN_MIN, posState, !mFastMode, mProbPrices);\n                                    mState = kRepNextStates[mState];\n                                }\n                            }\n                            else\n                            {\n                                mRC.RangeEnc_EncodeBit(ref mIsRep[mState], 0);\n                                mState = kMatchNextStates[mState];\n                                mLenEnc.LenEnc_Encode2(mRC, len - LZMA_MATCH_LEN_MIN, posState, !mFastMode, mProbPrices);\n                                pos -= LZMA_NUM_REPS;\n                                uint posSlot = GetPosSlot(pos);\n                                RcTree_Encode(mRC, mPosSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);\n\n                                if (posSlot >= kStartPosModelIndex)\n                                {\n                                    int footerBits = (int)((posSlot >> 1) - 1);\n                                    uint @base = ((2 | (posSlot & 1)) << footerBits);\n                                    uint posReduced = pos - @base;\n\n                                    if (posSlot < kEndPosModelIndex)\n                                        RcTree_ReverseEncode(mRC, P.From(mPosEncoders, @base - posSlot - 1), footerBits, posReduced);\n                                    else\n                                    {\n                                        mRC.RangeEnc_EncodeDirectBits(posReduced >> kNumAlignBits, (footerBits - kNumAlignBits));\n                                        RcTree_ReverseEncode(mRC, mPosAlignEncoder, kNumAlignBits, posReduced & kAlignMask);\n                                        mAlignPriceCount++;\n                                    }\n                                }\n                                TR(\"CodeOneBlock:push-rep-2\", pos);\n                                mReps._3 = mReps._2;\n                                mReps._2 = mReps._1;\n                                mReps._1 = mReps._0;\n                                mReps._0 = pos;\n                                mMatchPriceCount++;\n                            }\n                        }\n\n                        mAdditionalOffset -= len;\n                        nowPos32 += len;\n\n                        if (mAdditionalOffset == 0)\n                        {\n                            if (!mFastMode)\n                            {\n                                if (mMatchPriceCount >= (1 << 7))\n                                    FillDistancesPrices();\n                                if (mAlignPriceCount >= kAlignTableSize)\n                                    FillAlignPrices();\n                            }\n\n                            if (mMatchFinder.GetNumAvailableBytes(mMatchFinderObj) == 0)\n                                break;\n\n                            uint processed = nowPos32 - startPos32;\n                            if (useLimits)\n                            {\n                                if (processed + kNumOpts + 300 >= maxUnpackSize\n                                    || mRC.RangeEnc_GetProcessed() + kNumOpts * 2 >= maxPackSize)\n                                    break;\n                            }\n                            else if (processed >= (1 << 15))\n                            {\n                                mNowPos64 += nowPos32 - startPos32;\n                                TRS(\"CodeOneBlock\", \"chunk\");\n                                TR(\"CodeOneBlock:start\", startPos32);\n                                TR(\"CodeOneBlock:now\", nowPos32);\n                                return CheckErrors();\n                            }\n                        }\n                    }\n                }\n\n                mNowPos64 += nowPos32 - startPos32;\n                TRS(\"CodeOneBlock\", \"done\");\n                return Flush(nowPos32);\n            }\n\n            private const uint kBigHashDicLimit = 1u << 24;\n\n            private SRes LzmaEnc_Alloc(uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                if (!mRC.RangeEnc_Alloc(alloc))\n                    return SZ_ERROR_MEM;\n\n                bool btMode = mMatchFinderBase.mBtMode;\n#if !_7ZIP_ST\n                mMtMode = (mMultiThread && !mFastMode && btMode);\n#endif\n\n                int lclp = mLC + mLP;\n                if (mLitProbs == null || mSaveState.mLitProbs == null || mLcLp != lclp)\n                {\n                    LzmaEnc_FreeLits(alloc);\n                    mLitProbs = alloc.AllocUInt16(alloc, 0x300 << lclp);\n                    mSaveState.mLitProbs = alloc.AllocUInt16(alloc, 0x300 << lclp);\n                    if (mLitProbs == null || mSaveState.mLitProbs == null)\n                    {\n                        LzmaEnc_FreeLits(alloc);\n                        return SZ_ERROR_MEM;\n                    }\n                    mLcLp = lclp;\n                }\n\n                mMatchFinderBase.mBigHash = (mDictSize > kBigHashDicLimit);\n\n                uint beforeSize = kNumOpts;\n                if (beforeSize + mDictSize < keepWindowSize)\n                    beforeSize = keepWindowSize - mDictSize;\n\n#if !_7ZIP_ST\n                if (mMtMode)\n                {\n                    SRes res;\n                    if ((res = mMatchFinderMt.MatchFinderMt_Create(mDictSize, beforeSize, mNumFastBytes, LZMA_MATCH_LEN_MAX, allocBig)) != SZ_OK)\n                        return res;\n\n                    mMatchFinderObj = mMatchFinderMt;\n                    mMatchFinderMt.MatchFinderMt_CreateVTable(out mMatchFinder);\n                }\n                else\n#endif\n                {\n                    if (!mMatchFinderBase.MatchFinder_Create(mDictSize, beforeSize, mNumFastBytes, LZMA_MATCH_LEN_MAX, allocBig))\n                        return SZ_ERROR_MEM;\n\n                    mMatchFinderObj = mMatchFinderBase;\n                    MatchFinder_CreateVTable(mMatchFinderBase, out mMatchFinder);\n                }\n\n                return SZ_OK;\n            }\n\n            internal void LzmaEnc_Init()\n            {\n                TR(\"LzmaEnc_Init\", 0);\n\n                mState = 0;\n                mReps = new OptimumReps();\n\n                mRC.RangeEnc_Init();\n\n                for (uint i = 0; i < kNumStates; i++)\n                {\n                    for (uint j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)\n                    {\n                        mIsMatch[i][j] = kProbInitValue;\n                        mIsRep0Long[i][j] = kProbInitValue;\n                    }\n\n                    mIsRep[i] = kProbInitValue;\n                    mIsRepG0[i] = kProbInitValue;\n                    mIsRepG1[i] = kProbInitValue;\n                    mIsRepG2[i] = kProbInitValue;\n                }\n\n                uint n = 0x300u << (mLP + mLC);\n                for (uint i = 0; i < n; i++)\n                    mLitProbs[i] = kProbInitValue;\n\n                for (uint i = 0; i < kNumLenToPosStates; i++)\n                {\n                    P<ushort> probs = mPosSlotEncoder[i];\n                    for (uint j = 0; j < (1 << kNumPosSlotBits); j++)\n                        probs[j] = kProbInitValue;\n                }\n\n                for (uint i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)\n                    mPosEncoders[i] = kProbInitValue;\n\n                mLenEnc.LenEnc_Init();\n                mRepLenEnc.LenEnc_Init();\n\n                for (uint i = 0; i < (1 << kNumAlignBits); i++)\n                    mPosAlignEncoder[i] = kProbInitValue;\n\n                mOptimumEndIndex = 0;\n                mOptimumCurrentIndex = 0;\n                mAdditionalOffset = 0;\n\n                mPbMask = (1u << mPB) - 1;\n                mLpMask = (1u << mLP) - 1;\n            }\n\n            internal void LzmaEnc_InitPrices()\n            {\n                if (!mFastMode)\n                {\n                    FillDistancesPrices();\n                    FillAlignPrices();\n                }\n\n                uint tableSize = mNumFastBytes + 1 - LZMA_MATCH_LEN_MIN;\n                mLenEnc.mTableSize = tableSize;\n                mRepLenEnc.mTableSize = tableSize;\n                mLenEnc.LenPriceEnc_UpdateTables(1u << mPB, mProbPrices);\n                mRepLenEnc.LenPriceEnc_UpdateTables(1u << mPB, mProbPrices);\n            }\n\n            internal SRes LzmaEnc_AllocAndInit(uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                {\n                    uint i;\n                    for (i = 0; i < (uint)kDicLogSizeMaxCompress; i++)\n                        if (mDictSize <= (1u << (int)i))\n                            break;\n\n                    mDistTableSize = i * 2;\n                }\n\n                mFinished = false;\n                mResult = SZ_OK;\n\n                SRes res;\n                if ((res = LzmaEnc_Alloc(keepWindowSize, alloc, allocBig)) != SZ_OK)\n                    return res;\n\n                LzmaEnc_Init();\n                LzmaEnc_InitPrices();\n                mNowPos64 = 0;\n                return SZ_OK;\n            }\n\n            internal void LzmaEnc_SetInputBuf(P<byte> src, long srcLen)\n            {\n                mMatchFinderBase.mDirectInput = true;\n                mMatchFinderBase.mBufferBase = src;\n                mMatchFinderBase.mDirectInputRem = srcLen;\n            }\n\n            internal SRes LzmaEnc_Prepare(ISeqOutStream outStream, ISeqInStream inStream, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                mMatchFinderBase.mStream = inStream;\n                mNeedInit = true;\n                mRC.mOutStream = outStream;\n                return LzmaEnc_AllocAndInit(0, alloc, allocBig);\n            }\n\n            internal SRes LzmaEnc_PrepareForLzma2(ISeqInStream inStream, uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                mMatchFinderBase.mStream = inStream;\n                mNeedInit = true;\n                return LzmaEnc_AllocAndInit(keepWindowSize, alloc, allocBig);\n            }\n\n            internal SRes LzmaEnc_MemPrepare(P<byte> src, long srcLen, uint keepWindowSize, ISzAlloc alloc, ISzAlloc allocBig)\n            {\n                LzmaEnc_SetInputBuf(src, srcLen);\n                mNeedInit = true;\n                return LzmaEnc_AllocAndInit(keepWindowSize, alloc, allocBig);\n            }\n\n            internal void LzmaEnc_Finish()\n            {\n#if !_7ZIP_ST\n                if (mMtMode)\n                    mMatchFinderMt.MatchFinderMt_ReleaseStream();\n#endif\n            }\n\n            internal uint LzmaEnc_GetNumAvailableBytes()\n            {\n                return mMatchFinder.GetNumAvailableBytes(mMatchFinderObj);\n            }\n\n            internal P<byte> LzmaEnc_GetCurBuf()\n            {\n                return mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - mAdditionalOffset;\n            }\n\n            internal SRes LzmaEnc_CodeOneMemBlock(bool reInit, P<byte> dest, ref long destLen, uint desiredPackSize, ref uint unpackSize)\n            {\n                CSeqOutStreamBuf outStream = new CSeqOutStreamBuf();\n\n                outStream.mData = dest;\n                outStream.mRem = destLen;\n                outStream.mOverflow = false;\n\n                mWriteEndMark = false;\n                mFinished = false;\n                mResult = SZ_OK;\n\n                if (reInit)\n                    LzmaEnc_Init();\n\n                LzmaEnc_InitPrices();\n                ulong nowPos64 = mNowPos64;\n                mRC.RangeEnc_Init();\n                mRC.mOutStream = outStream;\n\n                SRes res = LzmaEnc_CodeOneBlock(true, desiredPackSize, unpackSize);\n\n                unpackSize = (uint)(mNowPos64 - nowPos64);\n                destLen -= outStream.mRem;\n                if (outStream.mOverflow)\n                    return SZ_ERROR_OUTPUT_EOF;\n\n                return res;\n            }\n\n            private SRes LzmaEnc_Encode2(ICompressProgress progress)\n            {\n                SRes res = SZ_OK;\n                for (;;)\n                {\n                    res = LzmaEnc_CodeOneBlock(false, 0, 0);\n                    if (res != SZ_OK || mFinished)\n                        break;\n\n                    if (progress != null)\n                    {\n                        res = progress.Progress(mNowPos64, mRC.RangeEnc_GetProcessed());\n                        if (res != SZ_OK)\n                        {\n                            res = SZ_ERROR_PROGRESS;\n                            break;\n                        }\n                    }\n                }\n\n                LzmaEnc_Finish();\n                return res;\n            }\n\n            private void MovePos(uint num)\n            {\n#if SHOW_STAT\n                ttt += (int)num;\n                Print(\"\\n MovePos {0}\", num);\n#endif\n                TR(\"MovePos\", num);\n                if (num != 0)\n                {\n                    mAdditionalOffset += num;\n                    mMatchFinder.Skip(mMatchFinderObj, num);\n                }\n            }\n\n            private uint ReadMatchDistances(out uint numDistancePairsRes)\n            {\n                mNumAvail = mMatchFinder.GetNumAvailableBytes(mMatchFinderObj);\n                uint numPairs = mMatchFinder.GetMatches(mMatchFinderObj, mMatches);\n\n#if SHOW_STAT\n                {\n                    Print(\"\\n i = {0} numPairs = {1}    \", ttt, numPairs / 2);\n                    ttt++;\n                    for(uint i = 0; i < numPairs; i += 2)\n                        Print(\"{0:00} {1:000000}   | \", mMatches[i], mMatches[i + 1]);\n                }\n#endif\n\n                {\n                    TR(\"ReadMatchDistances:matches\", numPairs);\n                    for (uint i = 0; i < numPairs; i++)\n                        TR(\"ReadMatchDistances:match[i]\", mMatches[i]);\n                }\n\n                uint lenRes = 0;\n                if (numPairs > 0)\n                {\n                    lenRes = mMatches[numPairs - 2];\n                    if (lenRes == mNumFastBytes)\n                    {\n                        P<byte> pby = mMatchFinder.GetPointerToCurrentPos(mMatchFinderObj) - 1;\n                        uint distance = mMatches[numPairs - 1] + 1;\n\n                        uint numAvail = mNumAvail;\n                        if (numAvail > LZMA_MATCH_LEN_MAX)\n                            numAvail = LZMA_MATCH_LEN_MAX;\n\n                        P<byte> pby2 = pby - distance;\n                        while (lenRes < numAvail && pby[lenRes] == pby2[lenRes])\n                            lenRes++;\n                    }\n                }\n\n                mAdditionalOffset++;\n                numDistancePairsRes = numPairs;\n                TR(\"ReadMatchDistances:lenRes\", lenRes);\n                return lenRes;\n            }\n\n            private uint GetRepLen1Price(uint state, uint posState)\n            {\n                return GET_PRICE_0(mIsRepG0[state])\n                    + GET_PRICE_0(mIsRep0Long[state][posState]);\n            }\n\n            private uint GetPureRepPrice(uint repIndex, uint state, uint posState)\n            {\n                uint price;\n                if (repIndex == 0)\n                {\n                    price = GET_PRICE_0(mIsRepG0[state]);\n                    price += GET_PRICE_1(mIsRep0Long[state][posState]);\n                }\n                else\n                {\n                    price = GET_PRICE_1(mIsRepG0[state]);\n                    if (repIndex == 1)\n                    {\n                        price += GET_PRICE_0(mIsRepG1[state]);\n                    }\n                    else\n                    {\n                        price += GET_PRICE_1(mIsRepG1[state]);\n                        price += GET_PRICE(mIsRepG2[state], repIndex - 2);\n                    }\n                }\n                return price;\n            }\n\n            private uint GetRepPrice(uint repIndex, uint len, uint state, uint posState)\n            {\n                return mRepLenEnc.mPrices[posState][len - LZMA_MATCH_LEN_MIN]\n                    + GetPureRepPrice(repIndex, state, posState);\n            }\n\n            private uint Backward(out uint backRes, uint cur)\n            {\n                uint posMem = mOpt[cur].mPosPrev;\n                uint backMem = mOpt[cur].mBackPrev;\n                mOptimumEndIndex = cur;\n                do\n                {\n                    if (mOpt[cur].mPrev1IsChar)\n                    {\n                        mOpt[posMem].MakeAsChar();\n                        mOpt[posMem].mPosPrev = posMem - 1;\n\n                        if (mOpt[cur].mPrev2)\n                        {\n                            mOpt[posMem - 1].mPrev1IsChar = false;\n                            mOpt[posMem - 1].mPosPrev = mOpt[cur].mPosPrev2;\n                            mOpt[posMem - 1].mBackPrev = mOpt[cur].mBackPrev2;\n                        }\n                    }\n\n                    uint posPrev = posMem;\n                    uint backCur = backMem;\n\n                    backMem = mOpt[posPrev].mBackPrev;\n                    posMem = mOpt[posPrev].mPosPrev;\n\n                    mOpt[posPrev].mBackPrev = backCur;\n                    mOpt[posPrev].mPosPrev = cur;\n                    cur = posPrev;\n                }\n                while (cur != 0);\n                backRes = mOpt[0].mBackPrev;\n                mOptimumCurrentIndex = mOpt[0].mPosPrev;\n                return mOptimumCurrentIndex;\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            private uint GET_PRICE(ushort prob, uint symbol)\n            {\n                return GET_PRICE(mProbPrices, prob, symbol);\n            }\n\n            private uint GET_PRICE_0(ushort prob)\n            {\n                return GET_PRICE_0(mProbPrices, prob);\n            }\n\n            private uint GET_PRICE_1(ushort prob)\n            {\n                return GET_PRICE_1(mProbPrices, prob);\n            }\n\n            #endregion\n        }\n\n        public static CLzmaEnc LzmaEnc_Create(ISzAlloc alloc)\n        {\n#if !DISABLE_TRACE\n            if (!alloc.CheckAllocObject<CLzmaEnc>())\n                return null;\n#endif\n            return new CLzmaEnc();\n        }\n\n        /* ---------- One Call Interface ---------- */\n\n        /* LzmaEncode\n        Return code:\n          SZ_OK               - OK\n          SZ_ERROR_MEM        - Memory allocation error\n          SZ_ERROR_PARAM      - Incorrect paramater\n          SZ_ERROR_OUTPUT_EOF - output buffer overflow\n          SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)\n        */\n\n        public static SRes LzmaEncode(P<byte> dest, ref long destLen, P<byte> src, long srcLen, CLzmaEncProps props, P<byte> propsEncoded, ref long propsSize, bool writeEndMark, ICompressProgress progress, ISzAlloc alloc, ISzAlloc allocBig)\n        {\n            CLzmaEnc encoder = LzmaEnc_Create(alloc);\n            if (encoder == null)\n                return SZ_ERROR_MEM;\n\n            SRes res;\n            res = encoder.LzmaEnc_SetProps(props);\n            if (res == SZ_OK)\n            {\n                res = encoder.LzmaEnc_WriteProperties(propsEncoded, ref propsSize);\n                if (res == SZ_OK)\n                    res = encoder.LzmaEnc_MemEncode(dest, ref destLen, src, srcLen, writeEndMark, progress, alloc, allocBig);\n            }\n\n            encoder.LzmaEnc_Destroy(alloc, allocBig);\n            return res;\n        }\n    }\n    partial class LZMA\n    {\n        /*\n        RAM requirements for LZMA:\n          for compression:   (dictSize * 11.5 + 6 MB) + state_size\n          for decompression: dictSize + state_size\n            state_size = (4 + (1.5 << (lc + lp))) KB\n            by default (lc=3, lp=0), state_size = 16 KB.\n\n        LZMA properties (5 bytes) format\n            Offset Size  Description\n              0     1    lc, lp and pb in encoded form.\n              1     4    dictSize (little endian).\n        */\n\n        /*\n        LzmaCompress\n        ------------\n\n        outPropsSize -\n             In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.\n             Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.\n\n          LZMA Encoder will use defult values for any parameter, if it is\n          -1  for any from: level, loc, lp, pb, fb, numThreads\n           0  for dictSize\n  \n        level - compression level: 0 <= level <= 9;\n\n          level dictSize algo  fb\n            0:    16 KB   0    32\n            1:    64 KB   0    32\n            2:   256 KB   0    32\n            3:     1 MB   0    32\n            4:     4 MB   0    32\n            5:    16 MB   1    32\n            6:    32 MB   1    32\n            7+:   64 MB   1    64\n \n          The default value for \"level\" is 5.\n\n          algo = 0 means fast method\n          algo = 1 means normal method\n\n        dictSize - The dictionary size in bytes. The maximum value is\n                128 MB = (1 << 27) bytes for 32-bit version\n                  1 GB = (1 << 30) bytes for 64-bit version\n             The default value is 16 MB = (1 << 24) bytes.\n             It's recommended to use the dictionary that is larger than 4 KB and\n             that can be calculated as (1 << N) or (3 << N) sizes.\n\n        lc - The number of literal context bits (high bits of previous literal).\n             It can be in the range from 0 to 8. The default value is 3.\n             Sometimes lc=4 gives the gain for big files.\n\n        lp - The number of literal pos bits (low bits of current position for literals).\n             It can be in the range from 0 to 4. The default value is 0.\n             The lp switch is intended for periodical data when the period is equal to 2^lp.\n             For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's\n             better to set lc=0, if you change lp switch.\n\n        pb - The number of pos bits (low bits of current position).\n             It can be in the range from 0 to 4. The default value is 2.\n             The pb switch is intended for periodical data when the period is equal 2^pb.\n\n        fb - Word size (the number of fast bytes).\n             It can be in the range from 5 to 273. The default value is 32.\n             Usually, a big number gives a little bit better compression ratio and\n             slower compression process.\n\n        numThreads - The number of thereads. 1 or 2. The default value is 2.\n             Fast mode (algo = 0) can use only 1 thread.\n\n        Out:\n          destLen  - processed output size\n        Returns:\n          SZ_OK               - OK\n          SZ_ERROR_MEM        - Memory allocation error\n          SZ_ERROR_PARAM      - Incorrect paramater\n          SZ_ERROR_OUTPUT_EOF - output buffer overflow\n          SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)\n        */\n\n        public static SRes LzmaCompress(\n            P<byte> dest, ref long destLen,\n            P<byte> src, long srcLen,\n            P<byte> outProps, ref long outPropsSize, /* *outPropsSize must be = 5 */\n            int level,      /* 0 <= level <= 9, default = 5 */\n            uint dictSize,  /* default = (1 << 24) */\n            int lc,        /* 0 <= lc <= 8, default = 3  */\n            int lp,        /* 0 <= lp <= 4, default = 0  */\n            int pb,        /* 0 <= pb <= 4, default = 2  */\n            int fb,        /* 5 <= fb <= 273, default = 32 */\n            int numThreads) /* 1 or 2, default = 2 */\n        {\n            CLzmaEncProps props = CLzmaEncProps.LzmaEncProps_Init();\n            props.mLevel = level;\n            props.mDictSize = dictSize;\n            props.mLC = lc;\n            props.mLP = lp;\n            props.mPB = pb;\n            props.mFB = fb;\n            props.mNumThreads = numThreads;\n\n            return LzmaEncode(dest, ref destLen, src, srcLen, props, outProps, ref outPropsSize, false, null, ISzAlloc.SmallAlloc, ISzAlloc.BigAlloc);\n        }\n\n        /*\n        LzmaUncompress\n        --------------\n        In:\n          dest     - output data\n          destLen  - output data size\n          src      - input data\n          srcLen   - input data size\n        Out:\n          destLen  - processed output size\n          srcLen   - processed input size\n        Returns:\n          SZ_OK                - OK\n          SZ_ERROR_DATA        - Data error\n          SZ_ERROR_MEM         - Memory allocation arror\n          SZ_ERROR_UNSUPPORTED - Unsupported properties\n          SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)\n        */\n\n        public static SRes LzmaUncompress(\n            P<byte> dest, ref long destLen,\n            P<byte> src, ref long srcLen,\n            P<byte> props, long propsSize)\n        {\n            ELzmaStatus status;\n            return CLzmaDec.LzmaDecode(dest, ref destLen, src, ref srcLen, props, (uint)propsSize, ELzmaFinishMode.LZMA_FINISH_ANY, out status, ISzAlloc.SmallAlloc);\n        }\n    }\n    partial class LZMA\n    {\n        internal sealed class CLoopThread\n        {\n            #region Variables\n\n            public CThread mThread;\n            public CEvent mStartEvent;\n            public CEvent mFinishedEvent;\n            public bool mStop;\n\n            public Action mFunc;\n            //public CMtThread mParam;\n            //public THREAD_FUNC_RET_TYPE mRes;\n\n            #endregion\n\n            #region Private Methods\n\n            private void LoopThreadFunc()\n            {\n                for (;;)\n                {\n                    if (Event_Wait(mStartEvent) != 0)\n                        return; // SZ_ERROR_THREAD;\n\n                    Trace.MatchObjectWait(this, \"LoopThreadFunc\");\n                    if (mStop)\n                    {\n                        Trace.MatchObjectDestroy(this, \"LoopThreadFunc\");\n                        return; // 0;\n                    }\n                    Trace.MatchObjectWait(this, \"LoopThreadFunc\");\n\n                    /* mRes = mFunc(mParam)*/\n                    mFunc();\n\n                    if (Event_Set(mFinishedEvent) != 0)\n                        return; // SZ_ERROR_THREAD;\n                }\n            }\n\n            #endregion\n\n            #region Methods\n\n            internal CLoopThread() // LoopThread_Construct\n            {\n                Thread_Construct(out mThread);\n                Event_Construct(out mStartEvent);\n                Event_Construct(out mFinishedEvent);\n            }\n\n            internal void LoopThread_Close()\n            {\n                Thread_Close(ref mThread);\n                Event_Close(ref mStartEvent);\n                Event_Close(ref mFinishedEvent);\n            }\n\n            internal SRes LoopThread_Create()\n            {\n                Trace.MatchObjectCreate(this, \"LoopThread_Create\");\n                mStop = false;\n                Trace.MatchObjectWait(this, \"LoopThread_Create\");\n\n                SRes res;\n                if ((res = AutoResetEvent_CreateNotSignaled(out mStartEvent)) != SZ_OK)\n                    return res;\n                if ((res = AutoResetEvent_CreateNotSignaled(out mFinishedEvent)) != SZ_OK)\n                    return res;\n                return Thread_Create(out mThread, LoopThreadFunc, \"LZMA 2 Loop Thread\");\n            }\n\n            internal SRes LoopThread_StopAndWait()\n            {\n                Trace.MatchObjectWait(this, \"LoopThread_StopAndWait\");\n                mStop = true;\n                Trace.MatchObjectWait(this, \"LoopThread_StopAndWait\");\n\n                if (Event_Set(mStartEvent) != 0)\n                    return SZ_ERROR_THREAD;\n\n                return Thread_Wait(mThread);\n            }\n\n            internal SRes LoopThread_StartSubThread()\n            {\n                return Event_Set(mStartEvent);\n            }\n\n            internal SRes LoopThread_WaitSubThread()\n            {\n                return Event_Wait(mFinishedEvent);\n            }\n\n            #endregion\n        }\n\n#if !_7ZIP_ST\n        public const int NUM_MT_CODER_THREADS_MAX = 32;\n#else\n        public const int NUM_MT_CODER_THREADS_MAX = 1;\n#endif\n\n        internal sealed class CMtProgress\n        {\n            #region Variables\n\n            internal ulong mTotalInSize;\n            internal ulong mTotalOutSize;\n            internal ICompressProgress mProgress;\n            internal SRes mRes;\n            internal CCriticalSection mCS = new CCriticalSection();\n            internal ulong[] mInSizes = new ulong[NUM_MT_CODER_THREADS_MAX];\n            internal ulong[] mOutSizes = new ulong[NUM_MT_CODER_THREADS_MAX];\n\n            #endregion\n\n            #region Methods\n\n            internal void MtProgress_Init(ICompressProgress progress)\n            {\n                for (uint i = 0; i < NUM_MT_CODER_THREADS_MAX; i++)\n                    mInSizes[i] = mOutSizes[i] = 0;\n\n                mTotalInSize = 0;\n                mTotalOutSize = 0;\n                mProgress = progress;\n                mRes = SZ_OK;\n            }\n\n            internal void MtProgress_Reinit(int index)\n            {\n                mInSizes[index] = 0;\n                mOutSizes[index] = 0;\n            }\n\n            private static void UPDATE_PROGRESS(ulong size, ref ulong prev, ref ulong total)\n            {\n                if (size != ~0ul)\n                {\n                    total += size - prev;\n                    prev = size;\n                }\n            }\n\n            private static SRes Progress(ICompressProgress p, ulong inSize, ulong outSize)\n            {\n                return (p != null && p.Progress(inSize, outSize) != SZ_OK) ? SZ_ERROR_PROGRESS : SZ_OK;\n            }\n\n            public SRes MtProgress_Set(int index, ulong inSize, ulong outSize)\n            {\n                CriticalSection_Enter(mCS);\n                UPDATE_PROGRESS(inSize, ref mInSizes[index], ref mTotalInSize);\n                UPDATE_PROGRESS(outSize, ref mOutSizes[index], ref mTotalOutSize);\n                if (mRes == SZ_OK)\n                    mRes = Progress(mProgress, mTotalInSize, mTotalOutSize);\n                SRes res = mRes;\n                CriticalSection_Leave(mCS);\n                return res;\n            }\n\n            internal void MtProgress_SetError(SRes res)\n            {\n                CriticalSection_Enter(mCS);\n                if (mRes == SZ_OK)\n                    mRes = res;\n                CriticalSection_Leave(mCS);\n            }\n\n            #endregion\n        }\n\n        internal sealed class CMtThread\n        {\n            #region Variables\n\n            internal CMtCoder mMtCoder;\n            internal byte[] mOutBuf;\n            internal long mOutBufSize;\n            internal byte[] mInBuf;\n            internal long mInBufSize;\n            internal int mIndex;\n            internal CLoopThread mThread;\n\n            internal bool mStopReading;\n            internal bool mStopWriting;\n            internal CEvent mCanRead;\n            internal CEvent mCanWrite;\n\n            #endregion\n\n            #region Methods\n\n            internal CMtThread(int index, CMtCoder mtCoder) // CMtThread_Construct\n            {\n                Trace.MatchObjectCreate(this, \"CMtThread_Construct\");\n\n                mIndex = index;\n                mMtCoder = mtCoder;\n                mOutBuf = null;\n                mInBuf = null;\n\n                Event_Construct(out mCanRead);\n                Event_Construct(out mCanWrite);\n\n                mThread = new CLoopThread();\n            }\n\n            internal CMtThread GET_NEXT_THREAD()\n            {\n                int index = mIndex + 1;\n                if (index == mMtCoder.mNumThreads)\n                    index = 0;\n\n                return mMtCoder.mThreads[index];\n            }\n\n            internal SRes MtThread_Process(out bool stop)\n            {\n                stop = true;\n                if (Event_Wait(mCanRead) != 0)\n                    return SZ_ERROR_THREAD;\n\n                CMtThread next = GET_NEXT_THREAD();\n\n                Trace.MatchObjectWait(this, \"MtThread_Process\");\n                if (mStopReading)\n                {\n                    next.mStopReading = true;\n                    Trace.MatchObjectWait(this, \"MtThread_Process\");\n                    return Event_Set(next.mCanRead) == 0 ? SZ_OK : SZ_ERROR_THREAD;\n                }\n                Trace.MatchObjectWait(this, \"MtThread_Process\");\n\n                {\n                    long size = mMtCoder.mBlockSize;\n                    long destSize = mOutBufSize;\n\n                    SRes res;\n                    if ((res = CMtCoder.FullRead(mMtCoder.mInStream, mInBuf, ref size)) != SZ_OK)\n                        return res;\n\n                    stop = (size != mMtCoder.mBlockSize);\n\n                    Trace.MatchObjectWait(this, \"MtThread_Process:2\");\n                    next.mStopReading = stop;\n                    Trace.MatchObjectWait(this, \"MtThread_Process:2\");\n\n                    if (Event_Set(next.mCanRead) != 0)\n                        return SZ_ERROR_THREAD;\n\n                    if ((res = mMtCoder.mMtCallback.Code(mIndex, mOutBuf, ref destSize, mInBuf, size, stop)) != SZ_OK)\n                        return res;\n\n                    mMtCoder.mMtProgress.MtProgress_Reinit(mIndex);\n\n                    if (Event_Wait(mCanWrite) != 0)\n                        return SZ_ERROR_THREAD;\n\n                    Trace.MatchObjectWait(this, \"MtThread_Process:3\");\n                    if (mStopWriting)\n                    {\n                        Trace.MatchObjectWait(this, \"MtThread_Process:3\");\n                        return SZ_ERROR_FAIL;\n                    }\n                    Trace.MatchObjectWait(this, \"MtThread_Process:3\");\n\n                    if (mMtCoder.mOutStream.Write(mOutBuf, destSize) != destSize)\n                        return SZ_ERROR_WRITE;\n\n                    return Event_Set(next.mCanWrite) == 0 ? SZ_OK : SZ_ERROR_THREAD;\n                }\n            }\n\n            internal void ThreadFunc()\n            {\n                for (;;)\n                {\n                    CMtThread next = GET_NEXT_THREAD();\n\n                    bool stop;\n                    SRes res = MtThread_Process(out stop);\n                    if (res != SZ_OK)\n                    {\n                        mMtCoder.MtCoder_SetError(res);\n                        mMtCoder.mMtProgress.MtProgress_SetError(res);\n\n                        Trace.MatchObjectWait(this, \"ThreadFunc\");\n                        next.mStopReading = true;\n                        next.mStopWriting = true;\n                        Trace.MatchObjectWait(this, \"ThreadFunc\");\n\n                        Event_Set(next.mCanRead);\n                        Event_Set(next.mCanWrite);\n                        return; // res;\n                    }\n\n                    if (stop)\n                        return; // 0;\n                }\n            }\n\n            #endregion\n\n            #region Private Methods\n\n            internal void CMtThread_CloseEvents()\n            {\n                Event_Close(ref mCanRead);\n                Event_Close(ref mCanWrite);\n            }\n\n            internal void CMtThread_Destruct()\n            {\n                Trace.MatchObjectDestroy(this, \"CMtThread_Destruct\");\n                CMtThread_CloseEvents();\n\n                if (Thread_WasCreated(mThread.mThread))\n                {\n                    mThread.LoopThread_StopAndWait();\n                    mThread.LoopThread_Close();\n                }\n\n                if (mMtCoder.mAlloc != null)\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mOutBuf);\n\n                mOutBuf = null;\n\n                if (mMtCoder.mAlloc != null)\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mInBuf);\n\n                mInBuf = null;\n            }\n\n            internal SRes CMtThread_Prepare()\n            {\n                if (mInBuf == null || mInBufSize != mMtCoder.mBlockSize)\n                {\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mInBuf);\n                    mInBufSize = mMtCoder.mBlockSize;\n                    mInBuf = IAlloc_AllocBytes(mMtCoder.mAlloc, mInBufSize);\n                    if (mInBuf == null)\n                        return SZ_ERROR_MEM;\n                }\n\n                if (mOutBuf == null || mOutBufSize != mMtCoder.mDestBlockSize)\n                {\n                    IAlloc_FreeBytes(mMtCoder.mAlloc, mOutBuf);\n                    mOutBufSize = mMtCoder.mDestBlockSize;\n                    mOutBuf = IAlloc_AllocBytes(mMtCoder.mAlloc, mOutBufSize);\n                    if (mOutBuf == null)\n                        return SZ_ERROR_MEM;\n                }\n\n                Trace.MatchObjectWait(this, \"CMtThread_Prepare\");\n                mStopReading = false;\n                mStopWriting = false;\n                Trace.MatchObjectWait(this, \"CMtThread_Prepare\");\n\n                if (AutoResetEvent_CreateNotSignaled(out mCanRead) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                if (AutoResetEvent_CreateNotSignaled(out mCanWrite) != SZ_OK)\n                    return SZ_ERROR_THREAD;\n\n                return SZ_OK;\n            }\n\n            #endregion\n        }\n\n        internal sealed class CMtCoder\n        {\n            #region Variables\n\n            public long mBlockSize;\n            public long mDestBlockSize;\n            public int mNumThreads;\n\n            public ISeqInStream mInStream;\n            public ISeqOutStream mOutStream;\n            public ICompressProgress mProgress;\n            public ISzAlloc mAlloc;\n\n            public CMtCallbackImp mMtCallback;\n            public CCriticalSection mCS = new CCriticalSection();\n            public SRes mRes;\n\n            public CMtProgress mMtProgress = new CMtProgress();\n            public CMtThread[] mThreads;\n\n            #endregion\n\n            #region Internal Methods\n\n            internal CMtCoder() // MtCoder_Construct\n            {\n                mAlloc = null;\n\n                mThreads = new CMtThread[NUM_MT_CODER_THREADS_MAX];\n                for (int i = 0; i < mThreads.Length; i++)\n                    mThreads[i] = new CMtThread(i, this);\n\n                CriticalSection_Init(out mCS);\n                CriticalSection_Init(out mMtProgress.mCS);\n            }\n\n            internal void MtCoder_Destruct()\n            {\n                for (uint i = 0; i < mThreads.Length; i++)\n                    mThreads[i].CMtThread_Destruct();\n\n                CriticalSection_Delete(mCS);\n                CriticalSection_Delete(mMtProgress.mCS);\n            }\n\n            internal SRes MtCoder_Code()\n            {\n                int numThreads = mNumThreads;\n                SRes res = SZ_OK;\n                mRes = SZ_OK;\n\n                mMtProgress.MtProgress_Init(mProgress);\n\n                for (uint i = 0; i < numThreads; i++)\n                {\n                    if ((res = mThreads[i].CMtThread_Prepare()) != SZ_OK)\n                        return res;\n                }\n\n                for (uint i = 0; i < numThreads; i++)\n                {\n                    CMtThread t = mThreads[i];\n                    CLoopThread lt = t.mThread;\n\n                    if (!Thread_WasCreated(lt.mThread))\n                    {\n                        lt.mFunc = t.ThreadFunc;\n                        if (lt.LoopThread_Create() != SZ_OK)\n                        {\n                            res = SZ_ERROR_THREAD;\n                            break;\n                        }\n                    }\n                }\n\n                if (res == SZ_OK)\n                {\n                    int i;\n                    for (i = 0; i < numThreads; i++)\n                    {\n                        CMtThread t = mThreads[i];\n                        if (t.mThread.LoopThread_StartSubThread() != SZ_OK)\n                        {\n                            res = SZ_ERROR_THREAD;\n                            Trace.MatchObjectWait(mThreads[0], \"MtCoder_Code\");\n                            mThreads[0].mStopReading = true;\n                            Trace.MatchObjectWait(mThreads[0], \"MtCoder_Code\");\n                            break;\n                        }\n                    }\n\n                    Event_Set(mThreads[0].mCanWrite);\n                    Event_Set(mThreads[0].mCanRead);\n\n                    for (int j = 0; j < i; j++)\n                        mThreads[j].mThread.LoopThread_WaitSubThread();\n                }\n\n                for (uint i = 0; i < numThreads; i++)\n                    mThreads[i].CMtThread_CloseEvents();\n\n                return (res == SZ_OK) ? mRes : res;\n            }\n\n            #endregion\n\n            #region Methods\n\n            internal void MtCoder_SetError(SRes res)\n            {\n                CriticalSection_Enter(mCS);\n                if (mRes == SZ_OK)\n                    mRes = res;\n                CriticalSection_Leave(mCS);\n            }\n\n            internal static SRes FullRead(ISeqInStream stream, P<byte> data, ref long processedSize)\n            {\n                long size = processedSize;\n                processedSize = 0;\n                while (size != 0)\n                {\n                    long curSize = size;\n                    SRes res = stream.Read(data, ref curSize);\n                    processedSize += curSize;\n                    data += curSize;\n                    size -= curSize;\n                    if (res != SZ_OK)\n                        return res;\n                    if (curSize == 0)\n                        return SZ_OK;\n                }\n                return SZ_OK;\n            }\n\n            #endregion\n        }\n    }\n    partial class LZMA\n    {\n        #region CThread\n\n        internal sealed class CThread\n        {\n#if BUILD_PORTABLE\n            internal System.Threading.Tasks.Task _task;\n#else\n            internal System.Threading.Thread _thread;\n#endif\n        }\n\n        internal static void Thread_Construct(out CThread p)\n        {\n            p = null;\n        }\n\n        internal static bool Thread_WasCreated(CThread p)\n        {\n            return p != null;\n        }\n\n        internal static void Thread_Close(ref CThread p)\n        {\n            if (p != null)\n            {\n#if !DISABLE_TRACE\n                Trace.MatchThreadClose(p._thread);\n#elif BUILD_PORTABLE\n                p._task.GetAwaiter().GetResult();\n#else\n                p._thread.Join();\n#endif\n            }\n\n            p = null;\n        }\n\n        internal static SRes Thread_Wait(CThread p)\n        {\n#if BUILD_PORTABLE\n            p._task.GetAwaiter().GetResult();\n#else\n            p._thread.Join();\n#endif\n\n#if !DISABLE_TRACE\n            Trace.MatchThreadWait(p._thread);\n#endif\n\n            return TSZ(\"Thread_Wait\");\n        }\n\n        internal static SRes Thread_Create(out CThread p, Action func, string threadName)\n        {\n            p = new CThread();\n#if !DISABLE_TRACE\n            p._thread = Trace.MatchThreadStart(func);\n#elif BUILD_PORTABLE\n            p._task = System.Threading.Tasks.Task.Run(func);\n#else\n            p._thread = new System.Threading.Thread(delegate () { func(); });\n            p._thread.Name = threadName;\n            p._thread.Start();\n#endif\n            return TSZ(\"Thread_Create\");\n        }\n\n        #endregion\n\n        #region CEvent\n\n        // this is a win32 autoreset event\n\n        internal sealed class CEvent\n        {\n#if DISABLE_TRACE\n            public System.Threading.AutoResetEvent Event;\n#endif\n        }\n\n        internal static void Event_Construct(out CEvent p)\n        {\n            p = null;\n        }\n\n        internal static bool Event_IsCreated(CEvent p)\n        {\n            return p != null;\n        }\n\n        internal static void Event_Close(ref CEvent p)\n        {\n            if (p != null)\n            {\n#if !DISABLE_TRACE\n                Trace.MatchObjectDestroy(p, \"Event_Close\");\n#elif BUILD_PORTABLE\n                p.Event.Dispose();\n#else\n                p.Event.Close();\n#endif\n            }\n            p = null;\n        }\n\n        internal static SRes Event_Wait(CEvent p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Event_Wait\");\n#else\n            p.Event.WaitOne();\n#endif\n            return TSZ(\"Event_Wait\");\n        }\n\n        internal static SRes Event_Set(CEvent p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Event_Set\");\n#else\n            p.Event.Set();\n#endif\n            return TSZ(\"Event_Set\");\n        }\n\n        internal static SRes Event_Reset(CEvent p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Event_Reset\");\n#else\n            p.Event.Reset();\n#endif\n            return TSZ(\"Event_Reset\");\n        }\n\n        internal static SRes AutoResetEvent_CreateNotSignaled(out CEvent p)\n        {\n            p = new CEvent();\n#if !DISABLE_TRACE\n            Trace.MatchObjectCreate(p, \"Event_Create\");\n#else\n            p.Event = new System.Threading.AutoResetEvent(false);\n#endif\n            return TSZ(\"Event_Create\");\n        }\n\n        #endregion\n\n        #region CSemaphore\n\n        internal sealed class CSemaphore\n        {\n#if DISABLE_TRACE\n            public System.Threading.Semaphore Semaphore;\n#endif\n        }\n\n        internal static void Semaphore_Construct(out CSemaphore p)\n        {\n            p = null;\n        }\n\n        internal static void Semaphore_Close(ref CSemaphore p)\n        {\n            if (p != null)\n            {\n#if !DISABLE_TRACE\n                Trace.MatchObjectDestroy(p, \"Semaphore_Close\");\n#elif BUILD_PORTABLE\n                p.Semaphore.Dispose();\n#else\n                p.Semaphore.Close();\n#endif\n            }\n\n            p = null;\n        }\n\n        internal static SRes Semaphore_Wait(CSemaphore p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Semaphore_Wait\");\n#else\n            p.Semaphore.WaitOne();\n#endif\n            return TSZ(\"Semaphore_Wait\");\n        }\n\n        internal static SRes Semaphore_Create(out CSemaphore p, uint initCount, uint maxCount)\n        {\n            p = new CSemaphore();\n#if !DISABLE_TRACE\n            Trace.MatchObjectCreate(p, \"Semaphore_Create\");\n            Trace.Match((int)initCount, (int)maxCount);\n#else\n            p.Semaphore = new System.Threading.Semaphore(checked((int)initCount), checked((int)maxCount));\n#endif\n            return TSZ(\"Semaphore_Create\");\n        }\n\n        internal static SRes Semaphore_Release1(CSemaphore p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"Semaphore_Release\");\n#else\n            p.Semaphore.Release();\n#endif\n            return TSZ(\"Semaphore_Release\");\n        }\n\n        #endregion\n\n        #region CCriticalSection\n\n        internal sealed class CCriticalSection { }\n\n        internal static SRes CriticalSection_Init(out CCriticalSection p)\n        {\n            p = new CCriticalSection();\n#if !DISABLE_TRACE\n            Trace.MatchObjectCreate(p, \"CriticalSection_Init\");\n#endif\n            return SZ_OK; // never fails in C code either\n        }\n\n        internal static void CriticalSection_Delete(CCriticalSection p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectDestroy(p, \"CriticalSection_Delete\");\n#endif\n        }\n\n        internal static void CriticalSection_Enter(CCriticalSection p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"CriticalSection_Enter\");\n#else\n            System.Threading.Monitor.Enter(p);\n#endif\n        }\n\n        internal static void CriticalSection_Leave(CCriticalSection p)\n        {\n#if !DISABLE_TRACE\n            Trace.MatchObjectWait(p, \"CriticalSection_Leave\");\n#else\n            System.Threading.Monitor.Exit(p);\n#endif\n        }\n\n        #endregion\n    }\n    partial class LZMA\n    {\n        public struct SRes\n        {\n            private int _code;\n            public SRes(int code) { _code = code; }\n            public override int GetHashCode() { return _code; }\n            public override bool Equals(object obj) { return obj is SRes && ((SRes)obj)._code == _code; }\n            public bool Equals(SRes obj) { return obj._code == _code; }\n            public static bool operator ==(SRes left, SRes right) { return left._code == right._code; }\n            public static bool operator !=(SRes left, SRes right) { return left._code != right._code; }\n            public static bool operator ==(SRes left, int right) { return left._code == right; }\n            public static bool operator !=(SRes left, int right) { return left._code != right; }\n        }\n\n        public static SRes SZ_OK { get { return new SRes(0); } }\n\n        public static SRes SZ_ERROR_DATA { get { return new SRes(1); } }\n        public static SRes SZ_ERROR_MEM { get { return new SRes(2); } }\n        public static SRes SZ_ERROR_CRC { get { return new SRes(3); } }\n        public static SRes SZ_ERROR_UNSUPPORTED { get { return new SRes(4); } }\n        public static SRes SZ_ERROR_PARAM { get { return new SRes(5); } }\n        public static SRes SZ_ERROR_INPUT_EOF { get { return new SRes(6); } }\n        public static SRes SZ_ERROR_OUTPUT_EOF { get { return new SRes(7); } }\n        public static SRes SZ_ERROR_READ { get { return new SRes(8); } }\n        public static SRes SZ_ERROR_WRITE { get { return new SRes(9); } }\n        public static SRes SZ_ERROR_PROGRESS { get { return new SRes(10); } }\n        public static SRes SZ_ERROR_FAIL { get { return new SRes(11); } }\n        public static SRes SZ_ERROR_THREAD { get { return new SRes(12); } }\n\n        public static SRes SZ_ERROR_ARCHIVE { get { return new SRes(16); } }\n        public static SRes SZ_ERROR_NO_ARCHIVE { get { return new SRes(17); } }\n\n        //#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }\n\n        /* The following interfaces use first parameter as pointer to structure */\n\n        /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.\n           (output(*size) < input(*size)) is allowed */\n        public interface ISeqInStream\n        {\n            SRes Read(P<byte> buf, ref long size);\n        }\n\n        public class CSeqInStream : ISeqInStream\n        {\n            private Func<P<byte>, long, long> mCallback;\n\n            public CSeqInStream(Func<P<byte>, long, long> callback)\n            {\n                mCallback = callback;\n            }\n\n            SRes ISeqInStream.Read(P<byte> buf, ref long size)\n            {\n                try { size = mCallback(buf, size); }\n                catch { return SZ_ERROR_READ; }\n                return SZ_OK;\n            }\n        }\n\n        /* Returns: result - the number of actually written bytes.\n           (result < size) means error */\n        public interface ISeqOutStream\n        {\n            long Write(P<byte> buf, long size);\n        }\n\n        public class CSeqOutStream : ISeqOutStream\n        {\n            private Action<P<byte>, long> mCallback;\n\n            public CSeqOutStream(Action<P<byte>, long> callback)\n            {\n                mCallback = callback;\n            }\n\n            long ISeqOutStream.Write(P<byte> buf, long size)\n            {\n                if (size <= 0)\n                {\n                    System.Diagnostics.Debugger.Break();\n                    return -1;\n                }\n\n                try { mCallback(buf, size); }\n                catch { return 0; }\n                return size;\n            }\n        }\n\n        /* Returns: result. (result != SZ_OK) means break.\n           Value (ulong)(long)-1 for size means unknown value. */\n        public interface ICompressProgress\n        {\n            SRes Progress(ulong inSize, ulong outSize);\n        }\n\n        //public delegate object ISzAlloc_Alloc(object p, long size);\n        //public delegate void ISzAlloc_Free(object p, object address); /* address can be null */\n        public sealed class ISzAlloc\n        {\n            public static readonly ISzAlloc BigAlloc = new ISzAlloc(200);\n            public static readonly ISzAlloc SmallAlloc = new ISzAlloc(100);\n\n            private static Dictionary<long, List<byte[]>> Cache1 = new Dictionary<long, List<byte[]>>();\n            private static Dictionary<long, List<ushort[]>> Cache2 = new Dictionary<long, List<ushort[]>>();\n            private static Dictionary<long, List<uint[]>> Cache3 = new Dictionary<long, List<uint[]>>();\n\n            private int mKind;\n\n            private ISzAlloc(int kind)\n            {\n                mKind = kind;\n            }\n\n#if !DISABLE_TRACE\n            internal bool CheckAllocObject<T>()\n            {\n                return true;\n            }\n#endif\n\n            public T AllocObject<T>(object p)\n                where T : class, new()\n            {\n#if !DISABLE_TRACE\n                if (!CheckAllocObject<T>())\n                    return null;\n#endif\n                return new T();\n            }\n\n            public byte[] AllocBytes(object p, long size)\n            {\n                lock (Cache1)\n                {\n                    List<byte[]> cache;\n                    if (Cache1.TryGetValue(size, out cache) && cache.Count > 0)\n                    {\n                        byte[] buffer = cache[cache.Count - 1];\n                        cache.RemoveAt(cache.Count - 1);\n                        return buffer;\n                    }\n                }\n\n                System.Diagnostics.Debug.WriteLine(\"Alloc byte size=\" + size);\n                return new byte[size];\n            }\n\n            public ushort[] AllocUInt16(object p, long size)\n            {\n                lock (Cache2)\n                {\n                    List<ushort[]> cache;\n                    if (Cache2.TryGetValue(size, out cache) && cache.Count > 0)\n                    {\n                        ushort[] buffer = cache[cache.Count - 1];\n                        cache.RemoveAt(cache.Count - 1);\n                        return buffer;\n                    }\n                }\n\n                System.Diagnostics.Debug.WriteLine(\"Alloc ushort size=\" + size);\n                return new ushort[size];\n            }\n\n            public uint[] AllocUInt32(object p, long size)\n            {\n                lock (Cache3)\n                {\n                    List<uint[]> cache;\n                    if (Cache3.TryGetValue(size, out cache) && cache.Count > 0)\n                    {\n                        uint[] buffer = cache[cache.Count - 1];\n                        cache.RemoveAt(cache.Count - 1);\n                        return buffer;\n                    }\n                }\n\n                System.Diagnostics.Debug.WriteLine(\"Alloc uint size=\" + size);\n                return new uint[size];\n            }\n\n            public void FreeObject(object p, object address)\n            {\n                // ignore\n            }\n\n            public void FreeBytes(object p, byte[] buffer)\n            {\n                if (buffer != null)\n                {\n                    lock (Cache1)\n                    {\n                        List<byte[]> cache;\n                        if (!Cache1.TryGetValue(buffer.Length, out cache))\n                            Cache1.Add(buffer.Length, cache = new List<byte[]>());\n\n                        cache.Add(buffer);\n                    }\n                }\n            }\n\n            public void FreeUInt16(object p, ushort[] buffer)\n            {\n                if (buffer != null)\n                {\n                    lock (Cache2)\n                    {\n                        List<ushort[]> cache;\n                        if (!Cache2.TryGetValue(buffer.Length, out cache))\n                            Cache2.Add(buffer.Length, cache = new List<ushort[]>());\n\n                        cache.Add(buffer);\n                    }\n                }\n            }\n\n            public void FreeUInt32(object p, uint[] buffer)\n            {\n                if (buffer != null)\n                {\n                    lock (Cache3)\n                    {\n                        List<uint[]> cache;\n                        if (!Cache3.TryGetValue(buffer.Length, out cache))\n                            Cache3.Add(buffer.Length, cache = new List<uint[]>());\n\n                        cache.Add(buffer);\n                    }\n                }\n            }\n        }\n\n        public static byte[] IAlloc_AllocBytes(object p, long size)\n        {\n            return ((ISzAlloc)p).AllocBytes(p, size);\n        }\n\n        public static uint[] IAlloc_AllocUInt32(object p, long size)\n        {\n            return ((ISzAlloc)p).AllocUInt32(p, size);\n        }\n\n        public static void IAlloc_FreeObject(object p, object a)\n        {\n            ((ISzAlloc)p).FreeObject(p, a);\n        }\n\n        public static void IAlloc_FreeBytes(object p, byte[] a)\n        {\n            ((ISzAlloc)p).FreeBytes(p, a);\n        }\n\n        public static void IAlloc_FreeUInt32(object p, uint[] a)\n        {\n            ((ISzAlloc)p).FreeUInt32(p, a);\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    /// <summary>\n    /// A comma between two parameters in a call to a C# method or indexer, or in the declaration of a method or\n    /// indexer, is not placed on the same line as the previous parameter.\n    /// </summary>\n    /// <remarks>\n    /// <para>A violation of this rule occurs when a comma between two parameters to a method or indexer is not placed\n    /// on the same line as the previous parameter. The following examples show correct placement of the comma:</para>\n    /// <code language=\"csharp\">\n    /// public string JoinName(string first, string last)\n    /// {\n    /// \u00a0\u00a0\u00a0 string name = JoinStrings(\n    /// \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 first,\n    /// \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 last);\n    /// }\n    ///\n    /// public int this[int x,\n    /// \u00a0\u00a0 int y]\n    /// {\n    /// \u00a0\u00a0\u00a0 get { return this.items[x, y]; }\n    /// }\n    /// </code>\n    /// </remarks>\n    [DiagnosticAnalyzer(LanguageNames.CSharp)]\n    internal class SA1113CommaMustBeOnSameLineAsPreviousParameter : DiagnosticAnalyzer\n    {\n        /// <summary>\n        /// The ID for diagnostics produced by the <see cref=\"SA1113CommaMustBeOnSameLineAsPreviousParameter\"/>\n        /// analyzer.\n        /// </summary>\n        public const string DiagnosticId = \"SA1113\";\n        private static readonly LocalizableString Title = new LocalizableResourceString(nameof(ReadabilityResources.SA1113Title), ReadabilityResources.ResourceManager, typeof(ReadabilityResources));\n        private static readonly LocalizableString MessageFormat = new LocalizableResourceString(nameof(ReadabilityResources.SA1113MessageFormat), ReadabilityResources.ResourceManager, typeof(ReadabilityResources));\n        private static readonly LocalizableString Description = new LocalizableResourceString(nameof(ReadabilityResources.SA1113Description), ReadabilityResources.ResourceManager, typeof(ReadabilityResources));\n        private static readonly string HelpLink = \"https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1113.md\";\n\n        private static readonly DiagnosticDescriptor Descriptor =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, AnalyzerCategory.ReadabilityRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        private static readonly ImmutableArray<SyntaxKind> BaseMethodDeclarationKinds =\n            ImmutableArray.Create(\n                SyntaxKind.MethodDeclaration,\n                SyntaxKind.ConstructorDeclaration,\n                SyntaxKind.OperatorDeclaration);\n\n        private static readonly Action<SyntaxNodeAnalysisContext> BaseMethodDeclarationAction = HandleBaseMethodDeclaration;\n        private static readonly Action<SyntaxNodeAnalysisContext> LocalFunctionStatementAction = HandleLocalFunctionStatement;\n        private static readonly Action<SyntaxNodeAnalysisContext> InvocationExpressionAction = HandleInvocationExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> ObjectCreationExpressionAction = HandleObjectCreationExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> IndexerDeclarationAction = HandleIndexerDeclaration;\n        private static readonly Action<SyntaxNodeAnalysisContext> ElementAccessExpressionAction = HandleElementAccessExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> AnonymousMethodExpressionAction = HandleAnonymousMethodExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> DelegateDeclarationAction = HandleDelegateDeclaration;\n        private static readonly Action<SyntaxNodeAnalysisContext> ParenthesizedLambdaExpressionAction = HandleParenthesizedLambdaExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> AttributeAction = HandleAttribute;\n        private static readonly Action<SyntaxNodeAnalysisContext> AttributeListAction = HandleAttributeList;\n        private static readonly Action<SyntaxNodeAnalysisContext> ArrayCreationExpressionAction = HandleArrayCreationExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> ConstructorInitializerAction = HandleConstructorInitializer;\n\n        /// <inheritdoc/>\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } =\n            ImmutableArray.Create(Descriptor);\n\n        /// <inheritdoc/>\n        public override void Initialize(AnalysisContext context)\n        {\n            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);\n            context.EnableConcurrentExecution();\n\n            context.RegisterSyntaxNodeAction(BaseMethodDeclarationAction, BaseMethodDeclarationKinds);\n            context.RegisterSyntaxNodeAction(LocalFunctionStatementAction, SyntaxKindEx.LocalFunctionStatement);\n            context.RegisterSyntaxNodeAction(InvocationExpressionAction, SyntaxKind.InvocationExpression);\n            context.RegisterSyntaxNodeAction(ObjectCreationExpressionAction, SyntaxKind.ObjectCreationExpression);\n            context.RegisterSyntaxNodeAction(IndexerDeclarationAction, SyntaxKind.IndexerDeclaration);\n            context.RegisterSyntaxNodeAction(ElementAccessExpressionAction, SyntaxKind.ElementAccessExpression);\n            context.RegisterSyntaxNodeAction(AnonymousMethodExpressionAction, SyntaxKind.AnonymousMethodExpression);\n            context.RegisterSyntaxNodeAction(DelegateDeclarationAction, SyntaxKind.DelegateDeclaration);\n            context.RegisterSyntaxNodeAction(ParenthesizedLambdaExpressionAction, SyntaxKind.ParenthesizedLambdaExpression);\n            context.RegisterSyntaxNodeAction(AttributeAction, SyntaxKind.Attribute);\n            context.RegisterSyntaxNodeAction(AttributeListAction, SyntaxKind.AttributeList);\n            context.RegisterSyntaxNodeAction(ArrayCreationExpressionAction, SyntaxKind.ArrayCreationExpression);\n            context.RegisterSyntaxNodeAction(ConstructorInitializerAction, SyntaxKinds.ConstructorInitializer);\n        }\n\n        private static void HandleArrayCreationExpression(SyntaxNodeAnalysisContext context)\n        {\n            var arrayCreationExpression = (ArrayCreationExpressionSyntax)context.Node;\n\n            if (arrayCreationExpression.Type == null)\n            {\n                return;\n            }\n\n            foreach (var arrayRankSpecifierSyntax in arrayCreationExpression.Type.RankSpecifiers)\n            {\n                var sizes = arrayRankSpecifierSyntax.Sizes;\n                if (sizes.Count < 2)\n                {\n                    continue;\n                }\n\n                if (!arrayRankSpecifierSyntax.CloseBracketToken.IsMissing)\n                {\n                    CheckIfCommasAreAtTheSameLineAsThePreviousParameter(context, sizes.GetWithSeparators());\n                }\n            }\n        }\n\n        private static void HandleAttributeList(SyntaxNodeAnalysisContext context)\n        {\n            var attributeList = (AttributeListSyntax)context.Node;\n\n            if (attributeList != null && !attributeList.IsMissing)\n            {\n                var attributes = attributeList.Attributes;\n                if (attributes.Count > 1)\n                {\n                    CheckIfCommasAreAtTheSameLineAsThePreviousParameter(context, attributes.GetWithSeparators());\n                }\n            }\n        }\n\n        private static void HandleAttribute(SyntaxNodeAnalysisContext context)\n        {\n            var attribute = (AttributeSyntax)context.Node;\n            var argumentList = attribute.ArgumentList;\n\n            if (argumentList != null && !argumentList.IsMissing)\n            {\n                var arguments = argumentList.Arguments;\n                if (arguments.Count > 1)\n                {\n                    CheckIfCommasAreAtTheSameLineAsThePreviousParameter(context, arguments.GetWithSeparators());\n                }\n            }\n        }\n\n        private static void HandleParenthesizedLambdaExpression(SyntaxNodeAnalysisContext context)\n        {\n            var parenthesizedLambdaExpression = (ParenthesizedLambdaExpressionSyntax)context.Node;\n            HandleBaseParameterListSyntax(context, parenthesizedLambdaExpression.ParameterList);\n        }\n\n        private static void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context)\n        {\n            var delegateDeclaration = (DelegateDeclarationSyntax)context.Node;\n            HandleBaseParameterListSyntax(context, delegateDeclaration.ParameterList);\n        }\n\n        private static void HandleAnonymousMethodExpression(SyntaxNodeAnalysisContext context)\n        {\n            var anonymousMethodExpression = (AnonymousMethodExpressionSyntax)context.Node;\n            HandleBaseParameterListSyntax(context, anonymousMethodExpression.ParameterList);\n        }\n\n        private static void HandleElementAccessExpression(SyntaxNodeAnalysisContext context)\n        {\n            var elementAccessExpression = (ElementAccessExpressionSyntax)context.Node;\n            HandleBaseArgumentListSyntax(context, elementAccessExpression.ArgumentList);\n        }\n\n        private static void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context)\n        {\n            var indexerDeclaration = (IndexerDeclarationSyntax)context.Node;\n            HandleBaseParameterListSyntax(context, indexerDeclaration.ParameterList);\n        }\n\n        private static void HandleObjectCreationExpression(SyntaxNodeAnalysisContext context)\n        {\n            var objectCreationExpression = (ObjectCreationExpressionSyntax)context.Node;\n            HandleBaseArgumentListSyntax(context, objectCreationExpression.ArgumentList);\n        }\n\n        private static void HandleInvocationExpression(SyntaxNodeAnalysisContext context)\n        {\n            var invocationEpression = (InvocationExpressionSyntax)context.Node;\n            HandleBaseArgumentListSyntax(context, invocationEpression.ArgumentList);\n        }\n\n        private static void HandleBaseMethodDeclaration(SyntaxNodeAnalysisContext context)\n        {\n            var baseMethodDeclaration = (BaseMethodDeclarationSyntax)context.Node;\n            HandleBaseParameterListSyntax(context, baseMethodDeclaration.ParameterList);\n        }\n\n        private static void HandleLocalFunctionStatement(SyntaxNodeAnalysisContext context)\n        {\n            var localFunctionStatement = (LocalFunctionStatementSyntaxWrapper)context.Node;\n            HandleBaseParameterListSyntax(context, localFunctionStatement.ParameterList);\n        }\n\n        private static void HandleConstructorInitializer(SyntaxNodeAnalysisContext context)\n        {\n            var constructorInitializer = (ConstructorInitializerSyntax)context.Node;\n            HandleBaseArgumentListSyntax(context, constructorInitializer.ArgumentList);\n        }\n\n        private static void HandleBaseArgumentListSyntax(SyntaxNodeAnalysisContext context, BaseArgumentListSyntax argumentList)\n        {\n            if (argumentList != null && !argumentList.IsMissing)\n            {\n                var arguments = argumentList.Arguments;\n                if (arguments.Count > 1)\n                {\n                    CheckIfCommasAreAtTheSameLineAsThePreviousParameter(context, arguments.GetWithSeparators());\n                }\n            }\n        }\n\n        private static void HandleBaseParameterListSyntax(SyntaxNodeAnalysisContext context, BaseParameterListSyntax parameterList)\n        {\n            if (parameterList != null && !parameterList.IsMissing)\n            {\n                var parameters = parameterList.Parameters;\n                if (parameters.Count > 1)\n                {\n                    CheckIfCommasAreAtTheSameLineAsThePreviousParameter(context, parameters.GetWithSeparators());\n                }\n            }\n        }\n\n        private static void CheckIfCommasAreAtTheSameLineAsThePreviousParameter(SyntaxNodeAnalysisContext context, SyntaxNodeOrTokenList nodeOrTokenList)\n        {\n            SyntaxNode previousNode = null;\n\n            // If index is even we expecting parameter syntax node, otherwise we expecting comma token.\n            for (int index = 0, count = nodeOrTokenList.Count; index < count; ++index)\n            {\n                SyntaxNodeOrToken nodeOrToken = nodeOrTokenList[index];\n                if (index % 2 == 0)\n                {\n                    // We expecting node here\n                    if (nodeOrToken.IsToken)\n                    {\n                        return;\n                    }\n\n                    previousNode = nodeOrToken.AsNode();\n                }\n                else\n                {\n                    // We expecting token here\n                    if (nodeOrToken.IsNode)\n                    {\n                        return;\n                    }\n\n                    if (previousNode.GetEndLine() < nodeOrToken.GetLineSpan().StartLinePosition.Line)\n                    {\n                        var properties = TokenSpacingProperties.RemovePrecedingPreserveLayout;\n                        context.ReportDiagnostic(Diagnostic.Create(Descriptor, nodeOrToken.GetLocation(), properties));\n                    }\n                }\n            }\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n        private static class Log\n        {\n            public static class EventIds\n            {\n                public static readonly EventId EndpointsFound = new EventId(100, \"EndpointsFound\");\n                public static readonly EventId EndpointsNotFound = new EventId(101, \"EndpointsNotFound\");\n\n                public static readonly EventId TemplateSucceeded = new EventId(102, \"TemplateSucceeded\");\n                public static readonly EventId TemplateFailedRequiredValues = new EventId(103, \"TemplateFailedRequiredValues\");\n                public static readonly EventId TemplateFailedConstraint = new EventId(103, \"TemplateFailedConstraint\");\n                public static readonly EventId TemplateFailedExpansion = new EventId(104, \"TemplateFailedExpansion\");\n\n                public static readonly EventId LinkGenerationSucceeded = new EventId(105, \"LinkGenerationSucceeded\");\n                public static readonly EventId LinkGenerationFailed = new EventId(106, \"LinkGenerationFailed\");\n            }\n\n            private static readonly Action<ILogger, IEnumerable<string>, object, Exception> _endpointsFound = LoggerMessage.Define<IEnumerable<string>, object>(\n                LogLevel.Debug,\n                EventIds.EndpointsFound,\n                \"Found the endpoints {Endpoints} for address {Address}\");\n\n            private static readonly Action<ILogger, object, Exception> _endpointsNotFound = LoggerMessage.Define<object>(\n                LogLevel.Debug,\n                EventIds.EndpointsNotFound,\n                \"No endpoints found for address {Address}\");\n\n            private static readonly Action<ILogger, string, string, string, string, Exception> _templateSucceeded = LoggerMessage.Define<string, string, string, string>(\n                LogLevel.Debug,\n                EventIds.TemplateSucceeded,\n                \"Successfully processed template {Template} for {Endpoint} resulting in {Path} and {Query}\");\n\n            private static readonly Action<ILogger, string, string, string, string, string, Exception> _templateFailedRequiredValues = LoggerMessage.Define<string, string, string, string, string>(\n                LogLevel.Debug,\n                EventIds.TemplateFailedRequiredValues,\n                \"Failed to process the template {Template} for {Endpoint}. \" +\n                \"A required route value is missing, or has a different value from the required default values.\" +\n                \"Supplied ambient values {AmbientValues} and {Values} with default values {Defaults}\");\n\n            private static readonly Action<ILogger, string, string, IRouteConstraint, string, string, Exception> _templateFailedConstraint = LoggerMessage.Define<string, string, IRouteConstraint, string, string>(\n                LogLevel.Debug,\n                EventIds.TemplateFailedConstraint,\n                \"Failed to process the template {Template} for {Endpoint}. \" + \n                \"The constraint {Constraint} for parameter {ParameterName} failed with values {Values}\");\n\n            private static readonly Action<ILogger, string, string, string, Exception> _templateFailedExpansion = LoggerMessage.Define<string, string, string>(\n                LogLevel.Debug,\n                EventIds.TemplateFailedExpansion,\n                \"Failed to process the template {Template} for {Endpoint}. \" +\n                \"The failure occured while expanding the template with values {Values} \" +\n                \"This is usually due to a missing or empty value in a complex segment\");\n\n            private static readonly Action<ILogger, IEnumerable<string>, string, Exception> _linkGenerationSucceeded = LoggerMessage.Define<IEnumerable<string>, string>(\n                LogLevel.Debug,\n                EventIds.LinkGenerationSucceeded,\n                \"Link generation succeeded for endpoints {Endpoints} with result {URI}\");\n\n            private static readonly Action<ILogger, IEnumerable<string>, Exception> _linkGenerationFailed = LoggerMessage.Define<IEnumerable<string>>(\n                LogLevel.Debug,\n                EventIds.LinkGenerationFailed,\n                \"Link generation failed for endpoints {Endpoints}\");\n\n            public static void EndpointsFound(ILogger logger, object address, IEnumerable<Endpoint> endpoints)\n            {\n                // Checking level again to avoid allocation on the common path\n                if (logger.IsEnabled(LogLevel.Debug))\n                {\n                    _endpointsFound(logger, endpoints.Select(e => e.DisplayName), address, null);\n                }\n            }\n\n            public static void EndpointsNotFound(ILogger logger, object address)\n            {\n                _endpointsNotFound(logger, address, null);\n            }\n\n            public static void TemplateSucceeded(ILogger logger, RouteEndpoint endpoint, PathString path, QueryString query)\n            {\n                _templateSucceeded(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, path.Value, query.Value, null);\n            }\n\n            public static void TemplateFailedRequiredValues(ILogger logger, RouteEndpoint endpoint, RouteValueDictionary ambientValues, RouteValueDictionary values)\n            {\n                // Checking level again to avoid allocation on the common path\n                if (logger.IsEnabled(LogLevel.Debug))\n                {\n                    _templateFailedRequiredValues(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, FormatRouteValues(ambientValues), FormatRouteValues(values), FormatRouteValues(endpoint.RoutePattern.Defaults), null);\n                }\n            }\n\n            public static void TemplateFailedConstraint(ILogger logger, RouteEndpoint endpoint, string parameterName, IRouteConstraint constraint, RouteValueDictionary values)\n            {\n                // Checking level again to avoid allocation on the common path\n                if (logger.IsEnabled(LogLevel.Debug))\n                {\n                    _templateFailedConstraint(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, constraint, parameterName, FormatRouteValues(values), null);\n                }\n            }\n\n            public static void TemplateFailedExpansion(ILogger logger, RouteEndpoint endpoint, RouteValueDictionary values)\n            {\n                // Checking level again to avoid allocation on the common path\n                if (logger.IsEnabled(LogLevel.Debug))\n                {\n                    _templateFailedExpansion(logger, endpoint.RoutePattern.RawText, endpoint.DisplayName, FormatRouteValues(values), null);\n                }\n            }\n\n            public static void LinkGenerationSucceeded(ILogger logger, IEnumerable<Endpoint> endpoints, string  uri)\n            {\n                // Checking level again to avoid allocation on the common path\n                if (logger.IsEnabled(LogLevel.Debug))\n                {\n                    _linkGenerationSucceeded(logger, endpoints.Select(e => e.DisplayName), uri, null);\n                }\n            }\n\n            public static void LinkGenerationFailed(ILogger logger, IEnumerable<Endpoint> endpoints)\n            {\n                // Checking level again to avoid allocation on the common path\n                if (logger.IsEnabled(LogLevel.Debug))\n                {\n                    _linkGenerationFailed(logger, endpoints.Select(e => e.DisplayName), null);\n                }\n            }\n\n            // EXPENSIVE: should only be used at Debug and higher levels of logging.\n            private static string FormatRouteValues(IReadOnlyDictionary<string, object> values)\n            {\n                if (values == null || values.Count == 0)\n                {\n                    return \"{ }\";\n                }\n\n                var builder = new StringBuilder();\n                builder.Append(\"{ \");\n\n                foreach (var kvp in values.OrderBy(kvp => kvp.Key))\n                {\n                    builder.Append(\"\\\"\");\n                    builder.Append(kvp.Key);\n                    builder.Append(\"\\\"\");\n                    builder.Append(\":\");\n                    builder.Append(\" \");\n                    builder.Append(\"\\\"\");\n                    builder.Append(kvp.Value);\n                    builder.Append(\"\\\"\");\n                    builder.Append(\", \");\n                }\n\n                // Trim trailing \", \"\n                builder.Remove(builder.Length - 2, 2);\n\n                builder.Append(\" }\");\n\n                return builder.ToString();\n            }\n        }\n\n        private static class Log\n        {\n            private static readonly Action<ILogger, string, Exception> _executingEndpoint = LoggerMessage.Define<string>(\n                LogLevel.Information,\n                new EventId(0, \"ExecutingEndpoint\"),\n                \"Executing endpoint '{EndpointName}'\");\n\n            private static readonly Action<ILogger, string, Exception> _executedEndpoint = LoggerMessage.Define<string>(\n                LogLevel.Information,\n                new EventId(1, \"ExecutedEndpoint\"),\n                \"Executed endpoint '{EndpointName}'\");\n\n            public static void ExecutingEndpoint(ILogger logger, Endpoint endpoint)\n            {\n                _executingEndpoint(logger, endpoint.DisplayName, null);\n            }\n\n            public static void ExecutedEndpoint(ILogger logger, Endpoint endpoint)\n            {\n                _executedEndpoint(logger, endpoint.DisplayName, null);\n            }\n        }\n\n        private static class Log\n        {\n            private static readonly Action<ILogger, string, Exception> _matchSuccess = LoggerMessage.Define<string>(\n                LogLevel.Debug,\n                new EventId(1, \"MatchSuccess\"),\n                \"Request matched endpoint '{EndpointName}'\");\n\n            private static readonly Action<ILogger, Exception> _matchFailure = LoggerMessage.Define(\n                LogLevel.Debug,\n                new EventId(2, \"MatchFailure\"),\n                \"Request did not match any endpoints\");\n\n            public static void MatchSuccess(ILogger logger, EndpointSelectorContext context)\n            {\n                _matchSuccess(logger, context.Endpoint.DisplayName, null);\n            }\n\n            public static void MatchFailure(ILogger logger)\n            {\n                _matchFailure(logger, null);\n            }\n        }\n", "label": "MultifacetedAbstraction"}
{"text": "\npublic class AutoCatTags : AutoCat {\n\n        public override AutoCatType AutoCatType {\n            get { return AutoCatType.Tags; }\n        }\n\n        public string Prefix { get; set; }\n        public int MaxTags { get; set; }\n        public HashSet<string> IncludedTags { get; set; }\n\n        public bool ListOwnedOnly { get; set; }\n        public float ListWeightFactor { get; set; }\n        public int ListMinScore { get; set; }\n        public int ListTagsPerGame { get; set; }\n        public bool ListScoreSort { get; set; }\n        public bool ListExcludeGenres { get; set; }\n\n        public const string TypeIdString = \"AutoCatTags\";\n        private const string XmlName_Name = \"Name\",\n            XmlName_Prefix = \"Prefix\",\n            XmlName_TagList = \"Tags\",\n            XmlName_Tag = \"Tag\",\n            XmlName_MaxTags = \"MaxTags\",\n            XmlName_ListOwnedOnly = \"List_OwnedOnly\",\n            XmlName_ListWeightFactor = \"List_WeightedScore\",\n            XmlName_ListMinScore = \"List_MinScore\",\n            XmlName_ListTagsPerGame = \"List_TagsPerGame\",\n            XmlName_ListExcludeGenres = \"List_ExcludeGenres\",\n            XmlName_ListScoreSort = \"List_ScoreSort\";\n\n        public AutoCatTags( string name, string prefix = \"\",\n            HashSet<string> tags = null, int maxTags = 0,\n            bool listOwnedOnly = true, float listWeightFactor = 1, int listMinScore = 0, int listTagsPerGame = 0, bool listScoreSort = true, bool listExcludeGenres = true )\n            : base( name ) {\n            this.Prefix = prefix;\n\n            if( tags == null ) IncludedTags = new HashSet<string>();\n            else IncludedTags = tags;\n\n            this.MaxTags = maxTags;\n            this.ListOwnedOnly = listOwnedOnly;\n            this.ListWeightFactor = listWeightFactor;\n            this.ListMinScore = listMinScore;\n            this.ListTagsPerGame = listTagsPerGame;\n            this.ListScoreSort = listScoreSort;\n            this.ListExcludeGenres = listExcludeGenres;\n        }\n\n        protected AutoCatTags( AutoCatTags other )\n            : base( other ) {\n            this.Prefix = other.Prefix;\n            this.IncludedTags = new HashSet<string>( other.IncludedTags );\n            this.MaxTags = other.MaxTags;\n\n            this.ListOwnedOnly = other.ListOwnedOnly;\n            this.ListWeightFactor = other.ListWeightFactor;\n            this.ListMinScore = other.ListMinScore;\n            this.ListTagsPerGame = other.ListTagsPerGame;\n            this.ListScoreSort = other.ListScoreSort;\n            this.ListExcludeGenres = other.ListExcludeGenres;\n        }\n\n        public override AutoCat Clone() {\n            return new AutoCatTags( this );\n        }\n\n        public override AutoCatResult CategorizeGame( GameInfo game ) {\n            if( games == null ) {\n                Program.Logger.Write( LoggerLevel.Error, GlobalStrings.Log_AutoCat_GamelistNull );\n                throw new ApplicationException( GlobalStrings.AutoCatGenre_Exception_NoGameList );\n            }\n            if( db == null ) {\n                Program.Logger.Write( LoggerLevel.Error, GlobalStrings.Log_AutoCat_DBNull );\n                throw new ApplicationException( GlobalStrings.AutoCatGenre_Exception_NoGameDB );\n            }\n            if( game == null ) {\n                Program.Logger.Write( LoggerLevel.Error, GlobalStrings.Log_AutoCat_GameNull );\n                return AutoCatResult.Failure;\n            }\n\n            if( !db.Contains( game.Id ) || db.Games[game.Id].LastStoreScrape == 0 ) return AutoCatResult.NotInDatabase;\n\n            List<string> gameTags = db.GetTagList( game.Id );\n\n            if( gameTags != null ) {\n                int added = 0;\n                for( int index = 0; index < gameTags.Count && ( MaxTags == 0 || added < MaxTags ); index++ ) {\n                    if( IncludedTags.Contains( gameTags[index] ) ) {\n                        game.AddCategory( games.GetCategory( GetProcessedString( gameTags[index] ) ) );\n                        added++;\n                    }\n                }\n            }\n\n            return AutoCatResult.Success;\n        }\n\n        public string GetProcessedString( string s ) {\n            if( string.IsNullOrEmpty( Prefix ) ) {\n                return s;\n            } else {\n                return Prefix + s;\n            }\n        }\n\n        public override void WriteToXml( XmlWriter writer ) {\n            writer.WriteStartElement( TypeIdString );\n\n            writer.WriteElementString( XmlName_Name, Name );\n            if( !string.IsNullOrEmpty( Prefix ) ) writer.WriteElementString( XmlName_Prefix, Prefix );\n            writer.WriteElementString( XmlName_MaxTags, MaxTags.ToString() );\n\n            if( IncludedTags != null && IncludedTags.Count > 0 ) {\n                writer.WriteStartElement( XmlName_TagList );\n                foreach( string s in IncludedTags ) {\n                    writer.WriteElementString( XmlName_Tag, s );\n                }\n                writer.WriteEndElement();\n            }\n\n            writer.WriteElementString( XmlName_ListOwnedOnly, ListOwnedOnly.ToString() );\n            writer.WriteElementString( XmlName_ListWeightFactor, ListWeightFactor.ToString() );\n            writer.WriteElementString( XmlName_ListMinScore, ListMinScore.ToString() );\n            writer.WriteElementString( XmlName_ListTagsPerGame, ListTagsPerGame.ToString() );\n            writer.WriteElementString( XmlName_ListScoreSort, ListScoreSort.ToString() );\n            writer.WriteElementString( XmlName_ListExcludeGenres, ListExcludeGenres.ToString() );\n\n            writer.WriteEndElement();\n        }\n\n        public static AutoCatTags LoadFromXmlElement( XmlElement xElement ) {\n            string name = XmlUtil.GetStringFromNode( xElement[XmlName_Name], TypeIdString );\n\n            AutoCatTags result = new AutoCatTags( name );\n\n            string prefix;\n            if( XmlUtil.TryGetStringFromNode( xElement[XmlName_Prefix], out prefix ) ) result.Prefix = prefix;\n\n            int maxTags;\n            if( XmlUtil.TryGetIntFromNode( xElement[XmlName_MaxTags], out maxTags ) ) result.MaxTags = maxTags;\n\n            bool listOwnedOnly;\n            if( XmlUtil.TryGetBoolFromNode( xElement[XmlName_ListOwnedOnly], out listOwnedOnly ) ) result.ListOwnedOnly = listOwnedOnly;\n\n            float listWeightFactor;\n            if( XmlUtil.TryGetFloatFromNode( xElement[XmlName_ListWeightFactor], out listWeightFactor ) ) result.ListWeightFactor = listWeightFactor;\n\n            int listMinScore;\n            if( XmlUtil.TryGetIntFromNode( xElement[XmlName_ListMinScore], out listMinScore ) ) result.ListMinScore = listMinScore;\n\n            int listTagsPerGame;\n            if( XmlUtil.TryGetIntFromNode( xElement[XmlName_ListTagsPerGame], out listTagsPerGame ) ) result.ListTagsPerGame = listTagsPerGame;\n\n            bool listScoreSort;\n            if( XmlUtil.TryGetBoolFromNode( xElement[XmlName_ListScoreSort], out listScoreSort ) ) result.ListScoreSort = listScoreSort;\n\n            bool listExcludeGenres;\n            if( XmlUtil.TryGetBoolFromNode( xElement[XmlName_ListExcludeGenres], out listExcludeGenres ) ) result.ListExcludeGenres = listExcludeGenres;\n\n            List<string> tagList = XmlUtil.GetStringsFromNodeList( xElement.SelectNodes( XmlName_TagList + \"/\" + XmlName_Tag ) );\n            result.IncludedTags = ( tagList == null ) ? new HashSet<string>() : new HashSet<string>( tagList );\n\n            return result;\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>http://json-ld.org/spec/latest/json-ld-api/#the-jsonldoptions-type</summary>\n    /// <author>tristan</author>\n    public class JsonLdOptions\n    {\n        public JsonLdOptions()\n        {\n            this.SetBase(string.Empty);\n        }\n\n        public JsonLdOptions(string @base)\n        {\n            this.SetBase(@base);\n        }\n\n        public virtual JsonLD.Core.JsonLdOptions Clone()\n        {\n            JsonLD.Core.JsonLdOptions rval = new JsonLD.Core.JsonLdOptions(GetBase());\n            return rval;\n        }\n\n        private string @base = null;\n\n        private bool compactArrays = true;\n\n        private JObject expandContext = null;\n\n        private string processingMode = \"json-ld-1.0\";\n\n        private bool? embed = null;\n\n        private bool? @explicit = null;\n\n        private bool? omitDefault = null;\n\n        internal bool useRdfType = false;\n\n        internal bool useNativeTypes = false;\n\n        private bool produceGeneralizedRdf = false;\n\n        // base options\n        // frame options\n        // rdf conversion options\n        public virtual bool? GetEmbed()\n        {\n            return embed;\n        }\n\n        public virtual void SetEmbed(bool? embed)\n        {\n            this.embed = embed;\n        }\n\n        public virtual bool? GetExplicit()\n        {\n            return @explicit;\n        }\n\n        public virtual void SetExplicit(bool? @explicit)\n        {\n            this.@explicit = @explicit;\n        }\n\n        public virtual bool? GetOmitDefault()\n        {\n            return omitDefault;\n        }\n\n        public virtual void SetOmitDefault(bool? omitDefault)\n        {\n            this.omitDefault = omitDefault;\n        }\n\n        public virtual bool GetCompactArrays()\n        {\n            return compactArrays;\n        }\n\n        public virtual void SetCompactArrays(bool compactArrays)\n        {\n            this.compactArrays = compactArrays;\n        }\n\n        public virtual JObject GetExpandContext()\n        {\n            return expandContext;\n        }\n\n        public virtual void SetExpandContext(JObject expandContext)\n        {\n            this.expandContext = expandContext;\n        }\n\n        public virtual string GetProcessingMode()\n        {\n            return processingMode;\n        }\n\n        public virtual void SetProcessingMode(string processingMode)\n        {\n            this.processingMode = processingMode;\n        }\n\n        public virtual string GetBase()\n        {\n            return @base;\n        }\n\n        public virtual void SetBase(string @base)\n        {\n            this.@base = @base;\n        }\n\n        public virtual bool GetUseRdfType()\n        {\n            return useRdfType;\n        }\n\n        public virtual void SetUseRdfType(bool useRdfType)\n        {\n            this.useRdfType = useRdfType;\n        }\n\n        public virtual bool GetUseNativeTypes()\n        {\n            return useNativeTypes;\n        }\n\n        public virtual void SetUseNativeTypes(bool useNativeTypes)\n        {\n            this.useNativeTypes = useNativeTypes;\n        }\n\n        public virtual bool GetProduceGeneralizedRdf()\n        {\n            // TODO Auto-generated method stub\n            return this.produceGeneralizedRdf;\n        }\n\n        public virtual void SetProduceGeneralizedRdf(bool produceGeneralizedRdf)\n        {\n            this.produceGeneralizedRdf = produceGeneralizedRdf;\n        }\n\n        public string format = null;\n\n        public bool useNamespaces = false;\n\n        public string outputForm = null;\n\n        public DocumentLoader documentLoader = new DocumentLoader();\n        // TODO: THE FOLLOWING ONLY EXIST SO I DON'T HAVE TO DELETE A LOT OF CODE,\n        // REMOVE IT WHEN DONE\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesCommon3 =\n        {\n            nameof(IRibbonSetCommon3.RibbonChampionG3Hoenn), nameof(IRibbonSetCommon3.RibbonArtist), nameof(IRibbonSetCommon3.RibbonEffort)\n        };\n\n        internal static bool[] RibbonBits(this IRibbonSetCommon3 set)\n        {\n            if (set == null)\n                return new bool[3];\n            return new[]\n            {\n                set.RibbonChampionG3Hoenn,\n                set.RibbonArtist,\n                set.RibbonEffort,\n            };\n        }\n\n        internal static string[] RibbonNames(this IRibbonSetCommon3 _) => RibbonSetNamesCommon3;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesCommon4 =\n        {\n            nameof(IRibbonSetCommon4.RibbonGorgeous), nameof(IRibbonSetCommon4.RibbonRoyal), nameof(IRibbonSetCommon4.RibbonGorgeousRoyal),\n        };\n\n        internal static bool[] RibbonBitsCosmetic(this IRibbonSetCommon4 set)\n        {\n            if (set == null)\n                return new bool[3];\n            return new[]\n            {\n                set.RibbonGorgeous,\n                set.RibbonRoyal,\n                set.RibbonGorgeousRoyal,\n            };\n        }\n\n        internal static string[] RibbonNamesCosmetic(this IRibbonSetCommon4 _) => RibbonSetNamesCommon4;\n\n        private static readonly string[] RibbonSetNamesCommon4Only =\n        {\n            nameof(IRibbonSetCommon4.RibbonRecord), nameof(IRibbonSetCommon4.RibbonChampionSinnoh), nameof(IRibbonSetCommon4.RibbonLegend),\n        };\n\n        internal static bool[] RibbonBitsOnly(this IRibbonSetCommon4 set)\n        {\n            if (set == null)\n                return new bool[3];\n            return new[]\n            {\n                set.RibbonRecord,\n                set.RibbonChampionSinnoh,\n                set.RibbonLegend,\n            };\n        }\n\n        internal static string[] RibbonNamesOnly(this IRibbonSetCommon4 _) => RibbonSetNamesCommon4Only;\n\n        private static readonly string[] RibbonSetNamesCommon4Daily =\n        {\n            nameof(IRibbonSetCommon4.RibbonAlert), nameof(IRibbonSetCommon4.RibbonShock),\n            nameof(IRibbonSetCommon4.RibbonDowncast), nameof(IRibbonSetCommon4.RibbonCareless), nameof(IRibbonSetCommon4.RibbonRelax),\n            nameof(IRibbonSetCommon4.RibbonSnooze), nameof(IRibbonSetCommon4.RibbonSmile),\n        };\n\n        internal static bool[] RibbonBitsDaily(this IRibbonSetCommon4 set)\n        {\n            if (set == null)\n                return new bool[7];\n            return new[]\n            {\n                set.RibbonAlert,\n                set.RibbonShock,\n                set.RibbonDowncast,\n                set.RibbonCareless,\n                set.RibbonRelax,\n                set.RibbonSnooze,\n                set.RibbonSmile,\n            };\n        }\n\n        internal static string[] RibbonNamesDaily(this IRibbonSetCommon4 _) => RibbonSetNamesCommon4Daily;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesCommon6Bool =\n        {\n            nameof(IRibbonSetCommon6.RibbonChampionKalos), nameof(IRibbonSetCommon6.RibbonChampionG6Hoenn), // nameof(IRibbonSetCommon6.RibbonBestFriends),\n            nameof(IRibbonSetCommon6.RibbonTraining), nameof(IRibbonSetCommon6.RibbonBattlerSkillful), nameof(IRibbonSetCommon6.RibbonBattlerExpert),\n            nameof(IRibbonSetCommon6.RibbonContestStar), nameof(IRibbonSetCommon6.RibbonMasterCoolness), nameof(IRibbonSetCommon6.RibbonMasterBeauty),\n            nameof(IRibbonSetCommon6.RibbonMasterCuteness), nameof(IRibbonSetCommon6.RibbonMasterCleverness), nameof(IRibbonSetCommon6.RibbonMasterToughness),\n        };\n\n        private static readonly string[] RibbonSetNamesCommon6Contest =\n        {\n            nameof(IRibbonSetCommon6.RibbonMasterCoolness), nameof(IRibbonSetCommon6.RibbonMasterBeauty),\n            nameof(IRibbonSetCommon6.RibbonMasterCuteness), nameof(IRibbonSetCommon6.RibbonMasterCleverness),\n            nameof(IRibbonSetCommon6.RibbonMasterToughness),\n        };\n\n        internal static bool[] RibbonBits(this IRibbonSetCommon6 set)\n        {\n            if (set == null)\n                return new bool[11];\n            return new[]\n            {\n                set.RibbonChampionKalos,\n                set.RibbonChampionG6Hoenn,\n                //set.RibbonBestFriends,\n                set.RibbonTraining,\n                set.RibbonBattlerSkillful,\n                set.RibbonBattlerExpert,\n\n                set.RibbonContestStar,\n                set.RibbonMasterCoolness,\n                set.RibbonMasterBeauty,\n                set.RibbonMasterCuteness,\n                set.RibbonMasterCleverness,\n                set.RibbonMasterToughness,\n            };\n        }\n\n        internal static bool[] RibbonBitsContest(this IRibbonSetCommon6 set)\n        {\n            if (set == null)\n                return new bool[5];\n            return new[]\n            {\n                set.RibbonMasterCoolness,\n                set.RibbonMasterBeauty,\n                set.RibbonMasterCuteness,\n                set.RibbonMasterCleverness,\n                set.RibbonMasterToughness,\n            };\n        }\n\n        internal static string[] RibbonNamesBool(this IRibbonSetCommon6 _) => RibbonSetNamesCommon6Bool;\n        internal static string[] RibbonNamesContest(this IRibbonSetCommon6 _) => RibbonSetNamesCommon6Contest;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesCommon7 =\n        {\n            nameof(IRibbonSetCommon7.RibbonChampionAlola), nameof(IRibbonSetCommon7.RibbonBattleRoyale),\n            nameof(IRibbonSetCommon7.RibbonBattleTreeGreat), nameof(IRibbonSetCommon7.RibbonBattleTreeMaster)\n        };\n\n        internal static bool[] RibbonBits(this IRibbonSetCommon7 set)\n        {\n            if (set == null)\n                return new bool[4];\n            return new[]\n            {\n                set.RibbonChampionAlola,\n                set.RibbonBattleRoyale,\n                set.RibbonBattleTreeGreat,\n                set.RibbonBattleTreeMaster,\n            };\n        }\n\n        internal static string[] RibbonNames(this IRibbonSetCommon7 _) => RibbonSetNamesCommon7;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesEvent3 =\n        {\n            nameof(IRibbonSetEvent3.RibbonEarth), nameof(IRibbonSetEvent3.RibbonNational), nameof(IRibbonSetEvent3.RibbonCountry),\n            nameof(IRibbonSetEvent3.RibbonChampionBattle), nameof(IRibbonSetEvent3.RibbonChampionRegional), nameof(IRibbonSetEvent3.RibbonChampionNational)\n        };\n\n        internal static bool[] RibbonBits(this IRibbonSetEvent3 set)\n        {\n            if (set == null)\n                return new bool[6];\n            return new[]\n            {\n                set.RibbonEarth,\n                set.RibbonNational,\n                set.RibbonCountry,\n                set.RibbonChampionBattle,\n                set.RibbonChampionRegional,\n                set.RibbonChampionNational,\n            };\n        }\n\n        internal static string[] RibbonNames(this IRibbonSetEvent3 _) => RibbonSetNamesEvent3;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesEvent4 =\n        {\n            nameof(IRibbonSetEvent4.RibbonClassic), nameof(IRibbonSetEvent4.RibbonWishing), nameof(IRibbonSetEvent4.RibbonPremier),\n            nameof(IRibbonSetEvent4.RibbonEvent), nameof(IRibbonSetEvent4.RibbonBirthday), nameof(IRibbonSetEvent4.RibbonSpecial),\n            nameof(IRibbonSetEvent4.RibbonWorld), nameof(IRibbonSetEvent4.RibbonChampionWorld), nameof(IRibbonSetEvent4.RibbonSouvenir)\n        };\n\n        internal static bool[] RibbonBits(this IRibbonSetEvent4 set)\n        {\n            if (set == null)\n                return new bool[9];\n            return new[]\n            {\n                set.RibbonClassic,\n                set.RibbonWishing,\n                set.RibbonPremier,\n                set.RibbonEvent,\n                set.RibbonBirthday,\n                set.RibbonSpecial,\n                set.RibbonWorld,\n                set.RibbonChampionWorld,\n                set.RibbonSouvenir,\n            };\n        }\n\n        internal static string[] RibbonNames(this IRibbonSetEvent4 _) => RibbonSetNamesEvent4;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesOnly3 =\n        {\n            nameof(IRibbonSetOnly3.RibbonCountG3Cool), nameof(IRibbonSetOnly3.RibbonCountG3Beauty), nameof(IRibbonSetOnly3.RibbonCountG3Cute),\n            nameof(IRibbonSetOnly3.RibbonCountG3Smart), nameof(IRibbonSetOnly3.RibbonCountG3Tough),\n\n            nameof(IRibbonSetOnly3.RibbonWorld),\n            nameof(IRibbonSetOnly3.Unused1), nameof(IRibbonSetOnly3.Unused2),\n            nameof(IRibbonSetOnly3.Unused3), nameof(IRibbonSetOnly3.Unused4),\n        };\n\n        internal static int[] RibbonCounts(this IRibbonSetOnly3 set)\n        {\n            if (set == null)\n                return new int[5];\n            return new[]\n            {\n                set.RibbonCountG3Cool,\n                set.RibbonCountG3Beauty,\n                set.RibbonCountG3Cute,\n                set.RibbonCountG3Smart,\n                set.RibbonCountG3Tough,\n            };\n        }\n\n        internal static string[] RibbonNames(this IRibbonSetOnly3 _) => RibbonSetNamesOnly3;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesUnique3 =\n        {\n            nameof(IRibbonSetUnique3.RibbonWinning), nameof(IRibbonSetUnique3.RibbonVictory),\n        };\n\n        internal static bool[] RibbonBits(this IRibbonSetUnique3 set)\n        {\n            if (set == null)\n                return new bool[2];\n            return new[]\n            {\n                set.RibbonWinning,\n                set.RibbonVictory,\n            };\n        }\n\n        internal static string[] RibbonNames(this IRibbonSetUnique3 _) => RibbonSetNamesUnique3;\n    }\n\n    internal static partial class RibbonExtensions\n    {\n        private static readonly string[] RibbonSetNamesUnique4Ability =\n        {\n            nameof(IRibbonSetUnique4.RibbonAbility),\n            nameof(IRibbonSetUnique4.RibbonAbilityGreat),\n            nameof(IRibbonSetUnique4.RibbonAbilityDouble),\n            nameof(IRibbonSetUnique4.RibbonAbilityMulti),\n            nameof(IRibbonSetUnique4.RibbonAbilityPair),\n            nameof(IRibbonSetUnique4.RibbonAbilityWorld),\n        };\n\n        private static readonly string[] RibbonSetNamesUnique4Contest3 =\n        {\n            nameof(IRibbonSetUnique4.RibbonG3Cool),\n            nameof(IRibbonSetUnique4.RibbonG3CoolSuper),\n            nameof(IRibbonSetUnique4.RibbonG3CoolHyper),\n            nameof(IRibbonSetUnique4.RibbonG3CoolMaster),\n            nameof(IRibbonSetUnique4.RibbonG3Beauty),\n            nameof(IRibbonSetUnique4.RibbonG3BeautySuper),\n            nameof(IRibbonSetUnique4.RibbonG3BeautyHyper),\n            nameof(IRibbonSetUnique4.RibbonG3BeautyMaster),\n            nameof(IRibbonSetUnique4.RibbonG3Cute),\n            nameof(IRibbonSetUnique4.RibbonG3CuteSuper),\n            nameof(IRibbonSetUnique4.RibbonG3CuteHyper),\n            nameof(IRibbonSetUnique4.RibbonG3CuteMaster),\n            nameof(IRibbonSetUnique4.RibbonG3Smart),\n            nameof(IRibbonSetUnique4.RibbonG3SmartSuper),\n            nameof(IRibbonSetUnique4.RibbonG3SmartHyper),\n            nameof(IRibbonSetUnique4.RibbonG3SmartMaster),\n            nameof(IRibbonSetUnique4.RibbonG3Tough),\n            nameof(IRibbonSetUnique4.RibbonG3ToughSuper),\n            nameof(IRibbonSetUnique4.RibbonG3ToughHyper),\n            nameof(IRibbonSetUnique4.RibbonG3ToughMaster),\n        };\n\n        private static readonly string[] RibbonSetNamesUnique4Contest4 =\n        {\n            nameof(IRibbonSetUnique4.RibbonG4Cool),\n            nameof(IRibbonSetUnique4.RibbonG4CoolGreat),\n            nameof(IRibbonSetUnique4.RibbonG4CoolUltra),\n            nameof(IRibbonSetUnique4.RibbonG4CoolMaster),\n            nameof(IRibbonSetUnique4.RibbonG4Beauty),\n            nameof(IRibbonSetUnique4.RibbonG4BeautyGreat),\n            nameof(IRibbonSetUnique4.RibbonG4BeautyUltra),\n            nameof(IRibbonSetUnique4.RibbonG4BeautyMaster),\n            nameof(IRibbonSetUnique4.RibbonG4Cute),\n            nameof(IRibbonSetUnique4.RibbonG4CuteGreat),\n            nameof(IRibbonSetUnique4.RibbonG4CuteUltra),\n            nameof(IRibbonSetUnique4.RibbonG4CuteMaster),\n            nameof(IRibbonSetUnique4.RibbonG4Smart),\n            nameof(IRibbonSetUnique4.RibbonG4SmartGreat),\n            nameof(IRibbonSetUnique4.RibbonG4SmartUltra),\n            nameof(IRibbonSetUnique4.RibbonG4SmartMaster),\n            nameof(IRibbonSetUnique4.RibbonG4Tough),\n            nameof(IRibbonSetUnique4.RibbonG4ToughGreat),\n            nameof(IRibbonSetUnique4.RibbonG4ToughUltra),\n            nameof(IRibbonSetUnique4.RibbonG4ToughMaster),\n        };\n\n        internal static bool[] RibbonBitsAbility(this IRibbonSetUnique4 set)\n        {\n            if (set == null)\n                return new bool[6];\n            return new[]\n            {\n                set.RibbonAbility,\n                set.RibbonAbilityGreat,\n                set.RibbonAbilityDouble,\n                set.RibbonAbilityMulti,\n                set.RibbonAbilityPair,\n                set.RibbonAbilityWorld,\n            };\n        }\n\n        internal static bool[] RibbonBitsContest3(this IRibbonSetUnique4 set)\n        {\n            if (set == null)\n                return new bool[20];\n\n            return new[]\n            {\n                set.RibbonG3Cool,\n                set.RibbonG3CoolSuper,\n                set.RibbonG3CoolHyper,\n                set.RibbonG3CoolMaster,\n\n                set.RibbonG3Beauty,\n                set.RibbonG3BeautySuper,\n                set.RibbonG3BeautyHyper,\n                set.RibbonG3BeautyMaster,\n\n                set.RibbonG3Cute,\n                set.RibbonG3CuteSuper,\n                set.RibbonG3CuteHyper,\n                set.RibbonG3CuteMaster,\n\n                set.RibbonG3Smart,\n                set.RibbonG3SmartSuper,\n                set.RibbonG3SmartHyper,\n                set.RibbonG3SmartMaster,\n\n                set.RibbonG3Tough,\n                set.RibbonG3ToughSuper,\n                set.RibbonG3ToughHyper,\n                set.RibbonG3ToughMaster,\n            };\n        }\n\n        internal static bool[] RibbonBitsContest4(this IRibbonSetUnique4 set)\n        {\n            if (set == null)\n                return new bool[20];\n\n            return new[]\n            {\n                set.RibbonG4Cool,\n                set.RibbonG4CoolGreat,\n                set.RibbonG4CoolUltra,\n                set.RibbonG4CoolMaster,\n\n                set.RibbonG4Beauty,\n                set.RibbonG4BeautyGreat,\n                set.RibbonG4BeautyUltra,\n                set.RibbonG4BeautyMaster,\n\n                set.RibbonG4Cute,\n                set.RibbonG4CuteGreat,\n                set.RibbonG4CuteUltra,\n                set.RibbonG4CuteMaster,\n\n                set.RibbonG4Smart,\n                set.RibbonG4SmartGreat,\n                set.RibbonG4SmartUltra,\n                set.RibbonG4SmartMaster,\n\n                set.RibbonG4Tough,\n                set.RibbonG4ToughGreat,\n                set.RibbonG4ToughUltra,\n                set.RibbonG4ToughMaster,\n            };\n        }\n\n        internal static string[] RibbonNamesAbility(this IRibbonSetUnique4 _) => RibbonSetNamesUnique4Ability;\n        internal static string[] RibbonNamesContest3(this IRibbonSetUnique4 _) => RibbonSetNamesUnique4Contest3;\n        internal static string[] RibbonNamesContest4(this IRibbonSetUnique4 _) => RibbonSetNamesUnique4Contest4;\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\t/// <summary>Class which represents the entity 'Document', mapped on table 'AdventureWorks.Production.Document'.</summary>\n\t[Table(Name=\"[Production].[Document]\")]\n\tpublic partial class Document : INotifyPropertyChanging, INotifyPropertyChanged\n\t{\n\t\t#region Events\n\t\t/// <summary>Event which is raised when a property value is changing.</summary>\n\t\tpublic event PropertyChangingEventHandler PropertyChanging;\n\t\t/// <summary>Event which is raised when a property value changes.</summary>\n\t\tpublic event PropertyChangedEventHandler PropertyChanged;\n\t\t#endregion\n\t\t\n\t\t#region Class Member Declarations\n\t\tprivate System.Int32\t_changeNumber;\n\t\tprivate Nullable<System.Int16>\t_documentLevel;\n\t\tprivate System.String\t_documentNode;\n\t\tprivate System.String\t_documentSummary;\n\t\tprivate System.Data.Linq.Binary\t_documentValue;\n\t\tprivate System.String\t_fileExtension;\n\t\tprivate System.String\t_fileName;\n\t\tprivate System.Boolean\t_folderFlag;\n\t\tprivate System.DateTime\t_modifiedDate;\n\t\tprivate System.Int32\t_owner;\n\t\tprivate System.String\t_revision;\n\t\tprivate System.Guid\t_rowguid;\n\t\tprivate System.Byte\t_status;\n\t\tprivate System.String\t_title;\n\t\tprivate EntityRef <Employee> _employee;\n\t\tprivate EntitySet <ProductDocument> _productDocuments;\n\t\t#endregion\n\t\t\n\t\t#region Extensibility Method Definitions\n\t\tpartial void OnLoaded();\n\t\tpartial void OnValidate(System.Data.Linq.ChangeAction action);\n\t\tpartial void OnCreated();\n\t\tpartial void OnChangeNumberChanging(System.Int32 value);\n\t\tpartial void OnChangeNumberChanged();\n\t\tpartial void OnDocumentLevelChanging(Nullable<System.Int16> value);\n\t\tpartial void OnDocumentLevelChanged();\n\t\tpartial void OnDocumentNodeChanging(System.String value);\n\t\tpartial void OnDocumentNodeChanged();\n\t\tpartial void OnDocumentSummaryChanging(System.String value);\n\t\tpartial void OnDocumentSummaryChanged();\n\t\tpartial void OnDocumentValueChanging(System.Data.Linq.Binary value);\n\t\tpartial void OnDocumentValueChanged();\n\t\tpartial void OnFileExtensionChanging(System.String value);\n\t\tpartial void OnFileExtensionChanged();\n\t\tpartial void OnFileNameChanging(System.String value);\n\t\tpartial void OnFileNameChanged();\n\t\tpartial void OnFolderFlagChanging(System.Boolean value);\n\t\tpartial void OnFolderFlagChanged();\n\t\tpartial void OnModifiedDateChanging(System.DateTime value);\n\t\tpartial void OnModifiedDateChanged();\n\t\tpartial void OnOwnerChanging(System.Int32 value);\n\t\tpartial void OnOwnerChanged();\n\t\tpartial void OnRevisionChanging(System.String value);\n\t\tpartial void OnRevisionChanged();\n\t\tpartial void OnRowguidChanging(System.Guid value);\n\t\tpartial void OnRowguidChanged();\n\t\tpartial void OnStatusChanging(System.Byte value);\n\t\tpartial void OnStatusChanged();\n\t\tpartial void OnTitleChanging(System.String value);\n\t\tpartial void OnTitleChanged();\n\t\t#endregion\n\t\t\n\t\t/// <summary>Initializes a new instance of the <see cref=\"Document\"/> class.</summary>\n\t\tpublic Document()\n\t\t{\n\t\t\t_employee = default(EntityRef<Employee>);\n\t\t\t_productDocuments = new EntitySet<ProductDocument>(new Action<ProductDocument>(this.Attach_ProductDocuments), new Action<ProductDocument>(this.Detach_ProductDocuments) );\n\t\t\tOnCreated();\n\t\t}\n\n\t\t/// <summary>Raises the PropertyChanging event</summary>\n\t\t/// <param name=\"propertyName\">name of the property which is changing</param>\n\t\tprotected virtual void SendPropertyChanging(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanging != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Raises the PropertyChanged event for the property specified</summary>\n\t\t/// <param name=\"propertyName\">name of the property which was changed</param>\n\t\tprotected virtual void SendPropertyChanged(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanged != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Attaches this instance to the entity specified as an associated entity</summary>\n\t\t/// <param name=\"entity\">The related entity to attach to</param>\n\t\tprivate void Attach_ProductDocuments(ProductDocument entity)\n\t\t{\n\t\t\tthis.SendPropertyChanging(\"ProductDocuments\");\n\t\t\tentity.Document = this;\n\t\t}\n\t\t\n\t\t/// <summary>Detaches this instance from the entity specified so it's no longer an associated entity</summary>\n\t\t/// <param name=\"entity\">The related entity to detach from</param>\n\t\tprivate void Detach_ProductDocuments(ProductDocument entity)\n\t\t{\n\t\t\tthis.SendPropertyChanging(\"ProductDocuments\");\n\t\t\tentity.Document = null;\n\t\t}\n\n\n\t\t#region Class Property Declarations\n\t\t/// <summary>Gets or sets the ChangeNumber field. Mapped on target field 'ChangeNumber'. </summary>\n\t\t[Column(Name=\"ChangeNumber\", Storage=\"_changeNumber\", CanBeNull=false, DbType=\"int NOT NULL\")]\n\t\tpublic System.Int32 ChangeNumber\n\t\t{\n\t\t\tget\t{ return _changeNumber; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_changeNumber != value))\n\t\t\t\t{\n\t\t\t\t\tOnChangeNumberChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ChangeNumber\");\n\t\t\t\t\t_changeNumber = value;\n\t\t\t\t\tSendPropertyChanged(\"ChangeNumber\");\n\t\t\t\t\tOnChangeNumberChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the DocumentLevel field. Mapped on target field 'DocumentLevel'. </summary>\n\t\t[Column(Name=\"DocumentLevel\", Storage=\"_documentLevel\", AutoSync=AutoSync.OnInsert, DbType=\"smallint NULL\", IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)]\n\t\tpublic Nullable<System.Int16> DocumentLevel\n\t\t{\n\t\t\tget\t{ return _documentLevel; }\n\t\t}\n\n\t\t/// <summary>Gets or sets the DocumentNode field. Mapped on target field 'DocumentNode'. </summary>\n\t\t[Column(Name=\"DocumentNode\", Storage=\"_documentNode\", CanBeNull=false, DbType=\"varchar(892) NOT NULL\", IsPrimaryKey=true)]\n\t\tpublic System.String DocumentNode\n\t\t{\n\t\t\tget\t{ return _documentNode; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_documentNode != value))\n\t\t\t\t{\n\t\t\t\t\tOnDocumentNodeChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"DocumentNode\");\n\t\t\t\t\t_documentNode = value;\n\t\t\t\t\tSendPropertyChanged(\"DocumentNode\");\n\t\t\t\t\tOnDocumentNodeChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the DocumentSummary field. Mapped on target field 'DocumentSummary'. </summary>\n\t\t[Column(Name=\"DocumentSummary\", Storage=\"_documentSummary\", DbType=\"nvarchar(MAX) NULL\", UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.String DocumentSummary\n\t\t{\n\t\t\tget\t{ return _documentSummary; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_documentSummary != value))\n\t\t\t\t{\n\t\t\t\t\tOnDocumentSummaryChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"DocumentSummary\");\n\t\t\t\t\t_documentSummary = value;\n\t\t\t\t\tSendPropertyChanged(\"DocumentSummary\");\n\t\t\t\t\tOnDocumentSummaryChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the DocumentValue field. Mapped on target field 'Document'. </summary>\n\t\t[Column(Name=\"Document\", Storage=\"_documentValue\", DbType=\"varbinary(MAX) NULL\", UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.Data.Linq.Binary DocumentValue\n\t\t{\n\t\t\tget\t{ return _documentValue; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_documentValue != value))\n\t\t\t\t{\n\t\t\t\t\tOnDocumentValueChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"DocumentValue\");\n\t\t\t\t\t_documentValue = value;\n\t\t\t\t\tSendPropertyChanged(\"DocumentValue\");\n\t\t\t\t\tOnDocumentValueChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the FileExtension field. Mapped on target field 'FileExtension'. </summary>\n\t\t[Column(Name=\"FileExtension\", Storage=\"_fileExtension\", CanBeNull=false, DbType=\"nvarchar(8) NOT NULL\")]\n\t\tpublic System.String FileExtension\n\t\t{\n\t\t\tget\t{ return _fileExtension; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_fileExtension != value))\n\t\t\t\t{\n\t\t\t\t\tOnFileExtensionChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"FileExtension\");\n\t\t\t\t\t_fileExtension = value;\n\t\t\t\t\tSendPropertyChanged(\"FileExtension\");\n\t\t\t\t\tOnFileExtensionChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the FileName field. Mapped on target field 'FileName'. </summary>\n\t\t[Column(Name=\"FileName\", Storage=\"_fileName\", CanBeNull=false, DbType=\"nvarchar(400) NOT NULL\")]\n\t\tpublic System.String FileName\n\t\t{\n\t\t\tget\t{ return _fileName; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_fileName != value))\n\t\t\t\t{\n\t\t\t\t\tOnFileNameChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"FileName\");\n\t\t\t\t\t_fileName = value;\n\t\t\t\t\tSendPropertyChanged(\"FileName\");\n\t\t\t\t\tOnFileNameChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the FolderFlag field. Mapped on target field 'FolderFlag'. </summary>\n\t\t[Column(Name=\"FolderFlag\", Storage=\"_folderFlag\", CanBeNull=false, DbType=\"bit NOT NULL\")]\n\t\tpublic System.Boolean FolderFlag\n\t\t{\n\t\t\tget\t{ return _folderFlag; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_folderFlag != value))\n\t\t\t\t{\n\t\t\t\t\tOnFolderFlagChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"FolderFlag\");\n\t\t\t\t\t_folderFlag = value;\n\t\t\t\t\tSendPropertyChanged(\"FolderFlag\");\n\t\t\t\t\tOnFolderFlagChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the ModifiedDate field. Mapped on target field 'ModifiedDate'. </summary>\n\t\t[Column(Name=\"ModifiedDate\", Storage=\"_modifiedDate\", CanBeNull=false, DbType=\"datetime NOT NULL\")]\n\t\tpublic System.DateTime ModifiedDate\n\t\t{\n\t\t\tget\t{ return _modifiedDate; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_modifiedDate != value))\n\t\t\t\t{\n\t\t\t\t\tOnModifiedDateChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ModifiedDate\");\n\t\t\t\t\t_modifiedDate = value;\n\t\t\t\t\tSendPropertyChanged(\"ModifiedDate\");\n\t\t\t\t\tOnModifiedDateChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Owner field. Mapped on target field 'Owner'. </summary>\n\t\t[Column(Name=\"Owner\", Storage=\"_owner\", CanBeNull=false, DbType=\"int NOT NULL\")]\n\t\tpublic System.Int32 Owner\n\t\t{\n\t\t\tget\t{ return _owner; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_owner != value))\n\t\t\t\t{\n\t\t\t\t\tif(_employee.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnOwnerChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Owner\");\n\t\t\t\t\t_owner = value;\n\t\t\t\t\tSendPropertyChanged(\"Owner\");\n\t\t\t\t\tOnOwnerChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Revision field. Mapped on target field 'Revision'. </summary>\n\t\t[Column(Name=\"Revision\", Storage=\"_revision\", CanBeNull=false, DbType=\"nchar(5) NOT NULL\")]\n\t\tpublic System.String Revision\n\t\t{\n\t\t\tget\t{ return _revision; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_revision != value))\n\t\t\t\t{\n\t\t\t\t\tOnRevisionChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Revision\");\n\t\t\t\t\t_revision = value;\n\t\t\t\t\tSendPropertyChanged(\"Revision\");\n\t\t\t\t\tOnRevisionChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Rowguid field. Mapped on target field 'rowguid'. </summary>\n\t\t[Column(Name=\"rowguid\", Storage=\"_rowguid\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"uniqueidentifier NOT NULL\", IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.Guid Rowguid\n\t\t{\n\t\t\tget\t{ return _rowguid; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_rowguid != value))\n\t\t\t\t{\n\t\t\t\t\tOnRowguidChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Rowguid\");\n\t\t\t\t\t_rowguid = value;\n\t\t\t\t\tSendPropertyChanged(\"Rowguid\");\n\t\t\t\t\tOnRowguidChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Status field. Mapped on target field 'Status'. </summary>\n\t\t[Column(Name=\"Status\", Storage=\"_status\", CanBeNull=false, DbType=\"tinyint NOT NULL\")]\n\t\tpublic System.Byte Status\n\t\t{\n\t\t\tget\t{ return _status; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_status != value))\n\t\t\t\t{\n\t\t\t\t\tOnStatusChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Status\");\n\t\t\t\t\t_status = value;\n\t\t\t\t\tSendPropertyChanged(\"Status\");\n\t\t\t\t\tOnStatusChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Title field. Mapped on target field 'Title'. </summary>\n\t\t[Column(Name=\"Title\", Storage=\"_title\", CanBeNull=false, DbType=\"nvarchar(50) NOT NULL\")]\n\t\tpublic System.String Title\n\t\t{\n\t\t\tget\t{ return _title; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_title != value))\n\t\t\t\t{\n\t\t\t\t\tOnTitleChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Title\");\n\t\t\t\t\t_title = value;\n\t\t\t\t\tSendPropertyChanged(\"Title\");\n\t\t\t\t\tOnTitleChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'Document.Employee - Employee.Documents (m:1)'</summary>\n\t\t[Association(Name=\"Document_Employeefb51c9a62c5340979fd40fe35e3b18bc\", Storage=\"_employee\", ThisKey=\"Owner\", IsForeignKey=true)] \n\t\tpublic Employee Employee\n\t\t{\n\t\t\tget { return _employee.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tEmployee previousValue = _employee.Entity;\n\t\t\t\tif((previousValue != value) || (_employee.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"Employee\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_employee.Entity = null;\n\t\t\t\t\t\tpreviousValue.Documents.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_employee.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_owner = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.Documents.Add(this);\n\t\t\t\t\t\t_owner = value.BusinessEntityId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"Employee\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'ProductDocument.Document - Document.ProductDocuments (m:1)'</summary>\n\t\t[Association(Name=\"ProductDocument_Document2b53484260ec4f40b66df266668c97af\", Storage=\"_productDocuments\", OtherKey=\"DocumentNode\")]\n\t\tpublic EntitySet<ProductDocument> ProductDocuments\n\t\t{\n\t\t\tget { return this._productDocuments; }\n\t\t\tset { this._productDocuments.Assign(value); }\n\t\t}\n\t\t\n\t\t#endregion\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "\n    internal static class PInvokeHelper\n    {\n        // http://zetalongpaths.codeplex.com/Thread/View.aspx?ThreadId=230652&ANCHOR#Post557779\n        internal const int MAX_PATH = 247;\n\n        // http://msdn.microsoft.com/en-us/library/ms681382(VS.85).aspx\n        internal const int ERROR_SUCCESS = 0;\n        internal const int ERROR_FILE_NOT_FOUND = 2;\n        internal const int ERROR_NO_MORE_FILES = 18;\n\n        // http://www.dotnet247.com/247reference/msgs/21/108780.aspx\n        [DllImport(@\"advapi32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]\n        internal static extern int GetNamedSecurityInfo(\n            string pObjectName,\n            int objectType,\n            int securityInfo,\n            out IntPtr ppsidOwner,\n            out IntPtr ppsidGroup,\n            out IntPtr ppDacl,\n            out IntPtr ppSacl,\n            out IntPtr ppSecurityDescriptor);\n\n        [DllImport(@\"advapi32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        internal static extern int LookupAccountSid(\n            string systemName,\n            IntPtr psid,\n            StringBuilder accountName,\n            ref int cbAccount,\n            [Out] StringBuilder domainName,\n            ref int cbDomainName,\n            out int use);\n\n        public const int OwnerSecurityInformation = 1;\n        public const int SeFileObject = 1;\n\n        [StructLayout(LayoutKind.Sequential)]\n        internal struct FILETIME\n        {\n            internal uint dwLowDateTime;\n            internal uint dwHighDateTime;\n        }\n\n        [BestFitMapping(false)]\n        //[Serializable]\n        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]\n        internal struct WIN32_FIND_DATA\n        {\n            [MarshalAs(UnmanagedType.U4)] internal FileAttributes dwFileAttributes;\n            internal FILETIME ftCreationTime;\n            internal FILETIME ftLastAccessTime;\n            internal FILETIME ftLastWriteTime;\n            internal uint nFileSizeHigh;\n            internal uint nFileSizeLow;\n            internal uint dwReserved0;\n            internal uint dwReserved1;\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 260)] internal string cFileName;\n            // not using this\n            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 14)] internal string cAlternate;\n        }\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true)]\n        internal static extern bool ReadFile(\n            SafeFileHandle hFile,\n            IntPtr lpBuffer,\n            uint nNumberOfBytesToRead,\n            out uint lpNumberOfBytesRead,\n            IntPtr lpOverlapped);\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true)]\n        internal static extern bool WriteFile(\n            SafeFileHandle hFile,\n            IntPtr lpBuffer,\n            uint nNumberOfBytesToWrite,\n            out uint lpNumberOfBytesWritten,\n            IntPtr lpOverlapped);\n\n        [DllImport(@\"kernel32.dll\", EntryPoint = @\"SetFilePointerEx\", SetLastError = true)]\n        public static extern bool Seek(\n            SafeFileHandle hFile,\n            long distance,\n            out long newFilePointer,\n            FileSeekOrigin origin);\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct SECURITY_ATTRIBUTES\n        {\n            public int nLength;\n            public IntPtr lpSecurityDescriptor;\n            public int bInheritHandle;\n        }\n\n        //[DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode)]\n        //[return: MarshalAs(UnmanagedType.Bool)]\n        //internal static extern bool CopyFile(string lpExistingFileName, string lpNewFileName, bool bFailIfExists);\n\n        [DllImport(@\"kernel32.dll\",\n            CharSet = CharSet.Unicode,\n            CallingConvention = CallingConvention.StdCall,\n            SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool CopyFile(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpExistingFileName,\n            [MarshalAs(UnmanagedType.LPTStr)] string lpNewFileName,\n            [MarshalAs(UnmanagedType.Bool)] bool bFailIfExists);\n\n        [DllImport(@\"kernel32.dll\",\n            CharSet = CharSet.Unicode,\n            CallingConvention = CallingConvention.StdCall,\n            SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool MoveFile(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpExistingFileName,\n            [MarshalAs(UnmanagedType.LPTStr)] string lpNewFileName);\n\n        [DllImport(@\"kernel32.dll\",\n            CharSet = CharSet.Unicode,\n            CallingConvention = CallingConvention.StdCall,\n            SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool MoveFileEx(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpExistingFileName,\n            [MarshalAs(UnmanagedType.LPTStr)] string lpNewFileName,\n            MoveFileExFlags dwFlags);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool CreateDirectory(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpPathName,\n            IntPtr lpSecurityAttributes);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        internal static extern uint GetFileAttributes(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true, BestFitMapping = false)]\n        internal static extern bool GetFileAttributesEx(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName,\n            int fInfoLevelId,\n            ref WIN32_FILE_ATTRIBUTE_DATA fileData);\n\n        [StructLayout(LayoutKind.Sequential)]\n        public struct WIN32_FILE_ATTRIBUTE_DATA\n        {\n            public int dwFileAttributes;\n            public FILETIME ftCreationTime;\n            public FILETIME ftLastAccessTime;\n            public FILETIME ftLastWriteTime;\n            public uint nFileSizeHigh;\n            public uint nFileSizeLow;\n        }\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool SetFileAttributes(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName,\n            [MarshalAs(UnmanagedType.U4)] FileAttributes dwFileAttributes);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool RemoveDirectory(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpPathName);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool DeleteFile(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        internal static extern IntPtr FindFirstFile(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName,\n            out WIN32_FIND_DATA lpFindFileData);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        internal static extern bool FindNextFile(\n            IntPtr hFindFile,\n            out WIN32_FIND_DATA lpFindFileData);\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool FindClose(\n            IntPtr hFindFile);\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true, EntryPoint = @\"SetFileTime\", ExactSpelling = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool SetFileTime1(\n            IntPtr hFile,\n            ref long lpCreationTime,\n            IntPtr lpLastAccessTime,\n            IntPtr lpLastWriteTime);\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true, EntryPoint = @\"SetFileTime\", ExactSpelling = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool SetFileTime2(\n            IntPtr hFile,\n            IntPtr lpCreationTime,\n            ref long lpLastAccessTime,\n            IntPtr lpLastWriteTime);\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true, EntryPoint = @\"SetFileTime\", ExactSpelling = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool SetFileTime3(\n            IntPtr hFile,\n            IntPtr lpCreationTime,\n            IntPtr lpLastAccessTime,\n            ref long lpLastWriteTime);\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true, EntryPoint = @\"SetFileTime\", ExactSpelling = true)]\n        [return: MarshalAs(UnmanagedType.Bool)]\n        internal static extern bool SetFileTime4(\n            IntPtr hFile,\n            ref long lpCreationTime,\n            ref long lpLastAccessTime,\n            ref long lpLastWriteTime);\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]\n        internal static extern int GetFullPathName(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName,\n            int nBufferLength,\n            /*[MarshalAs(UnmanagedType.LPTStr), Out]*/StringBuilder lpBuffer,\n            IntPtr mustBeZero);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        internal static extern uint GetShortPathName(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpszLongPath,\n            [MarshalAs(UnmanagedType.LPTStr), Out] StringBuilder lpszShortPath,\n            uint cchBuffer);\n\n        [DllImport(@\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        internal static extern uint GetLongPathName(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpszShortPath,\n            [MarshalAs(UnmanagedType.LPTStr), Out] StringBuilder lpszLongPath,\n            uint cchBuffer);\n\n        //internal static extern uint GetFullPathName(\n        //    string lpFileName,\n        //    uint nBufferLength,\n        //    [Out] StringBuilder lpBuffer,\n        //    out StringBuilder lpFilePart);\n\n        internal static int FILE_ATTRIBUTE_DIRECTORY = 0x00000010;\n        internal static uint INVALID_FILE_ATTRIBUTES = 0xFFFFFFFF;\n\n        internal static IntPtr INVALID_HANDLE_VALUE = new IntPtr(-1);\n\n        // Assume dirName passed in is already prefixed with \\\\?\\\n        public static List<string> FindFilesAndDirectories(\n            string directoryPath)\n        {\n            var results = new List<string>();\n            WIN32_FIND_DATA findData;\n            var findHandle = FindFirstFile(directoryPath.TrimEnd('\\\\') + @\"\\*\", out findData);\n\n            try\n            {\n                if (findHandle != INVALID_HANDLE_VALUE)\n                {\n                    bool found;\n                    do\n                    {\n                        var currentFileName = findData.cFileName;\n\n                        // if this is a directory, find its contents\n                        if (((int) findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0)\n                        {\n                            if (currentFileName != @\".\" && currentFileName != @\"..\")\n                            {\n                                var childResults = FindFilesAndDirectories(Path.Combine(directoryPath, currentFileName));\n                                // add children and self to results\n                                results.AddRange(childResults);\n                                results.Add(Path.Combine(directoryPath, currentFileName));\n                            }\n                        }\n\n                            // it's a file; add it to the results\n                        else\n                        {\n                            results.Add(Path.Combine(directoryPath, currentFileName));\n                        }\n\n                        // find next\n                        found = FindNextFile(findHandle, out findData);\n                    } while (found);\n                }\n            }\n            finally\n            {\n                // close the find handle\n                FindClose(findHandle);\n            }\n\n            return results;\n        }\n\n        [DllImport(@\"kernel32.dll\", SetLastError = true, CharSet = CharSet.Unicode)]\n        internal static extern SafeFileHandle CreateFile(\n            [MarshalAs(UnmanagedType.LPTStr)] string lpFileName,\n            FileAccess dwDesiredAccess,\n            FileShare dwShareMode,\n            IntPtr lpSecurityAttributes,\n            CreationDisposition dwCreationDisposition,\n            FileAttributes dwFlagsAndAttributes,\n            IntPtr hTemplateFile);\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /**\n     * Generator for Version 1 TbsCertificateStructures.\n     * <pre>\n     * TbsCertificate ::= Sequence {\n     *      version          [ 0 ]  Version DEFAULT v1(0),\n     *      serialNumber            CertificateSerialNumber,\n     *      signature               AlgorithmIdentifier,\n     *      issuer                  Name,\n     *      validity                Validity,\n     *      subject                 Name,\n     *      subjectPublicKeyInfo    SubjectPublicKeyInfo,\n     *      }\n     * </pre>\n     *\n     */\n    public class V1TbsCertificateGenerator\n    {\n        internal DerTaggedObject\t\tversion = new DerTaggedObject(0, new DerInteger(0));\n        internal DerInteger\t\t\t\tserialNumber;\n        internal AlgorithmIdentifier\tsignature;\n        internal X509Name\t\t\t\tissuer;\n        internal Time\t\t\t\t\tstartDate, endDate;\n        internal X509Name\t\t\t\tsubject;\n        internal SubjectPublicKeyInfo\tsubjectPublicKeyInfo;\n\n\t\tpublic V1TbsCertificateGenerator()\n        {\n        }\n\n\t\tpublic void SetSerialNumber(\n            DerInteger serialNumber)\n        {\n            this.serialNumber = serialNumber;\n        }\n\n\t\tpublic void SetSignature(\n            AlgorithmIdentifier signature)\n        {\n            this.signature = signature;\n        }\n\n\t\tpublic void SetIssuer(\n            X509Name issuer)\n        {\n            this.issuer = issuer;\n        }\n\n\t\tpublic void SetStartDate(\n            Time startDate)\n        {\n            this.startDate = startDate;\n        }\n\n\t\tpublic void SetStartDate(\n            DerUtcTime startDate)\n        {\n            this.startDate = new Time(startDate);\n        }\n\n\t\tpublic void SetEndDate(\n            Time endDate)\n        {\n            this.endDate = endDate;\n        }\n\n\t\tpublic void SetEndDate(\n            DerUtcTime endDate)\n        {\n            this.endDate = new Time(endDate);\n        }\n\n\t\tpublic void SetSubject(\n            X509Name subject)\n        {\n            this.subject = subject;\n        }\n\n\t\tpublic void SetSubjectPublicKeyInfo(\n            SubjectPublicKeyInfo pubKeyInfo)\n        {\n            this.subjectPublicKeyInfo = pubKeyInfo;\n        }\n\n\t\tpublic TbsCertificateStructure GenerateTbsCertificate()\n        {\n            if ((serialNumber == null) || (signature == null)\n                || (issuer == null) || (startDate == null) || (endDate == null)\n                || (subject == null) || (subjectPublicKeyInfo == null))\n            {\n                throw new InvalidOperationException(\"not all mandatory fields set in V1 TBScertificate generator\");\n            }\n\n\t\t\treturn new TbsCertificateStructure(\n\t\t\t\tnew DerSequence(\n\t\t\t\t\t//version, - not required as default value\n\t\t\t\t\tserialNumber,\n\t\t\t\t\tsignature,\n\t\t\t\t\tissuer,\n\t\t\t\t\tnew DerSequence(startDate, endDate), // before and after dates\n\t\t\t\t\tsubject,\n\t\t\t\t\tsubjectPublicKeyInfo));\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The ProviderElement Configuration Element.\n    /// </summary>\n    public partial class ProviderElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Provider Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Provider\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ProviderPropertyName = \"provider\";\n        \n        /// <summary>\n        /// Gets or sets the Provider.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Provider.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Provider\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ProviderPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region Constructors Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Constructors\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ConstructorsPropertyName = \"constructors\";\n        \n        /// <summary>\n        /// Gets or sets the Constructors.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Constructors.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ConstructorElementCollection Constructors\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ConstructorElementCollection)(base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.ProviderElement.ConstructorsPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>\n    /// Contains eye tracking results of a single frame. It holds a state that defines\n    /// the quality of the current tracking and fine grained tracking details down to eye level.\n    /// </summary>\n    public class GazeData\n    {\n        #region Constants\n\n        public const string TIMESTAMP_STRING_FORMAT = \"yyyy-MM-dd HH:mm:ss.fff\";\n\n        #endregion\n\n        #region Public properties\n\n        /// <summary>\n        /// Set when engine is calibrated and glint tracking successfully.\n        /// </summary>\n        public const int STATE_TRACKING_GAZE = 1;\n\n        /// <summary>\n        /// Set when engine has detected eyes.\n        /// </summary>\n        public const int STATE_TRACKING_EYES = 1 << 1;\n\n        /// <summary>\n        /// Set when engine has detected either face, eyes or glint.\n        /// </summary>\n        public const int STATE_TRACKING_PRESENCE = 1 << 2;\n\n        /// <summary>\n        /// Set when tracking failed in the last process frame.\n        /// </summary>\n        public const int STATE_TRACKING_FAIL = 1 << 3;\n\n        /// <summary>\n        /// Set when tracking has failed consecutively over a period of time defined by engine.\n        /// </summary>\n        public const int STATE_TRACKING_LOST = 1 << 4;\n\n        /// <summary>\n        /// State of this frame. States can be extracted using the STATE_ mask constants.\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_STATE)]\n        public int State { get; set; }\n\n        /// <summary>\n        /// Raw gaze coordinates in pixels\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_RAW_COORDINATES)]\n        public Point2D RawCoordinates { get; set; }\n\n        /// <summary>\n        /// Smoothed gaze coordinates in pixels\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_AVERAGE_COORDINATES)]\n        public Point2D SmoothedCoordinates { get; set; }\n\n        /// <summary>\n        /// Left GazeEye object\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_LEFT_EYE)]\n        public Eye LeftEye { get; set; }\n\n        /// <summary>\n        /// Right GazeEye object\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_RIGHT_EYE)]\n        public Eye RightEye { get; set; }\n\n        /// <summary>\n        /// Timestamp for this frame\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_TIME)]\n        public long TimeStamp { get; set; }\n\n        /// <summary>\n        /// Timestamp for this frame represented in String form\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_TIMESTAMP)]\n        public String TimeStampString { get; set; }\n\n        /// <summary>\n        /// Is user fixated in this frame?\n        /// </summary>\n        [JsonProperty(PropertyName = Protocol.FRAME_FIXATION)]\n        public bool IsFixated { get; set; }\n\n        #endregion\n\n        #region Constructor\n\n        public GazeData()\n        {\n            DateTime now = DateTime.Now;\n            TimeStamp = (long)((double)now.Ticks / TimeSpan.TicksPerMillisecond);\n            TimeStampString = now.ToString(TIMESTAMP_STRING_FORMAT);\n            IsFixated = false;\n            RawCoordinates = Point2D.Zero;\n            SmoothedCoordinates = Point2D.Zero;\n\n            LeftEye = new Eye();\n            RightEye = new Eye();\n        }\n\n        public GazeData(GazeData other)\n        {\n            if (null != other)\n            {\n                State = other.State;\n                TimeStamp = other.TimeStamp;\n                TimeStampString = other.TimeStampString;\n\n                RawCoordinates = new Point2D(other.RawCoordinates);\n                SmoothedCoordinates = new Point2D(other.SmoothedCoordinates);\n\n                LeftEye = new Eye(other.LeftEye);\n                RightEye = new Eye(other.RightEye);\n\n                IsFixated = other.IsFixated;\n            }\n        }\n\n        #endregion\n\n        #region Public methods\n\n        public override bool Equals(Object o)\n        {\n            if (ReferenceEquals(this, o))\n                return true;\n\n            if (!(o is GazeData))\n                return false;\n\n            var other = o as GazeData;\n\n            return\n                this.RawCoordinates.Equals(other.RawCoordinates) &&\n                this.SmoothedCoordinates.Equals(other.SmoothedCoordinates) &&\n                this.LeftEye.Equals(other.LeftEye) &&\n                this.RightEye.Equals(other.RightEye) &&\n                this.State == other.State &&\n                this.IsFixated == other.IsFixated;\n        }\n\n        public override int GetHashCode()\n        {\n            int hash = 2039;\n            hash = hash * 1553 + RawCoordinates.GetHashCode();\n            hash = hash * 1553 + SmoothedCoordinates.GetHashCode();\n            hash = hash * 1553 + LeftEye.GetHashCode();\n            hash = hash * 1553 + RightEye.GetHashCode();\n            hash = hash * 1553 + State.GetHashCode();\n            hash = hash * 1553 + IsFixated.GetHashCode();\n            return hash;\n        }\n\n        public String StateToString()\n        {\n            String stateString = \"\";\n            bool ticker = false;\n\n            if ((STATE_TRACKING_GAZE & State) != 0)\n            {\n                stateString += \"STATE_TRACKING_GAZE\";\n                ticker = true;\n            }\n\n            if ((STATE_TRACKING_GAZE & State) != 0)\n            {\n                stateString += (ticker ? \" | \" : \"\") + \"STATE_TRACKING_EYES\";\n                ticker = true;\n            }\n\n            if ((STATE_TRACKING_PRESENCE & State) != 0)\n            {\n                stateString += (ticker ? \" | \" : \"\") + \"STATE_TRACKING_PRESENCE\";\n                ticker = true;\n            }\n\n            if ((STATE_TRACKING_FAIL & State) != 0)\n            {\n                stateString += (ticker ? \" | \" : \"\") + \"STATE_TRACKING_FAIL\";\n                ticker = true;\n            }\n\n            if ((STATE_TRACKING_LOST & State) != 0)\n            {\n                stateString += (ticker ? \" | \" : \"\") + \"STATE_TRACKING_LOST\";\n                ticker = true;\n            }\n\n            return stateString;\n        }\n\n        private const int NO_TRACKING_MASK = STATE_TRACKING_LOST | STATE_TRACKING_FAIL;\n\n        public Boolean HasSmoothedGazeCoordinates()\n        {\n            return (State & NO_TRACKING_MASK) == 0 && SmoothedCoordinates.X != 0 && SmoothedCoordinates.Y != 0;\n        }\n\n        public Boolean HasRawGazeCoordinates()\n        {\n            return (State & NO_TRACKING_MASK) == 0 && RawCoordinates.X != 0 && RawCoordinates.Y != 0;\n        }\n\n        #endregion\n\n        #region Private methods\n\n        private void Set(GazeData other)\n        {\n            State = other.State;\n            TimeStamp = other.TimeStamp;\n            TimeStampString = other.TimeStampString;\n\n            RawCoordinates = new Point2D(other.RawCoordinates);\n            SmoothedCoordinates = new Point2D(other.SmoothedCoordinates);\n\n            LeftEye = new Eye(other.LeftEye);\n            RightEye = new Eye(other.RightEye);\n\n            IsFixated = other.IsFixated;\n        }\n\n        #endregion\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of NameTypeElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.NameTypeElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName)]\n    public partial class CacheManagerElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string NameTypeElementPropertyName = \"cacheManager\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.CacheManagerElementCollection.NameTypeElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(element)).Name;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.NameTypeElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement this[object name]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(name)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseAdd(cacheManager);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"cacheManager\">The <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.NameTypeElement cacheManager)\n        {\n            base.BaseRemove(this.GetElementKey(cacheManager));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"name\">The key of the <see cref=\"global::EApp.Core.Configuration.NameTypeElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.NameTypeElement GetItemByKey(string name)\n        {\n            return ((global::EApp.Core.Configuration.NameTypeElement)(base.BaseGet(((object)(name)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Default Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Default\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultPropertyName = \"default\";\n        \n        /// <summary>\n        /// Gets or sets the Default.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Default.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual string Default\n        {\n            get\n            {\n                return ((string)(base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.CacheManagerElementCollection.DefaultPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>\n    /// There are no comments for Microsoft.WindowsAzure.ActiveDirectory.ServicePrincipal in the schema.\n    /// </summary>\n    /// <KeyProperties>\n    /// objectId\n    /// </KeyProperties>\n    [global::System.Data.Services.Common.DataServiceKeyAttribute(\"objectId\")]\n    public partial class ServicePrincipal : DirectoryObject\n    {\n        /// <summary>\n        /// Create a new ServicePrincipal object.\n        /// </summary>\n        /// <param name=\"objectId\">Initial value of objectId.</param>\n        /// <param name=\"keyCredentials\">Initial value of keyCredentials.</param>\n        /// <param name=\"passwordCredentials\">Initial value of passwordCredentials.</param>\n        /// <param name=\"replyUrls\">Initial value of replyUrls.</param>\n        /// <param name=\"servicePrincipalNames\">Initial value of servicePrincipalNames.</param>\n        /// <param name=\"tags\">Initial value of tags.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public static ServicePrincipal CreateServicePrincipal(string objectId, global::System.Collections.ObjectModel.Collection<KeyCredential> keyCredentials, global::System.Collections.ObjectModel.Collection<PasswordCredential> passwordCredentials, global::System.Collections.ObjectModel.Collection<string> replyUrls, global::System.Collections.ObjectModel.Collection<string> servicePrincipalNames, global::System.Collections.ObjectModel.Collection<string> tags)\n        {\n            ServicePrincipal servicePrincipal = new ServicePrincipal();\n            servicePrincipal.objectId = objectId;\n            if ((keyCredentials == null))\n            {\n                throw new global::System.ArgumentNullException(\"keyCredentials\");\n            }\n            servicePrincipal.keyCredentials = keyCredentials;\n            if ((passwordCredentials == null))\n            {\n                throw new global::System.ArgumentNullException(\"passwordCredentials\");\n            }\n            servicePrincipal.passwordCredentials = passwordCredentials;\n            if ((replyUrls == null))\n            {\n                throw new global::System.ArgumentNullException(\"replyUrls\");\n            }\n            servicePrincipal.replyUrls = replyUrls;\n            if ((servicePrincipalNames == null))\n            {\n                throw new global::System.ArgumentNullException(\"servicePrincipalNames\");\n            }\n            servicePrincipal.servicePrincipalNames = servicePrincipalNames;\n            if ((tags == null))\n            {\n                throw new global::System.ArgumentNullException(\"tags\");\n            }\n            servicePrincipal.tags = tags;\n            return servicePrincipal;\n        }\n        /// <summary>\n        /// There are no comments for Property accountEnabled in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Nullable<bool> accountEnabled\n        {\n            get\n            {\n                return this._accountEnabled;\n            }\n            set\n            {\n                this.OnaccountEnabledChanging(value);\n                this._accountEnabled = value;\n                this.OnaccountEnabledChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Nullable<bool> _accountEnabled;\n        partial void OnaccountEnabledChanging(global::System.Nullable<bool> value);\n        partial void OnaccountEnabledChanged();\n        /// <summary>\n        /// There are no comments for Property appId in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Nullable<global::System.Guid> appId\n        {\n            get\n            {\n                return this._appId;\n            }\n            set\n            {\n                this.OnappIdChanging(value);\n                this._appId = value;\n                this.OnappIdChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Nullable<global::System.Guid> _appId;\n        partial void OnappIdChanging(global::System.Nullable<global::System.Guid> value);\n        partial void OnappIdChanged();\n        /// <summary>\n        /// There are no comments for Property displayName in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string displayName\n        {\n            get\n            {\n                return this._displayName;\n            }\n            set\n            {\n                this.OndisplayNameChanging(value);\n                this._displayName = value;\n                this.OndisplayNameChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _displayName;\n        partial void OndisplayNameChanging(string value);\n        partial void OndisplayNameChanged();\n        /// <summary>\n        /// There are no comments for Property errorUrl in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string errorUrl\n        {\n            get\n            {\n                return this._errorUrl;\n            }\n            set\n            {\n                this.OnerrorUrlChanging(value);\n                this._errorUrl = value;\n                this.OnerrorUrlChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _errorUrl;\n        partial void OnerrorUrlChanging(string value);\n        partial void OnerrorUrlChanged();\n        /// <summary>\n        /// There are no comments for Property homepage in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string homepage\n        {\n            get\n            {\n                return this._homepage;\n            }\n            set\n            {\n                this.OnhomepageChanging(value);\n                this._homepage = value;\n                this.OnhomepageChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _homepage;\n        partial void OnhomepageChanging(string value);\n        partial void OnhomepageChanged();\n        /// <summary>\n        /// There are no comments for Property keyCredentials in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Collections.ObjectModel.Collection<KeyCredential> keyCredentials\n        {\n            get\n            {\n                return this._keyCredentials;\n            }\n            set\n            {\n                this.OnkeyCredentialsChanging(value);\n                this._keyCredentials = value;\n                this.OnkeyCredentialsChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Collections.ObjectModel.Collection<KeyCredential> _keyCredentials = new global::System.Collections.ObjectModel.Collection<KeyCredential>();\n        partial void OnkeyCredentialsChanging(global::System.Collections.ObjectModel.Collection<KeyCredential> value);\n        partial void OnkeyCredentialsChanged();\n        /// <summary>\n        /// There are no comments for Property logoutUrl in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string logoutUrl\n        {\n            get\n            {\n                return this._logoutUrl;\n            }\n            set\n            {\n                this.OnlogoutUrlChanging(value);\n                this._logoutUrl = value;\n                this.OnlogoutUrlChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _logoutUrl;\n        partial void OnlogoutUrlChanging(string value);\n        partial void OnlogoutUrlChanged();\n        /// <summary>\n        /// There are no comments for Property passwordCredentials in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Collections.ObjectModel.Collection<PasswordCredential> passwordCredentials\n        {\n            get\n            {\n                return this._passwordCredentials;\n            }\n            set\n            {\n                this.OnpasswordCredentialsChanging(value);\n                this._passwordCredentials = value;\n                this.OnpasswordCredentialsChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Collections.ObjectModel.Collection<PasswordCredential> _passwordCredentials = new global::System.Collections.ObjectModel.Collection<PasswordCredential>();\n        partial void OnpasswordCredentialsChanging(global::System.Collections.ObjectModel.Collection<PasswordCredential> value);\n        partial void OnpasswordCredentialsChanged();\n        /// <summary>\n        /// There are no comments for Property publisherName in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string publisherName\n        {\n            get\n            {\n                return this._publisherName;\n            }\n            set\n            {\n                this.OnpublisherNameChanging(value);\n                this._publisherName = value;\n                this.OnpublisherNameChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _publisherName;\n        partial void OnpublisherNameChanging(string value);\n        partial void OnpublisherNameChanged();\n        /// <summary>\n        /// There are no comments for Property replyUrls in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Collections.ObjectModel.Collection<string> replyUrls\n        {\n            get\n            {\n                return this._replyUrls;\n            }\n            set\n            {\n                this.OnreplyUrlsChanging(value);\n                this._replyUrls = value;\n                this.OnreplyUrlsChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Collections.ObjectModel.Collection<string> _replyUrls = new global::System.Collections.ObjectModel.Collection<string>();\n        partial void OnreplyUrlsChanging(global::System.Collections.ObjectModel.Collection<string> value);\n        partial void OnreplyUrlsChanged();\n        /// <summary>\n        /// There are no comments for Property samlMetadataUrl in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string samlMetadataUrl\n        {\n            get\n            {\n                return this._samlMetadataUrl;\n            }\n            set\n            {\n                this.OnsamlMetadataUrlChanging(value);\n                this._samlMetadataUrl = value;\n                this.OnsamlMetadataUrlChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _samlMetadataUrl;\n        partial void OnsamlMetadataUrlChanging(string value);\n        partial void OnsamlMetadataUrlChanged();\n        /// <summary>\n        /// There are no comments for Property servicePrincipalNames in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Collections.ObjectModel.Collection<string> servicePrincipalNames\n        {\n            get\n            {\n                return this._servicePrincipalNames;\n            }\n            set\n            {\n                this.OnservicePrincipalNamesChanging(value);\n                this._servicePrincipalNames = value;\n                this.OnservicePrincipalNamesChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Collections.ObjectModel.Collection<string> _servicePrincipalNames = new global::System.Collections.ObjectModel.Collection<string>();\n        partial void OnservicePrincipalNamesChanging(global::System.Collections.ObjectModel.Collection<string> value);\n        partial void OnservicePrincipalNamesChanged();\n        /// <summary>\n        /// There are no comments for Property tags in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Collections.ObjectModel.Collection<string> tags\n        {\n            get\n            {\n                return this._tags;\n            }\n            set\n            {\n                this.OntagsChanging(value);\n                this._tags = value;\n                this.OntagsChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Collections.ObjectModel.Collection<string> _tags = new global::System.Collections.ObjectModel.Collection<string>();\n        partial void OntagsChanging(global::System.Collections.ObjectModel.Collection<string> value);\n        partial void OntagsChanged();\n        /// <summary>\n        /// There are no comments for permissions in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public global::System.Collections.ObjectModel.Collection<Permission> permissions\n        {\n            get\n            {\n                return this._permissions;\n            }\n            set\n            {\n                if ((value != null))\n                {\n                    this._permissions = value;\n                }\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private global::System.Collections.ObjectModel.Collection<Permission> _permissions = new global::System.Collections.ObjectModel.Collection<Permission>();\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n        /// <summary>\n        /// \n        /// </summary>\n        public class ShadowMapNode : SceneNode\n        {\n            /// <summary>\n            /// Gets or sets the resolution.\n            /// </summary>\n            /// <value>\n            /// The resolution.\n            /// </value>\n            public Size2 Resolution\n            {\n                get { return new Size2((RenderCore as ShadowMapCore).Width, (RenderCore as ShadowMapCore).Height); }\n                set { (RenderCore as ShadowMapCore).Width = value.Width; (RenderCore as ShadowMapCore).Height = value.Height; }\n            }\n\n            /// <summary>\n            ///\n            /// </summary>\n            public float Bias\n            {\n                get { return (RenderCore as ShadowMapCore).Bias; }\n                set { (RenderCore as ShadowMapCore).Bias = value; }\n            }\n\n            /// <summary>\n            ///\n            /// </summary>\n            public float Intensity\n            {\n                get { return (RenderCore as ShadowMapCore).Intensity; }\n                set { (RenderCore as ShadowMapCore).Intensity = value; }\n            }\n\n            private float distance = 200;\n            public float Distance\n            {\n                set\n                {\n                    SetAffectsRender(ref distance, value);\n                }\n                get { return distance; }\n            }\n\n            private float orthoWidth = 100;\n            public float OrthoWidth\n            {\n                set\n                {\n                    SetAffectsRender(ref orthoWidth, value);\n                }\n                get { return orthoWidth; }\n            }\n\n            private float farField = 500;\n            /// <summary>\n            /// Gets or sets the far field.\n            /// </summary>\n            /// <value>\n            /// The far field.\n            /// </value>\n            public float FarField\n            {\n                set\n                {\n                    if(SetAffectsRender(ref farField, value))\n                    {\n                        orthoCamera.FarPlaneDistance = value;\n                        persCamera.FarPlaneDistance = value;\n                    }\n                }\n                get { return farField; }\n            }\n\n            private float nearField = 500;\n            /// <summary>\n            /// Gets or sets the near field.\n            /// </summary>\n            /// <value>\n            /// The far field.\n            /// </value>\n            public float NearField\n            {\n                set\n                {\n                    if(SetAffectsRender(ref nearField, value))\n                    {\n                        orthoCamera.NearPlaneDistance = value;\n                        persCamera.NearPlaneDistance = value;\n                    }\n                }\n                get { return nearField; }\n            }\n            /// <summary>\n            /// Distance of the directional light from origin\n            /// </summary>\n            public ProjectionCameraCore LightCamera\n            {\n                set; get;\n            } = null;\n\n            /// <summary>\n            /// Called when [create render core].\n            /// </summary>\n            /// <returns></returns>\n            protected override RenderCore OnCreateRenderCore()\n            {\n                var core = new ShadowMapCore();\n                core.OnUpdateLightSource += Core_OnUpdateLightSource;\n                return core;\n            }\n\n            private ShadowMapCore shadowCore;\n\n            private readonly OrthographicCameraCore orthoCamera = new OrthographicCameraCore() { NearPlaneDistance = 1, FarPlaneDistance = 500 };\n            private readonly PerspectiveCameraCore persCamera = new PerspectiveCameraCore() { NearPlaneDistance = 1, FarPlaneDistance = 500 };\n\n            /// <summary>\n            /// Assigns the default values to core.\n            /// </summary>\n            /// <param name=\"core\">The core.</param>\n            protected override void AssignDefaultValuesToCore(RenderCore core)\n            {\n                base.AssignDefaultValuesToCore(core);\n                var c = core as ShadowMapCore;\n                //c.FactorPCF = (float)FactorPCF;\n                c.Intensity = (float)Intensity;\n                c.Bias = (float)Bias;\n                c.Width = (int)(Resolution.Width);\n                c.Height = (int)(Resolution.Height);\n            }\n\n            /// <summary>\n            /// To override Attach routine, please override this.\n            /// </summary>\n            /// <param name=\"host\"></param>\n            /// <returns>\n            /// Return true if attached\n            /// </returns>\n            protected override bool OnAttach(IRenderHost host)\n            {\n                base.OnAttach(host);\n                shadowCore = RenderCore as ShadowMapCore;\n                return true;\n            }\n\n            /// <summary>\n            /// <para>Determine if this can be rendered.</para>\n            /// </summary>\n            /// <param name=\"context\"></param>\n            /// <returns></returns>\n            protected override bool CanRender(RenderContext context)\n            {\n                return base.CanRender(context) && RenderHost.IsShadowMapEnabled;\n            }\n\n            private void Core_OnUpdateLightSource(object sender, ShadowMapCore.UpdateLightSourceEventArgs e)\n            {\n                CameraCore camera = LightCamera ?? null;\n                if (LightCamera == null)\n                {\n                    var lights = e.Context.RenderHost.PerFrameLights.Take(Constants.MaxLights);\n                    foreach (var light in lights)\n                    {\n                        if (light.LightType == LightType.Directional)\n                        {\n                            var dlight = light.RenderCore as DirectionalLightCore;\n                            var dir = Vector3.TransformNormal(dlight.Direction, dlight.ModelMatrix).Normalized() * distance;\n                            orthoCamera.LookDirection = dir;\n                            orthoCamera.Position = -dir;\n                            orthoCamera.UpDirection = Vector3.UnitZ;\n                            orthoCamera.Width = orthoWidth;\n                            camera = orthoCamera;\n                            break;\n                        }\n                        else if (light.LightType == LightType.Spot)\n                        {\n                            var splight = light.RenderCore as SpotLightCore;\n                            persCamera.Position = (splight.Position + splight.ModelMatrix.Row4.ToVector3());\n                            var look = Vector3.TransformNormal(splight.Direction, splight.ModelMatrix);\n                            persCamera.LookDirection = look;\n                            persCamera.FarPlaneDistance = (float)splight.Range;\n                            persCamera.FieldOfView = (float)splight.OuterAngle;\n                            persCamera.UpDirection = Vector3.UnitZ;\n                            camera = persCamera;\n                            break;\n                        }\n                    }\n                }\n                if (camera == null)\n                {\n                    shadowCore.FoundLightSource = false;\n                }\n                else\n                {\n                    shadowCore.FoundLightSource = true;\n                    shadowCore.LightViewProjectMatrix = camera.CreateViewMatrix() * camera.CreateProjectionMatrix(shadowCore.Width / shadowCore.Height);\n                }\n            }\n\n            /// <summary>\n            /// Determines whether this instance [can hit test] the specified context.\n            /// </summary>\n            /// <param name=\"context\">The context.</param>\n            /// <returns>\n            ///   <c>true</c> if this instance [can hit test] the specified context; otherwise, <c>false</c>.\n            /// </returns>\n            protected override bool CanHitTest(RenderContext context)\n            {\n                return false;\n            }\n\n            /// <summary>\n            /// Called when [hit test].\n            /// </summary>\n            /// <param name=\"context\">The context.</param>\n            /// <param name=\"totalModelMatrix\">The total model matrix.</param>\n            /// <param name=\"ray\">The ray.</param>\n            /// <param name=\"hits\">The hits.</param>\n            /// <returns></returns>\n            /// <exception cref=\"System.NotImplementedException\"></exception>\n            protected override bool OnHitTest(RenderContext context, Matrix totalModelMatrix, ref Ray ray, ref List<HitTestResult> hits)\n            {\n                return false;\n            }\n        }\n", "label": "MultifacetedAbstraction"}
{"text": "   \n   [DebuggerDisplay(\"{ControllerUrl}\")]\n   abstract class ControllerInfo : ICustomAttributeProvider {\n\n      ReadOnlyCollection<string> _CodeRoutingNamespace;\n      ReadOnlyCollection<string> _CodeRoutingContext;\n      ReadOnlyCollection<string> _NamespaceSegments;\n      ReadOnlyCollection<string> _BaseRouteAndNamespaceSegments;\n      RouteParameterCollection _RouteProperties;\n      Collection<ActionInfo> _Actions;\n      string _Name;\n      string _ControllerSegment;\n      string _CustomRoute;\n      bool _CustomRouteInit;\n      bool? _CustomRouteHasControllerToken;\n      string _UrlTemplate;\n      string _ControllerUrl;\n\n      public Type Type { get; private set; }\n      public RegisterSettings Register { get; private set; }\n      public CodeRoutingProvider Provider { get; private set; }\n\n      public virtual string Name {\n         get {\n            return _Name\n               ?? (_Name = Type.Name.Substring(0, Type.Name.Length - \"Controller\".Length));\n         }\n      }\n\n      public string Namespace {\n         get {\n            return Type.Namespace \n               ?? \"\";\n         }\n      }\n\n      public bool IsInRootNamespace {\n         get {\n            return Namespace == Register.RootNamespace\n               || IsInSubNamespace;\n         }\n      }\n\n      public bool IsInSubNamespace {\n         get {\n            return Namespace.Length > Register.RootNamespace.Length\n               && Namespace.StartsWith(Register.RootNamespace + \".\", StringComparison.Ordinal);\n         }\n      }\n\n      public bool IsRootController {\n         get {\n            return Type == Register.RootController;\n         }\n      }\n\n      public string ControllerSegment {\n         get {\n            return _ControllerSegment\n               ?? (_ControllerSegment = Register.Settings.FormatRouteSegment(new RouteFormatterArgs(Name, RouteSegmentType.Controller, Type)));\n         }\n      }\n\n      public ReadOnlyCollection<string> CodeRoutingNamespace {\n         get {\n            if (_CodeRoutingNamespace == null) {\n\n               var segments = new List<string>();\n\n               if (IsInSubNamespace) {\n                  \n                  segments.AddRange(Namespace.Remove(0, Register.RootNamespace.Length + 1).Split('.'));\n\n                  if (segments.Count > 0 && NameEquals(segments.Last(), Name))\n                     segments.RemoveAt(segments.Count - 1);\n               }\n\n               _CodeRoutingNamespace = new ReadOnlyCollection<string>(segments);\n            }\n\n            return _CodeRoutingNamespace;\n         }\n      }\n\n      public ReadOnlyCollection<string> CodeRoutingContext {\n         get {\n            if (_CodeRoutingContext == null) {\n\n               if (Register.BaseRoute == null) {\n                  _CodeRoutingContext = new ReadOnlyCollection<string>(CodeRoutingNamespace);\n               \n               } else {\n\n                  var segments = new List<string>();\n                  segments.AddRange(Register.BaseRoute.Split('/'));\n                  segments.AddRange(CodeRoutingNamespace);\n\n                  _CodeRoutingContext = new ReadOnlyCollection<string>(segments);\n               }\n            }\n\n            return _CodeRoutingContext;\n         }\n      }\n\n      public ReadOnlyCollection<string> NamespaceSegments {\n         get {\n            if (_NamespaceSegments == null) {\n\n               var namespaceSegments = new List<string>();\n\n               namespaceSegments.AddRange(\n                  CodeRoutingNamespace.Select(s => Register.Settings.FormatRouteSegment(new RouteFormatterArgs(s, RouteSegmentType.Namespace, Type)))\n               );\n\n               _NamespaceSegments = new ReadOnlyCollection<string>(namespaceSegments);\n            }\n\n            return _NamespaceSegments;\n         }\n      }\n\n      public ReadOnlyCollection<string> BaseRouteAndNamespaceSegments {\n         get {\n            if (_BaseRouteAndNamespaceSegments == null) {\n\n               if (Register.BaseRoute == null) {\n                  _BaseRouteAndNamespaceSegments = new ReadOnlyCollection<string>(NamespaceSegments);\n               \n               } else {\n\n                  var segments = new List<string>();\n                  segments.AddRange(Register.BaseRoute.Split('/'));\n                  segments.AddRange(NamespaceSegments);\n\n                  _BaseRouteAndNamespaceSegments = new ReadOnlyCollection<string>(segments);\n               }\n            }\n\n            return _BaseRouteAndNamespaceSegments;\n         }\n      }\n\n      public RouteParameterCollection RouteProperties {\n         get {\n            if (_RouteProperties == null) {\n\n               var types = new List<Type>();\n\n               for (Type t = this.Type; t != null; t = t.BaseType) {\n                  types.Add(t);\n               }\n\n               types.Reverse();\n\n               var list = new List<RouteParameter>();\n\n               foreach (Type t in types) {\n\n                  list.AddRange(\n                     from p in t.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public)\n                     \n                     let attr = Provider.GetCorrectAttribute<IFromRouteAttribute>(\n                        p, \n                        prov => prov.FromRouteAttributeType, \n                        inherit: false /* [1] */,\n                        errorMessage: (attrType, mistakenAttrType) =>\n                           String.Format(CultureInfo.InvariantCulture,\n                              \"Must use {0} instead of {1} (property {2} on {3}).\",\n                              attrType.FullName,\n                              mistakenAttrType.FullName,\n                              p.Name,\n                              t.FullName\n                           )\n                        )\n\n                     where attr != null\n                     let rp = CreateRouteParameter(p, attr)\n                     where !list.Any(item => RouteParameter.NameEquals(item.Name, rp.Name))\n                     select rp\n                  );\n               }\n\n               _RouteProperties = new RouteParameterCollection(list);\n            }\n\n            return _RouteProperties;\n\n            // [1] Procesing each type of the hierarchy one by one, hence inherit: false.\n         }\n      }\n\n      public Collection<ActionInfo> Actions {\n         get {\n            if (_Actions == null) {\n\n               var actions =\n                  (from a in GetActions()\n                   where !IsNonAction(a)\n                   select a).ToArray();\n\n               CheckDefaultActions(actions);\n               CheckOverloads(actions);\n               CheckCustomRoutes(actions);\n\n               _Actions = new Collection<ActionInfo>(actions);\n            }\n\n            return _Actions;\n         }\n      }\n\n      public string UrlTemplate {\n         get {\n            return _UrlTemplate\n               ?? (_UrlTemplate = BuildUrl(template: true));\n         }\n      }\n\n      public string ControllerUrl {\n         get {\n            return _ControllerUrl\n               ?? (_ControllerUrl = BuildUrl(template: false));\n         }\n      }\n\n      public string CustomRoute {\n         get {\n            if (!_CustomRouteInit) {\n\n               ICustomRouteAttribute attr = Provider\n                  .GetCorrectAttribute<ICustomRouteAttribute>(\n                     this,\n                     prov => prov.CustomRouteAttributeType,\n                     inherit: true,\n                     errorMessage: (attrType, mistakenAttrType) =>\n                        String.Format(CultureInfo.InvariantCulture,\n                           \"Must use {0} instead of {1} on {2}.\",\n                           attrType.FullName,\n                           mistakenAttrType.FullName,\n                           Type.FullName\n                        )\n                  );\n\n               if (attr != null) {\n                  _CustomRoute = attr.Url;\n               }\n\n               _CustomRouteInit = true;\n            }\n\n            return _CustomRoute;\n         }\n      }\n\n      public bool CustomRouteHasControllerToken {\n         get {\n            if (CustomRoute == null) {\n               return false;\n            }\n\n            if (_CustomRouteHasControllerToken == null) {\n               _CustomRouteHasControllerToken =\n                  CustomRoute.IndexOf(\"{controller}\", StringComparison.OrdinalIgnoreCase) != -1;\n            }\n\n            return _CustomRouteHasControllerToken.Value;\n         }\n      }\n\n      public bool CustomRouteIsAbsolute {\n         get {\n            if (CustomRoute == null) {\n               return false;\n            }\n\n            return CustomRoute.StartsWith(\"~/\", StringComparison.OrdinalIgnoreCase);\n         }\n      }\n\n      public static bool NameEquals(string name1, string name2) {\n         return String.Equals(name1, name2, StringComparison.OrdinalIgnoreCase);\n      }\n\n      string BuildUrl(bool template) {\n\n         string custRoute = this.CustomRoute;\n\n         var segments = new List<string>();\n         segments.AddRange(this.BaseRouteAndNamespaceSegments);\n\n         if (custRoute != null) {\n\n            if (this.CustomRouteIsAbsolute) {\n\n               segments.Clear();\n\n               if (this.Register.BaseRoute != null) {\n                  segments.AddRange(this.Register.BaseRoute.Split('/'));\n               }\n\n               custRoute = custRoute.Substring(2);\n            }\n\n            segments.AddRange(custRoute.Split('/'));\n\n         } else {\n\n            if (!this.IsRootController) {\n               segments.Add(template ? \"{controller}\" : this.ControllerSegment);\n            }\n\n            segments.AddRange(this.RouteProperties.Select(p => p.RouteSegment));\n         }\n\n         string url = String.Join(\"/\", segments);\n\n         return url;\n      }\n\n      void CheckOverloads(IEnumerable<ActionInfo> actions) {\n\n         var overloadedActions =\n            (from a in actions\n             where a.RouteParameters.Count > 0\n             group a by new { a.Controller, Name = a.ActionSegment } into g\n             where g.Count() > 1\n             select g).ToList();\n\n         if (!Provider.CanDisambiguateActionOverloads) {\n\n            var withoutRequiredAttr =\n               (from g in overloadedActions\n                let distinctParamCount = g.Select(a => a.RouteParameters.Count).Distinct()\n                where distinctParamCount.Count() > 1\n                let bad = g.Where(a => !a.HasActionOverloadDisambiguationAttribute)\n                where bad.Count() > 0\n                select bad).ToList();\n\n            if (withoutRequiredAttr.Count > 0) {\n\n               var first = withoutRequiredAttr.First();\n\n               throw new InvalidOperationException(\n                  String.Format(CultureInfo.InvariantCulture,\n                     \"The following action methods must be decorated with {0} for disambiguation: {1}.\",\n                     Provider.ActionOverloadDisambiguationAttributeType.FullName,\n                     String.Join(\", \", first.Select(a => String.Concat(a.DeclaringType.FullName, \".\", a.MethodName, \"(\", String.Join(\", \", a.Parameters.Select(p => p.Type.Name)), \")\")))\n                  )\n               );\n            }\n         }\n\n         var overloadsComparer = new ActionSignatureComparer();\n\n         var overloadsWithDifferentParameters =\n            (from g in overloadedActions\n             let ordered = g.OrderByDescending(a => a.RouteParameters.Count).ToArray()\n             let first = ordered.First()\n             where !ordered.Skip(1).All(a => overloadsComparer.Equals(first, a))\n             select g).ToList();\n\n         if (overloadsWithDifferentParameters.Count > 0) {\n\n            var first = overloadsWithDifferentParameters.First();\n\n            throw new InvalidOperationException(\n               String.Format(CultureInfo.InvariantCulture,\n                  \"Overloaded action methods must have route parameters that are equal in name, position and constraint ({0}).\",\n                  String.Concat(first.Key.Controller.Type.FullName, \".\", first.First().MethodName)\n               )\n            );\n         }\n      }\n\n      void CheckCustomRoutes(IEnumerable<ActionInfo> actions) { \n\n         var sameCustomRouteDifferentNames = \n            (from a in actions\n             where a.CustomRoute != null\n               && !a.CustomRouteHasActionToken\n             group a by a.CustomRoute into grp\n             let distinctNameCount = grp.Select(a => a.Name).Distinct(StringComparer.OrdinalIgnoreCase).Count()\n             where distinctNameCount > 1\n             select grp).ToList();\n\n         if (sameCustomRouteDifferentNames.Count > 0) {\n\n            var first = sameCustomRouteDifferentNames.First();\n            \n            throw new InvalidOperationException(\n               String.Format(CultureInfo.InvariantCulture,\n                  \"Action methods decorated with {0} must have the same name: {1}.\",\n                  Provider.CustomRouteAttributeType.FullName,\n                  String.Join(\", \", first.Select(a => String.Concat(a.DeclaringType.FullName, \".\", a.MethodName, \"(\", String.Join(\", \", a.Parameters.Select(p => p.Type.Name)), \")\")))\n               )\n            );\n         }\n      }\n\n      void CheckDefaultActions(IEnumerable<ActionInfo> actions) { \n         \n         // - Index is the default action by convention\n         // - You can use [DefaultAction] to override the convention\n         //   - Can only be applied to one action per controller type\n         //   - Can be inherited from base controller\n         //   - Derived controllers can override the inherited [DefaultAction] by applying it to a different action\n         // - Default action cannot have required route parameters (either no parameters or all optional)\n\n         Func<ActionInfo, bool> correctRouteParameterSetup = a =>\n            a.RouteParameters.Count == 0 \n               || a.RouteParameters.All(p => p.IsOptional);\n\n         ActionInfo defaultAction = null;\n\n         Type attrType = this.Provider.DefaultActionAttributeType;\n\n         if (attrType != null) {\n\n            var defaultActions =\n               (from a in actions\n                where a.GetCustomAttributes(attrType, inherit: false).Any()\n                select a).ToArray();\n\n            if (defaultActions.Any()) {\n\n               var byDeclaringType =\n                  from a in defaultActions\n                  group a by a.DeclaringType;\n\n               if (defaultActions.Length > byDeclaringType.Count()) {\n                  throw new InvalidOperationException(\n                     \"{0} can only be used once per declaring type: {1}.\".FormatInvariant(attrType.FullName, byDeclaringType.First(g => g.Count() > 1).Key.FullName)\n                  );\n               }\n\n               for (Type t = this.Type; t != null; t = t.BaseType) {\n\n                  defaultAction = defaultActions.SingleOrDefault(a => a.DeclaringType == t);\n\n                  if (defaultAction != null) {\n\n                     if (!correctRouteParameterSetup(defaultAction)) {\n                        throw new InvalidOperationException(\n                           \"Default actions cannot have required route parameters: {0}.\".FormatInvariant(\n                              String.Concat(defaultAction.DeclaringType.FullName, \".\", defaultAction.MethodName, \"(\", String.Join(\", \", defaultAction.Parameters.Select(p => p.Type.Name)), \")\")\n                           )\n                        );\n                     }\n\n                     break;\n                  }\n               }\n            } \n         }\n\n         if (defaultAction == null) {\n            defaultAction = actions.FirstOrDefault(a => ActionInfo.NameEquals(a.Name, \"Index\") && correctRouteParameterSetup(a));\n         }\n\n         if (defaultAction != null) {\n            defaultAction.IsDefaultAction = true;\n         }\n      }\n\n      protected ControllerInfo(Type type, RegisterSettings registerSettings, CodeRoutingProvider provider) {\n         \n         this.Type = type;\n         this.Register = registerSettings;\n         this.Provider = provider;\n      }\n\n      protected internal abstract ActionInfo[] GetActions();\n      public abstract object[] GetCustomAttributes(bool inherit);\n      public abstract object[] GetCustomAttributes(Type attributeType, bool inherit);\n      public abstract bool IsDefined(Type attributeType, bool inherit);\n      protected abstract bool IsNonAction(ICustomAttributeProvider action);\n\n      RouteParameter CreateRouteParameter(PropertyInfo property, IFromRouteAttribute routeAttr) {\n         return CreateRouteParameter(property.Name, property.PropertyType, routeAttr, isOptional: false, isCatchAll: false);\n      }\n\n      internal RouteParameter CreateRouteParameter(string name, Type type, IFromRouteAttribute routeAttr, bool isOptional, bool isCatchAll) {\n\n         if (routeAttr != null\n            && routeAttr.Name.HasValue()) {\n\n            name = routeAttr.Name;\n         }\n\n         type = TypeHelpers.GetNullableUnderlyingType(type);\n\n         string constraint = GetConstraintForType(type, routeAttr);\n\n         BinderSource binderSource;\n         ParameterBinder binder = GetBinderForType(type, routeAttr, out binderSource);\n\n         if (binder == null\n            && type.IsEnum) {\n\n            binder = (ParameterBinder)Activator.CreateInstance(typeof(EnumParameterBinder<>).MakeGenericType(type));\n         }\n\n         if (constraint.HasValue()\n            && binderSource != BinderSource.Parameter) {\n            \n            binder = null;\n         }\n\n         return new RouteParameter(name, type, constraint, isOptional, isCatchAll, binder);\n      }\n\n      ParameterBinder GetBinderForType(Type type, IFromRouteAttribute routeAttr, out BinderSource source) {\n\n         ParameterBinder paramBinder = null;\n         source = BinderSource.None;\n\n         if (routeAttr != null\n            && routeAttr.BinderType != null) {\n\n            paramBinder = ParameterBinder.GetInstance(null, routeAttr.BinderType);\n\n            if (paramBinder != null) {\n               source = BinderSource.Parameter;\n               return paramBinder;\n            }\n         }\n\n         type = TypeHelpers.GetNullableUnderlyingType(type);\n\n         if (this.Register.Settings.ParameterBinders.TryGetItem(type, out paramBinder)) {\n            source = BinderSource.Settings;\n            return paramBinder;\n         }\n\n         paramBinder = ParameterBinder.GetInstance(type, null);\n\n         if (paramBinder != null) {\n            source = BinderSource.Type;\n         }\n\n         return paramBinder;\n      }\n\n      string GetConstraintForType(Type type, IFromRouteAttribute routeAttr) {\n\n         string constraint = null;\n\n         if (routeAttr != null) {\n            constraint = routeAttr.Constraint;\n         }\n\n         if (constraint == null) {\n\n            type = TypeHelpers.GetNullableUnderlyingType(type);\n\n            this.Register.Settings.DefaultConstraints.TryGetValue(type, out constraint);\n         }\n\n         return constraint;\n      }\n\n      enum BinderSource { \n         None = 0,\n         Parameter,\n         Settings,\n         Type\n      }\n   }\n", "label": "MultifacetedAbstraction"}
{"text": "\t/// <summary>\n\t/// Predicate expression filter.\n\t/// Predicate expression filters are applied on the query results on the server.\n\t/// Predicate expression filters may occur on any bin in the record.\n\t/// <para>\n\t/// This is an experimental API and subject to change.\n\t/// </para>\n\t/// </summary>\n\tpublic abstract class PredExp\n\t{\n\t\t/// <summary>\n\t\t/// Create \"and\" expression.\n\t\t/// </summary>\n\t\t/// <param name=\"nexp\">\tnumber of expressions to perform \"and\" operation.  Usually two. </param>\n\t\tpublic static PredExp And(ushort nexp)\n\t\t{\n\t\t\treturn new AndOr(AND, nexp);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create \"or\" expression.\n\t\t/// </summary>\n\t\t/// <param name=\"nexp\">\tnumber of expressions to perform \"or\" operation.  Usually two. </param>\n\t\tpublic static PredExp Or(ushort nexp)\n\t\t{\n\t\t\treturn new AndOr(OR, nexp);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create \"not\" expression.\n\t\t/// </summary>\n\t\tpublic static PredExp Not()\n\t\t{\n\t\t\treturn new Op(NOT);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create Calendar value expressed in nanoseconds since 1970-01-01 epoch as 64 bit integer.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerValue(DateTime val)\n\t\t{\n\t\t\treturn new IntegerVal(Util.NanosFromEpoch(val), INTEGER_VALUE);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer value.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerValue(long val)\n\t\t{\n\t\t\treturn new IntegerVal(val, INTEGER_VALUE);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create string value.\n\t\t/// </summary>\n\t\tpublic static PredExp StringValue(string val)\n\t\t{\n\t\t\treturn new StringVal(val, STRING_VALUE);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create geospatial json string value.\n\t\t/// </summary>\n\t\tpublic static PredExp GeoJSONValue(string val)\n\t\t{\n\t\t\treturn new GeoJSONVal(val, GEOJSON_VALUE);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer bin predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerBin(string name)\n\t\t{\n\t\t\treturn new StringVal(name, INTEGER_BIN);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create string bin predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp StringBin(string name)\n\t\t{\n\t\t\treturn new StringVal(name, STRING_BIN);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create geospatial bin predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp GeoJSONBin(string name)\n\t\t{\n\t\t\treturn new StringVal(name, GEOJSON_BIN);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create list bin predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp ListBin(string name)\n\t\t{\n\t\t\treturn new StringVal(name, LIST_BIN);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create map bin predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp MapBin(string name)\n\t\t{\n\t\t\treturn new StringVal(name, MAP_BIN);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer variable used in list/map iterations.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerVar(string name)\n\t\t{\n\t\t\treturn new StringVal(name, INTEGER_VAR);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create string variable used in list/map iterations.\n\t\t/// </summary>\n\t\tpublic static PredExp StringVar(string name)\n\t\t{\n\t\t\treturn new StringVal(name, STRING_VAR);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create geospatial json string variable used in list/map iterations.\n\t\t/// </summary>\n\t\tpublic static PredExp GeoJSONVar(string name)\n\t\t{\n\t\t\treturn new StringVal(name, GEOJSON_VAR);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create record size on disk predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp RecDeviceSize()\n\t\t{\n\t\t\treturn new Op(RECSIZE);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create record last update time predicate expressed in nanoseconds since 1970-01-01 epoch as 64 bit integer.\n\t\t/// Example:\n\t\t/// <pre>\n\t\t/// // Record last update time >= 2017-01-15\n\t\t/// PredExp.RecLastUpdate()\n\t\t/// PredExp.IntegerValue(new DateTime(2017, 1, 15))\n\t\t/// PredExp.IntegerGreaterEq()\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp RecLastUpdate()\n\t\t{\n\t\t\treturn new Op(LAST_UPDATE);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create record expiration time predicate expressed in nanoseconds since 1970-01-01 epoch as 64 bit integer.\n\t\t/// Example:\n\t\t/// <pre>\n\t\t/// // Record expires on 2020-01-01\n\t\t/// PredExp.RecVoidTime()\n\t\t/// PredExp.IntegerValue(new DateTime(2020, 0, 1))\n\t\t/// PredExp.IntegerGreaterEq()\n\t\t/// PredExp.RecVoidTime()\n\t\t/// PredExp.IntegerValue(new DateTime(2020, 0, 2))\n\t\t/// PredExp.IntegerLess()\n\t\t/// PredExp.And(2)\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp RecVoidTime()\n\t\t{\n\t\t\treturn new Op(VOID_TIME);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create a digest modulo record metadata value predicate expression.\n\t\t/// The digest modulo expression assumes the value of 4 bytes of the\n\t\t/// record's key digest modulo it's argument.\n\t\t/// <para>\n\t\t/// For example, the following sequence of predicate expressions\n\t\t/// selects records that have digest(key) % 3 == 1):\n\t\t/// <pre>\n\t\t/// PredExp.RecDigestModulo(3)\n\t\t/// PredExp.IntegerValue(1)\n\t\t/// PredExp.IntegerEqual()\n\t\t/// </pre>\n\t\t/// </para>\n\t\t/// </summary>\n\t\tpublic static PredExp RecDigestModulo(int mod)\n\t\t{\n\t\t\treturn new OpInt(DIGEST_MODULO, (uint)mod);\n\t\t}\n\t\n\t\t/// <summary>\n\t\t/// Create 64 bit integer \"=\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerEqual()\n\t\t{\n\t\t\treturn new Op(INTEGER_EQUAL);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer \"!=\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerUnequal()\n\t\t{\n\t\t\treturn new Op(INTEGER_UNEQUAL);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer \">\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerGreater()\n\t\t{\n\t\t\treturn new Op(INTEGER_GREATER);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer \">=\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerGreaterEq()\n\t\t{\n\t\t\treturn new Op(INTEGER_GREATEREQ);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer \"&lt;\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerLess()\n\t\t{\n\t\t\treturn new Op(INTEGER_LESS);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create 64 bit integer \"&lt;=\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp IntegerLessEq()\n\t\t{\n\t\t\treturn new Op(INTEGER_LESSEQ);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create string \"=\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp StringEqual()\n\t\t{\n\t\t\treturn new Op(STRING_EQUAL);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create string \"!=\" operation predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp StringUnequal()\n\t\t{\n\t\t\treturn new Op(STRING_UNEQUAL);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create regular expression string operation predicate.  Example:\n\t\t/// <pre>\n\t\t/// PredExp.StringRegex(RegexFlag.EXTENDED | RegexFlag.ICASE)\n\t\t/// </pre>\n\t\t/// </summary>\n\t\t/// <param name=\"flags\">regular expression bit flags. See <see cref=\"RegexFlag\"/></param>\n\t\tpublic static PredExp StringRegex(uint flags)\n\t\t{\n\t\t\treturn new OpInt(STRING_REGEX, flags);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create geospatial json \"within\" predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp GeoJSONWithin()\n\t\t{\n\t\t\treturn new Op(GEOJSON_WITHIN);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create geospatial json \"contains\" predicate.\n\t\t/// </summary>\n\t\tpublic static PredExp GeoJSONContains()\n\t\t{\n\t\t\treturn new Op(GEOJSON_CONTAINS);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create list predicate where expression matches for any list item.\n\t\t/// Example:\n\t\t/// <pre>\n\t\t/// // Find records where any list item v = \"hello\" in list bin x.  \n\t\t/// PredExp.StringVar(\"v\")\n\t\t/// PredExp.StringValue(\"hello\")\n\t\t/// PredExp.StringEqual()\n\t\t/// PredExp.ListBin(\"x\")\n\t\t/// PredExp.ListIterateOr(\"v\")\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp ListIterateOr(string varName)\n\t\t{\n\t\t\treturn new StringVal(varName, LIST_ITERATE_OR);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create list predicate where expression matches for all list items.\n\t\t/// Example:\n\t\t/// <pre>\n\t\t/// // Find records where all list elements v != \"goodbye\" in list bin x.  \n\t\t/// PredExp.StringVar(\"v\")\n\t\t/// PredExp.StringValue(\"goodbye\")\n\t\t/// PredExp.StringUnequal()\n\t\t/// PredExp.ListBin(\"x\")\n\t\t/// PredExp.ListIterateAnd(\"v\")\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp ListIterateAnd(string varName)\n\t\t{\n\t\t\treturn new StringVal(varName, LIST_ITERATE_AND);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create map predicate where expression matches for any map key.\n\t\t/// Example:\n\t\t/// <pre>\n\t\t/// // Find records where any map key k = 7 in map bin m.  \n\t\t/// PredExp.IntegerVar(\"k\")\n\t\t/// PredExp.IntegerValue(7)\n\t\t/// PredExp.IntegerEqual()\n\t\t/// PredExp.MapBin(\"m\")\n\t\t/// PredExp.MapKeyIterateOr(\"k\")\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp MapKeyIterateOr(string varName)\n\t\t{\n\t\t\treturn new StringVal(varName, MAPKEY_ITERATE_OR);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create map key predicate where expression matches for all map keys.\n\t\t/// Example:\n\t\t/// <pre>\n\t\t/// // Find records where all map keys k &lt; 5 in map bin m.  \n\t\t/// PredExp.IntegerVar(\"k\")\n\t\t/// PredExp.IntegerValue(5)\n\t\t/// PredExp.IntegerLess()\n\t\t/// PredExp.MapBin(\"m\")\n\t\t/// PredExp.MapKeyIterateAnd(\"k\")\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp MapKeyIterateAnd(string varName)\n\t\t{\n\t\t\treturn new StringVal(varName, MAPKEY_ITERATE_AND);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create map predicate where expression matches for any map value.\n\t\t/// <pre>\n\t\t/// // Find records where any map value v > 100 in map bin m.  \n\t\t/// PredExp.IntegerVar(\"v\")\n\t\t/// PredExp.IntegerValue(100)\n\t\t/// PredExp.IntegerGreater()\n\t\t/// PredExp.MapBin(\"m\")\n\t\t/// PredExp.MapValIterateOr(\"v\")\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp MapValIterateOr(string varName)\n\t\t{\n\t\t\treturn new StringVal(varName, MAPVAL_ITERATE_OR);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Create map predicate where expression matches for all map values.\n\t\t/// Example:\n\t\t/// <pre>\n\t\t/// // Find records where all map values v > 500 in map bin m.  \n\t\t/// PredExp.IntegerVar(\"v\")\n\t\t/// PredExp.IntegerValue(500)\n\t\t/// PredExp.IntegerGreater()\n\t\t/// PredExp.MapBin(\"m\")\n\t\t/// PredExp.MapKeyIterateAnd(\"v\")\n\t\t/// </pre>\n\t\t/// </summary>\n\t\tpublic static PredExp MapValIterateAnd(string varName)\n\t\t{\n\t\t\treturn new StringVal(varName, MAPVAL_ITERATE_AND);\n\t\t}\n\n\t\tprivate const ushort AND = 1;\n\t\tprivate const ushort OR = 2;\n\t\tprivate const ushort NOT = 3;\n\t\tprivate const ushort INTEGER_VALUE = 10;\n\t\tprivate const ushort STRING_VALUE = 11;\n\t\tprivate const ushort GEOJSON_VALUE = 12;\n\t\tprivate const ushort INTEGER_BIN = 100;\n\t\tprivate const ushort STRING_BIN = 101;\n\t\tprivate const ushort GEOJSON_BIN = 102;\n\t\tprivate const ushort LIST_BIN = 103;\n\t\tprivate const ushort MAP_BIN = 104;\n\t\tprivate const ushort INTEGER_VAR = 120;\n\t\tprivate const ushort STRING_VAR = 121;\n\t\tprivate const ushort GEOJSON_VAR = 122;\n\t\tprivate const ushort RECSIZE = 150;\n\t\tprivate const ushort LAST_UPDATE = 151;\n\t\tprivate const ushort VOID_TIME = 152;\n\t\tprivate const ushort DIGEST_MODULO = 153;\n\t\tprivate const ushort INTEGER_EQUAL = 200;\n\t\tprivate const ushort INTEGER_UNEQUAL = 201;\n\t\tprivate const ushort INTEGER_GREATER = 202;\n\t\tprivate const ushort INTEGER_GREATEREQ = 203;\n\t\tprivate const ushort INTEGER_LESS = 204;\n\t\tprivate const ushort INTEGER_LESSEQ = 205;\n\t\tprivate const ushort STRING_EQUAL = 210;\n\t\tprivate const ushort STRING_UNEQUAL = 211;\n\t\tprivate const ushort STRING_REGEX = 212;\n\t\tprivate const ushort GEOJSON_WITHIN = 220;\n\t\tprivate const ushort GEOJSON_CONTAINS = 221;\n\t\tprivate const ushort LIST_ITERATE_OR = 250;\n\t\tprivate const ushort MAPKEY_ITERATE_OR = 251;\n\t\tprivate const ushort MAPVAL_ITERATE_OR = 252;\n\t\tprivate const ushort LIST_ITERATE_AND = 253;\n\t\tprivate const ushort MAPKEY_ITERATE_AND = 254;\n\t\tprivate const ushort MAPVAL_ITERATE_AND = 255;\n\n\t\tprivate const long NANOS_PER_MILLIS = 1000000L;\n\n\t\t/// <summary>\n\t\t/// Estimate size of predicate expressions.\n\t\t/// For internal use only.\n\t\t/// </summary>\n\t\tpublic static int EstimateSize(PredExp[] predExp)\n\t\t{\n\t\t\tint size = 0;\n\n\t\t\tforeach (PredExp pred in predExp)\n\t\t\t{\n\t\t\t\tsize += pred.EstimateSize();\n\t\t\t}\n\t\t\treturn size;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Write predicate expressions to write protocol.\n\t\t/// For internal use only.\n\t\t/// </summary>\n\t\tpublic static int Write(PredExp[] predExp, byte[] buf, int offset)\n\t\t{\n\t\t\tforeach (PredExp pred in predExp)\n\t\t\t{\n\t\t\t\toffset = pred.Write(buf, offset);\n\t\t\t}\n\t\t\treturn offset;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Estimate size of predicate expression.\n\t\t/// For internal use only.\n\t\t/// </summary>\n\t\tpublic abstract int EstimateSize();\n\n\t\t/// <summary>\n\t\t/// Write predicate expression to write protocol.\n\t\t/// For internal use only.\n\t\t/// </summary>\n\t\tpublic abstract int Write(byte[] buf, int offset);\n\n\t\tprivate class IntegerVal : PredExp\n\t\t{\n\t\t\tinternal readonly long value;\n\t\t\tinternal readonly ushort type;\n\n\t\t\tinternal IntegerVal(long value, ushort type)\n\t\t\t{\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.type = type;\n\t\t\t}\n\n\t\t\tpublic override int EstimateSize()\n\t\t\t{\n\t\t\t\treturn 14;\n\t\t\t}\n\n\t\t\tpublic override int Write(byte[] buf, int offset)\n\t\t\t{\n\t\t\t\t// Write value type\n\t\t\t\tByteUtil.ShortToBytes(type, buf, offset);\n\t\t\t\toffset += 2;\n\n\t\t\t\t// Write length\n\t\t\t\tByteUtil.IntToBytes(8, buf, offset);\n\t\t\t\toffset += 4;\n\n\t\t\t\t// Write value\n\t\t\t\tByteUtil.LongToBytes((ulong)value, buf, offset);\n\t\t\t\toffset += 8;\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t}\n\n\t\tprivate class StringVal : PredExp\n\t\t{\n\t\t\tinternal readonly string value;\n\t\t\tinternal readonly ushort type;\n\n\t\t\tpublic StringVal(string value, ushort type)\n\t\t\t{\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.type = type;\n\t\t\t}\n\n\t\t\tpublic override int EstimateSize()\n\t\t\t{\n\t\t\t\treturn ByteUtil.EstimateSizeUtf8(value) + 6;\n\t\t\t}\n\n\t\t\tpublic override int Write(byte[] buf, int offset)\n\t\t\t{\n\t\t\t\t// Write value type\n\t\t\t\tByteUtil.ShortToBytes(type, buf, offset);\n\t\t\t\toffset += 2;\n\n\t\t\t\t// Write value\n\t\t\t\tint len = ByteUtil.StringToUtf8(value, buf, offset + 4);\n\t\t\t\tByteUtil.IntToBytes((uint)len, buf, offset);\n\t\t\t\toffset += 4 + len;\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t}\n\n\t\tprivate class GeoJSONVal : PredExp\n\t\t{\n\t\t\tprivate readonly string value;\n\t\t\tprivate readonly ushort type;\n\n\t\t\tpublic GeoJSONVal(string value, ushort type)\n\t\t\t{\n\t\t\t\tthis.value = value;\n\t\t\t\tthis.type = type;\n\t\t\t}\n\n\t\t\tpublic override int EstimateSize()\n\t\t\t{\n\t\t\t\t// type + len + flags + ncells + jsonstr\n\t\t\t\treturn 2 + 4 + 1 + 2 + ByteUtil.EstimateSizeUtf8(this.value);\n\t\t\t}\n\n\t\t\tpublic override int Write(byte[] buf, int offset)\n\t\t\t{\n\t\t\t\t// Write value type\n\t\t\t\tByteUtil.ShortToBytes(type, buf, offset);\n\t\t\t\toffset += 2;\n\n\t\t\t\t// Write value\n\t\t\t\tint len = ByteUtil.StringToUtf8(value, buf, offset + 4 + 1 + 2);\n\t\t\t\tByteUtil.IntToBytes((uint)(len + 1 + 2), buf, offset);\n\t\t\t\toffset += 4;\n\n\t\t\t\tbuf[offset] = 0; // flags\n\t\t\t\toffset += 1;\n\n\t\t\t\tByteUtil.ShortToBytes(0, buf, offset); // ncells\n\t\t\t\toffset += 2;\n\n\t\t\t\toffset += len;\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate class AndOr : PredExp\n\t\t{\n\t\t\tinternal readonly ushort op;\n\t\t\tinternal readonly ushort nexp;\n\n\t\t\tinternal AndOr(ushort op, ushort nexp)\n\t\t\t{\n\t\t\t\tthis.op = op;\n\t\t\t\tthis.nexp = nexp;\n\t\t\t}\n\n\t\t\tpublic override int EstimateSize()\n\t\t\t{\n\t\t\t\treturn 8;\n\t\t\t}\n\n\t\t\tpublic override int Write(byte[] buf, int offset)\n\t\t\t{\n\t\t\t\t// Write type\n\t\t\t\tByteUtil.ShortToBytes(op, buf, offset);\n\t\t\t\toffset += 2;\n\n\t\t\t\t// Write length\n\t\t\t\tByteUtil.IntToBytes(2, buf, offset);\n\t\t\t\toffset += 4;\n\n\t\t\t\t// Write predicate count\n\t\t\t\tByteUtil.ShortToBytes(nexp, buf, offset);\n\t\t\t\toffset += 2;\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t}\n\n\t\tprivate class Op : PredExp\n\t\t{\n\t\t\tinternal readonly ushort op;\n\n\t\t\tinternal Op(ushort op)\n\t\t\t{\n\t\t\t\tthis.op = op;\n\t\t\t}\n\n\t\t\tpublic override int EstimateSize()\n\t\t\t{\n\t\t\t\treturn 6;\n\t\t\t}\n\n\t\t\tpublic override int Write(byte[] buf, int offset)\n\t\t\t{\n\t\t\t\t// Write op type\n\t\t\t\tByteUtil.ShortToBytes(op, buf, offset);\n\t\t\t\toffset += 2;\n\n\t\t\t\t// Write zero length\n\t\t\t\tByteUtil.IntToBytes(0, buf, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t}\n\n\t\tprivate class OpInt : PredExp\n\t\t{\n\t\t\tinternal readonly uint flags;\n\t\t\tinternal readonly ushort op;\n\n\t\t\tinternal OpInt(ushort op, uint flags)\n\t\t\t{\n\t\t\t\tthis.op = op;\n\t\t\t\tthis.flags = flags;\n\t\t\t}\n\n\t\t\tpublic override int EstimateSize()\n\t\t\t{\n\t\t\t\treturn 10;\n\t\t\t}\n\n\t\t\tpublic override int Write(byte[] buf, int offset)\n\t\t\t{\n\t\t\t\t// Write op type\n\t\t\t\tByteUtil.ShortToBytes(op, buf, offset);\n\t\t\t\toffset += 2;\n\n\t\t\t\t// Write length\n\t\t\t\tByteUtil.IntToBytes(4, buf, offset);\n\t\t\t\toffset += 4;\n\n\t\t\t\t// Write predicate count\n\t\t\t\tByteUtil.IntToBytes(flags, buf, offset);\n\t\t\t\toffset += 4;\n\t\t\t\treturn offset;\n\t\t\t}\n\t\t}\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "    public static class NativeMethods\n    { \n        //\n        // Messages\n        //\n        public const int WM_GETTABRECT = 0x130A;\n        public const int WS_EX_TRANSPARENT = 0x20;\n        public const int WM_SETFONT = 0x30;\n        public const int WM_FONTCHANGE = 0x1D;\n        public const int WM_PAINT = 0xF;\n        public const int WS_EX_LAYOUTRTL = 0x400000;\n        public const int WS_EX_NOINHERITLAYOUT = 0x100000;\n        public const int TCM_HITTEST = 0x130D;\n        public const int WM_NCLBUTTONDOWN = 0xA1;\n        public const int HT_CAPTION = 0x2;\n        /// <summary> When Mouse Wheel scrolling occurs </summary\n        public const int WM_MOUSEWHEEL = 0x20A;\n        /// <summary> When horizontal scrolling occurs </summary>\n        public const int WM_HSCROLL = 0x114;\n        /// <summary> The left mouse button is down </summary>\n        public const int MK_LBUTTON = 0x0001;\n        /// <summary> Set Cue-text on a Textbox control</summary>\n        public const int EM_SETCUEBANNER = 0x1501; \n        /// Animates the window from left to right. \n        /// This flag can be used with roll or slide animation.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_HOR = 0X1;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Animates the window from right to left. \n        /// This flag can be used with roll or slide animation.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_HOR_NEGATIVE = 0X2;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Animates the window from top to bottom. \n        /// This flag can be used with roll or slide animation.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_VER = 0X4;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Animates the window from bottom to top. \n        /// This flag can be used with roll or slide animation.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_VER_NEGATIVE = 0X8;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Makes the window appear to collapse inward \n        /// if AW_HIDE is used or expand outward if the AW_HIDE is not used.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_CENTER = 0X10;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Hides the window. By default, the window is shown.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_HIDE = 0X10000;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Activates the window.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_ACTIVATE = 0X20000;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Uses slide animation. By default, roll animation is used.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_SLIDE = 0X40000;\n        /// <span class=\"code-SummaryComment\"><summary></span>\n        /// Uses a fade effect. \n        /// This flag can be used only if hwnd is a top-level window.\n        /// <span class=\"code-SummaryComment\"></summary></span>\n        public const int AW_BLEND = 0X80000;\n\n        //\n        // Structures\n        //\n        struct MARGINS\n        {\n            int left;\n            int right;\n            int top;\n            int bottom;\n\n            public MARGINS(int left, int right, int top, int bottom)\n            {\n                this.left = left;\n                this.right = right;\n                this.top = top;\n                this.bottom = bottom;\n            }\n        };\n\n        //\n        // Content Alignment\n        //\n        public static readonly ContentAlignment AnyRightAlign = ContentAlignment.BottomRight | ContentAlignment.MiddleRight | ContentAlignment.TopRight;\n        public static readonly ContentAlignment AnyLeftAlign = ContentAlignment.BottomLeft | ContentAlignment.MiddleLeft | ContentAlignment.TopLeft;\n        public static readonly ContentAlignment AnyTopAlign = ContentAlignment.TopRight | ContentAlignment.TopCenter | ContentAlignment.TopLeft;\n        public static readonly ContentAlignment AnyBottomAlign = ContentAlignment.BottomRight | ContentAlignment.BottomCenter | ContentAlignment.BottomLeft;\n        public static readonly ContentAlignment AnyMiddleAlign = ContentAlignment.MiddleRight | ContentAlignment.MiddleCenter | ContentAlignment.MiddleLeft;\n        public static readonly ContentAlignment AnyCenterAlign = ContentAlignment.BottomCenter | ContentAlignment.MiddleCenter | ContentAlignment.TopCenter;\n        \n        //\n        // User32.dll\n        //\n        [DllImport(\"user32.dll\"), SecurityPermission(SecurityAction.Demand)]\n        public static extern IntPtr SendMessage(IntPtr hWnd, UInt32 msg, IntPtr wParam, IntPtr lParam);         \n        \n        [DllImportAttribute(\"user32.dll\")]\n        public static extern bool ReleaseCapture();\n\n        // P/Invoke declarations\n        [DllImport(\"user32.dll\")]        \n        public static extern IntPtr WindowFromPoint(Point pt);\n\n        //\n        // UXTheme\n        //\n        [DllImport(\"uxtheme.dll\", CharSet = CharSet.Unicode)]\n        public static extern int SetWindowTheme(IntPtr hWnd, IntPtr pszSubAppName, IntPtr pszSubIdList);\n\n        //\n        // DWM Api\n        //\n        [DllImport(\"dwmapi.dll\")]\n        private static extern int DwmExtendFrameIntoClientArea(IntPtr hWnd, ref MARGINS pMarInset);\n        \n        //\n        // WinINet\n        [DllImport(\"wininet.dll\", SetLastError = true)]\n        public static extern int InternetAttemptConnect(uint res);\n        \n        [DllImport(\"wininet.dll\", SetLastError = true)]\n        public static extern bool InternetGetConnectedState(long flags, long reserved);\n     \n\n        //\n        // Misc Functions\n        //\n        public static IntPtr ToIntPtr(object structure)\n        {            \n            IntPtr lparam = IntPtr.Zero;\n            lparam = Marshal.AllocCoTaskMem(Marshal.SizeOf(structure));\n            Marshal.StructureToPtr(structure, lparam, false);\n            return lparam;\n        }\n        public static IntPtr ToIntPtr(string str)\n        {            \n            return Marshal.StringToBSTR(str);\n        }\n\n        public static object FromIntPtr(IntPtr ptr, Type structureType)\n        {            \n            return Marshal.PtrToStructure(ptr, structureType);\n        }\n\n        public static bool ExtendWindowsFrame(Form form, int left = 0, int right = 0, int top = 0, int bottom = 0)\n        {\n            MARGINS mar = new MARGINS(left, right, top, bottom);\n            return (DwmExtendFrameIntoClientArea(form.Handle, ref mar) == 0);\n        }\n\n        public static void MoveWithMouse(IntPtr Handle)\n        {\n            ReleaseCapture();\n            IntPtr lparam = new IntPtr(HT_CAPTION);\n            IntPtr wparam = new IntPtr(0);\n            SendMessage(Handle, WM_NCLBUTTONDOWN, lparam, wparam);\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    \n\n        /// <summary>\n        ///\n        /// </summary>\n        public abstract partial class SceneNode2D : DisposeObject, IHitable2D\n        {\n            public sealed class UpdateEventArgs : EventArgs\n            {\n                public RenderContext2D Context { private set; get; }\n\n                public UpdateEventArgs(RenderContext2D context)\n                {\n                    Context = context;\n                }\n            }\n\n            /// <summary>\n            /// Gets the unique identifier.\n            /// </summary>\n            /// <value>\n            /// The unique identifier.\n            /// </value>\n            public Guid GUID { get; } = Guid.NewGuid();\n\n            /// <summary>\n            /// Gets or sets the parent.\n            /// </summary>\n            /// <value>\n            /// The parent.\n            /// </value>\n            public SceneNode2D Parent { set; get; }\n\n            private Visibility visibility = Visibility.Visible;\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this <see cref=\"SceneNode2D\"/> is visible.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if visible; otherwise, <c>false</c>.\n            /// </value>\n            public Visibility Visibility\n            {\n                set\n                {\n                    if (Set(ref visibility, value))\n                    { InvalidateVisual(); }\n                }\n                get { return visibility; }\n            }\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is hit test visible.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is hit test visible; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsHitTestVisible { set; get; } = true;\n\n            /// <summary>\n            /// Gets or sets the wrapper source used to link the external wrapper with the node.\n            /// </summary>\n            /// <value>\n            /// The hit test source.\n            /// </value>\n            public object WrapperSource { set; get; }\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is attached.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is attached; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsAttached { private set; get; }\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is renderable.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is renderable; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsRenderable { private set; get; } = true;\n\n            private RenderCore2D renderCore;\n\n            /// <summary>\n            /// Gets or sets the render core.\n            /// </summary>\n            /// <value>\n            /// The render core.\n            /// </value>\n            public RenderCore2D RenderCore\n            {\n                private set\n                {\n                    if (renderCore != value)\n                    {\n                        if (renderCore != null)\n                        {\n                            renderCore.InvalidateRender -= RenderCore_OnInvalidateRenderer;\n                        }\n                        renderCore = value;\n                        if (renderCore != null)\n                        {\n                            renderCore.InvalidateRender += RenderCore_OnInvalidateRenderer;\n                        }\n                    }\n                }\n                get\n                {\n                    if (renderCore == null)\n                    {\n                        RenderCore = CreateRenderCore();\n                    }\n                    return renderCore;\n                }\n            }\n\n            /// <summary>\n            /// Gets or sets the render host.\n            /// </summary>\n            /// <value>\n            /// The render host.\n            /// </value>\n            protected IRenderHost RenderHost { private set; get; }\n\n            /// <summary>\n            /// Gets the items.\n            /// </summary>\n            /// <value>\n            /// The items.\n            /// </value>\n            internal ObservableCollection<SceneNode2D> ItemsInternal { set; get; } = Constants.EmptyRenderable2D;\n            /// <summary>\n            /// Gets the items as readonly. Expose for outside for UI access or bindings\n            /// </summary>\n            /// <value>\n            /// The items.\n            /// </value>\n            public ReadOnlyObservableCollection<SceneNode2D> Items { internal set; get; } = Constants.EmptyReadOnlyRenderable2DArray;\n\n            private Matrix3x2 modelMatrix = Matrix3x2.Identity;\n\n            /// <summary>\n            /// Gets or sets the model matrix.\n            /// </summary>\n            /// <value>\n            /// The model matrix.\n            /// </value>\n            public Matrix3x2 ModelMatrix\n            {\n                set\n                {\n                    if (Set(ref modelMatrix, value))\n                    {\n                        RenderCore.LocalTransform = value;\n                        InvalidateVisual();\n                    }\n                }\n                get { return modelMatrix; }\n            }\n\n            private Matrix3x2 layoutTranslate = Matrix3x2.Identity;\n\n            /// <summary>\n            /// Gets or sets the layout translate.\n            /// </summary>\n            /// <value>\n            /// The layout translate.\n            /// </value>\n            public Matrix3x2 LayoutTranslate\n            {\n                set\n                {\n                    if (Set(ref layoutTranslate, value))\n                    {\n                        InvalidateRender();\n                    }\n                }\n                get { return layoutTranslate; }\n            }\n\n            private Matrix3x2 parentMatrix = Matrix3x2.Identity;\n\n            /// <summary>\n            /// Gets or sets the parent matrix.\n            /// </summary>\n            /// <value>\n            /// The parent matrix.\n            /// </value>\n            public Matrix3x2 ParentMatrix\n            {\n                set\n                {\n                    if (Set(ref parentMatrix, value))\n                    {\n                        IsTransformDirty = true;\n                    }\n                }\n                get { return parentMatrix; }\n            }\n\n            private Matrix3x2 totalTransform = Matrix3x2.Identity;\n\n            /// <summary>\n            /// Gets or sets the total model matrix.\n            /// </summary>\n            /// <value>\n            /// The total model matrix.\n            /// </value>\n            public Matrix3x2 TotalModelMatrix\n            {\n                private set\n                {\n                    if (Set(ref totalTransform, value))\n                    {\n                        for (int i = 0; i < ItemsInternal.Count; ++i)\n                        {\n                            ItemsInternal[i].ParentMatrix = totalTransform;\n                        }\n                        TransformChanged(ref value);\n                        OnTransformChanged?.Invoke(this, new Transform2DArgs(ref value));\n                    }\n                }\n                get\n                {\n                    return totalTransform;\n                }\n            }\n\n            /// <summary>\n            /// Gets or sets the transform matrix relative to its parent\n            /// </summary>\n            /// <value>\n            /// The relative matrix.\n            /// </value>\n            private Matrix3x2 RelativeMatrix\n            { set; get; }\n\n            /// <summary>\n            /// Gets or sets the layout bound with transform.\n            /// </summary>\n            /// <value>\n            /// The layout bound with transform.\n            /// </value>\n            public RectangleF LayoutBoundWithTransform\n            {\n                private set; get;\n            }\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is mouse over.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is mouse over; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsMouseOver\n            {\n                set { RenderCore.IsMouseOver = value; }\n                get { return RenderCore.IsMouseOver; }\n            }\n\n            /// <summary>\n            /// Initializes a new instance of the <see cref=\"SceneNode2D\"/> class.\n            /// </summary>\n            public SceneNode2D()\n            {\n                WrapperSource = this;\n            }\n\n            /// <summary>\n            /// Creates the render core.\n            /// </summary>\n            /// <returns></returns>\n            protected virtual RenderCore2D CreateRenderCore() { return new EmptyRenderCore2D(); }\n\n            /// <summary>\n            /// <para>Attaches the element to the specified host. To overide Attach, please override <see cref=\"OnAttach(IRenderHost)\"/> function.</para>\n            /// <para>Attach Flow: Set RenderHost -> Get Effect ->\n            /// <see cref=\"OnAttach(IRenderHost)\"/> -> <see cref=\"OnAttach\"/> -> <see cref=\"InvalidateRender\"/></para>\n            /// </summary>\n            /// <param name=\"host\">The host.</param>\n            public void Attach(IRenderHost host)\n            {\n                if (IsAttached || host == null)\n                {\n                    return;\n                }\n                RenderHost = host;\n                IsAttached = OnAttach(host);\n                if (IsAttached)\n                {\n                    Attached?.Invoke(this, EventArgs.Empty);\n                }\n                InvalidateAll();\n            }\n\n            /// <summary>\n            /// To override Attach routine, please override this.\n            /// </summary>\n            /// <param name=\"host\"></param>\n            /// <returns>Return true if attached</returns>\n            protected virtual bool OnAttach(IRenderHost host)\n            {\n                RenderCore.Attach(host);\n                return true;\n            }\n\n            /// <summary>\n            /// Detaches this instance.\n            /// </summary>\n            public void Detach()\n            {\n                if (IsAttached)\n                {\n                    IsAttached = false;\n                    RenderCore.Detach();\n                    Disposer.RemoveAndDispose(ref bitmapCache);\n                    OnDetach();\n                    Detached?.Invoke(this, EventArgs.Empty);\n                }\n            }\n\n            /// <summary>\n            /// Called when [detach].\n            /// </summary>\n            protected virtual void OnDetach()\n            {\n                RenderHost = null;\n            }\n\n            /// <summary>\n            /// Updates the specified context.\n            /// </summary>\n            /// <param name=\"context\">The context.</param>\n            public virtual void Update(RenderContext2D context)\n            {\n                UpdateRequested?.Invoke(this, new UpdateEventArgs(context));\n                IsRenderable = CanRender(context);\n            }\n\n            #region Handling Transforms\n\n            /// <summary>\n            /// Transforms the changed.\n            /// </summary>\n            /// <param name=\"totalTransform\">The total transform.</param>\n            protected virtual void TransformChanged(ref Matrix3x2 totalTransform)\n            {\n            }\n\n            /// <summary>\n            /// Occurs when [on transform changed].\n            /// </summary>\n            public event EventHandler<Transform2DArgs> OnTransformChanged;\n\n            #endregion Handling Transforms\n\n            #region Events;\n\n            /// <summary>\n            /// Occurs when [on attached].\n            /// </summary>\n            public event EventHandler Attached;\n\n            /// <summary>\n            /// Occurs when [on detached].\n            /// </summary>\n            public event EventHandler Detached;\n\n            /// <summary>\n            /// Occurs when [on update].\n            /// </summary>\n            public event EventHandler<UpdateEventArgs> UpdateRequested;\n\n            #endregion Events;\n\n            #region Rendering\n\n            /// <summary>\n            /// <para>Determine if this can be rendered.</para>\n            /// </summary>\n            /// <param name=\"context\"></param>\n            /// <returns></returns>\n            protected virtual bool CanRender(RenderContext2D context)\n            {\n                return Visibility == Visibility.Visible && IsAttached;\n            }\n\n            /// <summary>\n            /// <para>Renders the element in the specified context. To override Render, please override <see cref=\"OnRender\"/></para>\n            /// <para>Uses <see cref=\"CanRender\"/>  to call OnRender or not. </para>\n            /// </summary>\n            /// <param name=\"context\">The context.</param>\n            public void Render(RenderContext2D context)\n            {\n                if (!IsRenderable)\n                { return; }\n                if (IsTransformDirty)\n                {\n                    RelativeMatrix = Matrix3x2.Translation(-RenderSize * RenderTransformOrigin)\n                        * ModelMatrix * Matrix3x2.Translation(RenderSize * RenderTransformOrigin)\n                        * LayoutTranslate;\n                    TotalModelMatrix = RelativeMatrix * ParentMatrix;\n                    IsTransformDirty = false;\n                    InvalidateVisual();\n                }\n\n                LayoutBoundWithTransform = LayoutBound.Translate(TotalModelMatrix.TranslationVector);\n\n    #if DISABLEBITMAPCACHE\n                IsBitmapCacheValid = false;\n    #else\n                EnsureBitmapCache(context, new Size2((int)Math.Ceiling(LayoutClipBound.Width), (int)Math.Ceiling(LayoutClipBound.Height)), context.DeviceContext.MaximumBitmapSize);\n    #endif\n                if (EnableBitmapCache && IsBitmapCacheValid)\n                {\n                    if (IsVisualDirty)\n                    {\n    #if DEBUGDRAWING\n                        Debug.WriteLine(\"Redraw bitmap cache\");\n    #endif\n                        context.PushRenderTarget(bitmapCache, true);\n                        context.DeviceContext.Transform = Matrix3x2.Identity;\n                        context.PushRelativeTransform(Matrix3x2.Identity);\n                        RenderCore.Transform = context.RelativeTransform;\n                        OnRender(context);\n                        context.PopRelativeTransform();\n                        context.PopRenderTarget();\n                        IsVisualDirty = false;\n                    }\n                    if (context.HasTarget)\n                    {\n                        context.DeviceContext.Transform = context.RelativeTransform * RelativeMatrix;\n                        context.DeviceContext.DrawImage(bitmapCache, new Vector2(0, 0), LayoutClipBound,\n                            InterpolationMode.Linear, global::SharpDX.Direct2D1.CompositeMode.SourceOver);\n                    }\n                }\n                else if (context.HasTarget)\n                {\n                    context.PushRelativeTransform(context.RelativeTransform * RelativeMatrix);\n                    RenderCore.Transform = context.RelativeTransform;\n                    OnRender(context);\n                    context.PopRelativeTransform();\n                    IsVisualDirty = false;\n                }\n            }\n\n            /// <summary>\n            /// Renders the bitmap cache to a render target only.\n            /// </summary>\n            /// <param name=\"context\">The context.</param>\n            public void RenderBitmapCache(RenderContext2D context)\n            {\n                if (IsRenderable && EnableBitmapCache && IsBitmapCacheValid && !IsVisualDirty && context.HasTarget)\n                {\n                    context.DeviceContext.Transform = RelativeMatrix;\n                    context.DeviceContext.DrawImage(bitmapCache, new Vector2(0, 0), new RectangleF(0, 0, RenderSize.X, RenderSize.Y),\n                        InterpolationMode.Linear, global::SharpDX.Direct2D1.CompositeMode.SourceOver);\n                }\n                else\n                {\n                    Render(context);\n                }\n            }\n\n            /// <summary>\n            /// Called when [render].\n            /// </summary>\n            /// <param name=\"context\">The context.</param>\n            protected virtual void OnRender(RenderContext2D context)\n            {\n                RenderCore.Render(context);\n                for (int i = 0; i < this.ItemsInternal.Count; ++i)\n                {\n                    ItemsInternal[i].Render(context);\n                }\n            }\n\n            #endregion Rendering\n\n            /// <summary>\n            /// Determines whether this instance [can hit test].\n            /// </summary>\n            /// <returns>\n            ///   <c>true</c> if this instance [can hit test]; otherwise, <c>false</c>.\n            /// </returns>\n            protected virtual bool CanHitTest()\n            {\n                return IsAttached && IsHitTestVisible;\n            }\n\n            /// <summary>\n            /// Called when [hit test].\n            /// </summary>\n            /// <param name=\"mousePoint\">The mouse point.</param>\n            /// <param name=\"hitResult\">The hit result.</param>\n            /// <returns></returns>\n            protected abstract bool OnHitTest(ref Vector2 mousePoint, out HitTest2DResult hitResult);\n\n            /// <summary>\n            /// Hits the test.\n            /// </summary>\n            /// <param name=\"mousePoint\">The mouse point.</param>\n            /// <param name=\"hitResult\">The hit result.</param>\n            /// <returns></returns>\n            public bool HitTest(Vector2 mousePoint, out HitTest2DResult hitResult)\n            {\n                if (CanHitTest())\n                {\n                    return OnHitTest(ref mousePoint, out hitResult);\n                }\n                else\n                {\n                    hitResult = null;\n                    return false;\n                }\n            }\n\n            /// <summary>\n            /// Use InvalidateVisual if render update required.\n            /// </summary>\n            /// <param name=\"sender\">The source of the event.</param>\n            /// <param name=\"e\">The <see cref=\"EventArgs\"/> instance containing the event data.</param>\n            private void RenderCore_OnInvalidateRenderer(object sender, EventArgs e)\n            {\n                InvalidateVisual();\n            }\n\n            /// <summary>\n            /// Invalidates the render.\n            /// </summary>\n            public void InvalidateRender()\n            {\n                RenderHost?.InvalidateRender();\n            }\n\n            protected override void OnDispose(bool disposeManagedResources)\n            {\n                renderCore?.Dispose();\n                renderCore = null;\n                base.OnDispose(disposeManagedResources);\n            }\n\n            /// <summary>\n            ///\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"backingField\"></param>\n            /// <param name=\"value\"></param>\n            /// <returns></returns>\n            protected bool SetAffectsRender<T>(ref T backingField, T value)\n            {\n                if (EqualityComparer<T>.Default.Equals(backingField, value))\n                {\n                    return false;\n                }\n\n                backingField = value;\n                InvalidateRender();\n                return true;\n            }\n\n            /// <summary>\n            ///\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"backingField\"></param>\n            /// <param name=\"value\"></param>\n            /// <returns></returns>\n            protected bool SetAffectsMeasure<T>(ref T backingField, T value)\n            {\n                if (EqualityComparer<T>.Default.Equals(backingField, value))\n                {\n                    return false;\n                }\n\n                backingField = value;\n                InvalidateMeasure();\n                return true;\n            }\n        }\n\n        public partial class SceneNode2D\n        {\n    #pragma warning disable\n\n            /// <summary>\n            /// The minimum bitmap size by Bytes. Default 2048 * B8G8R8A8 format = 64kb.\n            /// <see href=\"https://msdn.microsoft.com/en-us/library/windows/desktop/dd372260%28v=vs.85%29.aspx?f=255&MSPPError=-2147217396\">Here</see>\n            /// </summary>\n            private const int MinimumBitmapSize = 2048;\n\n    #pragma warning restore\n\n            /// <summary>\n            /// Gets or sets a value indicating whether [enable bitmap cache].\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if [enable bitmap cache]; otherwise, <c>false</c>.\n            /// </value>\n            public bool EnableBitmapCache { set; get; } = true;\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is bitmap cache valid.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is bitmap cache valid; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsBitmapCacheValid { set; get; } = false;\n\n            private BitmapProxy bitmapCache;\n\n            /// <summary>\n            /// Ensures the bitmap cache.\n            /// </summary>\n            /// <param name=\"context\">The context.</param>\n            /// <param name=\"size\">The size.</param>\n            /// <param name=\"maxSize\">The maximum size.</param>\n            private void EnsureBitmapCache(RenderContext2D context, Size2 size, int maxSize)\n            {\n                IsBitmapCacheValid = false;\n                if (size.Width <= 0 || size.Height <= 0 || !EnableBitmapCache || size.Width * size.Height < MinimumBitmapSize)\n                {\n                    Disposer.RemoveAndDispose(ref bitmapCache);\n                }\n                else if (size.Width > maxSize || size.Height > maxSize)\n                {\n                    return;\n                }\n                else if (bitmapCache == null || size.Width > bitmapCache.Size.Width || size.Height > bitmapCache.Size.Height)\n                {\n    #if DEBUGCACHECREATE\n                    Debug.WriteLine(\"Create new bitmap cache.\");\n    #endif\n                    Disposer.RemoveAndDispose(ref bitmapCache);\n                    bitmapCache = BitmapProxy.Create(\"Cache\", context.DeviceContext, size, Format.B8G8R8A8_UNorm);\n                    IsBitmapCacheValid = true;\n                    IsVisualDirty = true;\n                }\n                else\n                {\n                    IsBitmapCacheValid = true;\n                }\n            }\n        }\n        /// <summary>\n        /// \n        /// </summary>\n        public partial class SceneNode2D\n        {\n            #region layout management\n\n            #region Properties\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is measure dirty.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is measure dirty; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsMeasureDirty { protected set; get; } = true;\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is arrange dirty.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is arrange dirty; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsArrangeDirty { protected set; get; } = true;\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is transform dirty.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is transform dirty; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsTransformDirty { private set; get; } = true;\n\n            /// <summary>\n            /// Gets or sets a value indicating whether this instance is visual dirty.\n            /// </summary>\n            /// <value>\n            ///   <c>true</c> if this instance is visual dirty; otherwise, <c>false</c>.\n            /// </value>\n            public bool IsVisualDirty { set; get; } = true;\n\n            private Thickness margin = new Thickness();\n\n            public Thickness Margin\n            {\n                set\n                {\n                    if (Set(ref margin, value))\n                    {\n                        MarginWidthHeight = new Vector2((value.Left + value.Right), (value.Top + value.Bottom));\n                        InvalidateMeasure();\n                    }\n                }\n                get\n                {\n                    return margin;\n                }\n            }\n\n            protected Vector2 MarginWidthHeight { private set; get; }\n\n            private float width = float.PositiveInfinity;\n\n            public float Width\n            {\n                set\n                {\n                    if (Set(ref width, value))\n                    {\n                        InvalidateMeasure();\n                    }\n                }\n                get\n                {\n                    return width;\n                }\n            }\n\n            private float height = float.PositiveInfinity;\n\n            public float Height\n            {\n                set\n                {\n                    if (Set(ref height, value))\n                    {\n                        InvalidateMeasure();\n                    }\n                }\n                get\n                {\n                    return height;\n                }\n            }\n\n            private float minimumWidth = 0;\n\n            public float MinimumWidth\n            {\n                set\n                {\n                    if (Set(ref minimumWidth, value) && value > width)\n                    {\n                        InvalidateMeasure();\n                    }\n                }\n                get\n                {\n                    return minimumWidth;\n                }\n            }\n\n            private float minimumHeight = 0;\n\n            public float MinimumHeight\n            {\n                set\n                {\n                    if (Set(ref minimumHeight, value) && value > height)\n                    {\n                        InvalidateMeasure();\n                    }\n                }\n                get\n                {\n                    return minimumHeight;\n                }\n            }\n\n            private float maximumWidth = float.PositiveInfinity;\n\n            public float MaximumWidth\n            {\n                set\n                {\n                    if (Set(ref maximumWidth, value) && value < width)\n                    {\n                        InvalidateMeasure();\n                    }\n                }\n                get\n                {\n                    return maximumWidth;\n                }\n            }\n\n            private float maximumHeight = float.PositiveInfinity;\n\n            public float MaximumHeight\n            {\n                set\n                {\n                    if (Set(ref maximumHeight, value) && value < height)\n                    {\n                        InvalidateMeasure();\n                    }\n                }\n                get\n                {\n                    return maximumHeight;\n                }\n            }\n\n            private HorizontalAlignment horizontalAlignment = HorizontalAlignment.Stretch;\n\n            public HorizontalAlignment HorizontalAlignment\n            {\n                set\n                {\n                    if (Set(ref horizontalAlignment, value))\n                    {\n                        InvalidateArrange();\n                    }\n                }\n                get\n                {\n                    return horizontalAlignment;\n                }\n            }\n\n            private VerticalAlignment verticalAlignment = VerticalAlignment.Stretch;\n\n            public VerticalAlignment VerticalAlignment\n            {\n                set\n                {\n                    if (Set(ref verticalAlignment, value))\n                    {\n                        InvalidateArrange();\n                    }\n                }\n                get\n                {\n                    return verticalAlignment;\n                }\n            }\n\n            private Vector2 layoutOffset = Vector2.Zero;\n\n            public Vector2 LayoutOffsets\n            {\n                private set\n                {\n                    if (Set(ref layoutOffset, value))\n                    {\n                        InvalidateTransform();\n                    }\n                }\n                get { return layoutOffset; }\n            }\n\n            private Vector2 renderSize = Vector2.Zero;\n\n            /// <summary>\n            /// Gets the render size. Same as the <see cref=\"LayoutBound\"/> size\n            /// </summary>\n            /// <value>\n            /// The size of the render.\n            /// </value>\n            public Vector2 RenderSize\n            {\n                get { return renderSize; }\n                private set\n                {\n                    if (Set(ref renderSize, value))\n                    {\n                        InvalidateTransform();\n                    }\n                }\n            }\n\n            private Vector2 renderTransformOrigin = new Vector2(0.5f, 0.5f);\n\n            public Vector2 RenderTransformOrigin\n            {\n                set\n                {\n                    if (Set(ref renderTransformOrigin, value))\n                    {\n                        InvalidateRender();\n                    }\n                }\n                get { return renderTransformOrigin; }\n            }\n\n            /// <summary>\n            /// Gets the size of the desired size after measure.\n            /// </summary>\n            /// <value>\n            /// The size of the desired.\n            /// </value>\n            public Vector2 DesiredSize { get; private set; }\n\n            /// <summary>\n            /// Gets the size of the unclipped desired size after measure.\n            /// </summary>\n            /// <value>\n            /// The size of the unclipped desired.\n            /// </value>\n            public Vector2 UnclippedDesiredSize { get; private set; } = new Vector2(-1, -1);\n\n            private Vector2 Size { get { return new Vector2(width, height); } }\n\n            public bool ClipEnabled { private set; get; } = false;\n\n            public bool ClipToBound { set; get; } = false;\n\n            /// <summary>\n            /// Gets or sets the layout clip bound. This bound includes the margin.\n            /// </summary>\n            /// <value>\n            /// The layout clip bound.\n            /// </value>\n            public RectangleF LayoutClipBound\n            {\n                private set\n                {\n                    RenderCore.LayoutClippingBound = value;\n                }\n                get { return RenderCore.LayoutClippingBound; }\n            }\n\n            /// <summary>\n            /// Gets the size of the actual layout bound without margin.\n            /// </summary>\n            public RectangleF LayoutBound\n            {\n                private set\n                {\n                    RenderCore.LayoutBound = value;\n                }\n                get { return RenderCore.LayoutBound; }\n            }\n\n            private Size2F? previousMeasureSize;\n            private RectangleF? previousArrange;\n\n            #endregion Properties\n\n            public void InvalidateMeasure()\n            {\n                IsArrangeDirty = true;\n                IsMeasureDirty = true;\n                TraverseUp(this, (p) =>\n                {\n                    if (p.IsArrangeDirty && p.IsMeasureDirty)\n                    {\n                        return false;\n                    }\n                    p.IsArrangeDirty = true;\n                    p.IsMeasureDirty = true;\n                    return true;\n                });\n                if (IsAttached)\n                {\n                    InvalidateRender();\n                }\n            }\n\n            public void InvalidateArrange()\n            {\n                IsArrangeDirty = true;\n                TraverseUp(this, (p) =>\n                {\n                    if (p.IsArrangeDirty)\n                    {\n                        return false;\n                    }\n                    p.IsArrangeDirty = true;\n                    return true;\n                });\n                if (IsAttached)\n                {\n                    InvalidateRender();\n                }\n            }\n\n            public void InvalidateVisual()\n            {\n                IsVisualDirty = true;\n                TraverseUp(this, (p) =>\n                {\n                    if (p.IsVisualDirty)\n                    {\n                        return false;\n                    }\n                    p.IsVisualDirty = true;\n                    return true;\n                });\n                if (IsAttached)\n                {\n                    InvalidateRender();\n                }\n            }\n\n            public void InvalidateTransform()\n            {\n                IsTransformDirty = true;\n                TraverseUp(this, (e) =>\n                {\n                    if (e.IsTransformDirty)\n                    { return false; }\n                    e.IsTransformDirty = true;\n                    return true;\n                });\n                if (IsAttached)\n                {\n                    InvalidateRender();\n                }\n            }\n\n            public void InvalidateAll()\n            {\n                IsTransformDirty = true;\n                IsMeasureDirty = true;\n                IsArrangeDirty = true;\n                IsVisualDirty = true;\n                TraverseUp(this, (p) =>\n                {\n                    if (p.IsTransformDirty && p.IsMeasureDirty && p.IsArrangeDirty && p.IsVisualDirty)\n                    {\n                        return false;\n                    }\n                    p.IsTransformDirty = true;\n                    p.IsMeasureDirty = true;\n                    p.IsArrangeDirty = true;\n                    p.IsVisualDirty = true;\n                    return true;\n                });\n                if (IsAttached)\n                {\n                    InvalidateRender();\n                }\n            }\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            protected static void TraverseUp(SceneNode2D core, Func<SceneNode2D, bool> action)\n            {\n                var ancestor = core.Parent as SceneNode2D;\n                while (ancestor != null)\n                {\n                    if (!action(ancestor))\n                    { break; }\n                    ancestor = ancestor.Parent as SceneNode2D;\n                }\n            }\n\n            public void Measure(Size2F size)\n            {\n                if (!IsAttached || Visibility == Visibility.Collapsed || (!IsMeasureDirty && previousMeasureSize == size))\n                {\n                    return;\n                }\n                previousMeasureSize = size;\n                var availableSize = size.ToVector2();\n                var availableSizeWithoutMargin = availableSize - MarginWidthHeight;\n                Vector2 maxSize = Vector2.Zero, minSize = Vector2.Zero;\n                CalculateMinMax(ref minSize, ref maxSize);\n\n                availableSizeWithoutMargin.X = Math.Max(minSize.X, Math.Min(availableSizeWithoutMargin.X, maxSize.X));\n                availableSizeWithoutMargin.Y = Math.Max(minSize.Y, Math.Min(availableSizeWithoutMargin.Y, maxSize.Y));\n\n                var desiredSize = MeasureOverride(availableSizeWithoutMargin.ToSize2F()).ToVector2();\n\n                var unclippedDesiredSize = desiredSize;\n\n                bool clipped = false;\n                if (desiredSize.X > maxSize.X)\n                {\n                    desiredSize.X = maxSize.X;\n                    clipped = true;\n                }\n\n                if (desiredSize.Y > maxSize.Y)\n                {\n                    desiredSize.Y = maxSize.Y;\n                    clipped = true;\n                }\n\n                var clippedDesiredSize = desiredSize + MarginWidthHeight;\n\n                if (clippedDesiredSize.X > availableSize.X)\n                {\n                    clippedDesiredSize.X = availableSize.X;\n                    clipped = true;\n                }\n\n                if (clippedDesiredSize.Y > availableSize.Y)\n                {\n                    clippedDesiredSize.Y = availableSize.Y;\n                    clipped = true;\n                }\n\n                if (clipped || clippedDesiredSize.X < 0 || clippedDesiredSize.Y < 0)\n                {\n                    UnclippedDesiredSize = unclippedDesiredSize;\n                }\n                else\n                {\n                    UnclippedDesiredSize = new Vector2(-1, -1);\n                }\n                if (DesiredSize != clippedDesiredSize)\n                {\n                    DesiredSize = clippedDesiredSize;\n                    for (int i = 0; i < ItemsInternal.Count; ++i)\n                    {\n                        ItemsInternal[i].InvalidateMeasure();\n                    }\n                }\n                else\n                {\n                    IsMeasureDirty = false;\n                }\n            }\n\n            public void Arrange(RectangleF rect)\n            {\n                if (!IsAttached || Visibility == Visibility.Collapsed)\n                {\n                    return;\n                }\n                if (IsMeasureDirty)\n                {\n                    Measure(previousMeasureSize ?? rect.Size);\n                }\n                bool ancestorDirty = false;\n                TraverseUp(this, (parent) =>\n                {\n                    if (parent.IsArrangeDirty)\n                    {\n                        ancestorDirty = true;\n                        return false;\n                    }\n                    else { return true; }\n                });\n\n                var rectWidthHeight = new Vector2(rect.Width, rect.Height);\n\n                if ((!IsArrangeDirty && !ancestorDirty && previousArrange == rect) || rectWidthHeight.IsZero)\n                    return;\n                previousArrange = rect;\n                var arrangeSize = rectWidthHeight;\n\n                ClipEnabled = false;\n                var desiredSize = DesiredSize;\n\n                if (float.IsNaN(DesiredSize.X) || float.IsNaN(DesiredSize.Y))\n                {\n                    if (UnclippedDesiredSize.X == -1 || UnclippedDesiredSize.Y == -1)\n                    {\n                        desiredSize = arrangeSize - MarginWidthHeight;\n                    }\n                    else\n                    {\n                        desiredSize = UnclippedDesiredSize - MarginWidthHeight;\n                    }\n                }\n\n                if (arrangeSize.X < desiredSize.X)\n                {\n                    ClipEnabled = true;\n                    arrangeSize.X = desiredSize.X;\n                }\n\n                if (arrangeSize.Y < desiredSize.Y)\n                {\n                    ClipEnabled = true;\n                    arrangeSize.Y = desiredSize.Y;\n                }\n\n                if (HorizontalAlignment != HorizontalAlignment.Stretch)\n                {\n                    arrangeSize.X = desiredSize.X;\n                }\n\n                if (VerticalAlignment != VerticalAlignment.Stretch)\n                {\n                    arrangeSize.Y = desiredSize.Y;\n                }\n\n                Vector2 minSize = Vector2.Zero, maxSize = Vector2.Zero;\n\n                CalculateMinMax(ref minSize, ref maxSize);\n\n                float calcedMaxWidth = Math.Max(desiredSize.X, maxSize.X);\n                if (calcedMaxWidth < arrangeSize.X)\n                {\n                    ClipEnabled = true;\n                    arrangeSize.X = calcedMaxWidth;\n                }\n\n                float calcedMaxHeight = Math.Max(desiredSize.Y, maxSize.Y);\n                if (calcedMaxHeight < arrangeSize.Y)\n                {\n                    ClipEnabled = true;\n                    arrangeSize.Y = calcedMaxHeight;\n                }\n\n                var oldRenderSize = RenderSize;\n                var arrangeResultSize = ArrangeOverride(new RectangleF(Margin.Left, Margin.Top, arrangeSize.X - MarginWidthHeight.X, arrangeSize.Y - MarginWidthHeight.Y)).ToVector2();\n\n                bool arrangeSizeChanged = arrangeResultSize != oldRenderSize;\n                if (arrangeSizeChanged)\n                {\n                    InvalidateAll();\n                }\n\n                RenderSize = arrangeResultSize;\n\n                var clippedArrangeResultSize = new Vector2(Math.Min(arrangeResultSize.X, maxSize.X), Math.Min(arrangeResultSize.Y, maxSize.Y));\n                if (!ClipEnabled)\n                {\n                    ClipEnabled = clippedArrangeResultSize.X < arrangeResultSize.X || clippedArrangeResultSize.Y < arrangeResultSize.Y;\n                }\n\n                var clientSize = new Vector2(Math.Max(0, rectWidthHeight.X - MarginWidthHeight.X), Math.Max(0, rectWidthHeight.Y - MarginWidthHeight.Y));\n\n                if (!ClipEnabled)\n                {\n                    ClipEnabled = clientSize.X < clippedArrangeResultSize.X || clientSize.Y < clippedArrangeResultSize.Y;\n                }\n\n                var layoutOffset = Vector2.Zero;\n\n                var tempHorizontalAlign = HorizontalAlignment;\n                var tempVerticalAlign = VerticalAlignment;\n\n                if (tempHorizontalAlign == HorizontalAlignment.Stretch && clippedArrangeResultSize.X >= clientSize.X)\n                {\n                    tempHorizontalAlign = HorizontalAlignment.Left;\n                }\n\n                if (tempVerticalAlign == VerticalAlignment.Stretch && clippedArrangeResultSize.Y >= clientSize.Y)\n                {\n                    tempVerticalAlign = VerticalAlignment.Top;\n                }\n\n                if ((tempHorizontalAlign == HorizontalAlignment.Center || tempHorizontalAlign == HorizontalAlignment.Stretch) && clientSize.X >= clippedArrangeResultSize.X)\n                {\n                    layoutOffset.X = (clientSize.X - clippedArrangeResultSize.X) / 2.0f;\n                }\n                else if (tempHorizontalAlign == HorizontalAlignment.Right && clientSize.X >= clippedArrangeResultSize.X)\n                {\n                    layoutOffset.X = clientSize.X - clippedArrangeResultSize.X;\n                }\n                else\n                {\n                    layoutOffset.X = 0;\n                }\n\n                if ((tempVerticalAlign == VerticalAlignment.Center || tempVerticalAlign == VerticalAlignment.Stretch) && clientSize.Y >= clippedArrangeResultSize.Y)\n                {\n                    layoutOffset.Y = (clientSize.Y - clippedArrangeResultSize.Y) / 2.0f;\n                }\n                else if (tempVerticalAlign == VerticalAlignment.Bottom && clientSize.Y >= clippedArrangeResultSize.Y)\n                {\n                    layoutOffset.Y = clientSize.Y - clippedArrangeResultSize.Y;\n                }\n                else\n                {\n                    layoutOffset.Y = 0;\n                }\n\n                layoutOffset += new Vector2(rect.Left, rect.Top);\n\n                if (ClipEnabled || ClipToBound)\n                {\n                    LayoutClipBound = new RectangleF(0, 0, clientSize.X, clientSize.Y);\n                }\n\n                LayoutOffsets = layoutOffset;\n                UpdateLayoutInternal();\n                IsArrangeDirty = false;\n            }\n\n            private void CalculateMinMax(ref Vector2 minSize, ref Vector2 maxSize)\n            {\n                maxSize.Y = MaximumHeight;\n                minSize.Y = MinimumHeight;\n\n                var dimensionLength = Height;\n\n                float height = dimensionLength;\n\n                maxSize.Y = Math.Max(Math.Min(height, maxSize.Y), minSize.Y);\n\n                height = (float.IsInfinity(dimensionLength) ? 0 : dimensionLength);\n\n                minSize.Y = Math.Max(Math.Min(maxSize.Y, height), minSize.Y);\n\n                maxSize.X = MaximumWidth;\n                minSize.X = MinimumWidth;\n\n                dimensionLength = Width;\n\n                float width = dimensionLength;\n\n                maxSize.X = Math.Max(Math.Min(width, maxSize.X), minSize.X);\n\n                width = (float.IsInfinity(dimensionLength) ? 0 : dimensionLength);\n\n                minSize.X = Math.Max(Math.Min(maxSize.X, width), minSize.X);\n            }\n\n            private void UpdateLayoutInternal()\n            {\n                LayoutBound = new RectangleF((float)Margin.Left, (float)Margin.Top, RenderSize.X, RenderSize.Y);\n                LayoutClipBound = new RectangleF(0, 0, RenderSize.X + MarginWidthHeight.X, RenderSize.Y + MarginWidthHeight.Y);\n                LayoutTranslate = Matrix3x2.Translation((float)Math.Round(LayoutOffsets.X), (float)Math.Round(LayoutOffsets.Y));\n            }\n\n            protected virtual RectangleF ArrangeOverride(RectangleF finalSize)\n            {\n                for (int i = 0; i < ItemsInternal.Count; ++i)\n                {\n                    ItemsInternal[i].Arrange(finalSize);\n                }\n                return finalSize;\n            }\n\n            protected virtual Size2F MeasureOverride(Size2F availableSize)\n            {\n                for (int i = 0; i < ItemsInternal.Count; ++i)\n                {\n                    ItemsInternal[i].Measure(availableSize);\n                }\n                return availableSize;\n            }\n\n            #endregion layout management\n        }\n        public partial class SceneNode2D\n        {\n            public static implicit operator Element2D(SceneNode2D s)\n            {\n                return s.WrapperSource as Element2D;\n            }\n        }\n", "label": "MultifacetedAbstraction"}
{"text": "    public class ViewUserControl<TModel> : System.Web.Mvc.ViewUserControl<TModel>,IOrchardViewPage {\n        private ScriptRegister _scriptRegister;\n        private ResourceRegister _stylesheetRegister;\n        \n        private object _display;\n        private Localizer _localizer = NullLocalizer.Instance;\n        private object _layout;\n        private WorkContext _workContext;\n\n        public Localizer T { get { return _localizer; } }\n        public dynamic Display { get { return _display; } }\n        public dynamic New { get { return ShapeFactory; } }\n        public dynamic Layout { get { return _layout; } }\n        public WorkContext WorkContext { get { return _workContext; } }\n\n        private IDisplayHelperFactory _displayHelperFactory;\n        public IDisplayHelperFactory DisplayHelperFactory {\n            get {\n                return _displayHelperFactory ?? (_displayHelperFactory = _workContext.Resolve<IDisplayHelperFactory>());\n            }\n        }\n\n        private IShapeFactory _shapeFactory;\n        public IShapeFactory ShapeFactory {\n            get {\n                return _shapeFactory ?? (_shapeFactory = _workContext.Resolve<IShapeFactory>());\n            }\n        }\n\n        private IAuthorizer _authorizer;\n        public IAuthorizer Authorizer {\n            get {\n                return _authorizer ?? (_authorizer = _workContext.Resolve<IAuthorizer>());\n            }\n        }\n\n        public ScriptRegister Script {\n            get {\n                return _scriptRegister ??\n                    (_scriptRegister = new ViewPage.ViewPageScriptRegister(Writer, Html.ViewDataContainer, Html.GetWorkContext().Resolve<IResourceManager>()));\n            }\n        }\n\n        public ResourceRegister Style {\n            get {\n                return _stylesheetRegister ??\n                    (_stylesheetRegister = new ResourceRegister(Html.ViewDataContainer, Html.GetWorkContext().Resolve<IResourceManager>(), \"stylesheet\"));\n            }\n        }\n\n        public virtual void RegisterLink(LinkEntry link) {\n            Html.GetWorkContext().Resolve<IResourceManager>().RegisterLink(link);\n        }\n\n        public void SetMeta(string name = null, string content = null, string httpEquiv = null, string charset = null) {\n            var metaEntry = new MetaEntry();\n\n            if (!String.IsNullOrEmpty(name)) {\n                metaEntry.Name = name;\n            }\n\n            if (!String.IsNullOrEmpty(content)) {\n                metaEntry.Content = content;\n            }\n\n            if (!String.IsNullOrEmpty(httpEquiv)) {\n                metaEntry.HttpEquiv = httpEquiv;\n            }\n\n            if (!String.IsNullOrEmpty(charset)) {\n                metaEntry.Charset = charset;\n            }\n\n            SetMeta(metaEntry);\n        }\n\n        public virtual void SetMeta(MetaEntry meta) {\n            Html.GetWorkContext().Resolve<IResourceManager>().SetMeta(meta);\n        }\n\n        public void AppendMeta(string name, string content, string contentSeparator) {\n            AppendMeta(new MetaEntry { Name = name, Content = content }, contentSeparator);\n        }\n\n        public virtual void AppendMeta(MetaEntry meta, string contentSeparator) {\n            Html.GetWorkContext().Resolve<IResourceManager>().AppendMeta(meta, contentSeparator);\n        }\n        \n        public override void RenderView(ViewContext viewContext) {\n            _workContext = viewContext.GetWorkContext();\n\n            _localizer = LocalizationUtilities.Resolve(viewContext, AppRelativeVirtualPath);\n            _display = DisplayHelperFactory.CreateHelper(viewContext, this);\n            _layout = _workContext.Layout;\n\n            base.RenderView(viewContext);\n        }\n\n        public MvcHtmlString H(string value) {\n            return MvcHtmlString.Create(Html.Encode(value));\n        }\n\n        public bool AuthorizedFor(Permission permission) {\n            return Authorizer.Authorize(permission);\n        }\n\n        public bool HasText(object thing) {\n            return !string.IsNullOrWhiteSpace(Convert.ToString(thing));\n        }\n\n        public OrchardTagBuilder Tag(dynamic shape, string tagName) {\n            return Html.GetWorkContext().Resolve<ITagBuilderFactory>().Create(shape, tagName);\n        }\n\n        public IHtmlString DisplayChildren(dynamic shape) {\n            var writer = new HtmlStringWriter();\n            foreach (var item in shape) {\n                writer.Write(Display(item));\n            }\n            return writer;\n        }\n\n        public IDisposable Capture(Action<IHtmlString> callback) {\n            return new ViewPage.CaptureScope(Writer, callback);\n        }\n\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// A collection of MiscSettingAddElement instances.\n    /// </summary>\n    [global::System.Configuration.ConfigurationCollectionAttribute(typeof(global::EApp.Core.Configuration.MiscSettingAddElement), CollectionType=global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate, AddItemName=global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName)]\n    public partial class MiscSettingElementCollection : global::System.Configuration.ConfigurationElementCollection\n    {\n        \n        #region Constants\n        /// <summary>\n        /// The XML name of the individual <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> instances in this collection.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string MiscSettingAddElementPropertyName = \"add\";\n        #endregion\n        \n        #region Overrides\n        /// <summary>\n        /// Gets the type of the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"global::System.Configuration.ConfigurationElementCollectionType\"/> of this collection.</returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override global::System.Configuration.ConfigurationElementCollectionType CollectionType\n        {\n            get\n            {\n                return global::System.Configuration.ConfigurationElementCollectionType.BasicMapAlternate;\n            }\n        }\n        \n        /// <summary>\n        /// Gets the name used to identify this collection of elements\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override string ElementName\n        {\n            get\n            {\n                return global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName;\n            }\n        }\n        \n        /// <summary>\n        /// Indicates whether the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/> exists in the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"elementName\">The name of the element to verify.</param>\n        /// <returns>\n        /// <see langword=\"true\"/> if the element exists in the collection; otherwise, <see langword=\"false\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override bool IsElementName(string elementName)\n        {\n            return (elementName == global::EApp.Core.Configuration.MiscSettingElementCollection.MiscSettingAddElementPropertyName);\n        }\n        \n        /// <summary>\n        /// Gets the element key for the specified configuration element.\n        /// </summary>\n        /// <param name=\"element\">The <see cref=\"global::System.Configuration.ConfigurationElement\"/> to return the key for.</param>\n        /// <returns>\n        /// An <see cref=\"object\"/> that acts as the key for the specified <see cref=\"global::System.Configuration.ConfigurationElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override object GetElementKey(global::System.Configuration.ConfigurationElement element)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(element)).key;\n        }\n        \n        /// <summary>\n        /// Creates a new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </summary>\n        /// <returns>\n        /// A new <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/>.\n        /// </returns>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        protected override global::System.Configuration.ConfigurationElement CreateNewElement()\n        {\n            return new global::EApp.Core.Configuration.MiscSettingAddElement();\n        }\n        #endregion\n        \n        #region Indexer\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[int index]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n            }\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement this[object key]\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(key)));\n            }\n        }\n        #endregion\n        \n        #region Add\n        /// <summary>\n        /// Adds the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to add.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Add(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseAdd(add);\n        }\n        #endregion\n        \n        #region Remove\n        /// <summary>\n        /// Removes the specified <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> from the <see cref=\"global::System.Configuration.ConfigurationElementCollection\"/>.\n        /// </summary>\n        /// <param name=\"add\">The <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to remove.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public void Remove(global::EApp.Core.Configuration.MiscSettingAddElement add)\n        {\n            base.BaseRemove(this.GetElementKey(add));\n        }\n        #endregion\n        \n        #region GetItem\n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The index of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemAt(int index)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(index)));\n        }\n        \n        /// <summary>\n        /// Gets the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> with the specified key.\n        /// </summary>\n        /// <param name=\"key\">The key of the <see cref=\"global::EApp.Core.Configuration.MiscSettingAddElement\"/> to retrieve.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public global::EApp.Core.Configuration.MiscSettingAddElement GetItemByKey(string key)\n        {\n            return ((global::EApp.Core.Configuration.MiscSettingAddElement)(base.BaseGet(((object)(key)))));\n        }\n        #endregion\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "  /// <summary>\n  /// Description of Update.\n  /// </summary>\n  public static class UpdateHelper\n  {\n    private const string uacRegistryKey = \"Software\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Policies\\\\System\";\n    private const string uacRegistryValue = \"EnableLUA\";\n\n    private const string uninstallRegistryKey = \"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Uninstall\";\n\n    private static uint STANDARD_RIGHTS_READ = 0x00020000;\n    private static uint TOKEN_QUERY = 0x0008;\n    private static uint TOKEN_READ = (STANDARD_RIGHTS_READ | TOKEN_QUERY);\n\n    [DllImport(\"advapi32.dll\", SetLastError = true)]\n    [return: MarshalAs(UnmanagedType.Bool)]\n    static extern bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, out IntPtr TokenHandle);\n\n    [DllImport(\"advapi32.dll\", SetLastError = true)]\n    public static extern bool GetTokenInformation(IntPtr TokenHandle, TOKEN_INFORMATION_CLASS TokenInformationClass, IntPtr TokenInformation, uint TokenInformationLength, out uint ReturnLength);\n\n    public enum TOKEN_INFORMATION_CLASS\n    {\n      TokenUser = 1,\n      TokenGroups,\n      TokenPrivileges,\n      TokenOwner,\n      TokenPrimaryGroup,\n      TokenDefaultDacl,\n      TokenSource,\n      TokenType,\n      TokenImpersonationLevel,\n      TokenStatistics,\n      TokenRestrictedSids,\n      TokenSessionId,\n      TokenGroupsAndPrivileges,\n      TokenSessionReference,\n      TokenSandBoxInert,\n      TokenAuditPolicy,\n      TokenOrigin,\n      TokenElevationType,\n      TokenLinkedToken,\n      TokenElevation,\n      TokenHasRestrictions,\n      TokenAccessInformation,\n      TokenVirtualizationAllowed,\n      TokenVirtualizationEnabled,\n      TokenIntegrityLevel,\n      TokenUIAccess,\n      TokenMandatoryPolicy,\n      TokenLogonSid,\n      MaxTokenInfoClass\n    }\n\n    public enum TOKEN_ELEVATION_TYPE\n    {\n      TokenElevationTypeDefault = 1,\n      TokenElevationTypeFull,\n      TokenElevationTypeLimited\n    }\n\n    public static bool IsUacEnabled\n    {\n      get\n      {\n        RegistryKey uacKey = Registry.LocalMachine.OpenSubKey(uacRegistryKey, false);\n        bool result = uacKey.GetValue(uacRegistryValue).Equals(1);\n        return result;\n      }\n    }\n\n    public static bool IsProcessElevated\n    {\n      get\n      {\n        if (IsUacEnabled)\n        {\n          IntPtr tokenHandle;\n          if (!OpenProcessToken(Process.GetCurrentProcess().Handle, TOKEN_READ, out tokenHandle))\n          {\n            throw new ApplicationException(\"Could not get process token.  Win32 Error Code: \" + Marshal.GetLastWin32Error());\n          }\n\n          TOKEN_ELEVATION_TYPE elevationResult = TOKEN_ELEVATION_TYPE.TokenElevationTypeDefault;\n\n          int elevationResultSize = Marshal.SizeOf((int)elevationResult);\n          uint returnedSize = 0;\n          IntPtr elevationTypePtr = Marshal.AllocHGlobal(elevationResultSize);\n\n          bool success = GetTokenInformation(tokenHandle, TOKEN_INFORMATION_CLASS.TokenElevationType, elevationTypePtr, (uint)elevationResultSize, out returnedSize);\n          if (success)\n          {\n            elevationResult = (TOKEN_ELEVATION_TYPE)Marshal.ReadInt32(elevationTypePtr);\n            bool isProcessAdmin = elevationResult == TOKEN_ELEVATION_TYPE.TokenElevationTypeFull;\n            return isProcessAdmin;\n          }\n          else\n          {\n            throw new ApplicationException(\"Unable to determine the current elevation.\");\n          }\n        }\n        else\n        {\n          WindowsIdentity identity = WindowsIdentity.GetCurrent();\n          WindowsPrincipal principal = new WindowsPrincipal(identity);\n          bool result = principal.IsInRole(WindowsBuiltInRole.Administrator);\n          return result;\n        }\n      }\n    }\n\n    public static bool HasWriteAccessToFolder(string strPath)\n    {\n      try\n      {\n        bool writeable = false;\n        WindowsPrincipal principal = new WindowsPrincipal(WindowsIdentity.GetCurrent());\n        DirectorySecurity security = Directory.GetAccessControl(strPath);\n        AuthorizationRuleCollection authRules = security.GetAccessRules(true, true, typeof(SecurityIdentifier));\n\n        foreach (FileSystemAccessRule accessRule in authRules)\n        {\n\n          if (principal.IsInRole(accessRule.IdentityReference as SecurityIdentifier))\n          {\n            if ((FileSystemRights.WriteData & accessRule.FileSystemRights) == FileSystemRights.WriteData)\n            {\n              if (accessRule.AccessControlType == AccessControlType.Allow)\n              {\n                writeable = true;\n              }\n              else if (accessRule.AccessControlType == AccessControlType.Deny)\n              {\n                //Deny usually overrides any Allow\n                return false;\n              }\n\n            }\n          }\n        }\n        return writeable;\n      }\n      catch (UnauthorizedAccessException)\n      {\n        return false;\n      }\n    }\n\n\n    public static void RunElevated()\n    {\n      RunElevated(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppDomain.CurrentDomain.FriendlyName), \"\");\n    }\n\n    public static void RunElevated(string command)\n    {\n      RunElevated(command, \"\");\n    }\n\n    public static void RunElevated(string[] arguments)\n    {\n      RunElevated(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppDomain.CurrentDomain.FriendlyName), String.Join(\" \", arguments));\n    }\n\n    public static void RunElevated(string command, string arguments)\n    {\n      Process p = new Process();\n      p.StartInfo.Verb = \"runas\";\n      p.StartInfo.FileName = command;\n      p.StartInfo.Arguments = arguments;\n      p.StartInfo.UseShellExecute = true;\n      p.Start();\n    }\n\n    public static void Restart()\n    {\n      Process.Start(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppDomain.CurrentDomain.FriendlyName));\n      Process.GetCurrentProcess().Kill();\n    }\n\n    public static object[] LegacyIDs = { \"Generic Mod Manager_is1\", \"{F97B1D1B-F722-4F37-902E-9FB501FADD0E}_is1\" };\n    public static bool IsLegacyFommInstalled\n    {\n      get\n      {\n        bool bLegacyInstalled = false;\n        string SubKey;\n        SubKey = String.Format(\"{0}\\\\{1}_is1\", uninstallRegistryKey, \"Generic Mod Manager\");\n        bLegacyInstalled |= (Registry.LocalMachine.OpenSubKey(SubKey, false) != null);\n\n        SubKey = String.Format(\"{0}\\\\{{{1}}}_is1\", uninstallRegistryKey, Fomm.ProductInfo.GUID.ToString());\n        bLegacyInstalled |= (Registry.LocalMachine.OpenSubKey(SubKey, false) != null);\n\n        return bLegacyInstalled;\n      }\n    }\n\n    private static UninstallInfo uiFomm = new UninstallInfo(Fomm.ProductInfo.GUID);\n    public static UninstallInfo FommUninstallInfo\n    {\n      get\n      {\n        return uiFomm;\n      }\n    }\n\n    public static void Associate(string[] formats)\n    {\n\n    }\n  }\n", "label": "MultifacetedAbstraction"}
{"text": "\n  internal sealed partial class PersistentPayload : pb::IMessage<PersistentPayload> {\n    private static readonly pb::MessageParser<PersistentPayload> _parser = new pb::MessageParser<PersistentPayload>(() => new PersistentPayload());\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public static pb::MessageParser<PersistentPayload> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Akka.Persistence.Serialization.Proto.Msg.PersistenceReflection.Descriptor.MessageTypes[1]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public PersistentPayload() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public PersistentPayload(PersistentPayload other) : this() {\n      serializerId_ = other.serializerId_;\n      payload_ = other.payload_;\n      payloadManifest_ = other.payloadManifest_;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public PersistentPayload Clone() {\n      return new PersistentPayload(this);\n    }\n\n    /// <summary>Field number for the \"serializerId\" field.</summary>\n    public const int SerializerIdFieldNumber = 1;\n    private int serializerId_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public int SerializerId {\n      get { return serializerId_; }\n      set {\n        serializerId_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"payload\" field.</summary>\n    public const int PayloadFieldNumber = 2;\n    private pb::ByteString payload_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public pb::ByteString Payload {\n      get { return payload_; }\n      set {\n        payload_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"payloadManifest\" field.</summary>\n    public const int PayloadManifestFieldNumber = 3;\n    private pb::ByteString payloadManifest_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public pb::ByteString PayloadManifest {\n      get { return payloadManifest_; }\n      set {\n        payloadManifest_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override bool Equals(object other) {\n      return Equals(other as PersistentPayload);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public bool Equals(PersistentPayload other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (SerializerId != other.SerializerId) return false;\n      if (Payload != other.Payload) return false;\n      if (PayloadManifest != other.PayloadManifest) return false;\n      return true;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (SerializerId != 0) hash ^= SerializerId.GetHashCode();\n      if (Payload.Length != 0) hash ^= Payload.GetHashCode();\n      if (PayloadManifest.Length != 0) hash ^= PayloadManifest.GetHashCode();\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void WriteTo(pb::CodedOutputStream output) {\n      if (SerializerId != 0) {\n        output.WriteRawTag(8);\n        output.WriteInt32(SerializerId);\n      }\n      if (Payload.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(Payload);\n      }\n      if (PayloadManifest.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(PayloadManifest);\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public int CalculateSize() {\n      int size = 0;\n      if (SerializerId != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SerializerId);\n      }\n      if (Payload.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);\n      }\n      if (PayloadManifest.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PayloadManifest);\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void MergeFrom(PersistentPayload other) {\n      if (other == null) {\n        return;\n      }\n      if (other.SerializerId != 0) {\n        SerializerId = other.SerializerId;\n      }\n      if (other.Payload.Length != 0) {\n        Payload = other.Payload;\n      }\n      if (other.PayloadManifest.Length != 0) {\n        PayloadManifest = other.PayloadManifest;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void MergeFrom(pb::CodedInputStream input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n        switch(tag) {\n          default:\n            input.SkipLastField();\n            break;\n          case 8: {\n            SerializerId = input.ReadInt32();\n            break;\n          }\n          case 18: {\n            Payload = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            PayloadManifest = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n\n  }\n", "label": "MultifacetedAbstraction"}
{"text": "    public partial class AboutForm : Form\n    {\n        public AboutForm()\n        {\n            InitializeComponent();\n        }\n\n        private void AboutFormLoad(object sender, EventArgs e)\n        {\n            // removed .Version.ToString(2) in favor of just .ToString() here so we can see the build number now\n            versionLabel.Text = \"Borderless Gaming \" + Assembly.GetExecutingAssembly().GetName().Version;\n            _copyrightLabel.Text = \"Copyright \u00a9 2014-\" + DateTime.Now.Year + \" Andrew Sampson\";\n        }\n\n        #region Project and Maintainer Links\n\n        private void OpenBlog(object sender, LinkLabelLinkClickedEventArgs e)\n        {\n            Tools.GotoSite(\"http://blog.andrew.im/\");\n        }\n\n        private void OpenSteamGroup(object sender, LinkLabelLinkClickedEventArgs e)\n        {\n            Tools.GotoSite(\"http://steamcommunity.com/app/388080/\");\n        }\n\n        private void OpenOwnerGithub(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/Codeusa/\");\n        }\n\n        private void OpenOwnerSteam(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"http://steamcommunity.com/id/Andrewmd5/\");\n        }\n\n        private void OpenGithubRepo(object sender, LinkLabelLinkClickedEventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/Codeusa/Borderless-Gaming\");\n        }\n\n        private void _impulserNameTag_Click(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://www.indiegogo.com/projects/the-mad-scientist-scholarship/x/3590458\");\n        }\n\n        #endregion\n\n        #region Contributers\n\n        private void OpenDmxtGithub(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/dmxt/\");\n        }\n\n        private void OpenImpulserGithub(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/Impulser/\");\n        }\n\n        private void OpenStackOfPancakesGithub(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/Stack-of-Pancakes/\");\n        }\n\n        private void OpenMadpewGithub(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/madpew/\");\n        }\n\n        private void OpenPsouza4Github(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/psouza4/\");\n        }\n\n        private void OpenPsouza4Steam(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"http://steamcommunity.com/id/psouza4/\");\n        }\n\n        private void OpenSecretOnlineGithub(object sender, EventArgs e)\n        {\n            Tools.GotoSite(\"https://github.com/SecretOnline/\");\n        }\n\n        #endregion\n    }\n    partial class AboutForm\n    {\n        /// <summary>\n        /// Required designer variable.\n        /// </summary>\n        private System.ComponentModel.IContainer components = null;\n\n        /// <summary>\n        /// Clean up any resources being used.\n        /// </summary>\n        /// <param name=\"disposing\">true if managed resources should be disposed; otherwise, false.</param>\n        protected override void Dispose(bool disposing)\n        {\n            if (disposing && (components != null))\n            {\n                components.Dispose();\n            }\n            base.Dispose(disposing);\n        }\n\n        #region Windows Form Designer generated code\n\n        /// <summary>\n        /// Required method for Designer support - do not modify\n        /// the contents of this method with the code editor.\n        /// </summary>\n        private void InitializeComponent()\n        {\n            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(AboutForm));\n            this.versionLabel = new System.Windows.Forms.Label();\n            this._gitHubLabel = new System.Windows.Forms.Label();\n            this._blogLabel = new System.Windows.Forms.Label();\n            this._viewGithubLinkLabel = new System.Windows.Forms.LinkLabel();\n            this._viewBlogLinkLabel = new System.Windows.Forms.LinkLabel();\n            this._ownerLabel = new System.Windows.Forms.Label();\n            this._ownerGithubGlobe = new System.Windows.Forms.PictureBox();\n            this.pictureBox1 = new System.Windows.Forms.PictureBox();\n            this._ownerNameTag = new System.Windows.Forms.Label();\n            this._committersLabel = new System.Windows.Forms.Label();\n            this._dmxtGithubGlobe = new System.Windows.Forms.PictureBox();\n            this._dmxtNameTag = new System.Windows.Forms.Label();\n            this._impulserGithubGlobe = new System.Windows.Forms.PictureBox();\n            this._impulserNameTag = new System.Windows.Forms.Label();\n            this._copyrightLabel = new System.Windows.Forms.Label();\n            this._steamGroupLabel = new System.Windows.Forms.Label();\n            this._viewSteamGroupLinkLabel = new System.Windows.Forms.LinkLabel();\n            this._madpewGithubGlobe = new System.Windows.Forms.PictureBox();\n            this._madpewNametag = new System.Windows.Forms.Label();\n            this._psouza4Nametag = new System.Windows.Forms.Label();\n            this._psouza4GithubGlobe = new System.Windows.Forms.PictureBox();\n            this._SecretOnlineNametag = new System.Windows.Forms.Label();\n            this._SecretOnlineGithubGlobe = new System.Windows.Forms.PictureBox();\n            this.pictureBox2 = new System.Windows.Forms.PictureBox();\n            this._codeusaSoftwareLogo = new System.Windows.Forms.PictureBox();\n            this._stackOfPancakesNameTag = new System.Windows.Forms.Label();\n            this._stackOfPancakesGithubGlobe = new System.Windows.Forms.PictureBox();\n            ((System.ComponentModel.ISupportInitialize)(this._ownerGithubGlobe)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this._dmxtGithubGlobe)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this._impulserGithubGlobe)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this._madpewGithubGlobe)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this._psouza4GithubGlobe)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this._SecretOnlineGithubGlobe)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this._codeusaSoftwareLogo)).BeginInit();\n            ((System.ComponentModel.ISupportInitialize)(this._stackOfPancakesGithubGlobe)).BeginInit();\n            this.SuspendLayout();\n            // \n            // versionLabel\n            // \n            resources.ApplyResources(this.versionLabel, \"versionLabel\");\n            this.versionLabel.Name = \"versionLabel\";\n            // \n            // _gitHubLabel\n            // \n            resources.ApplyResources(this._gitHubLabel, \"_gitHubLabel\");\n            this._gitHubLabel.Name = \"_gitHubLabel\";\n            // \n            // _blogLabel\n            // \n            resources.ApplyResources(this._blogLabel, \"_blogLabel\");\n            this._blogLabel.Name = \"_blogLabel\";\n            // \n            // _viewGithubLinkLabel\n            // \n            resources.ApplyResources(this._viewGithubLinkLabel, \"_viewGithubLinkLabel\");\n            this._viewGithubLinkLabel.Name = \"_viewGithubLinkLabel\";\n            this._viewGithubLinkLabel.TabStop = true;\n            this._viewGithubLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.OpenGithubRepo);\n            // \n            // _viewBlogLinkLabel\n            // \n            resources.ApplyResources(this._viewBlogLinkLabel, \"_viewBlogLinkLabel\");\n            this._viewBlogLinkLabel.Name = \"_viewBlogLinkLabel\";\n            this._viewBlogLinkLabel.TabStop = true;\n            this._viewBlogLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.OpenBlog);\n            // \n            // _ownerLabel\n            // \n            resources.ApplyResources(this._ownerLabel, \"_ownerLabel\");\n            this._ownerLabel.Name = \"_ownerLabel\";\n            // \n            // _ownerGithubGlobe\n            // \n            resources.ApplyResources(this._ownerGithubGlobe, \"_ownerGithubGlobe\");\n            this._ownerGithubGlobe.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._ownerGithubGlobe.Name = \"_ownerGithubGlobe\";\n            this._ownerGithubGlobe.TabStop = false;\n            this._ownerGithubGlobe.Click += new System.EventHandler(this.OpenOwnerGithub);\n            // \n            // pictureBox1\n            // \n            resources.ApplyResources(this.pictureBox1, \"pictureBox1\");\n            this.pictureBox1.Cursor = System.Windows.Forms.Cursors.Hand;\n            this.pictureBox1.Name = \"pictureBox1\";\n            this.pictureBox1.TabStop = false;\n            this.pictureBox1.Click += new System.EventHandler(this.OpenOwnerSteam);\n            // \n            // _ownerNameTag\n            // \n            resources.ApplyResources(this._ownerNameTag, \"_ownerNameTag\");\n            this._ownerNameTag.Name = \"_ownerNameTag\";\n            // \n            // _committersLabel\n            // \n            resources.ApplyResources(this._committersLabel, \"_committersLabel\");\n            this._committersLabel.Name = \"_committersLabel\";\n            // \n            // _dmxtGithubGlobe\n            // \n            resources.ApplyResources(this._dmxtGithubGlobe, \"_dmxtGithubGlobe\");\n            this._dmxtGithubGlobe.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._dmxtGithubGlobe.Name = \"_dmxtGithubGlobe\";\n            this._dmxtGithubGlobe.TabStop = false;\n            this._dmxtGithubGlobe.Click += new System.EventHandler(this.OpenDmxtGithub);\n            // \n            // _dmxtNameTag\n            // \n            resources.ApplyResources(this._dmxtNameTag, \"_dmxtNameTag\");\n            this._dmxtNameTag.Name = \"_dmxtNameTag\";\n            // \n            // _impulserGithubGlobe\n            // \n            resources.ApplyResources(this._impulserGithubGlobe, \"_impulserGithubGlobe\");\n            this._impulserGithubGlobe.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._impulserGithubGlobe.Name = \"_impulserGithubGlobe\";\n            this._impulserGithubGlobe.TabStop = false;\n            this._impulserGithubGlobe.Click += new System.EventHandler(this.OpenImpulserGithub);\n            // \n            // _impulserNameTag\n            // \n            resources.ApplyResources(this._impulserNameTag, \"_impulserNameTag\");\n            this._impulserNameTag.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._impulserNameTag.Name = \"_impulserNameTag\";\n            this._impulserNameTag.Click += new System.EventHandler(this._impulserNameTag_Click);\n            // \n            // _copyrightLabel\n            // \n            resources.ApplyResources(this._copyrightLabel, \"_copyrightLabel\");\n            this._copyrightLabel.Name = \"_copyrightLabel\";\n            // \n            // _steamGroupLabel\n            // \n            resources.ApplyResources(this._steamGroupLabel, \"_steamGroupLabel\");\n            this._steamGroupLabel.Name = \"_steamGroupLabel\";\n            // \n            // _viewSteamGroupLinkLabel\n            // \n            resources.ApplyResources(this._viewSteamGroupLinkLabel, \"_viewSteamGroupLinkLabel\");\n            this._viewSteamGroupLinkLabel.Name = \"_viewSteamGroupLinkLabel\";\n            this._viewSteamGroupLinkLabel.TabStop = true;\n            this._viewSteamGroupLinkLabel.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.OpenSteamGroup);\n            // \n            // _madpewGithubGlobe\n            // \n            resources.ApplyResources(this._madpewGithubGlobe, \"_madpewGithubGlobe\");\n            this._madpewGithubGlobe.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._madpewGithubGlobe.Name = \"_madpewGithubGlobe\";\n            this._madpewGithubGlobe.TabStop = false;\n            this._madpewGithubGlobe.Click += new System.EventHandler(this.OpenMadpewGithub);\n            // \n            // _madpewNametag\n            // \n            resources.ApplyResources(this._madpewNametag, \"_madpewNametag\");\n            this._madpewNametag.Name = \"_madpewNametag\";\n            // \n            // _psouza4Nametag\n            // \n            resources.ApplyResources(this._psouza4Nametag, \"_psouza4Nametag\");\n            this._psouza4Nametag.Name = \"_psouza4Nametag\";\n            // \n            // _psouza4GithubGlobe\n            // \n            resources.ApplyResources(this._psouza4GithubGlobe, \"_psouza4GithubGlobe\");\n            this._psouza4GithubGlobe.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._psouza4GithubGlobe.Name = \"_psouza4GithubGlobe\";\n            this._psouza4GithubGlobe.TabStop = false;\n            this._psouza4GithubGlobe.Click += new System.EventHandler(this.OpenPsouza4Github);\n            // \n            // _SecretOnlineNametag\n            // \n            resources.ApplyResources(this._SecretOnlineNametag, \"_SecretOnlineNametag\");\n            this._SecretOnlineNametag.Name = \"_SecretOnlineNametag\";\n            // \n            // _SecretOnlineGithubGlobe\n            // \n            resources.ApplyResources(this._SecretOnlineGithubGlobe, \"_SecretOnlineGithubGlobe\");\n            this._SecretOnlineGithubGlobe.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._SecretOnlineGithubGlobe.Name = \"_SecretOnlineGithubGlobe\";\n            this._SecretOnlineGithubGlobe.TabStop = false;\n            this._SecretOnlineGithubGlobe.Click += new System.EventHandler(this.OpenSecretOnlineGithub);\n            // \n            // pictureBox2\n            // \n            resources.ApplyResources(this.pictureBox2, \"pictureBox2\");\n            this.pictureBox2.Cursor = System.Windows.Forms.Cursors.Hand;\n            this.pictureBox2.Name = \"pictureBox2\";\n            this.pictureBox2.TabStop = false;\n            this.pictureBox2.Click += new System.EventHandler(this.OpenPsouza4Steam);\n            // \n            // _codeusaSoftwareLogo\n            // \n            resources.ApplyResources(this._codeusaSoftwareLogo, \"_codeusaSoftwareLogo\");\n            this._codeusaSoftwareLogo.Name = \"_codeusaSoftwareLogo\";\n            this._codeusaSoftwareLogo.TabStop = false;\n            // \n            // _stackOfPancakesNameTag\n            // \n            resources.ApplyResources(this._stackOfPancakesNameTag, \"_stackOfPancakesNameTag\");\n            this._stackOfPancakesNameTag.Name = \"_stackOfPancakesNameTag\";\n            // \n            // _stackOfPancakesGithubGlobe\n            // \n            resources.ApplyResources(this._stackOfPancakesGithubGlobe, \"_stackOfPancakesGithubGlobe\");\n            this._stackOfPancakesGithubGlobe.Cursor = System.Windows.Forms.Cursors.Hand;\n            this._stackOfPancakesGithubGlobe.Name = \"_stackOfPancakesGithubGlobe\";\n            this._stackOfPancakesGithubGlobe.TabStop = false;\n            this._stackOfPancakesGithubGlobe.Click += new System.EventHandler(this.OpenStackOfPancakesGithub);\n            // \n            // AboutForm\n            // \n            resources.ApplyResources(this, \"$this\");\n            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;\n            this.Controls.Add(this._SecretOnlineNametag);\n            this.Controls.Add(this._SecretOnlineGithubGlobe);\n            this.Controls.Add(this.pictureBox2);\n            this.Controls.Add(this._psouza4Nametag);\n            this.Controls.Add(this._psouza4GithubGlobe);\n            this.Controls.Add(this._madpewNametag);\n            this.Controls.Add(this._madpewGithubGlobe);\n            this.Controls.Add(this._codeusaSoftwareLogo);\n            this.Controls.Add(this._copyrightLabel);\n            this.Controls.Add(this._stackOfPancakesNameTag);\n            this.Controls.Add(this._impulserNameTag);\n            this.Controls.Add(this._stackOfPancakesGithubGlobe);\n            this.Controls.Add(this._dmxtNameTag);\n            this.Controls.Add(this._impulserGithubGlobe);\n            this.Controls.Add(this._ownerNameTag);\n            this.Controls.Add(this._dmxtGithubGlobe);\n            this.Controls.Add(this.pictureBox1);\n            this.Controls.Add(this._committersLabel);\n            this.Controls.Add(this._ownerGithubGlobe);\n            this.Controls.Add(this._ownerLabel);\n            this.Controls.Add(this._viewSteamGroupLinkLabel);\n            this.Controls.Add(this._viewBlogLinkLabel);\n            this.Controls.Add(this._viewGithubLinkLabel);\n            this.Controls.Add(this._steamGroupLabel);\n            this.Controls.Add(this._blogLabel);\n            this.Controls.Add(this._gitHubLabel);\n            this.Controls.Add(this.versionLabel);\n            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;\n            this.MaximizeBox = false;\n            this.MinimizeBox = false;\n            this.Name = \"AboutForm\";\n            this.Load += new System.EventHandler(this.AboutFormLoad);\n            ((System.ComponentModel.ISupportInitialize)(this._ownerGithubGlobe)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox1)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this._dmxtGithubGlobe)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this._impulserGithubGlobe)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this._madpewGithubGlobe)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this._psouza4GithubGlobe)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this._SecretOnlineGithubGlobe)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this.pictureBox2)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this._codeusaSoftwareLogo)).EndInit();\n            ((System.ComponentModel.ISupportInitialize)(this._stackOfPancakesGithubGlobe)).EndInit();\n            this.ResumeLayout(false);\n            this.PerformLayout();\n\n        }\n\n        #endregion\n\n        private System.Windows.Forms.Label versionLabel;\n        private System.Windows.Forms.Label _gitHubLabel;\n        private System.Windows.Forms.Label _blogLabel;\n        private System.Windows.Forms.LinkLabel _viewGithubLinkLabel;\n        private System.Windows.Forms.LinkLabel _viewBlogLinkLabel;\n        private System.Windows.Forms.Label _ownerLabel;\n        private System.Windows.Forms.PictureBox _ownerGithubGlobe;\n        private System.Windows.Forms.PictureBox pictureBox1;\n        private System.Windows.Forms.Label _ownerNameTag;\n        private System.Windows.Forms.Label _committersLabel;\n        private System.Windows.Forms.PictureBox _dmxtGithubGlobe;\n        private System.Windows.Forms.Label _dmxtNameTag;\n        private System.Windows.Forms.PictureBox _impulserGithubGlobe;\n        private System.Windows.Forms.Label _impulserNameTag;\n        private System.Windows.Forms.Label _copyrightLabel;\n        private System.Windows.Forms.Label _steamGroupLabel;\n        private System.Windows.Forms.LinkLabel _viewSteamGroupLinkLabel;\n        private System.Windows.Forms.PictureBox _madpewGithubGlobe;\n        private System.Windows.Forms.Label _madpewNametag;\n        private System.Windows.Forms.Label _psouza4Nametag;\n        private System.Windows.Forms.PictureBox _psouza4GithubGlobe;\n        private System.Windows.Forms.Label _SecretOnlineNametag;\n        private System.Windows.Forms.PictureBox _SecretOnlineGithubGlobe;\n        private System.Windows.Forms.PictureBox pictureBox2;\n        private System.Windows.Forms.PictureBox _codeusaSoftwareLogo;\n        private System.Windows.Forms.Label _stackOfPancakesNameTag;\n        private System.Windows.Forms.PictureBox _stackOfPancakesGithubGlobe;\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>\n    /// Provides the semantics of a reference to an EDM type definition.\n    /// </summary>\n    internal class CsdlSemanticsTypeDefinitionReference : CsdlSemanticsNamedTypeReference, IEdmTypeDefinitionReference\n    {\n        private static readonly Func<CsdlSemanticsTypeDefinitionReference, bool> ComputeIsUnboundedFunc = me => me.ComputeIsUnbounded();\n        private static readonly Func<CsdlSemanticsTypeDefinitionReference, int?> ComputeMaxLengthFunc = me => me.ComputeMaxLength();\n        private static readonly Func<CsdlSemanticsTypeDefinitionReference, bool?> ComputeIsUnicodeFunc = me => me.ComputeIsUnicode();\n        private static readonly Func<CsdlSemanticsTypeDefinitionReference, int?> ComputePrecisionFunc = me => me.ComputePrecision();\n        private static readonly Func<CsdlSemanticsTypeDefinitionReference, int?> ComputeScaleFunc = me => me.ComputeScale();\n        private static readonly Func<CsdlSemanticsTypeDefinitionReference, int?> ComputeSridFunc = me => me.ComputeSrid();\n\n        private readonly Cache<CsdlSemanticsTypeDefinitionReference, bool> isUnboundedCache = new Cache<CsdlSemanticsTypeDefinitionReference, bool>();\n        private readonly Cache<CsdlSemanticsTypeDefinitionReference, int?> maxLengthCache = new Cache<CsdlSemanticsTypeDefinitionReference, int?>();\n        private readonly Cache<CsdlSemanticsTypeDefinitionReference, bool?> isUnicodeCache = new Cache<CsdlSemanticsTypeDefinitionReference, bool?>();\n        private readonly Cache<CsdlSemanticsTypeDefinitionReference, int?> precisionCache = new Cache<CsdlSemanticsTypeDefinitionReference, int?>();\n        private readonly Cache<CsdlSemanticsTypeDefinitionReference, int?> scaleCache = new Cache<CsdlSemanticsTypeDefinitionReference, int?>();\n        private readonly Cache<CsdlSemanticsTypeDefinitionReference, int?> sridCache = new Cache<CsdlSemanticsTypeDefinitionReference, int?>();\n\n        public CsdlSemanticsTypeDefinitionReference(CsdlSemanticsSchema schema, CsdlNamedTypeReference reference)\n            : base(schema, reference)\n        {\n        }\n\n        public bool IsUnbounded\n        {\n            get { return this.isUnboundedCache.GetValue(this, ComputeIsUnboundedFunc, null); }\n        }\n\n        public int? MaxLength\n        {\n            get { return this.maxLengthCache.GetValue(this, ComputeMaxLengthFunc, null); }\n        }\n\n        public bool? IsUnicode\n        {\n            get { return this.isUnicodeCache.GetValue(this, ComputeIsUnicodeFunc, null); }\n        }\n\n        public int? Precision\n        {\n            get { return this.precisionCache.GetValue(this, ComputePrecisionFunc, null); }\n        }\n\n        public int? Scale\n        {\n            get { return this.scaleCache.GetValue(this, ComputeScaleFunc, null); }\n        }\n\n        public int? SpatialReferenceIdentifier\n        {\n            get { return this.sridCache.GetValue(this, ComputeSridFunc, null); }\n        }\n\n        private CsdlNamedTypeReference Reference\n        {\n            get { return (CsdlNamedTypeReference)this.Element; }\n        }\n\n        private bool ComputeIsUnbounded()\n        {\n            return this.UnderlyingType().CanSpecifyMaxLength() && this.Reference.IsUnbounded;\n        }\n\n        private int? ComputeMaxLength()\n        {\n            return this.UnderlyingType().CanSpecifyMaxLength() ? this.Reference.MaxLength : null;\n        }\n\n        private bool? ComputeIsUnicode()\n        {\n            return this.UnderlyingType().IsString() ? this.Reference.IsUnicode : null;\n        }\n\n        private int? ComputePrecision()\n        {\n            if (this.UnderlyingType().IsDecimal())\n            {\n                return this.Reference.Precision;\n            }\n\n            if (this.UnderlyingType().IsTemporal())\n            {\n                return this.Reference.Precision ?? CsdlConstants.Default_TemporalPrecision;\n            }\n\n            return null;\n        }\n\n        private int? ComputeScale()\n        {\n            return this.UnderlyingType().IsDecimal() ? this.Reference.Scale : null;\n        }\n\n        private int? ComputeSrid()\n        {\n            if (this.UnderlyingType().IsGeography())\n            {\n                return DefaultSridIfUnspecified(CsdlConstants.Default_SpatialGeographySrid);\n            }\n\n            if (this.UnderlyingType().IsGeometry())\n            {\n                return DefaultSridIfUnspecified(CsdlConstants.Default_SpatialGeometrySrid);\n            }\n\n            return null;\n        }\n\n        private int? DefaultSridIfUnspecified(int defaultSrid)\n        {\n            if (this.Reference.SpatialReferenceIdentifier != CsdlConstants.Default_UnspecifiedSrid)\n            {\n                // The SRID is specified.\n                return this.Reference.SpatialReferenceIdentifier;\n            }\n\n            return defaultSrid;\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    internal class Natives {\n\n        #region Consts\n\n        private const int SOURCE_COPY = 0x00CC0020;\n        private const int BI_RGB = 0;\n        private const int DIB_RGB_COLORS = 0;\n\n        private const int DTT_COMPOSITED = ( int ) ( 1UL << 13 );\n        private const int DTT_GLOWSIZE = ( int ) ( 1UL << 11 );\n\n        private const int DT_SINGLELINE = 0x00000020;\n        private const int DT_CENTER = 0x00000001;\n        private const int DT_VCENTER = 0x00000004;\n        private const int DT_NOPREFIX = 0x00000800;\n\n        public const int WM_NCHITTEST = 0x84;\n        public const int WM_NCLBUTTONUP = 0x00A2;\n        public const int WM_NCLBUTTONDOWN = 0x00A1;\n        public const int WM_NCLBUTTONDBLCLK = 0x00A3;\n\n        public const int HTCAPTION = 2;\n        public const int HTCLIENT = 1;\n\n        public const int S_OK = 0x0;\n\n        public const int EP_EDITTEXT = 1;\n        public const int ETS_DISABLED = 4;\n        public const int ETS_NORMAL = 1;\n        public const int ETS_READONLY = 6;\n\n        public const int WM_THEMECHANGED = 0x031A;\n        public const int WM_NCPAINT = 0x85;\n        public const int WM_NCCALCSIZE = 0x83;\n\n        public const int WS_EX_CLIENTEDGE = 0x200;\n        public const int WVR_HREDRAW = 0x100;\n        public const int WVR_VREDRAW = 0x200;\n        public const int WVR_REDRAW = ( WVR_HREDRAW | WVR_VREDRAW );\n\n        #endregion\n\n        #region Enums/Structs\n\n        [StructLayout( LayoutKind.Sequential )]\n        public struct DLLVersionInfo {\n            public int cbSize;\n            public int dwMajorVersion;\n            public int dwMinorVersion;\n            public int dwBuildNumber;\n            public int dwPlatformID;\n        }\n\n        [StructLayout( LayoutKind.Sequential )]\n        public struct NCCALCSIZE_PARAMS {\n            public RECT rgrc0, rgrc1, rgrc2;\n            public IntPtr lppos;\n        }\n\n        #endregion\n\n        #region P/Invoke API Calls\n\n        [DllImport( \"dwmapi.dll\", PreserveSig = false )]\n        private static extern bool DwmIsCompositionEnabled();\n\n        [DllImport( \"dwmapi.dll\" )]\n        private static extern void DwmExtendFrameIntoClientArea( IntPtr hWnd, ref Margins margin );\n\n        [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )]\n        private static extern int SaveDC( IntPtr hdc );\n\n        [DllImport( \"user32.dll\", ExactSpelling = true, SetLastError = true )]\n        private static extern int ReleaseDC( IntPtr hdc, int state );\n\n        [DllImport( \"user32.dll\", ExactSpelling = true, SetLastError = true )]\n        private static extern IntPtr GetDC( IntPtr hdc );\n\n        [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )]\n        private static extern IntPtr CreateCompatibleDC( IntPtr hDC );\n\n        [DllImport( \"gdi32.dll\", ExactSpelling = true )]\n        private static extern IntPtr SelectObject( IntPtr hDC, IntPtr hObject );\n\n        [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )]\n        private static extern bool DeleteObject( IntPtr hObject );\n\n        [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )]\n        private static extern bool DeleteDC( IntPtr hdc );\n\n        [DllImport( \"gdi32.dll\" )]\n        private static extern bool BitBlt( IntPtr hdc, int nXDest, int nYDest, int nWidth, int nHeight, IntPtr hdcSrc, int nXSrc, int nYSrc, uint dwRop );\n\n        [DllImport( \"gdi32.dll\", ExactSpelling = true, SetLastError = true )]\n        private static extern IntPtr CreateDIBSection( IntPtr hdc, uint iUsage, int ppvBits, IntPtr hSection, uint dwOffset );\n\n        [DllImport( \"user32.dll\", CharSet = CharSet.Auto, SetLastError = false )]\n        public static extern IntPtr SendMessage( IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam );\n\n        [DllImport( \"user32.dll\", SetLastError = false )]\n        public static extern bool PostMessage( IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam );\n\n        [DllImport( \"UxTheme.dll\", ExactSpelling = true, SetLastError = true, CharSet = CharSet.Unicode )]\n        private static extern int DrawThemeTextEx( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, string text, int iCharCount, int dwFlags, ref RECT pRect);\n\n        [DllImport( \"UxTheme.dll\", CharSet = CharSet.Auto )]\n        public static extern bool IsAppThemed();\n\n        [DllImport( \"UxTheme.dll\", CharSet = CharSet.Auto )]\n        public static extern bool IsThemeActive();\n\n        [DllImport( \"comctl32.dll\", CharSet = CharSet.Auto )]\n        public static extern int DllGetVersion( ref DLLVersionInfo version );\n\n        [DllImport( \"uxtheme.dll\", ExactSpelling = true, CharSet = CharSet.Unicode )]\n        public static extern IntPtr OpenThemeData( IntPtr hWnd, String classList );\n\n        [DllImport( \"uxtheme.dll\", ExactSpelling = true )]\n        public extern static Int32 CloseThemeData( IntPtr hTheme );\n\n        [DllImport( \"uxtheme\", ExactSpelling = true )]\n        public extern static Int32 DrawThemeBackground( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, ref RECT pRect, IntPtr pClipRect );\n\n        [DllImport( \"uxtheme\", ExactSpelling = true )]\n        public extern static int IsThemeBackgroundPartiallyTransparent( IntPtr hTheme, int iPartId, int iStateId );\n\n        [DllImport( \"uxtheme\", ExactSpelling = true )]\n        public extern static Int32 GetThemeBackgroundContentRect( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, ref RECT pBoundingRect, out RECT pContentRect );\n\n        [DllImport( \"uxtheme\", ExactSpelling = true )]\n        public extern static Int32 DrawThemeParentBackground( IntPtr hWnd, IntPtr hdc, ref RECT pRect );\n\n        [DllImport( \"uxtheme\", ExactSpelling = true )]\n        public extern static Int32 DrawThemeBackground( IntPtr hTheme, IntPtr hdc, int iPartId, int iStateId, ref RECT pRect, ref RECT pClipRect );\n\n        [DllImport( \"user32.dll\" )]\n        public static extern IntPtr GetWindowDC( IntPtr hWnd );\n\n        [DllImport( \"user32.dll\" )]\n        public static extern int ReleaseDC( IntPtr hWnd, IntPtr hDC );\n\n        [DllImport( \"user32.dll\" )]\n        public static extern bool GetWindowRect( IntPtr hWnd, out RECT lpRect );\n\n        [DllImport( \"gdi32.dll\" )]\n        public static extern int ExcludeClipRect( IntPtr hdc, int nLeftRect, int nTopRect, int nRightRect, int nBottomRect );\n\n        #endregion\n\n        #region Drawing / Utils\n\n        //Most methods have been snipped\n\n        public static bool CanRender() {\n            Type t = typeof(Application);\n            System.Reflection.PropertyInfo pi = t.GetProperty(\"RenderWithVisualStyles\");\n\n            if (pi == null) {\n                OperatingSystem os = System.Environment.OSVersion;\n                if (os.Platform == PlatformID.Win32NT && (((os.Version.Major == 5) && (os.Version.Minor >= 1)) || (os.Version.Major > 5))) {\n                    DLLVersionInfo version = new DLLVersionInfo();\n                    version.cbSize = Marshal.SizeOf(typeof(DLLVersionInfo));\n                    if (DllGetVersion(ref version) == 0) {\n                        return (version.dwMajorVersion > 5) && IsThemeActive() && IsAppThemed();\n                    }\n                }\n\n                return false;\n            }\n            else {\n\t\t\t\tbool result = (bool)pi.GetValue(null, null);\n                return result;\n            }\n        }\n\n        #endregion\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    public class MissionScore\n    {\n        [Key]\n        [Column(Order = 0)]\n        [DatabaseGenerated(DatabaseGeneratedOption.None)]\n        public int MissionID { get; set; }\n        [Key]\n        [Column(Order = 1)]\n        [DatabaseGenerated(DatabaseGeneratedOption.None)]\n        public int AccountID { get; set; }\n        public int Score { get; set; }\n        public DateTime Time { get; set; }\n        public int MissionRevision { get; set; }\n        public int GameSeconds { get; set; }\n\n        public virtual Account Account { get; set; }\n        public virtual Mission Mission { get; set; }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\t/// <summary>Class which represents the entity 'BusinessEntityContact', mapped on table 'AdventureWorks.Person.BusinessEntityContact'.</summary>\n\t[Table(Name=\"[Person].[BusinessEntityContact]\")]\n\tpublic partial class BusinessEntityContact : INotifyPropertyChanging, INotifyPropertyChanged\n\t{\n\t\t#region Events\n\t\t/// <summary>Event which is raised when a property value is changing.</summary>\n\t\tpublic event PropertyChangingEventHandler PropertyChanging;\n\t\t/// <summary>Event which is raised when a property value changes.</summary>\n\t\tpublic event PropertyChangedEventHandler PropertyChanged;\n\t\t#endregion\n\t\t\n\t\t#region Class Member Declarations\n\t\tprivate System.Int32\t_businessEntityId;\n\t\tprivate System.Int32\t_contactTypeId;\n\t\tprivate System.DateTime\t_modifiedDate;\n\t\tprivate System.Int32\t_personId;\n\t\tprivate System.Guid\t_rowguid;\n\t\tprivate EntityRef <BusinessEntity> _businessEntity;\n\t\tprivate EntityRef <ContactType> _contactType;\n\t\tprivate EntityRef <Person> _person;\n\t\t#endregion\n\t\t\n\t\t#region Extensibility Method Definitions\n\t\tpartial void OnLoaded();\n\t\tpartial void OnValidate(System.Data.Linq.ChangeAction action);\n\t\tpartial void OnCreated();\n\t\tpartial void OnBusinessEntityIdChanging(System.Int32 value);\n\t\tpartial void OnBusinessEntityIdChanged();\n\t\tpartial void OnContactTypeIdChanging(System.Int32 value);\n\t\tpartial void OnContactTypeIdChanged();\n\t\tpartial void OnModifiedDateChanging(System.DateTime value);\n\t\tpartial void OnModifiedDateChanged();\n\t\tpartial void OnPersonIdChanging(System.Int32 value);\n\t\tpartial void OnPersonIdChanged();\n\t\tpartial void OnRowguidChanging(System.Guid value);\n\t\tpartial void OnRowguidChanged();\n\t\t#endregion\n\t\t\n\t\t/// <summary>Initializes a new instance of the <see cref=\"BusinessEntityContact\"/> class.</summary>\n\t\tpublic BusinessEntityContact()\n\t\t{\n\t\t\t_businessEntity = default(EntityRef<BusinessEntity>);\n\t\t\t_contactType = default(EntityRef<ContactType>);\n\t\t\t_person = default(EntityRef<Person>);\n\t\t\tOnCreated();\n\t\t}\n\n\t\t/// <summary>Raises the PropertyChanging event</summary>\n\t\t/// <param name=\"propertyName\">name of the property which is changing</param>\n\t\tprotected virtual void SendPropertyChanging(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanging != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Raises the PropertyChanged event for the property specified</summary>\n\t\t/// <param name=\"propertyName\">name of the property which was changed</param>\n\t\tprotected virtual void SendPropertyChanged(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanged != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t#region Class Property Declarations\n\t\t/// <summary>Gets or sets the BusinessEntityId field. Mapped on target field 'BusinessEntityID'. </summary>\n\t\t[Column(Name=\"BusinessEntityID\", Storage=\"_businessEntityId\", CanBeNull=false, DbType=\"int NOT NULL\", IsPrimaryKey=true)]\n\t\tpublic System.Int32 BusinessEntityId\n\t\t{\n\t\t\tget\t{ return _businessEntityId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_businessEntityId != value))\n\t\t\t\t{\n\t\t\t\t\tif(_businessEntity.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnBusinessEntityIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"BusinessEntityId\");\n\t\t\t\t\t_businessEntityId = value;\n\t\t\t\t\tSendPropertyChanged(\"BusinessEntityId\");\n\t\t\t\t\tOnBusinessEntityIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the ContactTypeId field. Mapped on target field 'ContactTypeID'. </summary>\n\t\t[Column(Name=\"ContactTypeID\", Storage=\"_contactTypeId\", CanBeNull=false, DbType=\"int NOT NULL\", IsPrimaryKey=true)]\n\t\tpublic System.Int32 ContactTypeId\n\t\t{\n\t\t\tget\t{ return _contactTypeId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_contactTypeId != value))\n\t\t\t\t{\n\t\t\t\t\tif(_contactType.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnContactTypeIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ContactTypeId\");\n\t\t\t\t\t_contactTypeId = value;\n\t\t\t\t\tSendPropertyChanged(\"ContactTypeId\");\n\t\t\t\t\tOnContactTypeIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the ModifiedDate field. Mapped on target field 'ModifiedDate'. </summary>\n\t\t[Column(Name=\"ModifiedDate\", Storage=\"_modifiedDate\", CanBeNull=false, DbType=\"datetime NOT NULL\")]\n\t\tpublic System.DateTime ModifiedDate\n\t\t{\n\t\t\tget\t{ return _modifiedDate; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_modifiedDate != value))\n\t\t\t\t{\n\t\t\t\t\tOnModifiedDateChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ModifiedDate\");\n\t\t\t\t\t_modifiedDate = value;\n\t\t\t\t\tSendPropertyChanged(\"ModifiedDate\");\n\t\t\t\t\tOnModifiedDateChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the PersonId field. Mapped on target field 'PersonID'. </summary>\n\t\t[Column(Name=\"PersonID\", Storage=\"_personId\", CanBeNull=false, DbType=\"int NOT NULL\", IsPrimaryKey=true)]\n\t\tpublic System.Int32 PersonId\n\t\t{\n\t\t\tget\t{ return _personId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_personId != value))\n\t\t\t\t{\n\t\t\t\t\tif(_person.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnPersonIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"PersonId\");\n\t\t\t\t\t_personId = value;\n\t\t\t\t\tSendPropertyChanged(\"PersonId\");\n\t\t\t\t\tOnPersonIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Rowguid field. Mapped on target field 'rowguid'. </summary>\n\t\t[Column(Name=\"rowguid\", Storage=\"_rowguid\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"uniqueidentifier NOT NULL\", IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.Guid Rowguid\n\t\t{\n\t\t\tget\t{ return _rowguid; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_rowguid != value))\n\t\t\t\t{\n\t\t\t\t\tOnRowguidChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Rowguid\");\n\t\t\t\t\t_rowguid = value;\n\t\t\t\t\tSendPropertyChanged(\"Rowguid\");\n\t\t\t\t\tOnRowguidChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'BusinessEntityContact.BusinessEntity - BusinessEntity.BusinessEntityContacts (m:1)'</summary>\n\t\t[Association(Name=\"BusinessEntityContact_BusinessEntity64816da69dbd4c27a5e5b66d1c074092\", Storage=\"_businessEntity\", ThisKey=\"BusinessEntityId\", IsForeignKey=true)] \n\t\tpublic BusinessEntity BusinessEntity\n\t\t{\n\t\t\tget { return _businessEntity.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tBusinessEntity previousValue = _businessEntity.Entity;\n\t\t\t\tif((previousValue != value) || (_businessEntity.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"BusinessEntity\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_businessEntity.Entity = null;\n\t\t\t\t\t\tpreviousValue.BusinessEntityContacts.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_businessEntity.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_businessEntityId = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.BusinessEntityContacts.Add(this);\n\t\t\t\t\t\t_businessEntityId = value.BusinessEntityId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"BusinessEntity\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'BusinessEntityContact.ContactType - ContactType.BusinessEntityContacts (m:1)'</summary>\n\t\t[Association(Name=\"BusinessEntityContact_ContactType9e4dc4bf61a84ab4adc3b76ed46315bd\", Storage=\"_contactType\", ThisKey=\"ContactTypeId\", IsForeignKey=true)] \n\t\tpublic ContactType ContactType\n\t\t{\n\t\t\tget { return _contactType.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tContactType previousValue = _contactType.Entity;\n\t\t\t\tif((previousValue != value) || (_contactType.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"ContactType\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_contactType.Entity = null;\n\t\t\t\t\t\tpreviousValue.BusinessEntityContacts.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_contactType.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_contactTypeId = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.BusinessEntityContacts.Add(this);\n\t\t\t\t\t\t_contactTypeId = value.ContactTypeId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"ContactType\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'BusinessEntityContact.Person - Person.BusinessEntityContacts (m:1)'</summary>\n\t\t[Association(Name=\"BusinessEntityContact_Personf81c089467ff45ab81dafb455497a611\", Storage=\"_person\", ThisKey=\"PersonId\", IsForeignKey=true)] \n\t\tpublic Person Person\n\t\t{\n\t\t\tget { return _person.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tPerson previousValue = _person.Entity;\n\t\t\t\tif((previousValue != value) || (_person.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"Person\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_person.Entity = null;\n\t\t\t\t\t\tpreviousValue.BusinessEntityContacts.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_person.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_personId = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.BusinessEntityContacts.Add(this);\n\t\t\t\t\t\t_personId = value.BusinessEntityId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"Person\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#endregion\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "\n\tpublic class ControllerBase : Controller {\n\n\t\tprivate static readonly Logger log = LogManager.GetCurrentClassLogger();\n\t\tprotected static readonly TimeSpan imageExpirationTime = TimeSpan.FromMinutes(5);\n\t\tprotected const int entriesPerPage = 30;\n\t\tprotected const int invalidId = 0;\n\t\tprotected static readonly TimeSpan pictureCacheDuration = TimeSpan.FromDays(30);\n\t\tprotected const int pictureCacheDurationSec = 30 * 24 * 60 * 60;\n\t\tprotected const int statsCacheDurationSec = 24 * 60 * 60;\n\n\t\tprotected ControllerBase() {\n\t\t\tPageProperties.OpenGraph.Image = VocaUriBuilder.StaticResource(\"/img/vocaDB-title-large.png\");\n\t\t}\n\n\t\tprotected string Hostname => WebHelper.GetRealHost(Request);\n\n\t\tprotected int LoggedUserId {\n\t\t\tget {\n\n\t\t\t\tPermissionContext.VerifyLogin();\n\n\t\t\t\treturn PermissionContext.LoggedUser.Id;\n\n\t\t\t}\n\t\t}\n\n\t\tprotected PagePropertiesData PageProperties => PagePropertiesData.Get(ViewBag);\n\n\t\tprotected IUserPermissionContext PermissionContext => MvcApplication.LoginManager;\n\n\t\tprotected string GetHostnameForValidHit() {\n\t\t\treturn WebHelper.IsValidHit(Request) ? WebHelper.GetRealHost(Request) : string.Empty;\n\t\t}\n\n\t\tprotected ActionResult NoId() {\n\t\t\treturn HttpNotFound(\"No ID specified\");\n\t\t}\n\n\t\tprotected void AddFormSubmissionError(string details) {\n\t\t\t\n\t\t\tlog.Warn(\"Form submission error: {0}\", details);\n\t\t\tModelState.AddModelError(string.Empty, string.Format(\"Error while sending form contents - please try again. Diagnostic error message: {0}.\", details));\n\n\t\t}\n\n\t\tprotected ActionResult Picture(EntryForPictureDisplayContract contract) {\n\n\t\t\tParamIs.NotNull(() => contract);\n\n\t\t\t// Allow images to be cached by public proxies, images shouldn't contain anything sensitive so this should be ok.\n\t\t\tResponse.Cache.SetCacheability(HttpCacheability.Public);\n\n\t\t\tResponse.Cache.SetETag(string.Format(\"{0}{1}v{2}\", contract.EntryType, contract.EntryId, contract.Version));\n\n\t\t\t// Cached version indicated by the \"v\" request parameter.\n\t\t\t// If no version is specified, assume no caching.\n\t\t\tif (contract.Version > 0 && !string.IsNullOrEmpty(Request.Params[\"v\"]))\n\t\t\t\tResponse.Cache.SetMaxAge(pictureCacheDuration);\n\n\t\t\treturn Picture(contract.Picture, contract.Name);\n\n\t\t}\n\n\t\tprotected void CheckConcurrentEdit(EntryType entryType, int id) {\n\n\t\t\tLogin.Manager.VerifyLogin();\n\n\t\t\tvar conflictingEditor = ConcurrentEntryEditManager.CheckConcurrentEdits(new EntryRef(entryType, id), Login.User);\n\n\t\t\tif (conflictingEditor.UserId != ConcurrentEntryEditManager.Nothing.UserId) {\n\n\t\t\t\tvar ago = DateTime.Now - conflictingEditor.Time;\n\n\t\t\t\tif (ago.TotalMinutes < 1) {\n\n\t\t\t\t\tTempData.SetStatusMessage(string.Format(ViewRes.EntryEditStrings.ConcurrentEditWarningNow, conflictingEditor.UserName));\n\n\t\t\t\t} else {\n\n\t\t\t\t\tTempData.SetStatusMessage(string.Format(ViewRes.EntryEditStrings.ConcurrentEditWarning, conflictingEditor.UserName, (int)ago.TotalMinutes));\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tprotected bool CheckUploadedPicture(HttpPostedFileBase pictureUpload, string fieldName) {\n\n\t\t\tbool errors = false;\n\n\t\t\tif (pictureUpload.ContentLength > ImageHelper.MaxImageSizeBytes) {\n\t\t\t\tModelState.AddModelError(fieldName, \"Picture file is too large.\");\n\t\t\t\terrors = true;\n\t\t\t}\n\n\t\t\tif (!ImageHelper.IsValidImageExtension(pictureUpload.FileName)) {\n\t\t\t\tModelState.AddModelError(fieldName, \"Picture format is not valid.\");\n\t\t\t\terrors = true;\n\t\t\t}\n\n\t\t\treturn !errors;\n\n\t\t}\n\n\t\tprotected ActionResult HttpStatusCodeResult(HttpStatusCode code, string message) {\n\n\t\t\tResponse.StatusCode = (int)code;\n\t\t\tResponse.StatusDescription = message;\n\n\t\t\treturn Content((int)code + \": \" + message);\n\n\t\t}\n\n\t\tprotected void ParseAdditionalPictures(HttpPostedFileBase mainPic, IList<EntryPictureFileContract> pictures) {\n\n\t\t\tParamIs.NotNull(() => mainPic);\n\t\t\tParamIs.NotNull(() => pictures);\n\n\t\t\tvar additionalPics = Enumerable.Range(0, Request.Files.Count)\n\t\t\t\t.Select(i => Request.Files.Get(i))\n\t\t\t\t.Where(f => f != null && f.FileName != mainPic.FileName)\n\t\t\t\t.ToArray();\n\n\t\t\tvar newPics = pictures.Where(p => p.Id == 0).ToArray();\n\n\t\t\tfor (int i = 0; i < additionalPics.Length; ++i) {\n\n\t\t\t\tif (i >= newPics.Length)\n\t\t\t\t\tbreak;\n\n\t\t\t\tvar contract = ParsePicture(additionalPics[i], \"Pictures\");\n\n\t\t\t\tif (contract != null) {\n\t\t\t\t\tnewPics[i].OriginalFileName = contract.OriginalFileName;\n\t\t\t\t\tnewPics[i].UploadedFile = contract.UploadedFile;\n\t\t\t\t\tnewPics[i].Mime = contract.Mime;\t\t\n\t\t\t\t\tnewPics[i].ContentLength = contract.ContentLength;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tCollectionHelper.RemoveAll(pictures, p => p.Id == 0 && p.UploadedFile == null);\n\n\t\t}\n\n\t\tprotected EntryPictureFileContract ParsePicture(HttpPostedFileBase pictureUpload, string fieldName) {\n\n\t\t\tEntryPictureFileContract pictureData = null;\n\n\t\t\tif (Request.Files.Count > 0 && pictureUpload != null && pictureUpload.ContentLength > 0) {\n\n\t\t\t\tif (pictureUpload.ContentLength > ImageHelper.MaxImageSizeBytes) {\n\t\t\t\t\tModelState.AddModelError(fieldName, \"Picture file is too large.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tif (!ImageHelper.IsValidImageExtension(pictureUpload.FileName)) {\n\t\t\t\t\tModelState.AddModelError(fieldName, \"Picture format is not valid.\");\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t\tpictureData = new EntryPictureFileContract();\n\t\t\t\tpictureData.OriginalFileName = pictureUpload.FileName;\n\t\t\t\tpictureData.UploadedFile = pictureUpload.InputStream;\n\t\t\t\tpictureData.Mime = pictureUpload.ContentType ?? string.Empty;\n\t\t\t\tpictureData.ContentLength = pictureUpload.ContentLength;\n\n\t\t\t}\n\n\t\t\treturn pictureData;\n\n\t\t}\n\n\t\tprotected ActionResult Picture(PictureContract pictureData, string title) {\n\n\t\t\tif (pictureData?.Bytes == null || string.IsNullOrEmpty(pictureData.Mime))\n\t\t\t\treturn File(Server.MapPath(\"~/Content/unknown.png\"), \"image/png\");\n\n\t\t\tvar ext = ImageHelper.GetExtensionFromMime(pictureData.Mime);\n\n\t\t\tif (!string.IsNullOrEmpty(ext)) {\n\t\t\t\t//var encoded = Url.Encode(title);\n\t\t\t\t// Note: there is no good way to encode content-disposition filename (see http://stackoverflow.com/a/216777)\n\t\t\t\tResponse.AddHeader(\"content-disposition\", string.Format(\"inline;filename=\\\"{0}{1}\\\"\", title, ext));\n\t\t\t}\n\n\t\t\treturn File(pictureData.Bytes, pictureData.Mime);\n\n\t\t}\n\n\t\tprotected ActionResult LowercaseJson(object obj) {\n\n\t\t\treturn new JsonNetResult { Data = obj };\n\n\t\t}\n\n\t\tprotected new ActionResult Json(object obj) {\n\n\t\t\treturn Content(JsonConvert.SerializeObject(obj), \"application/json\");\n\t\n\t\t}\n\n\t\tprotected new ActionResult Json(object obj, string jsonPCallback) {\n\n\t\t\tif (string.IsNullOrEmpty(jsonPCallback))\n\t\t\t\treturn Json(obj);\n\n\t\t\treturn Content(string.Format(\"{0}({1})\", jsonPCallback, JsonConvert.SerializeObject(obj)), \"application/json\");\n\n\t\t}\n\n\t\tprotected string RenderPartialViewToString(string viewName, object model) {\n\n\t\t\tif (string.IsNullOrEmpty(viewName))\n\t\t\t\tviewName = ControllerContext.RouteData.GetRequiredString(\"action\");\n\n\t\t\tViewData.Model = model;\n\n\t\t\tusing (var sw = new StringWriter()) {\n\t\t\t\tvar viewResult = ViewEngines.Engines.FindPartialView(ControllerContext, viewName);\n\t\t\t\tvar viewContext = new ViewContext(ControllerContext, viewResult.View, ViewData, TempData, sw);\n\t\t\t\tviewResult.View.Render(viewContext, sw);\n\n\t\t\t\treturn sw.GetStringBuilder().ToString();\n\t\t\t}\n\n\t\t}\n\n\t\tprotected void RestoreErrorsFromTempData() {\n\n\t\t\tvar list = TempData[\"ModelErrors\"] as ModelStateList;\n\n\t\t\tif (list == null)\n\t\t\t\treturn;\n\n\t\t\tforeach (var state in list.ModelStates) {\n\t\t\t\tif (ModelState[state.Key] == null || !ModelState[state.Key].Errors.Any()) {\n\t\t\t\t\tforeach (var err in state.Errors) {\n\t\t\t\t\t\tif (err.Exception != null)\n\t\t\t\t\t\t\tModelState.AddModelError(state.Key, err.Exception);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tModelState.AddModelError(state.Key, err.ErrorMessage);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tprotected void SaveErrorsToTempData() {\n\n\t\t\tvar list = new ModelStateList { ModelStates \n\t\t\t\t= ViewData.ModelState.Select(m => new ModelStateErrors(m.Key, m.Value)).ToArray() };\n\n\t\t\tTempData[\"ModelErrors\"] = list;\n\n\t\t}\n\n\t\tprotected void SetSearchEntryType(EntryType entryType) {\n\n\t\t\tPageProperties.GlobalSearchType = entryType;\n\n\t\t}\n\n\t\tprotected VocaUrlMapper UrlMapper => new VocaUrlMapper();\n\n\t\tprotected ActionResult Xml(string content) {\n\n\t\t\tif (string.IsNullOrEmpty(content))\n\t\t\t\treturn new EmptyResult();\n\n\t\t\treturn new ContentResult {\n\t\t\t\tContentType = \"text/xml\",\n\t\t\t\tContent = content,\n\t\t\t\tContentEncoding = Encoding.UTF8\n\t\t\t};\n\n\t\t}\n\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "    [Serializable]\n    [TypeConverterAttribute(typeof(UriTypeConverter))]\n    public class Uri : ISerializable\n    {\n        public static readonly string UriSchemeFile;\n        public static readonly string UriSchemeFtp;\n        public static readonly string UriSchemeGopher;\n        public static readonly string UriSchemeHttp;\n        public static readonly string UriSchemeHttps;\n        public static readonly string UriSchemeMailto;\n        public static readonly string UriSchemeNews;\n        public static readonly string UriSchemeNntp;\n        public static readonly string UriSchemeNetTcp;\n        public static readonly string UriSchemeNetPipe;\n        public static readonly string SchemeDelimiter;\n    \n        public string AbsolutePath\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string AbsoluteUri\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string LocalPath\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string Authority\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public UriHostNameType HostNameType\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public bool IsDefaultPort\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public bool IsFile\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public bool IsLoopback\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string PathAndQuery\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string[] Segments\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public bool IsUnc\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string Host\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public int Port\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string Query\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string Fragment\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string Scheme\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string OriginalString\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string DnsSafeHost\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public bool IsAbsoluteUri\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public bool UserEscaped\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n        public string UserInfo\n        {\n            get { throw new NotImplementedException(); }\n        }\n    \n    \n        public Uri(string uriString)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The constructor has been deprecated. Please use new Uri(string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        public Uri(string uriString, bool dontEscape)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The constructor has been deprecated. Please new Uri(Uri, string). The dontEscape parameter is deprecated and is always false. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        public Uri(Uri baseUri, string relativeUri, bool dontEscape)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public Uri(string uriString, UriKind uriKind)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public Uri(Uri baseUri, string relativeUri)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public Uri(Uri baseUri, Uri relativeUri)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static UriHostNameType CheckHostName(string name)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public string GetLeftPart(UriPartial part)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static string HexEscape(char character)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static char HexUnescape(string pattern, ref int index)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool IsHexEncoding(string pattern, int index)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool CheckSchemeName(string schemeName)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool IsHexDigit(char character)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static int FromHex(char digit)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public override int GetHashCode()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public override string ToString()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool operator ==(Uri uri1, Uri uri2)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool operator !=(Uri uri1, Uri uri2)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public override bool Equals(object comparand)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public Uri MakeRelativeUri(Uri uri)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. Please use MakeRelativeUri(Uri uri). http://go.microsoft.com/fwlink/?linkid=14202\")]\n        public string MakeRelative(Uri toUri)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected virtual void Parse()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected virtual void Canonicalize()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected virtual void Escape()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. Please use GetComponents() or static UnescapeDataString() to unescape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected virtual string Unescape(string path)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. Please use GetComponents() or static EscapeUriString() to escape a Uri component or a string. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected static string EscapeString(string str)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected virtual void CheckSecurity()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected virtual bool IsReservedCharacter(char character)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected static bool IsExcludedCharacter(char character)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        [ObsoleteAttribute(\"The method has been deprecated. It is not used by the system. http://go.microsoft.com/fwlink/?linkid=14202\")]\n        protected virtual bool IsBadFileSystemCharacter(char character)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool TryCreate(string uriString, UriKind uriKind, ref Uri result)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool TryCreate(Uri baseUri, string relativeUri, ref Uri result)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool TryCreate(Uri baseUri, Uri relativeUri, ref Uri result)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public string GetComponents(UriComponents components, UriFormat format)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public bool IsWellFormedOriginalString()\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static bool IsWellFormedUriString(string uriString, UriKind uriKind)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static string UnescapeDataString(string stringToUnescape)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static string EscapeUriString(string stringToEscape)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public static string EscapeDataString(string stringToEscape)\n        {\n             throw new NotImplementedException();\n        }\n        \n        \n        public bool IsBaseOf(Uri uri)\n        {\n             throw new NotImplementedException();\n        }\n\n\n\n        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context)\n        {\n            throw new NotImplementedException();\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n  internal sealed partial class PersistentPayload : pb::IMessage<PersistentPayload> {\n    private static readonly pb::MessageParser<PersistentPayload> _parser = new pb::MessageParser<PersistentPayload>(() => new PersistentPayload());\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public static pb::MessageParser<PersistentPayload> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Akka.Persistence.Serialization.Proto.Msg.PersistenceReflection.Descriptor.MessageTypes[1]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public PersistentPayload() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public PersistentPayload(PersistentPayload other) : this() {\n      serializerId_ = other.serializerId_;\n      payload_ = other.payload_;\n      payloadManifest_ = other.payloadManifest_;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public PersistentPayload Clone() {\n      return new PersistentPayload(this);\n    }\n\n    /// <summary>Field number for the \"serializerId\" field.</summary>\n    public const int SerializerIdFieldNumber = 1;\n    private int serializerId_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public int SerializerId {\n      get { return serializerId_; }\n      set {\n        serializerId_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"payload\" field.</summary>\n    public const int PayloadFieldNumber = 2;\n    private pb::ByteString payload_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public pb::ByteString Payload {\n      get { return payload_; }\n      set {\n        payload_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    /// <summary>Field number for the \"payloadManifest\" field.</summary>\n    public const int PayloadManifestFieldNumber = 3;\n    private pb::ByteString payloadManifest_ = pb::ByteString.Empty;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public pb::ByteString PayloadManifest {\n      get { return payloadManifest_; }\n      set {\n        payloadManifest_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override bool Equals(object other) {\n      return Equals(other as PersistentPayload);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public bool Equals(PersistentPayload other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (SerializerId != other.SerializerId) return false;\n      if (Payload != other.Payload) return false;\n      if (PayloadManifest != other.PayloadManifest) return false;\n      return true;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (SerializerId != 0) hash ^= SerializerId.GetHashCode();\n      if (Payload.Length != 0) hash ^= Payload.GetHashCode();\n      if (PayloadManifest.Length != 0) hash ^= PayloadManifest.GetHashCode();\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void WriteTo(pb::CodedOutputStream output) {\n      if (SerializerId != 0) {\n        output.WriteRawTag(8);\n        output.WriteInt32(SerializerId);\n      }\n      if (Payload.Length != 0) {\n        output.WriteRawTag(18);\n        output.WriteBytes(Payload);\n      }\n      if (PayloadManifest.Length != 0) {\n        output.WriteRawTag(26);\n        output.WriteBytes(PayloadManifest);\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public int CalculateSize() {\n      int size = 0;\n      if (SerializerId != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeInt32Size(SerializerId);\n      }\n      if (Payload.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(Payload);\n      }\n      if (PayloadManifest.Length != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeBytesSize(PayloadManifest);\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void MergeFrom(PersistentPayload other) {\n      if (other == null) {\n        return;\n      }\n      if (other.SerializerId != 0) {\n        SerializerId = other.SerializerId;\n      }\n      if (other.Payload.Length != 0) {\n        Payload = other.Payload;\n      }\n      if (other.PayloadManifest.Length != 0) {\n        PayloadManifest = other.PayloadManifest;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void MergeFrom(pb::CodedInputStream input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n        switch(tag) {\n          default:\n            input.SkipLastField();\n            break;\n          case 8: {\n            SerializerId = input.ReadInt32();\n            break;\n          }\n          case 18: {\n            Payload = input.ReadBytes();\n            break;\n          }\n          case 26: {\n            PayloadManifest = input.ReadBytes();\n            break;\n          }\n        }\n      }\n    }\n\n  }\n", "label": "MultifacetedAbstraction"}
{"text": "        \n\n        /// <summary>\n        /// \n        /// </summary>\n        public abstract class MaterialVariable : ReferenceCountDisposeObject\n        {\n            public static readonly ConstantBufferDescription DefaultMeshConstantBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.ModelCB,\n                          PhongPBRMaterialStruct.SizeInBytes);\n\n            public static readonly ConstantBufferDescription DefaultPointLineConstantBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.PointLineModelCB,\n                            PointLineMaterialStruct.SizeInBytes);\n\n            public static readonly ConstantBufferDescription DefaultVolumeConstantBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.VolumeModelCB,\n                            VolumeParamsStruct.SizeInBytes);\n\n            public static readonly ConstantBufferDescription DefaultNonMaterialBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.SimpleMeshCB,\n                    SimpleMeshStruct.SizeInBytes);\n\n            public event EventHandler UpdateNeeded;\n            /// <summary>\n            /// Gets or sets the identifier. Used for material sorting\n            /// </summary>\n            /// <value>\n            /// The identifier.\n            /// </value>\n            public ushort ID { set; get; } = 0;\n\n            protected IRenderTechnique Technique { get; }\n            protected IEffectsManager EffectsManager { get; }\n            protected bool NeedUpdate { private set; get; } = true;\n            /// <summary>\n            /// Gets the material cb.\n            /// </summary>\n            /// <value>\n            /// The material cb.\n            /// </value>\n            protected ConstantBufferComponent MaterialCB { get; }\n            /// <summary>\n            /// Gets the non material cb. Used for non material related rendering such as Shadow map\n            /// </summary>\n            /// <value>\n            /// The non material cb.\n            /// </value>\n            protected ConstantBufferComponent NonMaterialCB { get; }\n            private readonly object updateLock = new object();\n            private readonly MaterialCore material;\n            /// <summary>\n            /// Initializes a new instance of the <see cref=\"MaterialVariable\"/> class.\n            /// </summary>\n            /// <param name=\"manager\">The manager.</param>\n            /// <param name=\"technique\">The technique.</param>\n            /// <param name=\"meshMaterialConstantBufferDesc\">The Constant Buffer description</param>\n            /// <param name=\"materialCore\"></param>\n            public MaterialVariable(IEffectsManager manager, IRenderTechnique technique, \n                ConstantBufferDescription meshMaterialConstantBufferDesc, \n                MaterialCore materialCore)\n            {\n                Technique = technique;\n                EffectsManager = manager;\n                if(materialCore != null)\n                {\n                    material = materialCore;\n                    material.PropertyChanged += MaterialCore_PropertyChanged;\n                }\n                MaterialCB = new ConstantBufferComponent(meshMaterialConstantBufferDesc);\n                NonMaterialCB = new ConstantBufferComponent(DefaultNonMaterialBufferDesc);\n            }\n\n            internal void Initialize()\n            {\n                MaterialCB.Attach(Technique);\n                NonMaterialCB.Attach(Technique);\n                OnInitialPropertyBindings();\n                foreach(var v in propertyBindings.Values)\n                {\n                    v.Invoke();\n                }\n            }\n\n            protected virtual void OnInitialPropertyBindings() { }\n            /// <summary>\n            /// Binds the material textures, samplers, etc,.\n            /// </summary>\n            /// <param name=\"context\"></param>\n            /// <param name=\"deviceContext\">The device context.</param>\n            /// <param name=\"shaderPass\">The shader pass.</param>\n            /// <returns></returns>\n            public abstract bool BindMaterialResources(RenderContext context, DeviceContextProxy deviceContext, ShaderPass shaderPass);\n\n            protected virtual void UpdateInternalVariables(DeviceContextProxy deviceContext) { }\n\n            /// <summary>\n            /// Gets the pass.\n            /// </summary>\n            /// <param name=\"renderType\">Type of the render.</param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetPass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the shadow pass.\n            /// </summary>\n            /// <param name=\"renderType\"></param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetShadowPass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the wireframe pass.\n            /// </summary>\n            /// <param name=\"renderType\"></param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetWireframePass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the depth pass.\n            /// </summary>\n            /// <param name=\"renderType\">Type of the render.</param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetDepthPass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the name of the pass by.\n            /// </summary>\n            /// <param name=\"name\">The name.</param>\n            /// <returns></returns>\n            public ShaderPass GetPassByName(string name)\n            {\n                return Technique[name];\n            }\n\n            /// <summary>\n            /// Updates the material structure. And upload data to constant buffer\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"context\">The context.</param>\n            /// <param name=\"model\">The model.</param>\n            /// <param name=\"structSize\"></param>\n            public bool UpdateMaterialStruct<T>(DeviceContextProxy context, ref T model, int structSize) where T : struct\n            {\n                if (NeedUpdate)\n                {\n                    lock (updateLock)\n                    {\n                        if (NeedUpdate)\n                        {\n                            UpdateInternalVariables(context);\n                            NeedUpdate = false;\n                        }\n                    }\n                }\n                return MaterialCB.Upload(context, ref model, structSize);\n            }\n            /// <summary>\n            /// Updates the non material structure.\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"context\">The context.</param>\n            /// <param name=\"model\">The model.</param>\n            /// <param name=\"structSize\">Size of the structure.</param>\n            /// <returns></returns>\n            public bool UpdateNonMaterialStruct<T>(DeviceContextProxy context, ref T model, int structSize) where T : struct\n            {\n                return NonMaterialCB.Upload(context, ref model, structSize);\n            }\n            /// <summary>\n            /// Draws the specified device context.\n            /// </summary>\n            /// <param name=\"deviceContext\">The device context.</param>\n            /// <param name=\"bufferModel\">Geometry buffer model.</param>\n            /// <param name=\"instanceCount\">The instance count.</param>\n            public abstract void Draw(DeviceContextProxy deviceContext, IAttachableBufferModel bufferModel, int instanceCount);\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            protected void InvalidateRenderer()\n            {\n                Technique?.EffectsManager?.RaiseInvalidateRender();\n            }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            protected void NotifyUpdateNeeded()\n            {\n                NeedUpdate = true;\n                UpdateNeeded?.Invoke(this, EventArgs.Empty);\n                InvalidateRenderer();\n            }\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public static void DrawIndexed(DeviceContextProxy context, int indexCount, int instanceCount)\n            {\n                if (instanceCount <= 0)\n                {\n                    context.DrawIndexed(indexCount, 0, 0);\n                }\n                else\n                {\n                    context.DrawIndexedInstanced(indexCount, instanceCount, 0, 0, 0);\n                }\n            }\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public static void DrawPoints(DeviceContextProxy context, int vertexCount, int instanceCount)\n            {\n                if (instanceCount <= 0)\n                {\n                    context.Draw(vertexCount, 0);\n                }\n                else\n                {\n                    context.DrawInstanced(vertexCount, instanceCount, 0, 0);\n                }\n            }\n            /// <summary>\n            /// Writes the value to internal buffer array\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"name\">The name.</param>\n            /// <param name=\"value\">The value.</param>\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public void WriteValue<T>(string name, ref T value) where T : struct\n            {\n                MaterialCB.WriteValueByName(name, value);\n            }\n            /// <summary>\n            /// Writes the value to internal buffer array\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"name\">The name.</param>\n            /// <param name=\"value\">The value.</param>\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public void WriteValue<T>(string name, T value) where T : struct\n            {\n                MaterialCB.WriteValueByName(name, value);\n            }\n            /// <summary>\n            /// Writes the value to internal buffer array with offset\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"value\">The value.</param>\n            /// <param name=\"offset\">The offset.</param>\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public void WriteValue<T>(ref T value, int offset) where T : struct\n            {\n                MaterialCB.WriteValue(value, offset);\n            }\n\n            /// <summary>\n            /// \n            /// </summary>\n            /// <param name=\"disposeManagedResources\"></param>\n            protected override void OnDispose(bool disposeManagedResources)\n            {\n                if (disposeManagedResources)\n                {\n                    UpdateNeeded = null;\n                    if(material != null)\n                    {\n                        material.PropertyChanged -= MaterialCore_PropertyChanged;\n                    }\n                    MaterialCB.Detach();\n                    NonMaterialCB.Detach();\n                    propertyBindings.Clear();\n                }\n                base.OnDispose(disposeManagedResources);\n            }\n\n            #region Material Property Bindings\n            private readonly Dictionary<string, Action> propertyBindings = new Dictionary<string, Action>();\n\n            protected void AddPropertyBinding(string propertyName, Action action)\n            {\n                propertyBindings.Add(propertyName, action);\n            }\n\n            protected void TriggerPropertyAction(string propertyName)\n            {\n                if (propertyBindings.TryGetValue(propertyName, out Action act))\n                {\n                    act.Invoke();\n                }\n            }\n\n            private void MaterialCore_PropertyChanged(object sender, PropertyChangedEventArgs e)\n            {\n                TriggerPropertyAction(e.PropertyName);\n                InvalidateRenderer();\n            }\n            #endregion\n        }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    /// <summary>\n    /// The spacing around an operator symbol is incorrect, within a C# code file.\n    /// </summary>\n    /// <remarks>\n    /// <para>A violation of this rule occurs when the spacing around an operator symbol is incorrect.</para>\n    ///\n    /// <para>The following types of operator symbols should be surrounded by a single space on either side: colons,\n    /// arithmetic operators, assignment operators, conditional operators, logical operators, relational operators,\n    /// shift operators, and lambda operators. For example:</para>\n    ///\n    /// <code language=\"cs\">\n    /// int x = 4 + y;\n    /// </code>\n    ///\n    /// <para>In contrast, unary operators should be preceded by a single space, but should never be followed by any space.\n    /// For example:</para>\n    ///\n    /// <code language=\"cs\">\n    /// bool x = !value;\n    /// </code>\n    ///\n    /// <para>An exception occurs whenever the symbol is preceded or followed by a parenthesis or bracket, in which case\n    /// there should be no space between the symbol and the bracket. For example:</para>\n    ///\n    /// <code language=\"cs\">\n    /// if (!value)\n    /// {\n    /// }\n    /// </code>\n    /// </remarks>\n    [DiagnosticAnalyzer(LanguageNames.CSharp)]\n    internal class SA1003SymbolsMustBeSpacedCorrectly : DiagnosticAnalyzer\n    {\n        /// <summary>\n        /// The ID for diagnostics produced by the <see cref=\"SA1003SymbolsMustBeSpacedCorrectly\"/> analyzer.\n        /// </summary>\n        public const string DiagnosticId = \"SA1003\";\n\n        internal const string CodeFixAction = \"Action\";\n        internal const string InsertBeforeTag = \"InsertBefore\";\n        internal const string RemoveBeforeTag = \"RemoveBefore\";\n        internal const string InsertAfterTag = \"InsertAfter\";\n        internal const string RemoveAfterTag = \"RemoveAfter\";\n        internal const string RemoveEndOfLineTag = \"RemoveEndOfLine\";\n        internal const string RemoveEndOfLineWithTrailingSpaceTag = \"RemoveEndOfLineWithTrailingSpace\";\n\n        private const string Title = \"Symbols should be spaced correctly\";\n        private const string MessageFormatNotFollowedByComment = \"Operator '{0}' should not be followed by a comment.\";\n        private const string MessageFormatPrecededByWhitespace = \"Operator '{0}' should be preceded by whitespace.\";\n        private const string MessageFormatNotPrecededByWhitespace = \"Operator '{0}' should not be preceded by whitespace.\";\n        private const string MessageFormatFollowedByWhitespace = \"Operator '{0}' should be followed by whitespace.\";\n        private const string MessageFormatNotFollowedByWhitespace = \"Operator '{0}' should not be followed by whitespace.\";\n        private const string MessageFormatNotAtEndOfLine = \"Operator '{0}' should not appear at the end of a line.\";\n        private const string Description = \"The spacing around an operator symbol is incorrect, within a C# code file.\";\n        private const string HelpLink = \"https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1003.md\";\n\n        private static readonly ImmutableArray<SyntaxKind> BinaryExpressionKinds =\n            ImmutableArray.Create(\n                SyntaxKind.CoalesceExpression,\n                SyntaxKind.IsExpression,\n                SyntaxKind.AsExpression,\n                SyntaxKind.BitwiseOrExpression,\n                SyntaxKind.ExclusiveOrExpression,\n                SyntaxKind.BitwiseAndExpression,\n                SyntaxKind.EqualsExpression,\n                SyntaxKind.NotEqualsExpression,\n                SyntaxKind.LessThanExpression,\n                SyntaxKind.LessThanOrEqualExpression,\n                SyntaxKind.GreaterThanExpression,\n                SyntaxKind.GreaterThanOrEqualExpression,\n                SyntaxKind.LeftShiftExpression,\n                SyntaxKind.RightShiftExpression,\n                SyntaxKind.AddExpression,\n                SyntaxKind.SubtractExpression,\n                SyntaxKind.MultiplyExpression,\n                SyntaxKind.DivideExpression,\n                SyntaxKind.ModuloExpression,\n                SyntaxKind.LogicalAndExpression,\n                SyntaxKind.LogicalOrExpression);\n\n        private static readonly ImmutableArray<SyntaxKind> PrefixUnaryExpressionKinds =\n            ImmutableArray.Create(\n                SyntaxKind.UnaryPlusExpression,\n                SyntaxKind.UnaryMinusExpression,\n                SyntaxKind.BitwiseNotExpression,\n                SyntaxKind.LogicalNotExpression,\n                SyntaxKind.PreIncrementExpression,\n                SyntaxKind.PreDecrementExpression,\n                SyntaxKind.AddressOfExpression);\n\n        private static readonly ImmutableArray<SyntaxKind> PostfixUnaryExpressionKinds =\n            ImmutableArray.Create(SyntaxKind.PostIncrementExpression, SyntaxKind.PostDecrementExpression);\n\n        private static readonly ImmutableArray<SyntaxKind> AssignmentExpressionKinds =\n            ImmutableArray.Create(\n                SyntaxKind.OrAssignmentExpression,\n                SyntaxKind.AndAssignmentExpression,\n                SyntaxKind.ExclusiveOrAssignmentExpression,\n                SyntaxKind.LeftShiftAssignmentExpression,\n                SyntaxKind.RightShiftAssignmentExpression,\n                SyntaxKind.AddAssignmentExpression,\n                SyntaxKind.SubtractAssignmentExpression,\n                SyntaxKind.MultiplyAssignmentExpression,\n                SyntaxKind.DivideAssignmentExpression,\n                SyntaxKind.ModuloAssignmentExpression,\n                SyntaxKind.SimpleAssignmentExpression);\n\n        private static readonly Action<SyntaxNodeAnalysisContext> ConstructorDeclarationAction = HandleConstructorDeclaration;\n        private static readonly Action<SyntaxNodeAnalysisContext> ConditionalExpressionAction = HandleConditionalExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> TypeParameterConstraintClauseAction = HandleTypeParameterConstraintClause;\n        private static readonly Action<SyntaxNodeAnalysisContext> BinaryExpressionAction = HandleBinaryExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> PrefixUnaryExpressionAction = HandlePrefixUnaryExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> PostfixUnaryExpressionAction = HandlePostfixUnaryExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> AssignmentExpressionAction = HandleAssignmentExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> CastExpressionAction = HandleCastExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> EqualsValueClauseAction = HandleEqualsValueClause;\n        private static readonly Action<SyntaxNodeAnalysisContext> LambdaExpressionAction = HandleLambdaExpression;\n        private static readonly Action<SyntaxNodeAnalysisContext> ArrowExpressionClauseAction = HandleArrowExpressionClause;\n\n        /// <summary>\n        /// Gets the descriptor for prefix unary expression that may not be followed by a comment.\n        /// </summary>\n        /// <value>\n        /// A diagnostic descriptor.\n        /// </value>\n        public static DiagnosticDescriptor DescriptorNotFollowedByComment { get; } =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormatNotFollowedByComment, AnalyzerCategory.SpacingRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        /// <summary>\n        /// Gets the descriptor indicating that an operator should be preceded by whitespace.\n        /// </summary>\n        /// <value>\n        /// A diagnostic descriptor.\n        /// </value>\n        public static DiagnosticDescriptor DescriptorPrecededByWhitespace { get; } =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormatPrecededByWhitespace, AnalyzerCategory.SpacingRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        /// <summary>\n        /// Gets the descriptor indicating that an operator should be preceded by whitespace.\n        /// </summary>\n        /// <value>\n        /// A diagnostic descriptor.\n        /// </value>\n        public static DiagnosticDescriptor DescriptorNotPrecededByWhitespace { get; } =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormatNotPrecededByWhitespace, AnalyzerCategory.SpacingRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        /// <summary>\n        /// Gets the descriptor indicating that an operator should be followed by whitespace.\n        /// </summary>\n        /// <value>\n        /// A diagnostic descriptor.\n        /// </value>\n        public static DiagnosticDescriptor DescriptorFollowedByWhitespace { get; } =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormatFollowedByWhitespace, AnalyzerCategory.SpacingRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        /// <summary>\n        /// Gets the descriptor indicating that an operator should be preceded by whitespace.\n        /// </summary>\n        /// <value>\n        /// A diagnostic descriptor.\n        /// </value>\n        public static DiagnosticDescriptor DescriptorNotFollowedByWhitespace { get; } =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormatNotFollowedByWhitespace, AnalyzerCategory.SpacingRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        /// <summary>\n        /// Gets the descriptor indicating that an operator should be appear at the end of a text line.\n        /// </summary>\n        /// <value>\n        /// A diagnostic descriptor.\n        /// </value>\n        public static DiagnosticDescriptor DescriptorNotAtEndOfLine { get; } =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormatNotAtEndOfLine, AnalyzerCategory.SpacingRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        /// <inheritdoc/>\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } =\n            ImmutableArray.Create(DescriptorPrecededByWhitespace);\n\n        /// <inheritdoc/>\n        public override void Initialize(AnalysisContext context)\n        {\n            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);\n            context.EnableConcurrentExecution();\n\n            context.RegisterSyntaxNodeAction(ConstructorDeclarationAction, SyntaxKind.ConstructorDeclaration);\n            context.RegisterSyntaxNodeAction(ConditionalExpressionAction, SyntaxKind.ConditionalExpression);\n            context.RegisterSyntaxNodeAction(TypeParameterConstraintClauseAction, SyntaxKind.TypeParameterConstraintClause);\n            context.RegisterSyntaxNodeAction(BinaryExpressionAction, BinaryExpressionKinds);\n            context.RegisterSyntaxNodeAction(PrefixUnaryExpressionAction, PrefixUnaryExpressionKinds);\n            context.RegisterSyntaxNodeAction(PostfixUnaryExpressionAction, PostfixUnaryExpressionKinds);\n            context.RegisterSyntaxNodeAction(AssignmentExpressionAction, AssignmentExpressionKinds);\n            context.RegisterSyntaxNodeAction(CastExpressionAction, SyntaxKind.CastExpression);\n            context.RegisterSyntaxNodeAction(EqualsValueClauseAction, SyntaxKind.EqualsValueClause);\n            context.RegisterSyntaxNodeAction(LambdaExpressionAction, SyntaxKinds.LambdaExpression);\n            context.RegisterSyntaxNodeAction(ArrowExpressionClauseAction, SyntaxKind.ArrowExpressionClause);\n        }\n\n        private static void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context)\n        {\n            var constructorDeclaration = (ConstructorDeclarationSyntax)context.Node;\n            if (constructorDeclaration.Initializer == null)\n            {\n                return;\n            }\n\n            CheckToken(context, constructorDeclaration.Initializer.ColonToken, true, false, true);\n        }\n\n        private static void HandleConditionalExpression(SyntaxNodeAnalysisContext context)\n        {\n            var conditionalExpression = (ConditionalExpressionSyntax)context.Node;\n\n            CheckToken(context, conditionalExpression.QuestionToken, true, true, true);\n            CheckToken(context, conditionalExpression.ColonToken, true, true, true);\n        }\n\n        private static void HandleTypeParameterConstraintClause(SyntaxNodeAnalysisContext context)\n        {\n            var typeParameterConstraint = (TypeParameterConstraintClauseSyntax)context.Node;\n\n            CheckToken(context, typeParameterConstraint.ColonToken, true, true, true);\n        }\n\n        private static void HandleBinaryExpression(SyntaxNodeAnalysisContext context)\n        {\n            var binaryExpression = (BinaryExpressionSyntax)context.Node;\n\n            CheckToken(context, binaryExpression.OperatorToken, true, true, true);\n        }\n\n        private static void HandlePrefixUnaryExpression(SyntaxNodeAnalysisContext context)\n        {\n            var unaryExpression = (PrefixUnaryExpressionSyntax)context.Node;\n            var precedingToken = unaryExpression.OperatorToken.GetPreviousToken();\n            var followingToken = unaryExpression.OperatorToken.GetNextToken();\n            var followingTrivia = TriviaHelper.MergeTriviaLists(unaryExpression.OperatorToken.TrailingTrivia, followingToken.LeadingTrivia);\n\n            /* let the outer operator handle things like the following, so no error is reported for '++':\n             *   c ^= *++buf4;\n             *\n             * if the unary expression is inside parenthesis or an indexer, there should be no leading space\n             */\n            var mustHaveLeadingWhitespace = !(unaryExpression.Parent is PrefixUnaryExpressionSyntax)\n                && !(unaryExpression.Parent is CastExpressionSyntax)\n                && !precedingToken.IsKind(SyntaxKind.OpenParenToken)\n                && !precedingToken.IsKind(SyntaxKind.OpenBracketToken)\n                && !(precedingToken.IsKind(SyntaxKind.OpenBraceToken) && (precedingToken.Parent is InterpolationSyntax));\n\n            bool analyze;\n            switch (unaryExpression.OperatorToken.Kind())\n            {\n            case SyntaxKind.PlusToken:\n            case SyntaxKind.MinusToken:\n            case SyntaxKind.PlusPlusToken:\n            case SyntaxKind.MinusMinusToken:\n                // These expressions are handled by SA1020, SA1021, SA1022\n                analyze = false;\n                break;\n\n            default:\n                analyze = true;\n                break;\n            }\n\n            if (analyze)\n            {\n                if (followingTrivia.Any(SyntaxKind.SingleLineCommentTrivia) || followingTrivia.Any(SyntaxKind.MultiLineCommentTrivia))\n                {\n                    context.ReportDiagnostic(Diagnostic.Create(DescriptorNotFollowedByComment, unaryExpression.OperatorToken.GetLocation(), unaryExpression.OperatorToken.Text));\n                }\n                else\n                {\n                    CheckToken(context, unaryExpression.OperatorToken, mustHaveLeadingWhitespace, false, false);\n                }\n            }\n        }\n\n        private static void HandlePostfixUnaryExpression(SyntaxNodeAnalysisContext context)\n        {\n            var unaryExpression = (PostfixUnaryExpressionSyntax)context.Node;\n            var followingToken = unaryExpression.OperatorToken.GetNextToken();\n\n            bool mustHaveTrailingWhitespace;\n            switch (followingToken.Kind())\n            {\n            case SyntaxKind.CloseParenToken:\n            case SyntaxKind.CloseBracketToken:\n            case SyntaxKind.SemicolonToken:\n            case SyntaxKind.CommaToken:\n            case SyntaxKind.DotToken:\n            case SyntaxKind.MinusGreaterThanToken:\n                mustHaveTrailingWhitespace = false;\n                break;\n\n            case SyntaxKind.QuestionToken:\n                mustHaveTrailingWhitespace = !(followingToken.Parent is ConditionalAccessExpressionSyntax);\n                break;\n\n            case SyntaxKind.CloseBraceToken:\n                mustHaveTrailingWhitespace = !(followingToken.Parent is InterpolationSyntax);\n                break;\n\n            default:\n                mustHaveTrailingWhitespace = true;\n                break;\n            }\n\n            // If the next token is a close brace token we are in an anonymous object creation or an initialization.\n            // Then we allow a new line\n            bool allowEndOfLine = followingToken.IsKind(SyntaxKind.CloseBraceToken);\n\n            CheckToken(context, unaryExpression.OperatorToken, false, allowEndOfLine, mustHaveTrailingWhitespace);\n        }\n\n        private static void HandleAssignmentExpression(SyntaxNodeAnalysisContext context)\n        {\n            var assignmentExpression = (AssignmentExpressionSyntax)context.Node;\n\n            CheckToken(context, assignmentExpression.OperatorToken, true, true, true);\n        }\n\n        private static void HandleCastExpression(SyntaxNodeAnalysisContext context)\n        {\n            var castExpression = (CastExpressionSyntax)context.Node;\n            var precedingToken = castExpression.OpenParenToken.GetPreviousToken();\n\n            var mustHaveLeadingWhitespace = !(castExpression.Parent is PrefixUnaryExpressionSyntax)\n                && !(castExpression.Parent is CastExpressionSyntax)\n                && !precedingToken.IsKind(SyntaxKind.OpenParenToken)\n                && !precedingToken.IsKind(SyntaxKind.OpenBracketToken)\n                && !(precedingToken.IsKind(SyntaxKind.OpenBraceToken) && (precedingToken.Parent is InterpolationSyntax));\n\n            var tokenString = castExpression.OpenParenToken.ToString() + castExpression.Type.ToString() + castExpression.CloseParenToken.ToString();\n            CheckToken(context, castExpression.OpenParenToken, mustHaveLeadingWhitespace, false, false, tokenString);\n            CheckToken(context, castExpression.CloseParenToken, false, false, false, tokenString);\n        }\n\n        private static void HandleEqualsValueClause(SyntaxNodeAnalysisContext context)\n        {\n            var equalsValueClause = (EqualsValueClauseSyntax)context.Node;\n\n            CheckToken(context, equalsValueClause.EqualsToken, true, true, true);\n        }\n\n        private static void HandleLambdaExpression(SyntaxNodeAnalysisContext context)\n        {\n            var lambdaExpression = (LambdaExpressionSyntax)context.Node;\n\n            CheckToken(context, lambdaExpression.ArrowToken, true, true, true);\n        }\n\n        private static void HandleArrowExpressionClause(SyntaxNodeAnalysisContext context)\n        {\n            ArrowExpressionClauseSyntax arrowExpressionClause = (ArrowExpressionClauseSyntax)context.Node;\n            CheckToken(context, arrowExpressionClause.ArrowToken, true, true, true);\n        }\n\n        private static void CheckToken(SyntaxNodeAnalysisContext context, SyntaxToken token, bool withLeadingWhitespace, bool allowAtEndOfLine, bool withTrailingWhitespace, string tokenText = null)\n        {\n            tokenText = tokenText ?? token.Text;\n\n            var precedingToken = token.GetPreviousToken();\n            var precedingTriviaList = TriviaHelper.MergeTriviaLists(precedingToken.TrailingTrivia, token.LeadingTrivia);\n\n            var followingToken = token.GetNextToken();\n            var followingTriviaList = TriviaHelper.MergeTriviaLists(token.TrailingTrivia, followingToken.LeadingTrivia);\n\n            if (withLeadingWhitespace)\n            {\n                // Don't report missing leading whitespace when the token is the first token on a text line.\n                if (!token.IsFirstInLine()\n                    && ((precedingTriviaList.Count == 0) || !precedingTriviaList.Last().IsKind(SyntaxKind.WhitespaceTrivia)))\n                {\n                    var properties = ImmutableDictionary.Create<string, string>()\n                        .Add(CodeFixAction, InsertBeforeTag);\n                    context.ReportDiagnostic(Diagnostic.Create(DescriptorPrecededByWhitespace, token.GetLocation(), properties, tokenText));\n                }\n            }\n            else\n            {\n                // don't report leading whitespace when the token is the first token on a text line\n                if (!token.IsOnlyPrecededByWhitespaceInLine()\n                    && ((precedingTriviaList.Count > 0) && precedingTriviaList.Last().IsKind(SyntaxKind.WhitespaceTrivia)))\n                {\n                    var properties = ImmutableDictionary.Create<string, string>()\n                        .Add(CodeFixAction, RemoveBeforeTag);\n                    context.ReportDiagnostic(Diagnostic.Create(DescriptorNotPrecededByWhitespace, token.GetLocation(), properties, tokenText));\n                }\n            }\n\n            if (!allowAtEndOfLine && token.TrailingTrivia.Any(SyntaxKind.EndOfLineTrivia))\n            {\n                var properties = ImmutableDictionary.Create<string, string>();\n\n                // Do not register a code fix action if there are non whitespace or end of line tokens present.\n                if (followingTriviaList.All(t => t.IsKind(SyntaxKind.WhitespaceTrivia) || t.IsKind(SyntaxKind.EndOfLineTrivia)))\n                {\n                    properties = properties.Add(CodeFixAction, withTrailingWhitespace ? RemoveEndOfLineWithTrailingSpaceTag : RemoveEndOfLineTag);\n                }\n\n                context.ReportDiagnostic(Diagnostic.Create(DescriptorNotAtEndOfLine, token.GetLocation(), properties, tokenText));\n                return;\n            }\n\n            if (withTrailingWhitespace)\n            {\n                if ((followingTriviaList.Count == 0) || !(followingTriviaList.First().IsKind(SyntaxKind.WhitespaceTrivia) || followingTriviaList.First().IsKind(SyntaxKind.EndOfLineTrivia)))\n                {\n                    var properties = ImmutableDictionary.Create<string, string>()\n                        .Add(CodeFixAction, InsertAfterTag);\n                    context.ReportDiagnostic(Diagnostic.Create(DescriptorFollowedByWhitespace, token.GetLocation(), properties, tokenText));\n                }\n            }\n            else\n            {\n                if ((followingTriviaList.Count > 0) && followingTriviaList.First().IsKind(SyntaxKind.WhitespaceTrivia))\n                {\n                    var properties = ImmutableDictionary.Create<string, string>()\n                        .Add(CodeFixAction, RemoveAfterTag);\n                    context.ReportDiagnostic(Diagnostic.Create(DescriptorNotFollowedByWhitespace, token.GetLocation(), properties, tokenText));\n                }\n            }\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /**\n     * Generator for Version 1 TbsCertificateStructures.\n     * <pre>\n     * TbsCertificate ::= Sequence {\n     *      version          [ 0 ]  Version DEFAULT v1(0),\n     *      serialNumber            CertificateSerialNumber,\n     *      signature               AlgorithmIdentifier,\n     *      issuer                  Name,\n     *      validity                Validity,\n     *      subject                 Name,\n     *      subjectPublicKeyInfo    SubjectPublicKeyInfo,\n     *      }\n     * </pre>\n     *\n     */\n    public class V1TbsCertificateGenerator\n    {\n        internal DerTaggedObject\t\tversion = new DerTaggedObject(0, new DerInteger(0));\n        internal DerInteger\t\t\t\tserialNumber;\n        internal AlgorithmIdentifier\tsignature;\n        internal X509Name\t\t\t\tissuer;\n        internal Time\t\t\t\t\tstartDate, endDate;\n        internal X509Name\t\t\t\tsubject;\n        internal SubjectPublicKeyInfo\tsubjectPublicKeyInfo;\n\n\t\tpublic V1TbsCertificateGenerator()\n        {\n        }\n\n\t\tpublic void SetSerialNumber(\n            DerInteger serialNumber)\n        {\n            this.serialNumber = serialNumber;\n        }\n\n\t\tpublic void SetSignature(\n            AlgorithmIdentifier signature)\n        {\n            this.signature = signature;\n        }\n\n\t\tpublic void SetIssuer(\n            X509Name issuer)\n        {\n            this.issuer = issuer;\n        }\n\n\t\tpublic void SetStartDate(\n            Time startDate)\n        {\n            this.startDate = startDate;\n        }\n\n\t\tpublic void SetStartDate(\n            DerUtcTime startDate)\n        {\n            this.startDate = new Time(startDate);\n        }\n\n\t\tpublic void SetEndDate(\n            Time endDate)\n        {\n            this.endDate = endDate;\n        }\n\n\t\tpublic void SetEndDate(\n            DerUtcTime endDate)\n        {\n            this.endDate = new Time(endDate);\n        }\n\n\t\tpublic void SetSubject(\n            X509Name subject)\n        {\n            this.subject = subject;\n        }\n\n\t\tpublic void SetSubjectPublicKeyInfo(\n            SubjectPublicKeyInfo pubKeyInfo)\n        {\n            this.subjectPublicKeyInfo = pubKeyInfo;\n        }\n\n\t\tpublic TbsCertificateStructure GenerateTbsCertificate()\n        {\n            if ((serialNumber == null) || (signature == null)\n                || (issuer == null) || (startDate == null) || (endDate == null)\n                || (subject == null) || (subjectPublicKeyInfo == null))\n            {\n                throw new InvalidOperationException(\"not all mandatory fields set in V1 TBScertificate generator\");\n            }\n\n\t\t\treturn new TbsCertificateStructure(\n\t\t\t\tnew DerSequence(\n\t\t\t\t\t//version, - not required as default value\n\t\t\t\t\tserialNumber,\n\t\t\t\t\tsignature,\n\t\t\t\t\tissuer,\n\t\t\t\t\tnew DerSequence(startDate, endDate), // before and after dates\n\t\t\t\t\tsubject,\n\t\t\t\t\tsubjectPublicKeyInfo));\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    internal sealed partial class Payload : pb::IMessage<Payload>\n    {\n        private static readonly pb::MessageParser<Payload> _parser = new pb::MessageParser<Payload>(() => new Payload());\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public static pb::MessageParser<Payload> Parser { get { return _parser; } }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public static pbr::MessageDescriptor Descriptor\n        {\n            get { return global::Akka.Streams.Serialization.Proto.Msg.StreamRefMessagesReflection.Descriptor.MessageTypes[4]; }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        pbr::MessageDescriptor pb::IMessage.Descriptor\n        {\n            get { return Descriptor; }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public Payload()\n        {\n            OnConstruction();\n        }\n\n        partial void OnConstruction();\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public Payload(Payload other) : this()\n        {\n            enclosedMessage_ = other.enclosedMessage_;\n            serializerId_ = other.serializerId_;\n            messageManifest_ = other.messageManifest_;\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public Payload Clone()\n        {\n            return new Payload(this);\n        }\n\n        /// <summary>Field number for the \"enclosedMessage\" field.</summary>\n        public const int EnclosedMessageFieldNumber = 1;\n        private pb::ByteString enclosedMessage_ = pb::ByteString.Empty;\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public pb::ByteString EnclosedMessage\n        {\n            get { return enclosedMessage_; }\n            set\n            {\n                enclosedMessage_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n            }\n        }\n\n        /// <summary>Field number for the \"serializerId\" field.</summary>\n        public const int SerializerIdFieldNumber = 2;\n        private int serializerId_;\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public int SerializerId\n        {\n            get { return serializerId_; }\n            set\n            {\n                serializerId_ = value;\n            }\n        }\n\n        /// <summary>Field number for the \"messageManifest\" field.</summary>\n        public const int MessageManifestFieldNumber = 3;\n        private pb::ByteString messageManifest_ = pb::ByteString.Empty;\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public pb::ByteString MessageManifest\n        {\n            get { return messageManifest_; }\n            set\n            {\n                messageManifest_ = pb::ProtoPreconditions.CheckNotNull(value, \"value\");\n            }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public override bool Equals(object other)\n        {\n            return Equals(other as Payload);\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public bool Equals(Payload other)\n        {\n            if (ReferenceEquals(other, null))\n            {\n                return false;\n            }\n            if (ReferenceEquals(other, this))\n            {\n                return true;\n            }\n            if (EnclosedMessage != other.EnclosedMessage) return false;\n            if (SerializerId != other.SerializerId) return false;\n            if (MessageManifest != other.MessageManifest) return false;\n            return true;\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public override int GetHashCode()\n        {\n            int hash = 1;\n            if (EnclosedMessage.Length != 0) hash ^= EnclosedMessage.GetHashCode();\n            if (SerializerId != 0) hash ^= SerializerId.GetHashCode();\n            if (MessageManifest.Length != 0) hash ^= MessageManifest.GetHashCode();\n            return hash;\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public override string ToString()\n        {\n            return pb::JsonFormatter.ToDiagnosticString(this);\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public void WriteTo(pb::CodedOutputStream output)\n        {\n            if (EnclosedMessage.Length != 0)\n            {\n                output.WriteRawTag(10);\n                output.WriteBytes(EnclosedMessage);\n            }\n            if (SerializerId != 0)\n            {\n                output.WriteRawTag(16);\n                output.WriteInt32(SerializerId);\n            }\n            if (MessageManifest.Length != 0)\n            {\n                output.WriteRawTag(26);\n                output.WriteBytes(MessageManifest);\n            }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public int CalculateSize()\n        {\n            int size = 0;\n            if (EnclosedMessage.Length != 0)\n            {\n                size += 1 + pb::CodedOutputStream.ComputeBytesSize(EnclosedMessage);\n            }\n            if (SerializerId != 0)\n            {\n                size += 1 + pb::CodedOutputStream.ComputeInt32Size(SerializerId);\n            }\n            if (MessageManifest.Length != 0)\n            {\n                size += 1 + pb::CodedOutputStream.ComputeBytesSize(MessageManifest);\n            }\n            return size;\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public void MergeFrom(Payload other)\n        {\n            if (other == null)\n            {\n                return;\n            }\n            if (other.EnclosedMessage.Length != 0)\n            {\n                EnclosedMessage = other.EnclosedMessage;\n            }\n            if (other.SerializerId != 0)\n            {\n                SerializerId = other.SerializerId;\n            }\n            if (other.MessageManifest.Length != 0)\n            {\n                MessageManifest = other.MessageManifest;\n            }\n        }\n\n        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n        public void MergeFrom(pb::CodedInputStream input)\n        {\n            uint tag;\n            while ((tag = input.ReadTag()) != 0)\n            {\n                switch (tag)\n                {\n                    default:\n                        input.SkipLastField();\n                        break;\n                    case 10:\n                        {\n                            EnclosedMessage = input.ReadBytes();\n                            break;\n                        }\n                    case 16:\n                        {\n                            SerializerId = input.ReadInt32();\n                            break;\n                        }\n                    case 26:\n                        {\n                            MessageManifest = input.ReadBytes();\n                            break;\n                        }\n                }\n            }\n        }\n\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    /// <summary>\n    /// The opening and closing braces for a multi-line C# statement have been omitted.\n    /// </summary>\n    /// <remarks>\n    /// <para>A violation of this rule occurs when the opening and closing braces for a multi-line statement have been\n    /// omitted. In C#, some types of statements may optionally include braces. Examples include <c>if</c>,\n    /// <c>while</c>, and <c>for</c> statements. For example, an if-statement may be written without braces:</para>\n    ///\n    /// <code language=\"csharp\">\n    /// if (true)\n    /// \u00a0\u00a0\u00a0 return\n    ///         this.value;\n    /// </code>\n    ///\n    /// <para>Although this is legal in C#, StyleCop requires the braces to be present when the statement spans multiple\n    /// lines, to increase the readability and maintainability of the code.</para>\n    /// </remarks>\n    [DiagnosticAnalyzer(LanguageNames.CSharp)]\n    internal class SA1519BracesMustNotBeOmittedFromMultiLineChildStatement : DiagnosticAnalyzer\n    {\n        /// <summary>\n        /// The ID for diagnostics produced by the <see cref=\"SA1519BracesMustNotBeOmittedFromMultiLineChildStatement\"/> analyzer.\n        /// </summary>\n        public const string DiagnosticId = \"SA1519\";\n\n        /// <summary>\n        /// The diagnostic descriptor for the <see cref=\"SA1519BracesMustNotBeOmittedFromMultiLineChildStatement\"/> analyzer.\n        /// </summary>\n        public static readonly DiagnosticDescriptor Descriptor =\n            new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, AnalyzerCategory.LayoutRules, DiagnosticSeverity.Warning, AnalyzerConstants.EnabledByDefault, Description, HelpLink);\n\n        private const string Title = \"Braces should not be omitted from multi-line child statement\";\n        private const string MessageFormat = \"Braces should not be omitted from multi-line child statement\";\n        private const string Description = \"The opening and closing braces for a multi-line C# statement have been omitted.\";\n        private const string HelpLink = \"https://github.com/DotNetAnalyzers/StyleCopAnalyzers/blob/master/documentation/SA1519.md\";\n\n        private static readonly Action<SyntaxNodeAnalysisContext> IfStatementAction = HandleIfStatement;\n        private static readonly Action<SyntaxNodeAnalysisContext> DoStatementAction = HandleDoStatement;\n        private static readonly Action<SyntaxNodeAnalysisContext> WhileStatementAction = HandleWhileStatement;\n        private static readonly Action<SyntaxNodeAnalysisContext> ForStatementAction = HandleForStatement;\n        private static readonly Action<SyntaxNodeAnalysisContext> ForEachStatementAction = HandleForEachStatement;\n        private static readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> UsingStatementAction = HandleUsingStatement;\n\n        /// <inheritdoc/>\n        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get; } =\n            ImmutableArray.Create(Descriptor);\n\n        /// <inheritdoc/>\n        public override void Initialize(AnalysisContext context)\n        {\n            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);\n            context.EnableConcurrentExecution();\n\n            context.RegisterSyntaxNodeAction(IfStatementAction, SyntaxKind.IfStatement);\n            context.RegisterSyntaxNodeAction(DoStatementAction, SyntaxKind.DoStatement);\n            context.RegisterSyntaxNodeAction(WhileStatementAction, SyntaxKind.WhileStatement);\n            context.RegisterSyntaxNodeAction(ForStatementAction, SyntaxKind.ForStatement);\n            context.RegisterSyntaxNodeAction(ForEachStatementAction, SyntaxKind.ForEachStatement);\n            context.RegisterSyntaxNodeAction(UsingStatementAction, SyntaxKind.UsingStatement);\n        }\n\n        private static void HandleIfStatement(SyntaxNodeAnalysisContext context)\n        {\n            var ifStatement = (IfStatementSyntax)context.Node;\n\n            CheckChildStatement(context, ifStatement.Statement);\n\n            if (ifStatement.Else != null)\n            {\n                // an 'else' directly followed by an 'if' should not trigger this diagnostic.\n                if (!ifStatement.Else.Statement.IsKind(SyntaxKind.IfStatement))\n                {\n                    CheckChildStatement(context, ifStatement.Else.Statement);\n                }\n            }\n        }\n\n        private static void HandleDoStatement(SyntaxNodeAnalysisContext context)\n        {\n            var doStatement = (DoStatementSyntax)context.Node;\n            CheckChildStatement(context, doStatement.Statement);\n        }\n\n        private static void HandleWhileStatement(SyntaxNodeAnalysisContext context)\n        {\n            var whileStatement = (WhileStatementSyntax)context.Node;\n            CheckChildStatement(context, whileStatement.Statement);\n        }\n\n        private static void HandleForStatement(SyntaxNodeAnalysisContext context)\n        {\n            var forStatement = (ForStatementSyntax)context.Node;\n            CheckChildStatement(context, forStatement.Statement);\n        }\n\n        private static void HandleForEachStatement(SyntaxNodeAnalysisContext context)\n        {\n            var forEachStatement = (ForEachStatementSyntax)context.Node;\n            CheckChildStatement(context, forEachStatement.Statement);\n        }\n\n        private static void HandleUsingStatement(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var usingStatement = (UsingStatementSyntax)context.Node;\n\n            if (settings.LayoutRules.AllowConsecutiveUsings && (usingStatement.Statement is UsingStatementSyntax))\n            {\n                return;\n            }\n\n            CheckChildStatement(context, usingStatement.Statement);\n        }\n\n        private static void CheckChildStatement(SyntaxNodeAnalysisContext context, StatementSyntax childStatement)\n        {\n            if (childStatement is BlockSyntax)\n            {\n                return;\n            }\n\n            FileLinePositionSpan lineSpan = childStatement.GetLineSpan();\n            if (lineSpan.StartLinePosition.Line == lineSpan.EndLinePosition.Line)\n            {\n                return;\n            }\n\n            context.ReportDiagnostic(Diagnostic.Create(Descriptor, childStatement.GetLocation()));\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>\n    /// There are no comments for Microsoft.WindowsAzure.ActiveDirectory.DirectoryLinkChange in the schema.\n    /// </summary>\n    /// <KeyProperties>\n    /// objectId\n    /// </KeyProperties>\n    [global::System.Data.Services.Common.DataServiceKeyAttribute(\"objectId\")]\n    public partial class DirectoryLinkChange : DirectoryObject\n    {\n        /// <summary>\n        /// Create a new DirectoryLinkChange object.\n        /// </summary>\n        /// <param name=\"objectId\">Initial value of objectId.</param>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public static DirectoryLinkChange CreateDirectoryLinkChange(string objectId)\n        {\n            DirectoryLinkChange directoryLinkChange = new DirectoryLinkChange();\n            directoryLinkChange.objectId = objectId;\n            return directoryLinkChange;\n        }\n        /// <summary>\n        /// There are no comments for Property associationType in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string associationType\n        {\n            get\n            {\n                return this._associationType;\n            }\n            set\n            {\n                this.OnassociationTypeChanging(value);\n                this._associationType = value;\n                this.OnassociationTypeChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _associationType;\n        partial void OnassociationTypeChanging(string value);\n        partial void OnassociationTypeChanged();\n        /// <summary>\n        /// There are no comments for Property sourceObjectId in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string sourceObjectId\n        {\n            get\n            {\n                return this._sourceObjectId;\n            }\n            set\n            {\n                this.OnsourceObjectIdChanging(value);\n                this._sourceObjectId = value;\n                this.OnsourceObjectIdChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _sourceObjectId;\n        partial void OnsourceObjectIdChanging(string value);\n        partial void OnsourceObjectIdChanged();\n        /// <summary>\n        /// There are no comments for Property sourceObjectType in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string sourceObjectType\n        {\n            get\n            {\n                return this._sourceObjectType;\n            }\n            set\n            {\n                this.OnsourceObjectTypeChanging(value);\n                this._sourceObjectType = value;\n                this.OnsourceObjectTypeChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _sourceObjectType;\n        partial void OnsourceObjectTypeChanging(string value);\n        partial void OnsourceObjectTypeChanged();\n        /// <summary>\n        /// There are no comments for Property sourceObjectUri in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string sourceObjectUri\n        {\n            get\n            {\n                return this._sourceObjectUri;\n            }\n            set\n            {\n                this.OnsourceObjectUriChanging(value);\n                this._sourceObjectUri = value;\n                this.OnsourceObjectUriChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _sourceObjectUri;\n        partial void OnsourceObjectUriChanging(string value);\n        partial void OnsourceObjectUriChanged();\n        /// <summary>\n        /// There are no comments for Property targetObjectId in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string targetObjectId\n        {\n            get\n            {\n                return this._targetObjectId;\n            }\n            set\n            {\n                this.OntargetObjectIdChanging(value);\n                this._targetObjectId = value;\n                this.OntargetObjectIdChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _targetObjectId;\n        partial void OntargetObjectIdChanging(string value);\n        partial void OntargetObjectIdChanged();\n        /// <summary>\n        /// There are no comments for Property targetObjectType in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string targetObjectType\n        {\n            get\n            {\n                return this._targetObjectType;\n            }\n            set\n            {\n                this.OntargetObjectTypeChanging(value);\n                this._targetObjectType = value;\n                this.OntargetObjectTypeChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _targetObjectType;\n        partial void OntargetObjectTypeChanging(string value);\n        partial void OntargetObjectTypeChanged();\n        /// <summary>\n        /// There are no comments for Property targetObjectUri in the schema.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        public string targetObjectUri\n        {\n            get\n            {\n                return this._targetObjectUri;\n            }\n            set\n            {\n                this.OntargetObjectUriChanging(value);\n                this._targetObjectUri = value;\n                this.OntargetObjectUriChanged();\n            }\n        }\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"System.Data.Services.Design\", \"1.0.0\")]\n        private string _targetObjectUri;\n        partial void OntargetObjectUriChanging(string value);\n        partial void OntargetObjectUriChanged();\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>\n    /// Represents LinkedIn full profile\n    /// </summary>\n    public class LinkedInFullProfile\n    {\n        internal LinkedInFullProfile()\n        {\n        }\n\n        private List<LinkedInPublication> _Publications;\n        private List<LinkedInPatent> _Patents;\n        private List<LinkedInLanguage> _Languages;\n        private List<LinkedInSkill> _Skills;\n        private List<LinkedInEducation> _Educations;\n        private List<LinkedInCertification> _Certifications;\n        private List<LinkedInCourse> _Courses;\n        private List<LinkedInVolunteerExperience> _Volunteer;\n        private List<LinkedInPosition> _ThreeCurrentPositions;\n        private List<LinkedInPosition> _ThreePastPositions;\n        private List<LinkedInPerson> _RelatedProfileViews;\n        private List<LinkedInMemberUrl> _MemberUrls;\n        private List<LinkedInRecommendation> _RecommendationsReceived;\n        private List<LinkedInJobBookmark> _JobBookmarks;\n        private List<LinkedInPerson> _Connections;\n\n        /// <summary>\n        /// Gets the timestamp when the member's profile was last edited\n        /// </summary>\n        public DateTime? LastModifiedTimestamp { get; internal set; }\n        /// <summary>\n        /// Gets description how the member approaches proposals\n        /// </summary>\n        public string ProposalComments { get; internal set; }\n        /// <summary>\n        /// Gets a string enumerating the Associations a member has\n        /// </summary>\n        public string Associations { get; internal set; }\n        /// <summary>\n        /// Gets description of the member's interests\n        /// </summary>\n        public string Interests { get; internal set; }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInPublication\"/> objects representing publications authored by this member\n        /// </summary>\n        public IEnumerable<LinkedInPublication> Publications\n        {\n            get { return _Publications == null ? null : _Publications.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInPatent\"/> objects representing patents or patent applications held by this member\n        /// </summary>\n        public IEnumerable<LinkedInPatent> Patents\n        {\n            get { return _Patents == null ? null : _Patents.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInLanguage\"/> objects representing languages and the level of the member's proficiency for each\n        /// </summary>\n        public IEnumerable<LinkedInLanguage> Languages\n        {\n            get { return _Languages == null ? null : _Languages.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInSkill\"/> objects representing skills held by this member\n        /// </summary>\n        public IEnumerable<LinkedInSkill> Skills\n        {\n            get { return _Skills == null ? null : _Skills.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInEducation\"/> objects representing education institutions a member has attended\n        /// </summary>\n        public IEnumerable<LinkedInEducation> Educations\n        {\n            get { return _Educations == null ? null : _Educations.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInCertification\"/> objects representing certifications earned by this member\n        /// </summary>\n        public IEnumerable<LinkedInCertification> Certifications\n        {\n            get { return _Certifications == null ? null : _Certifications.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInCourse\"/> objects representing courses a member has taken\n        /// </summary>\n        public IEnumerable<LinkedInCourse> Courses\n        {\n            get { return _Courses == null ? null : _Courses.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInVolunteerExperience\"/> objects representing volunteering experiences a member has participated in, including organizations and causes\n        /// </summary>\n        public IEnumerable<LinkedInVolunteerExperience> Volunteer\n        {\n            get { return _Volunteer == null ? null : _Volunteer.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInPosition\"/> objects representing positions a member currently holds, limited to three\n        /// </summary>\n        public IEnumerable<LinkedInPosition> ThreeCurrentPositions\n        {\n            get { return _ThreeCurrentPositions == null ? null : _ThreeCurrentPositions.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInPosition\"/> objects representing positions a member formerly held, limited to the three most recent\n        /// </summary>\n        public IEnumerable<LinkedInPosition> ThreePastPositions\n        {\n            get { return _ThreePastPositions == null ? null : _ThreePastPositions.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInPerson\"/> objects representing related profiles that were viewed before or after the member's profile\n        /// </summary>\n        public IEnumerable<LinkedInPerson> RelatedProfileViews\n        {\n            get { return _RelatedProfileViews == null ? null : _RelatedProfileViews.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInPerson\"/> objects representing member's connection\n        /// </summary>\n        public IEnumerable<LinkedInPerson> Connections\n        {\n            get { return _Connections == null ? null : _Connections.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInMemberUrl\"/> objects representing URLs the member has chosen to share on their LinkedIn profile\n        /// </summary>\n        public IEnumerable<LinkedInMemberUrl> MemberUrls\n        {\n            get { return _MemberUrls == null ? null : _MemberUrls.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets member's birth date\n        /// </summary>\n        public LinkedInDate DateOfBirth { get; internal set; }\n        /// <summary>\n        /// Gets the number of recommendations the member has\n        /// </summary>\n        public int ? NumRecommenders { get; internal set; }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInRecommendation\"/> objects representing recommendations a member has received\n        /// </summary>\n        public IEnumerable<LinkedInRecommendation> RecommendationsReceived\n        {\n            get { return _RecommendationsReceived == null ? null : _RecommendationsReceived.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets a URL for the member's multiple feeds\n        /// </summary>\n        public string MfeedRssUrl { get; internal set; }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInJobBookmark\"/> objects representing jobs that the member is following\n        /// </summary>\n        public IEnumerable<LinkedInJobBookmark> JobBookmarks\n        {\n            get { return _JobBookmarks == null ? null : _JobBookmarks.AsEnumerable(); }\n        }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInFollowing\"/> objects representing people, companies and industries that the member is following\n        /// </summary>\n        public LinkedInFollowing Following { get; internal set; }\n        /// <summary>\n        /// Gets collection of <see cref=\"LinkedInSuggestions\"/> objects representing people, companies and industries suggested for the member to follow\n        /// </summary>\n        public LinkedInSuggestions Suggestions { get; internal set; }\n\n        internal void AddPublications(IEnumerable<LinkedInPublication> publications)\n        {\n            if (_Publications == null) _Publications = new List<LinkedInPublication>();\n            _Publications.AddRange(publications);\n        }\n\n        internal void AddPatents(IEnumerable<LinkedInPatent> patents)\n        {\n            if (_Patents == null) _Patents = new List<LinkedInPatent>();\n            _Patents.AddRange(patents);\n        }\n\n        internal void AddLanguages(IEnumerable<LinkedInLanguage> languages)\n        {\n            if (_Languages == null) _Languages = new List<LinkedInLanguage>();\n            _Languages.AddRange(languages);\n        }\n\n        internal void AddSkills(IEnumerable<LinkedInSkill> skills)\n        {\n            if (_Skills == null) _Skills = new List<LinkedInSkill>();\n            _Skills.AddRange(skills);\n        }\n\n        internal void AddEducations(IEnumerable<LinkedInEducation> educations)\n        {\n            if (_Educations == null) _Educations = new List<LinkedInEducation>();\n            _Educations.AddRange(educations);\n        }\n\n        internal void AddCertifications(IEnumerable<LinkedInCertification> certifications)\n        {\n            if (_Certifications == null) _Certifications = new List<LinkedInCertification>();\n            _Certifications.AddRange(certifications);\n        }\n\n        internal void AddCourses(IEnumerable<LinkedInCourse> courses)\n        {\n            if (_Courses == null) _Courses = new List<LinkedInCourse>();\n            _Courses.AddRange(courses);\n        }\n\n        internal void AddVolunteer(IEnumerable<LinkedInVolunteerExperience> voluteer)\n        {\n            if (_Volunteer == null) _Volunteer = new List<LinkedInVolunteerExperience>();\n            _Volunteer.AddRange(voluteer);\n        }\n\n        internal void AddPositions(IEnumerable<LinkedInPosition> positions, bool current)\n        {\n            if (current)\n            {\n                if (_ThreeCurrentPositions == null) _ThreeCurrentPositions = new List<LinkedInPosition>();\n                _ThreeCurrentPositions.AddRange(positions);\n            }\n            else\n            {\n                if (_ThreePastPositions == null) _ThreePastPositions = new List<LinkedInPosition>();\n                _ThreePastPositions.AddRange(positions);\n            }\n        }\n\n        internal void AddRelatedProfileViews(IEnumerable<LinkedInPerson> persons)\n        {\n            if (_RelatedProfileViews == null) _RelatedProfileViews = new List<LinkedInPerson>();\n            _RelatedProfileViews.AddRange(persons);\n        }\n\n        internal void AddMemberUrls(IEnumerable<LinkedInMemberUrl> urls)\n        {\n            if (_MemberUrls == null) _MemberUrls = new List<LinkedInMemberUrl>();\n            _MemberUrls.AddRange(urls);\n        }\n\n        internal void AddRecommendations(IEnumerable<LinkedInRecommendation> recommendations)\n        {\n            if (_RecommendationsReceived == null) _RecommendationsReceived = new List<LinkedInRecommendation>();\n            _RecommendationsReceived.AddRange(recommendations);\n        }\n\n        internal void AddJobBookmarks(IEnumerable<LinkedInJobBookmark> jbookmarks)\n        {\n            if (_JobBookmarks == null) _JobBookmarks = new List<LinkedInJobBookmark>();\n            _JobBookmarks.AddRange(jbookmarks);\n        }\n\n        internal void AddConnections(IEnumerable<LinkedInPerson> connections)\n        {\n            if (_Connections == null) _Connections = new List<LinkedInPerson>();\n            _Connections.AddRange(connections);\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\tpublic class TimeStampTokenGenerator\n\t{\n\t\tprivate int accuracySeconds = -1;\n\t\tprivate int accuracyMillis = -1;\n\t\tprivate int accuracyMicros = -1;\n\t\tprivate bool ordering = false;\n\t\tprivate GeneralName tsa = null;\n\t\tprivate string tsaPolicyOID;\n\n\t\tprivate AsymmetricKeyParameter\tkey;\n\t\tprivate X509Certificate\t\t\tcert;\n\t\tprivate string\t\t\t\t\tdigestOID;\n\t\tprivate Asn1.Cms.AttributeTable\tsignedAttr;\n\t\tprivate Asn1.Cms.AttributeTable\tunsignedAttr;\n\t\tprivate IX509Store\t\t\t\tx509Certs;\n\t\tprivate IX509Store\t\t\t\tx509Crls;\n\n\t\t/**\n\t\t * basic creation - only the default attributes will be included here.\n\t\t */\n\t\tpublic TimeStampTokenGenerator(\n\t\t\tAsymmetricKeyParameter\tkey,\n\t\t\tX509Certificate\t\t\tcert,\n\t\t\tstring\t\t\t\t\tdigestOID,\n\t\t\tstring\t\t\t\t\ttsaPolicyOID)\n\t\t\t: this(key, cert, digestOID, tsaPolicyOID, null, null)\n\t\t{\n\t\t}\n\n\t\t/**\n\t\t * create with a signer with extra signed/unsigned attributes.\n\t\t */\n\t\tpublic TimeStampTokenGenerator(\n\t\t\tAsymmetricKeyParameter\tkey,\n\t\t\tX509Certificate\t\t\tcert,\n\t\t\tstring\t\t\t\t\tdigestOID,\n\t\t\tstring\t\t\t\t\ttsaPolicyOID,\n\t\t\tAsn1.Cms.AttributeTable\tsignedAttr,\n\t\t\tAsn1.Cms.AttributeTable\tunsignedAttr)\n\t\t{\n\t\t\tthis.key = key;\n\t\t\tthis.cert = cert;\n\t\t\tthis.digestOID = digestOID;\n\t\t\tthis.tsaPolicyOID = tsaPolicyOID;\n\t\t\tthis.unsignedAttr = unsignedAttr;\n\n\t\t\tTspUtil.ValidateCertificate(cert);\n\n\t\t\t//\n\t\t\t// Add the ESSCertID attribute\n\t\t\t//\n\t\t\tIDictionary signedAttrs;\n\t\t\tif (signedAttr != null)\n\t\t\t{\n\t\t\t\tsignedAttrs = signedAttr.ToDictionary();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsignedAttrs = Platform.CreateHashtable();\n\t\t\t}\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tbyte[] hash = DigestUtilities.CalculateDigest(\"SHA-1\", cert.GetEncoded());\n\n\t\t\t\tEssCertID essCertid = new EssCertID(hash);\n\n\t\t\t\tAsn1.Cms.Attribute attr = new Asn1.Cms.Attribute(\n\t\t\t\t\tPkcsObjectIdentifiers.IdAASigningCertificate,\n\t\t\t\t\tnew DerSet(new SigningCertificate(essCertid)));\n\n\t\t\t\tsignedAttrs[attr.AttrType] = attr;\n\t\t\t}\n\t\t\tcatch (CertificateEncodingException e)\n\t\t\t{\n\t\t\t\tthrow new TspException(\"Exception processing certificate.\", e);\n\t\t\t}\n\t\t\tcatch (SecurityUtilityException e)\n\t\t\t{\n\t\t\t\tthrow new TspException(\"Can't find a SHA-1 implementation.\", e);\n\t\t\t}\n\n\t\t\tthis.signedAttr = new Asn1.Cms.AttributeTable(signedAttrs);\n\t\t}\n\n\t\tpublic void SetCertificates(\n\t\t\tIX509Store certificates)\n\t\t{\n\t\t\tthis.x509Certs = certificates;\n\t\t}\n\n\t\tpublic void SetCrls(\n\t\t\tIX509Store crls)\n\t\t{\n\t\t\tthis.x509Crls = crls;\n\t\t}\n\n\t\tpublic void SetAccuracySeconds(\n\t\t\tint accuracySeconds)\n\t\t{\n\t\t\tthis.accuracySeconds = accuracySeconds;\n\t\t}\n\n\t\tpublic void SetAccuracyMillis(\n\t\t\tint accuracyMillis)\n\t\t{\n\t\t\tthis.accuracyMillis = accuracyMillis;\n\t\t}\n\n\t\tpublic void SetAccuracyMicros(\n\t\t\tint accuracyMicros)\n\t\t{\n\t\t\tthis.accuracyMicros = accuracyMicros;\n\t\t}\n\n\t\tpublic void SetOrdering(\n\t\t\tbool ordering)\n\t\t{\n\t\t\tthis.ordering = ordering;\n\t\t}\n\n\t\tpublic void SetTsa(\n\t\t\tGeneralName tsa)\n\t\t{\n\t\t\tthis.tsa = tsa;\n\t\t}\n\n\t\t//------------------------------------------------------------------------------\n\n\t\tpublic TimeStampToken Generate(\n\t\t\tTimeStampRequest\trequest,\n\t\t\tBigInteger\t\t\tserialNumber,\n\t\t\tDateTime\t\t\tgenTime)\n\t\t{\n\t\t\tDerObjectIdentifier digestAlgOID = new DerObjectIdentifier(request.MessageImprintAlgOid);\n\n\t\t\tAlgorithmIdentifier algID = new AlgorithmIdentifier(digestAlgOID, DerNull.Instance);\n\t\t\tMessageImprint messageImprint = new MessageImprint(algID, request.GetMessageImprintDigest());\n\n\t\t\tAccuracy accuracy = null;\n\t\t\tif (accuracySeconds > 0 || accuracyMillis > 0 || accuracyMicros > 0)\n\t\t\t{\n\t\t\t\tDerInteger seconds = null;\n\t\t\t\tif (accuracySeconds > 0)\n\t\t\t\t{\n\t\t\t\t\tseconds = new DerInteger(accuracySeconds);\n\t\t\t\t}\n\n\t\t\t\tDerInteger millis = null;\n\t\t\t\tif (accuracyMillis > 0)\n\t\t\t\t{\n\t\t\t\t\tmillis = new DerInteger(accuracyMillis);\n\t\t\t\t}\n\n\t\t\t\tDerInteger micros = null;\n\t\t\t\tif (accuracyMicros > 0)\n\t\t\t\t{\n\t\t\t\t\tmicros = new DerInteger(accuracyMicros);\n\t\t\t\t}\n\n\t\t\t\taccuracy = new Accuracy(seconds, millis, micros);\n\t\t\t}\n\n\t\t\tDerBoolean derOrdering = null;\n\t\t\tif (ordering)\n\t\t\t{\n\t\t\t\tderOrdering = DerBoolean.GetInstance(ordering);\n\t\t\t}\n\n\t\t\tDerInteger nonce = null;\n\t\t\tif (request.Nonce != null)\n\t\t\t{\n\t\t\t\tnonce = new DerInteger(request.Nonce);\n\t\t\t}\n\n\t\t\tDerObjectIdentifier tsaPolicy = new DerObjectIdentifier(tsaPolicyOID);\n\t\t\tif (request.ReqPolicy != null)\n\t\t\t{\n\t\t\t\ttsaPolicy = new DerObjectIdentifier(request.ReqPolicy);\n\t\t\t}\n\n\t\t\tTstInfo tstInfo = new TstInfo(tsaPolicy, messageImprint,\n\t\t\t\tnew DerInteger(serialNumber), new DerGeneralizedTime(genTime), accuracy,\n\t\t\t\tderOrdering, nonce, tsa, request.Extensions);\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tCmsSignedDataGenerator signedDataGenerator = new CmsSignedDataGenerator();\n\n\t\t\t\tbyte[] derEncodedTstInfo = tstInfo.GetDerEncoded();\n\n\t\t\t\tif (request.CertReq)\n\t\t\t\t{\n\t\t\t\t\tsignedDataGenerator.AddCertificates(x509Certs);\n\t\t\t\t}\n\n\t\t\t\tsignedDataGenerator.AddCrls(x509Crls);\n\t\t\t\tsignedDataGenerator.AddSigner(key, cert, digestOID, signedAttr, unsignedAttr);\n\n\t\t\t\tCmsSignedData signedData = signedDataGenerator.Generate(\n\t\t\t\t\tPkcsObjectIdentifiers.IdCTTstInfo.Id,\n\t\t\t\t\tnew CmsProcessableByteArray(derEncodedTstInfo),\n\t\t\t\t\ttrue);\n\n\t\t\t\treturn new TimeStampToken(signedData);\n\t\t\t}\n\t\t\tcatch (CmsException cmsEx)\n\t\t\t{\n\t\t\t\tthrow new TspException(\"Error generating time-stamp token\", cmsEx);\n\t\t\t}\n\t\t\tcatch (IOException e)\n\t\t\t{\n\t\t\t\tthrow new TspException(\"Exception encoding info\", e);\n\t\t\t}\n\t\t\tcatch (X509StoreException e)\n\t\t\t{\n\t\t\t\tthrow new TspException(\"Exception handling CertStore\", e);\n\t\t\t}\n//\t\t\tcatch (InvalidAlgorithmParameterException e)\n//\t\t\t{\n//\t\t\t\tthrow new TspException(\"Exception handling CertStore CRLs\", e);\n//\t\t\t}\n\t\t}\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "\t/// <summary>Class which represents the entity 'SalesTaxRate', mapped on table 'AdventureWorks.Sales.SalesTaxRate'.</summary>\n\t[Table(Name=\"[Sales].[SalesTaxRate]\")]\n\tpublic partial class SalesTaxRate : INotifyPropertyChanging, INotifyPropertyChanged\n\t{\n\t\t#region Events\n\t\t/// <summary>Event which is raised when a property value is changing.</summary>\n\t\tpublic event PropertyChangingEventHandler PropertyChanging;\n\t\t/// <summary>Event which is raised when a property value changes.</summary>\n\t\tpublic event PropertyChangedEventHandler PropertyChanged;\n\t\t#endregion\n\t\t\n\t\t#region Class Member Declarations\n\t\tprivate System.DateTime\t_modifiedDate;\n\t\tprivate System.String\t_name;\n\t\tprivate System.Guid\t_rowguid;\n\t\tprivate System.Int32\t_salesTaxRateId;\n\t\tprivate System.Int32\t_stateProvinceId;\n\t\tprivate System.Decimal\t_taxRate;\n\t\tprivate System.Byte\t_taxType;\n\t\tprivate EntityRef <StateProvince> _stateProvince;\n\t\t#endregion\n\t\t\n\t\t#region Extensibility Method Definitions\n\t\tpartial void OnLoaded();\n\t\tpartial void OnValidate(System.Data.Linq.ChangeAction action);\n\t\tpartial void OnCreated();\n\t\tpartial void OnModifiedDateChanging(System.DateTime value);\n\t\tpartial void OnModifiedDateChanged();\n\t\tpartial void OnNameChanging(System.String value);\n\t\tpartial void OnNameChanged();\n\t\tpartial void OnRowguidChanging(System.Guid value);\n\t\tpartial void OnRowguidChanged();\n\t\tpartial void OnSalesTaxRateIdChanging(System.Int32 value);\n\t\tpartial void OnSalesTaxRateIdChanged();\n\t\tpartial void OnStateProvinceIdChanging(System.Int32 value);\n\t\tpartial void OnStateProvinceIdChanged();\n\t\tpartial void OnTaxRateChanging(System.Decimal value);\n\t\tpartial void OnTaxRateChanged();\n\t\tpartial void OnTaxTypeChanging(System.Byte value);\n\t\tpartial void OnTaxTypeChanged();\n\t\t#endregion\n\t\t\n\t\t/// <summary>Initializes a new instance of the <see cref=\"SalesTaxRate\"/> class.</summary>\n\t\tpublic SalesTaxRate()\n\t\t{\n\t\t\t_stateProvince = default(EntityRef<StateProvince>);\n\t\t\tOnCreated();\n\t\t}\n\n\t\t/// <summary>Raises the PropertyChanging event</summary>\n\t\t/// <param name=\"propertyName\">name of the property which is changing</param>\n\t\tprotected virtual void SendPropertyChanging(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanging != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Raises the PropertyChanged event for the property specified</summary>\n\t\t/// <param name=\"propertyName\">name of the property which was changed</param>\n\t\tprotected virtual void SendPropertyChanged(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanged != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t#region Class Property Declarations\n\t\t/// <summary>Gets or sets the ModifiedDate field. Mapped on target field 'ModifiedDate'. </summary>\n\t\t[Column(Name=\"ModifiedDate\", Storage=\"_modifiedDate\", CanBeNull=false, DbType=\"datetime NOT NULL\")]\n\t\tpublic System.DateTime ModifiedDate\n\t\t{\n\t\t\tget\t{ return _modifiedDate; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_modifiedDate != value))\n\t\t\t\t{\n\t\t\t\t\tOnModifiedDateChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ModifiedDate\");\n\t\t\t\t\t_modifiedDate = value;\n\t\t\t\t\tSendPropertyChanged(\"ModifiedDate\");\n\t\t\t\t\tOnModifiedDateChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Name field. Mapped on target field 'Name'. </summary>\n\t\t[Column(Name=\"Name\", Storage=\"_name\", CanBeNull=false, DbType=\"nvarchar(50) NOT NULL\")]\n\t\tpublic System.String Name\n\t\t{\n\t\t\tget\t{ return _name; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_name != value))\n\t\t\t\t{\n\t\t\t\t\tOnNameChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Name\");\n\t\t\t\t\t_name = value;\n\t\t\t\t\tSendPropertyChanged(\"Name\");\n\t\t\t\t\tOnNameChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Rowguid field. Mapped on target field 'rowguid'. </summary>\n\t\t[Column(Name=\"rowguid\", Storage=\"_rowguid\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"uniqueidentifier NOT NULL\", IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.Guid Rowguid\n\t\t{\n\t\t\tget\t{ return _rowguid; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_rowguid != value))\n\t\t\t\t{\n\t\t\t\t\tOnRowguidChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Rowguid\");\n\t\t\t\t\t_rowguid = value;\n\t\t\t\t\tSendPropertyChanged(\"Rowguid\");\n\t\t\t\t\tOnRowguidChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the SalesTaxRateId field. Mapped on target field 'SalesTaxRateID'. </summary>\n\t\t[Column(Name=\"SalesTaxRateID\", Storage=\"_salesTaxRateId\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"int NOT NULL IDENTITY\", IsPrimaryKey=true, IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.Int32 SalesTaxRateId\n\t\t{\n\t\t\tget\t{ return _salesTaxRateId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_salesTaxRateId != value))\n\t\t\t\t{\n\t\t\t\t\tOnSalesTaxRateIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"SalesTaxRateId\");\n\t\t\t\t\t_salesTaxRateId = value;\n\t\t\t\t\tSendPropertyChanged(\"SalesTaxRateId\");\n\t\t\t\t\tOnSalesTaxRateIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the StateProvinceId field. Mapped on target field 'StateProvinceID'. </summary>\n\t\t[Column(Name=\"StateProvinceID\", Storage=\"_stateProvinceId\", CanBeNull=false, DbType=\"int NOT NULL\")]\n\t\tpublic System.Int32 StateProvinceId\n\t\t{\n\t\t\tget\t{ return _stateProvinceId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_stateProvinceId != value))\n\t\t\t\t{\n\t\t\t\t\tif(_stateProvince.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnStateProvinceIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"StateProvinceId\");\n\t\t\t\t\t_stateProvinceId = value;\n\t\t\t\t\tSendPropertyChanged(\"StateProvinceId\");\n\t\t\t\t\tOnStateProvinceIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the TaxRate field. Mapped on target field 'TaxRate'. </summary>\n\t\t[Column(Name=\"TaxRate\", Storage=\"_taxRate\", CanBeNull=false, DbType=\"smallmoney NOT NULL\")]\n\t\tpublic System.Decimal TaxRate\n\t\t{\n\t\t\tget\t{ return _taxRate; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_taxRate != value))\n\t\t\t\t{\n\t\t\t\t\tOnTaxRateChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"TaxRate\");\n\t\t\t\t\t_taxRate = value;\n\t\t\t\t\tSendPropertyChanged(\"TaxRate\");\n\t\t\t\t\tOnTaxRateChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the TaxType field. Mapped on target field 'TaxType'. </summary>\n\t\t[Column(Name=\"TaxType\", Storage=\"_taxType\", CanBeNull=false, DbType=\"tinyint NOT NULL\")]\n\t\tpublic System.Byte TaxType\n\t\t{\n\t\t\tget\t{ return _taxType; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_taxType != value))\n\t\t\t\t{\n\t\t\t\t\tOnTaxTypeChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"TaxType\");\n\t\t\t\t\t_taxType = value;\n\t\t\t\t\tSendPropertyChanged(\"TaxType\");\n\t\t\t\t\tOnTaxTypeChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'SalesTaxRate.StateProvince - StateProvince.SalesTaxRates (m:1)'</summary>\n\t\t[Association(Name=\"SalesTaxRate_StateProvince2631d9a0bd4a4b9989375b6925a20368\", Storage=\"_stateProvince\", ThisKey=\"StateProvinceId\", IsForeignKey=true)] \n\t\tpublic StateProvince StateProvince\n\t\t{\n\t\t\tget { return _stateProvince.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tStateProvince previousValue = _stateProvince.Entity;\n\t\t\t\tif((previousValue != value) || (_stateProvince.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"StateProvince\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_stateProvince.Entity = null;\n\t\t\t\t\t\tpreviousValue.SalesTaxRates.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_stateProvince.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_stateProvinceId = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.SalesTaxRates.Add(this);\n\t\t\t\t\t\t_stateProvinceId = value.StateProvinceId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"StateProvince\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#endregion\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "\n    /// <summary>\n    /// This is the base class for analyzers which examine the <c>&lt;summary&gt;</c> text of a documentation comment.\n    /// </summary>\n    internal abstract class ElementDocumentationSummaryBase : DiagnosticAnalyzer\n    {\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> typeDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> methodDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> constructorDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> destructorDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> propertyDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> indexerDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> fieldDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> delegateDeclarationAction;\n        private readonly Action<SyntaxNodeAnalysisContext, StyleCopSettings> eventDeclarationAction;\n\n        protected ElementDocumentationSummaryBase()\n        {\n            this.typeDeclarationAction = this.HandleTypeDeclaration;\n            this.methodDeclarationAction = this.HandleMethodDeclaration;\n            this.constructorDeclarationAction = this.HandleConstructorDeclaration;\n            this.destructorDeclarationAction = this.HandleDestructorDeclaration;\n            this.propertyDeclarationAction = this.HandlePropertyDeclaration;\n            this.indexerDeclarationAction = this.HandleIndexerDeclaration;\n            this.fieldDeclarationAction = this.HandleFieldDeclaration;\n            this.delegateDeclarationAction = this.HandleDelegateDeclaration;\n            this.eventDeclarationAction = this.HandleEventDeclaration;\n        }\n\n        /// <inheritdoc/>\n        public override void Initialize(AnalysisContext context)\n        {\n            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);\n            context.EnableConcurrentExecution();\n\n            context.RegisterSyntaxNodeAction(this.typeDeclarationAction, SyntaxKinds.BaseTypeDeclaration);\n            context.RegisterSyntaxNodeAction(this.methodDeclarationAction, SyntaxKind.MethodDeclaration);\n            context.RegisterSyntaxNodeAction(this.constructorDeclarationAction, SyntaxKind.ConstructorDeclaration);\n            context.RegisterSyntaxNodeAction(this.destructorDeclarationAction, SyntaxKind.DestructorDeclaration);\n            context.RegisterSyntaxNodeAction(this.propertyDeclarationAction, SyntaxKind.PropertyDeclaration);\n            context.RegisterSyntaxNodeAction(this.indexerDeclarationAction, SyntaxKind.IndexerDeclaration);\n            context.RegisterSyntaxNodeAction(this.fieldDeclarationAction, SyntaxKinds.BaseFieldDeclaration);\n            context.RegisterSyntaxNodeAction(this.delegateDeclarationAction, SyntaxKind.DelegateDeclaration);\n            context.RegisterSyntaxNodeAction(this.eventDeclarationAction, SyntaxKind.EventDeclaration);\n        }\n\n        /// <summary>\n        /// Analyzes the top-level <c>&lt;summary&gt;</c> element of a documentation comment.\n        /// </summary>\n        /// <param name=\"context\">The current analysis context.</param>\n        /// <param name=\"needsComment\"><see langword=\"true\"/> if the current documentation settings indicate that the\n        /// element should be documented; otherwise, <see langword=\"false\"/>.</param>\n        /// <param name=\"documentation\">The documentation syntax associated with the element.</param>\n        /// <param name=\"syntax\">The <see cref=\"XmlElementSyntax\"/> or <see cref=\"XmlEmptyElementSyntax\"/> of the node\n        /// to examine.</param>\n        /// <param name=\"completeDocumentation\">The complete documentation for the declared symbol, with any\n        /// <c>&lt;include&gt;</c> elements expanded. If the XML documentation comment included a <c>&lt;summary&gt;</c>\n        /// element, this value will be <see langword=\"null\"/>, even if the XML documentation comment also included an\n        /// <c>&lt;include&gt;</c> element.</param>\n        /// <param name=\"diagnosticLocations\">The location(s) where diagnostics, if any, should be reported.</param>\n        protected abstract void HandleXmlElement(SyntaxNodeAnalysisContext context, bool needsComment, DocumentationCommentTriviaSyntax documentation, XmlNodeSyntax syntax, XElement completeDocumentation, params Location[] diagnosticLocations);\n\n        private void HandleTypeDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (BaseTypeDeclarationSyntax)context.Node;\n            if (node.Identifier.IsMissing)\n            {\n                return;\n            }\n\n            if (node.Modifiers.Any(SyntaxKind.PartialKeyword))\n            {\n                // partial elements are handled by PartialElementDocumentationSummaryBase\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.Identifier.GetLocation());\n        }\n\n        private void HandleDelegateDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (DelegateDeclarationSyntax)context.Node;\n            if (node.Identifier.IsMissing)\n            {\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.Identifier.GetLocation());\n        }\n\n        private void HandleMethodDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (MethodDeclarationSyntax)context.Node;\n            if (node.Identifier.IsMissing)\n            {\n                return;\n            }\n\n            if (node.Modifiers.Any(SyntaxKind.PartialKeyword))\n            {\n                // partial elements are handled by PartialElementDocumentationSummaryBase\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.Identifier.GetLocation());\n        }\n\n        private void HandleConstructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (ConstructorDeclarationSyntax)context.Node;\n            if (node.Identifier.IsMissing)\n            {\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.Identifier.GetLocation());\n        }\n\n        private void HandleDestructorDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (DestructorDeclarationSyntax)context.Node;\n            if (node.Identifier.IsMissing)\n            {\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.Identifier.GetLocation());\n        }\n\n        private void HandlePropertyDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (PropertyDeclarationSyntax)context.Node;\n            if (node.Identifier.IsMissing)\n            {\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.Identifier.GetLocation());\n        }\n\n        private void HandleIndexerDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (IndexerDeclarationSyntax)context.Node;\n            if (node.ThisKeyword.IsMissing)\n            {\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.ThisKeyword.GetLocation());\n        }\n\n        private void HandleFieldDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (BaseFieldDeclarationSyntax)context.Node;\n            if (node.Declaration == null)\n            {\n                return;\n            }\n\n            Location[] locations = new Location[node.Declaration.Variables.Count];\n\n            int insertionIndex = 0;\n\n            foreach (var variable in node.Declaration.Variables)\n            {\n                var identifier = variable.Identifier;\n                if (!identifier.IsMissing)\n                {\n                    locations[insertionIndex++] = identifier.GetLocation();\n                }\n            }\n\n            // PERF: Most of the time locations will have the correct size.\n            // The only case where it might be smaller is in invalid syntax like\n            // int i,;\n            Array.Resize(ref locations, insertionIndex);\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, locations);\n        }\n\n        private void HandleEventDeclaration(SyntaxNodeAnalysisContext context, StyleCopSettings settings)\n        {\n            var node = (EventDeclarationSyntax)context.Node;\n            if (node.Identifier.IsMissing)\n            {\n                return;\n            }\n\n            Accessibility declaredAccessibility = node.GetDeclaredAccessibility(context.SemanticModel, context.CancellationToken);\n            Accessibility effectiveAccessibility = node.GetEffectiveAccessibility(context.SemanticModel, context.CancellationToken);\n            bool needsComment = SA1600ElementsMustBeDocumented.NeedsComment(settings.DocumentationRules, node.Kind(), node.Parent.Kind(), declaredAccessibility, effectiveAccessibility);\n            this.HandleDeclaration(context, needsComment, node, node.Identifier.GetLocation());\n        }\n\n        private void HandleDeclaration(SyntaxNodeAnalysisContext context, bool needsComment, SyntaxNode node, params Location[] locations)\n        {\n            var documentation = node.GetDocumentationCommentTriviaSyntax();\n            if (documentation == null)\n            {\n                // missing documentation is reported by SA1600, SA1601, and SA1602\n                return;\n            }\n\n            XElement completeDocumentation = null;\n            var relevantXmlElement = documentation.Content.GetFirstXmlElement(XmlCommentHelper.SummaryXmlTag);\n            if (relevantXmlElement == null)\n            {\n                relevantXmlElement = documentation.Content.GetFirstXmlElement(XmlCommentHelper.IncludeXmlTag);\n                if (relevantXmlElement != null)\n                {\n                    var declaration = context.SemanticModel.GetDeclaredSymbol(node, context.CancellationToken);\n                    if (declaration == null)\n                    {\n                        return;\n                    }\n\n                    var rawDocumentation = declaration.GetDocumentationCommentXml(expandIncludes: true, cancellationToken: context.CancellationToken);\n                    completeDocumentation = XElement.Parse(rawDocumentation, LoadOptions.None);\n                }\n            }\n\n            this.HandleXmlElement(context, needsComment, documentation, relevantXmlElement, completeDocumentation, locations);\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    public class BaseRegion : Region\n    {\n        private static readonly List<Rectangle3D> m_RectBuffer1 = new List<Rectangle3D>();\n        private static readonly List<Rectangle3D> m_RectBuffer2 = new List<Rectangle3D>();\n        private static readonly List<Int32> m_SpawnBuffer1 = new List<Int32>();\n        private static readonly List<Item> m_SpawnBuffer2 = new List<Item>();\n        private bool m_ExcludeFromParentSpawns;\n        private Rectangle3D[] m_Rectangles;\n        private int[] m_RectangleWeights;\n        private string m_RuneName;\n        private SpawnEntry[] m_Spawns;\n        private int m_TotalWeight;\n\n        public BaseRegion(string name, Map map, int priority, params Rectangle2D[] area)\n            : base(name, map, priority, area)\n        {\n        }\n\n        public BaseRegion(string name, Map map, int priority, params Rectangle3D[] area)\n            : base(name, map, priority, area)\n        {\n        }\n\n        public BaseRegion(string name, Map map, Region parent, params Rectangle2D[] area)\n            : base(name, map, parent, area)\n        {\n        }\n\n        public BaseRegion(string name, Map map, Region parent, params Rectangle3D[] area)\n            : base(name, map, parent, area)\n        {\n        }\n\n        public BaseRegion(XmlElement xml, Map map, Region parent)\n            : base(xml, map, parent)\n        {\n            ReadString(xml[\"rune\"], \"name\", ref m_RuneName, false);\n\n            var logoutDelayActive = true;\n            ReadBoolean(xml[\"logoutDelay\"], \"active\", ref logoutDelayActive, false);\n            NoLogoutDelay = !logoutDelayActive;\n\n            var spawning = xml[\"spawning\"];\n            if (spawning != null)\n            {\n                ReadBoolean(spawning, \"excludeFromParent\", ref m_ExcludeFromParentSpawns, false);\n\n                var zLevel = SpawnZLevel.Lowest;\n                ReadEnum(spawning, \"zLevel\", ref zLevel, false);\n                SpawnZLevel = zLevel;\n\n                var list = new List<SpawnEntry>();\n\n                foreach (XmlNode node in spawning.ChildNodes)\n                {\n                    var el = node as XmlElement;\n\n                    if (el != null)\n                    {\n                        var def = SpawnDefinition.GetSpawnDefinition(el);\n                        if (def == null)\n                            continue;\n\n                        var id = 0;\n                        if (!ReadInt32(el, \"id\", ref id, true))\n                            continue;\n\n                        var amount = 0;\n                        if (!ReadInt32(el, \"amount\", ref amount, true))\n                            continue;\n\n                        var minSpawnTime = SpawnEntry.DefaultMinSpawnTime;\n                        ReadTimeSpan(el, \"minSpawnTime\", ref minSpawnTime, false);\n\n                        var maxSpawnTime = SpawnEntry.DefaultMaxSpawnTime;\n                        ReadTimeSpan(el, \"maxSpawnTime\", ref maxSpawnTime, false);\n\n                        var home = Point3D.Zero;\n                        var range = 0;\n\n                        var homeEl = el[\"home\"];\n                        if (ReadPoint3D(homeEl, map, ref home, false))\n                            ReadInt32(homeEl, \"range\", ref range, false);\n\n                        var dir = SpawnEntry.InvalidDirection;\n                        ReadEnum(el[\"direction\"], \"value\", ref dir, false);\n\n                        var entry = new SpawnEntry(id, this, home, range, dir, def, amount, minSpawnTime, maxSpawnTime);\n                        list.Add(entry);\n                    }\n                }\n\n                if (list.Count > 0)\n                {\n                    m_Spawns = list.ToArray();\n                }\n            }\n        }\n\n        public virtual bool YoungProtected\n        {\n            get { return true; }\n        }\n\n        public string RuneName\n        {\n            get { return m_RuneName; }\n            set { m_RuneName = value; }\n        }\n\n        public bool NoLogoutDelay { get; set; }\n\n        public SpawnEntry[] Spawns\n        {\n            get { return m_Spawns; }\n            set\n            {\n                if (m_Spawns != null)\n                {\n                    for (var i = 0; i < m_Spawns.Length; i++)\n                        m_Spawns[i].Delete();\n                }\n\n                m_Spawns = value;\n            }\n        }\n\n        public SpawnZLevel SpawnZLevel { get; set; }\n\n        public bool ExcludeFromParentSpawns\n        {\n            get { return m_ExcludeFromParentSpawns; }\n            set { m_ExcludeFromParentSpawns = value; }\n        }\n\n        public static void Configure()\n        {\n            DefaultRegionType = typeof (BaseRegion);\n        }\n\n        public static string GetRuneNameFor(Region region)\n        {\n            while (region != null)\n            {\n                var br = region as BaseRegion;\n\n                if (br != null && br.m_RuneName != null)\n                    return br.m_RuneName;\n\n                if (br != null && br.Name != null)\n                    return br.Name;\n\n                region = region.Parent;\n            }\n\n            return null;\n        }\n\n        public static bool CanSpawn(Region region, params Type[] types)\n        {\n            while (region != null)\n            {\n                if (!region.AllowSpawn())\n                    return false;\n\n                var br = region as BaseRegion;\n\n                if (br != null)\n                {\n                    if (br.Spawns != null)\n                    {\n                        for (var i = 0; i < br.Spawns.Length; i++)\n                        {\n                            var entry = br.Spawns[i];\n\n                            if (entry.Definition.CanSpawn(types))\n                                return true;\n                        }\n                    }\n\n                    if (br.ExcludeFromParentSpawns)\n                        return false;\n                }\n\n                region = region.Parent;\n            }\n\n            return false;\n        }\n\n        public override void OnUnregister()\n        {\n            base.OnUnregister();\n\n            Spawns = null;\n        }\n\n        public override TimeSpan GetLogoutDelay(Mobile m)\n        {\n            if (NoLogoutDelay)\n            {\n                if (m.Aggressors.Count == 0 && m.Aggressed.Count == 0 && !m.Criminal)\n                    return TimeSpan.Zero;\n            }\n\n            return base.GetLogoutDelay(m);\n        }\n\n        public override void OnEnter(Mobile m)\n        {\n            if (m is PlayerMobile && ((PlayerMobile) m).Young)\n            {\n                if (!YoungProtected)\n                {\n                    m.SendGump(new YoungDungeonWarning());\n                }\n            }\n        }\n\n        public override bool AcceptsSpawnsFrom(Region region)\n        {\n            if (region == this || !m_ExcludeFromParentSpawns)\n                return base.AcceptsSpawnsFrom(region);\n\n            return false;\n        }\n\n        public Point3D RandomSpawnLocation(int spawnHeight, bool land, bool water, Point3D home, int range)\n        {\n            var map = Map;\n\n            if (map == Map.Internal)\n                return Point3D.Zero;\n\n            InitRectangles();\n\n            if (m_TotalWeight <= 0)\n                return Point3D.Zero;\n\n            for (var i = 0; i < 10; i++) // Try 10 times\n            {\n                int x, y, minZ, maxZ;\n\n                if (home == Point3D.Zero)\n                {\n                    var rand = Utility.Random(m_TotalWeight);\n\n                    x = int.MinValue;\n                    y = int.MinValue;\n                    minZ = int.MaxValue;\n                    maxZ = int.MinValue;\n                    for (var j = 0; j < m_RectangleWeights.Length; j++)\n                    {\n                        var curWeight = m_RectangleWeights[j];\n\n                        if (rand < curWeight)\n                        {\n                            var rect = m_Rectangles[j];\n\n                            x = rect.Start.X + rand%rect.Width;\n                            y = rect.Start.Y + rand/rect.Width;\n\n                            minZ = rect.Start.Z;\n                            maxZ = rect.End.Z;\n\n                            break;\n                        }\n\n                        rand -= curWeight;\n                    }\n                }\n                else\n                {\n                    x = Utility.RandomMinMax(home.X - range, home.X + range);\n                    y = Utility.RandomMinMax(home.Y - range, home.Y + range);\n\n                    minZ = int.MaxValue;\n                    maxZ = int.MinValue;\n                    for (var j = 0; j < Area.Length; j++)\n                    {\n                        var rect = Area[j];\n\n                        if (x >= rect.Start.X && x < rect.End.X && y >= rect.Start.Y && y < rect.End.Y)\n                        {\n                            minZ = rect.Start.Z;\n                            maxZ = rect.End.Z;\n                            break;\n                        }\n                    }\n\n                    if (minZ == int.MaxValue)\n                        continue;\n                }\n\n                if (x < 0 || y < 0 || x >= map.Width || y >= map.Height)\n                    continue;\n\n                var lt = map.Tiles.GetLandTile(x, y);\n\n                int ltLowZ = 0, ltAvgZ = 0, ltTopZ = 0;\n                map.GetAverageZ(x, y, ref ltLowZ, ref ltAvgZ, ref ltTopZ);\n\n                var ltFlags = TileData.LandTable[lt.ID & TileData.MaxLandValue].Flags;\n                var ltImpassable = ((ltFlags & TileFlag.Impassable) != 0);\n\n                if (!lt.Ignored && ltAvgZ >= minZ && ltAvgZ < maxZ)\n                    if ((ltFlags & TileFlag.Wet) != 0)\n                    {\n                        if (water)\n                            m_SpawnBuffer1.Add(ltAvgZ);\n                    }\n                    else if (land && !ltImpassable)\n                        m_SpawnBuffer1.Add(ltAvgZ);\n\n                var staticTiles = map.Tiles.GetStaticTiles(x, y, true);\n\n                for (var j = 0; j < staticTiles.Length; j++)\n                {\n                    var tile = staticTiles[j];\n                    var id = TileData.ItemTable[tile.ID & TileData.MaxItemValue];\n                    var tileZ = tile.Z + id.CalcHeight;\n\n                    if (tileZ >= minZ && tileZ < maxZ)\n                        if ((id.Flags & TileFlag.Wet) != 0)\n                        {\n                            if (water)\n                                m_SpawnBuffer1.Add(tileZ);\n                        }\n                        else if (land && id.Surface && !id.Impassable)\n                            m_SpawnBuffer1.Add(tileZ);\n                }\n\n                var sector = map.GetSector(x, y);\n\n                for (var j = 0; j < sector.Items.Count; j++)\n                {\n                    var item = sector.Items[j];\n\n                    if (!(item is BaseMulti) && item.ItemID <= TileData.MaxItemValue && item.AtWorldPoint(x, y))\n                    {\n                        m_SpawnBuffer2.Add(item);\n\n                        if (!item.Movable)\n                        {\n                            var id = item.ItemData;\n                            var itemZ = item.Z + id.CalcHeight;\n\n                            if (itemZ >= minZ && itemZ < maxZ)\n                                if ((id.Flags & TileFlag.Wet) != 0)\n                                {\n                                    if (water)\n                                        m_SpawnBuffer1.Add(itemZ);\n                                }\n                                else if (land && id.Surface && !id.Impassable)\n                                    m_SpawnBuffer1.Add(itemZ);\n                        }\n                    }\n                }\n\n                if (m_SpawnBuffer1.Count == 0)\n                {\n                    m_SpawnBuffer1.Clear();\n                    m_SpawnBuffer2.Clear();\n                    continue;\n                }\n\n                int z;\n                switch (SpawnZLevel)\n                {\n                    case SpawnZLevel.Lowest:\n                    {\n                        z = int.MaxValue;\n\n                        for (var j = 0; j < m_SpawnBuffer1.Count; j++)\n                        {\n                            var l = m_SpawnBuffer1[j];\n\n                            if (l < z)\n                                z = l;\n                        }\n\n                        break;\n                    }\n                    case SpawnZLevel.Highest:\n                    {\n                        z = int.MinValue;\n\n                        for (var j = 0; j < m_SpawnBuffer1.Count; j++)\n                        {\n                            var l = m_SpawnBuffer1[j];\n\n                            if (l > z)\n                                z = l;\n                        }\n\n                        break;\n                    }\n                    default: // SpawnZLevel.Random\n                    {\n                        var index = Utility.Random(m_SpawnBuffer1.Count);\n                        z = m_SpawnBuffer1[index];\n\n                        break;\n                    }\n                }\n\n                m_SpawnBuffer1.Clear();\n\n                if (!Find(new Point3D(x, y, z), map).AcceptsSpawnsFrom(this))\n                {\n                    m_SpawnBuffer2.Clear();\n                    continue;\n                }\n\n                var top = z + spawnHeight;\n\n                var ok = true;\n                for (var j = 0; j < m_SpawnBuffer2.Count; j++)\n                {\n                    var item = m_SpawnBuffer2[j];\n                    var id = item.ItemData;\n\n                    if ((id.Surface || id.Impassable) && item.Z + id.CalcHeight > z && item.Z < top)\n                    {\n                        ok = false;\n                        break;\n                    }\n                }\n\n                m_SpawnBuffer2.Clear();\n\n                if (!ok)\n                    continue;\n\n                if (ltImpassable && ltAvgZ > z && ltLowZ < top)\n                    continue;\n\n                for (var j = 0; j < staticTiles.Length; j++)\n                {\n                    var tile = staticTiles[j];\n                    var id = TileData.ItemTable[tile.ID & TileData.MaxItemValue];\n\n                    if ((id.Surface || id.Impassable) && tile.Z + id.CalcHeight > z && tile.Z < top)\n                    {\n                        ok = false;\n                        break;\n                    }\n                }\n\n                if (!ok)\n                    continue;\n\n                for (var j = 0; j < sector.Mobiles.Count; j++)\n                {\n                    var m = sector.Mobiles[j];\n\n                    if (m.X == x && m.Y == y && (m.IsPlayer() || !m.Hidden))\n                        if (m.Z + 16 > z && m.Z < top)\n                        {\n                            ok = false;\n                            break;\n                        }\n                }\n\n                if (ok)\n                    return new Point3D(x, y, z);\n            }\n\n            return Point3D.Zero;\n        }\n\n        public override string ToString()\n        {\n            if (Name != null)\n                return Name;\n            if (RuneName != null)\n                return RuneName;\n            return GetType().Name;\n        }\n\n        private void InitRectangles()\n        {\n            if (m_Rectangles != null)\n                return;\n\n            // Test if area rectangles are overlapping, and in that case break them into smaller non overlapping rectangles\n            for (var i = 0; i < Area.Length; i++)\n            {\n                m_RectBuffer2.Add(Area[i]);\n\n                for (var j = 0; j < m_RectBuffer1.Count && m_RectBuffer2.Count > 0; j++)\n                {\n                    var comp = m_RectBuffer1[j];\n\n                    for (var k = m_RectBuffer2.Count - 1; k >= 0; k--)\n                    {\n                        var rect = m_RectBuffer2[k];\n\n                        int l1 = rect.Start.X, r1 = rect.End.X, t1 = rect.Start.Y, b1 = rect.End.Y;\n                        int l2 = comp.Start.X, r2 = comp.End.X, t2 = comp.Start.Y, b2 = comp.End.Y;\n\n                        if (l1 < r2 && r1 > l2 && t1 < b2 && b1 > t2)\n                        {\n                            m_RectBuffer2.RemoveAt(k);\n\n                            var sz = rect.Start.Z;\n                            var ez = rect.End.X;\n\n                            if (l1 < l2)\n                            {\n                                m_RectBuffer2.Add(new Rectangle3D(new Point3D(l1, t1, sz), new Point3D(l2, b1, ez)));\n                            }\n\n                            if (r1 > r2)\n                            {\n                                m_RectBuffer2.Add(new Rectangle3D(new Point3D(r2, t1, sz), new Point3D(r1, b1, ez)));\n                            }\n\n                            if (t1 < t2)\n                            {\n                                m_RectBuffer2.Add(new Rectangle3D(new Point3D(Math.Max(l1, l2), t1, sz),\n                                    new Point3D(Math.Min(r1, r2), t2, ez)));\n                            }\n\n                            if (b1 > b2)\n                            {\n                                m_RectBuffer2.Add(new Rectangle3D(new Point3D(Math.Max(l1, l2), b2, sz),\n                                    new Point3D(Math.Min(r1, r2), b1, ez)));\n                            }\n                        }\n                    }\n                }\n\n                m_RectBuffer1.AddRange(m_RectBuffer2);\n                m_RectBuffer2.Clear();\n            }\n\n            m_Rectangles = m_RectBuffer1.ToArray();\n            m_RectBuffer1.Clear();\n\n            m_RectangleWeights = new int[m_Rectangles.Length];\n            for (var i = 0; i < m_Rectangles.Length; i++)\n            {\n                var rect = m_Rectangles[i];\n                var weight = rect.Width*rect.Height;\n\n                m_RectangleWeights[i] = weight;\n                m_TotalWeight += weight;\n            }\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "#endif\n\n        /// <summary>\n        /// A collection reader scope; keeping track of the current reader state and an item associated with this state.\n        /// </summary>\n        protected sealed class Scope\n        {\n            /// <summary>The reader state of this scope.</summary>\n            private readonly ODataCollectionReaderState state;\n\n            /// <summary>The item attached to this scope.</summary>\n            private readonly object item;\n\n            /// <summary>True, if the collection element attached to this scope is empty. False otherwise.</summary>\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1823\", Justification = \"isCollectionElementEmpty is used in debug.\")]\n            private readonly bool isCollectionElementEmpty;\n\n            /// <summary>\n            /// Constructor creating a new reader scope.\n            /// </summary>\n            /// <param name=\"state\">The reader state of this scope.</param>\n            /// <param name=\"item\">The item attached to this scope.</param>\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\", Justification = \"Debug.Assert check only.\")]\n            public Scope(ODataCollectionReaderState state, object item) : this(state, item, false)\n            {\n            }\n\n            /// <summary>\n            /// Constructor creating a new reader scope.\n            /// </summary>\n            /// <param name=\"state\">The reader state of this scope.</param>\n            /// <param name=\"item\">The item attached to this scope.</param>\n            /// <param name=\"isCollectionElementEmpty\">The state of the collection element - empty or not-empty</param>\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\", Justification = \"Debug.Assert check only.\")]\n            public Scope(ODataCollectionReaderState state, object item, bool isCollectionElementEmpty)\n            {\n                Debug.Assert(\n                   state == ODataCollectionReaderState.Start && item == null ||\n                   state == ODataCollectionReaderState.CollectionStart && item is ODataCollectionStart ||\n                   state == ODataCollectionReaderState.Value && (item == null || EdmLibraryExtensions.IsPrimitiveType(item.GetType()) || item is ODataEnumValue) ||\n                   state == ODataCollectionReaderState.CollectionEnd && item is ODataCollectionStart ||\n                   state == ODataCollectionReaderState.Exception && item == null ||\n                   state == ODataCollectionReaderState.Completed && item == null,\n                   \"Reader state and associated item do not match.\");\n\n                this.state = state;\n                this.item = item;\n                this.isCollectionElementEmpty = isCollectionElementEmpty;\n\n\n                // When isCollectionElementEmpty is true, Reader needs to be in CollectionStart state.\n                Debug.Assert(!this.isCollectionElementEmpty ||\n                        (this.isCollectionElementEmpty && state == ODataCollectionReaderState.CollectionStart),\n                        \"Expected state to be CollectionStart if isCollectionElementyEmpty is true.\");\n            }\n\n            /// <summary>\n            /// The reader state of this scope.\n            /// </summary>\n            public ODataCollectionReaderState State\n            {\n                get\n                {\n                    return this.state;\n                }\n            }\n\n            /// <summary>\n            /// The item attached to this scope.\n            /// </summary>\n            public object Item\n            {\n                get\n                {\n                    return this.item;\n                }\n            }\n        }\n\n        /// <summary>\n        /// A writer scope; keeping track of the current writer state and an item associated with this state.\n        /// </summary>\n        private sealed class Scope\n        {\n            /// <summary>The writer state of this scope.</summary>\n            private readonly CollectionWriterState state;\n\n            /// <summary>The item attached to this scope.</summary>\n            private readonly object item;\n\n            /// <summary>\n            /// Constructor creating a new writer scope.\n            /// </summary>\n            /// <param name=\"state\">The writer state of this scope.</param>\n            /// <param name=\"item\">The item attached to this scope.</param>\n            public Scope(CollectionWriterState state, object item)\n            {\n                this.state = state;\n                this.item = item;\n            }\n\n            /// <summary>\n            /// The writer state of this scope.\n            /// </summary>\n            public CollectionWriterState State\n            {\n                get\n                {\n                    return this.state;\n                }\n            }\n\n            /// <summary>\n            /// The item attached to this scope.\n            /// </summary>\n            public object Item\n            {\n                get\n                {\n                    return this.item;\n                }\n            }\n        }\n#endif\n\n        /// <summary>\n        /// A parameter reader scope; keeping track of the current reader state and an item associated with this state.\n        /// </summary>\n        protected sealed class Scope\n        {\n            /// <summary>The reader state of this scope.</summary>\n            private readonly ODataParameterReaderState state;\n\n            /// <summary>The parameter name attached to this scope.</summary>\n            private readonly string name;\n\n            /// <summary>The parameter value attached to this scope.</summary>\n            private readonly object value;\n\n            /// <summary>\n            /// Constructor creating a new reader scope.\n            /// </summary>\n            /// <param name=\"state\">The reader state of this scope.</param>\n            /// <param name=\"name\">The parameter name attached to this scope.</param>\n            /// <param name=\"value\">The parameter value attached to this scope.</param>\n            public Scope(ODataParameterReaderState state, string name, object value)\n            {\n                Debug.Assert(\n                   state == ODataParameterReaderState.Start && name == null && value == null ||\n                   state == ODataParameterReaderState.Value && !string.IsNullOrEmpty(name) && (value == null || value is ODataEnumValue || EdmLibraryExtensions.IsPrimitiveType(value.GetType())) ||\n                   state == ODataParameterReaderState.Resource && !string.IsNullOrEmpty(name) && value == null ||\n                   state == ODataParameterReaderState.ResourceSet && !string.IsNullOrEmpty(name) && value == null ||\n                   state == ODataParameterReaderState.Collection && !string.IsNullOrEmpty(name) && value == null ||\n                   state == ODataParameterReaderState.Exception && name == null && value == null ||\n                   state == ODataParameterReaderState.Completed && name == null && value == null,\n                   \"Reader state and associated item do not match.\");\n\n                this.state = state;\n                this.name = name;\n                this.value = value;\n            }\n\n            /// <summary>\n            /// The reader state of this scope.\n            /// </summary>\n            public ODataParameterReaderState State\n            {\n                get\n                {\n                    return this.state;\n                }\n            }\n\n            /// <summary>\n            /// The parameter name attached to this scope.\n            /// </summary>\n            public string Name\n            {\n                get\n                {\n                    return this.name;\n                }\n            }\n\n            /// <summary>\n            /// The parameter value attached to this scope.\n            /// </summary>\n            public object Value\n            {\n                get\n                {\n                    return this.value;\n                }\n            }\n        }\n\n        /// <summary>\n        /// A reader scope; keeping track of the current reader state and an item associated with this state.\n        /// </summary>\n        protected internal class Scope\n        {\n            /// <summary>The reader state of this scope.</summary>\n            private readonly ODataReaderState state;\n\n            /// <summary>The item attached to this scope.</summary>\n            private readonly ODataItem item;\n\n            /// <summary>The odataUri parsed based on the context uri attached to this scope.</summary>\n            private readonly ODataUri odataUri;\n\n            /// <summary>\n            /// The <see cref=\"ResourceSetWithoutExpectedTypeValidator\"/> to use for entries in this resourceSet.\n            /// </summary>\n            private ResourceSetWithoutExpectedTypeValidator resourceTypeValidator;\n\n            /// <summary>\n            /// Constructor creating a new reader scope.\n            /// </summary>\n            /// <param name=\"state\">The reader state of this scope.</param>\n            /// <param name=\"item\">The item attached to this scope.</param>\n            /// <param name=\"odataUri\">The odataUri parsed based on the context uri for current scope</param>\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\", Justification = \"Debug.Assert check only.\")]\n            internal Scope(ODataReaderState state, ODataItem item, ODataUri odataUri)\n            {\n                Debug.Assert(\n                    state == ODataReaderState.Exception && item == null ||\n                    state == ODataReaderState.ResourceStart && (item == null || item is ODataResource) ||\n                    state == ODataReaderState.ResourceEnd && (item is ODataResource || item == null) ||\n                    state == ODataReaderState.Primitive && (item == null || item is ODataPrimitiveValue || item is ODataNullValue) ||\n                    state == ODataReaderState.Stream && (item == null || item is ODataStreamItem) ||\n                    state == ODataReaderState.NestedProperty && (item == null || item is ODataPropertyInfo) ||\n                    state == ODataReaderState.ResourceSetStart && item is ODataResourceSet ||\n                    state == ODataReaderState.ResourceSetEnd && item is ODataResourceSet ||\n                    state == ODataReaderState.NestedResourceInfoStart && item is ODataNestedResourceInfo ||\n                    state == ODataReaderState.NestedResourceInfoEnd && item is ODataNestedResourceInfo ||\n                    state == ODataReaderState.EntityReferenceLink && item is ODataEntityReferenceLink ||\n                    state == ODataReaderState.DeletedResourceStart && (item == null || item is ODataDeletedResource) ||\n                    state == ODataReaderState.DeletedResourceEnd && (item is ODataDeletedResource || item == null) ||\n                    state == ODataReaderState.DeltaResourceSetStart && item is ODataDeltaResourceSet ||\n                    state == ODataReaderState.DeltaResourceSetEnd && item is ODataDeltaResourceSet ||\n                    state == ODataReaderState.DeltaLink && (item == null || item is ODataDeltaLink) ||\n                    state == ODataReaderState.DeltaDeletedLink && (item == null || item is ODataDeltaDeletedLink) ||\n                    state == ODataReaderState.Start && item == null ||\n                    state == ODataReaderState.Completed && item == null,\n                    \"Reader state and associated item do not match.\");\n\n                this.state = state;\n                this.item = item;\n                this.odataUri = odataUri;\n            }\n\n            /// <summary>\n            /// Constructor creating a new reader scope.\n            /// </summary>\n            /// <param name=\"state\">The reader state of this scope.</param>\n            /// <param name=\"item\">The item attached to this scope.</param>\n            /// <param name=\"navigationSource\">The navigation source we are going to read entities for.</param>\n            /// <param name=\"expectedResourceTypeReference\">The expected resource type reference for the scope.</param>\n            /// <param name=\"odataUri\">The odataUri parsed based on the context uri for current scope</param>\n            /// <remarks>The <paramref name=\"expectedResourceTypeReference\"/> has the following meanings for given state:\n            /// Start -               it's the expected base type reference of the top-level resource or resources in the top-level resource set.\n            /// ResourceSetStart -           it's the expected base type reference of the resources in the resource set.\n            ///                       note that it might be a more derived type than the base type of the entity set for the resource set.\n            /// EntryStart -          it's the expected base type reference of the resource. If the resource has no type name specified\n            ///                       this type will be assumed. Otherwise the specified type name must be\n            ///                       the expected type or a more derived type.\n            /// NestedResourceInfoStart - it's the expected base type reference the entries in the expanded link (either the single resource\n            ///                       or entries in the expanded resource set).\n            /// EntityReferenceLink - it's null, no need for types on entity reference links.\n            /// In all cases the specified type must be an structured type.</remarks>\n            [SuppressMessage(\"Microsoft.Performance\", \"CA1800:DoNotCastUnnecessarily\", Justification = \"Debug.Assert check only.\")]\n            internal Scope(ODataReaderState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmTypeReference expectedResourceTypeReference, ODataUri odataUri)\n                : this(state, item, odataUri)\n            {\n                this.NavigationSource = navigationSource;\n                this.ResourceTypeReference = expectedResourceTypeReference;\n            }\n\n            /// <summary>\n            /// The reader state of this scope.\n            /// </summary>\n            internal ODataReaderState State\n            {\n                get\n                {\n                    return this.state;\n                }\n            }\n\n            /// <summary>\n            /// The item attached to this scope.\n            /// </summary>\n            internal ODataItem Item\n            {\n                get\n                {\n                    return this.item;\n                }\n            }\n\n            /// <summary>\n            /// The odataUri parsed based on the context url to this scope.\n            /// </summary>\n            internal ODataUri ODataUri\n            {\n                get\n                {\n                    return this.odataUri;\n                }\n            }\n\n            /// <summary>\n            /// The navigation source we are reading entries from (possibly null).\n            /// </summary>\n            internal IEdmNavigationSource NavigationSource { get; set; }\n\n            /// <summary>\n            /// The resource type for this scope. Can be either the expected one if the real one\n            /// was not found yet, or the one specified in the payload itself (the real one).\n            /// </summary>\n            internal IEdmType ResourceType\n            {\n                get\n                {\n                    if (this.ResourceTypeReference != null)\n                    {\n                        return ResourceTypeReference.Definition;\n                    }\n\n                    return null;\n                }\n            }\n\n            /// <summary>\n            /// The resource type reference for this scope. Can be either the expected one if the real one\n            /// was not found yet, or the one specified in the payload itself (the real one).\n            /// </summary>\n            internal IEdmTypeReference ResourceTypeReference { get; set; }\n\n            /// <summary>\n            /// Validator for resource type.\n            /// </summary>\n            internal ResourceSetWithoutExpectedTypeValidator ResourceTypeValidator\n            {\n                get\n                {\n                    return this.resourceTypeValidator;\n                }\n\n                set\n                {\n                    this.resourceTypeValidator = value;\n                }\n            }\n\n            /// <summary>\n            /// Gets or sets the derived type constraint validator.\n            /// </summary>\n            internal DerivedTypeValidator DerivedTypeValidator { get; set; }\n        }\n\n        /// <summary>\n        /// A writer scope; keeping track of the current writer state and an item associated with this state.\n        /// </summary>\n        internal class Scope\n        {\n            /// <summary>The writer state of this scope.</summary>\n            private readonly WriterState state;\n\n            /// <summary>The item attached to this scope.</summary>\n            private readonly ODataItem item;\n\n            /// <summary>Set to true if the content of the scope should not be written.</summary>\n            /// <remarks>This is used when writing navigation links which were not projected on the owning resource.</remarks>\n            private readonly bool skipWriting;\n\n            /// <summary>The selected properties for the current scope.</summary>\n            private readonly SelectedPropertiesNode selectedProperties;\n\n            /// <summary>The navigation source we are going to write entities for.</summary>\n            private IEdmNavigationSource navigationSource;\n\n            /// <summary>The structured type for the resources in the resourceSet to be written (or null if the entity set base type should be used).</summary>\n            private IEdmStructuredType resourceType;\n\n            /// <summary>The IEdmType of the item (may not be structured for primitive types).</summary>\n            private IEdmType itemType;\n\n            /// <summary>The odata uri info for current scope.</summary>\n            private ODataUri odataUri;\n\n            /// <summary>\n            /// Constructor creating a new writer scope.\n            /// </summary>\n            /// <param name=\"state\">The writer state of this scope.</param>\n            /// <param name=\"item\">The item attached to this scope.</param>\n            /// <param name=\"navigationSource\">The navigation source we are going to write resource set for.</param>\n            /// <param name=\"itemType\">The type for the items in the resource set to be written (or null if the entity set base type should be used).</param>\n            /// <param name=\"skipWriting\">true if the content of this scope should not be written.</param>\n            /// <param name=\"selectedProperties\">The selected properties of this scope.</param>\n            /// <param name=\"odataUri\">The ODataUri info of this scope.</param>\n            internal Scope(WriterState state, ODataItem item, IEdmNavigationSource navigationSource, IEdmType itemType, bool skipWriting, SelectedPropertiesNode selectedProperties, ODataUri odataUri)\n            {\n                this.state = state;\n                this.item = item;\n                this.itemType = itemType;\n                this.resourceType = itemType as IEdmStructuredType;\n                this.navigationSource = navigationSource;\n                this.skipWriting = skipWriting;\n                this.selectedProperties = selectedProperties;\n                this.odataUri = odataUri;\n            }\n\n            /// <summary>\n            /// The structured type for the items in the resource set to be written (or null if the entity set base type should be used).\n            /// </summary>\n            public IEdmStructuredType ResourceType\n            {\n                get\n                {\n                    return this.resourceType;\n                }\n\n                set\n                {\n                    this.resourceType = value;\n                    this.itemType = value;\n                }\n            }\n\n            /// <summary>\n            /// The structured type for the items in the resource set to be written (or null if the entity set base type should be used).\n            /// </summary>\n            public IEdmType ItemType\n            {\n                get\n                {\n                    return this.itemType;\n                }\n\n                set\n                {\n                    this.itemType = value;\n                    this.resourceType = value as IEdmStructuredType;\n                }\n            }\n\n            /// <summary>\n            /// The writer state of this scope.\n            /// </summary>\n            internal WriterState State\n            {\n                get\n                {\n                    return this.state;\n                }\n            }\n\n            /// <summary>\n            /// The item attached to this scope.\n            /// </summary>\n            internal ODataItem Item\n            {\n                get\n                {\n                    return this.item;\n                }\n            }\n\n            /// <summary>The navigation source we are going to write entities for.</summary>\n            internal IEdmNavigationSource NavigationSource\n            {\n                get\n                {\n                    return this.navigationSource;\n                }\n\n                set\n                {\n                    this.navigationSource = value;\n                }\n            }\n\n            /// <summary>The selected properties for the current scope.</summary>\n            internal SelectedPropertiesNode SelectedProperties\n            {\n                get\n                {\n                    return this.selectedProperties;\n                }\n            }\n\n            /// <summary>The odata Uri for the current scope.</summary>\n            internal ODataUri ODataUri\n            {\n                get\n                {\n                    Debug.Assert(this.odataUri != null, \"this.odataUri != null\");\n                    return this.odataUri;\n                }\n            }\n\n            /// <summary>\n            /// Set to true if the content of this scope should not be written.\n            /// </summary>\n            internal bool SkipWriting\n            {\n                get\n                {\n                    return this.skipWriting;\n                }\n            }\n\n            /// <summary>Gets or sets the derived type constraints for the current scope.</summary>\n            internal IEnumerable<string> DerivedTypeConstraints { get; set; }\n        }\n", "label": "MultifacetedAbstraction"}
{"text": "\n\t/// <summary>\n\t/// Class StringExtensions.\n\t/// </summary>\n\tpublic static class StringExtensions\n\t{\n\t\t/// <summary>\n\t\t/// To the specified value.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>T.</returns>\n\t\tpublic static T To<T>(this string value)\n\t\t{\n\t\t\treturn TypeSerializer.DeserializeFromString<T>(value);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the specified default value.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"defaultValue\">The default value.</param>\n\t\t/// <returns>T.</returns>\n\t\tpublic static T To<T>(this string value, T defaultValue)\n\t\t{\n\t\t\treturn String.IsNullOrEmpty(value) ? defaultValue : TypeSerializer.DeserializeFromString<T>(value);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the or default value.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>T.</returns>\n\t\tpublic static T ToOrDefaultValue<T>(this string value)\n\t\t{\n\t\t\treturn String.IsNullOrEmpty(value) ? default(T) : TypeSerializer.DeserializeFromString<T>(value);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the specified type.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"type\">The type.</param>\n\t\t/// <returns>System.Object.</returns>\n\t\tpublic static object To(this string value, Type type)\n\t\t{\n\t\t\treturn TypeSerializer.DeserializeFromString(value, type);\n\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Converts from base: 0 - 62\n\t\t/// </summary>\n\t\t/// <param name=\"source\">The source.</param>\n\t\t/// <param name=\"from\">From.</param>\n\t\t/// <param name=\"to\">To.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string BaseConvert(this string source, int from, int to)\n\t\t{\n\t\t\tconst string chars = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\t\t\tvar result = \"\";\n\t\t\tvar length = source.Length;\n\t\t\tvar number = new int[length];\n\n\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t{\n\t\t\t\tnumber[i] = chars.IndexOf(source[i]);\n\t\t\t}\n\n\t\t\tint newlen;\n\n\t\t\tdo\n\t\t\t{\n\t\t\t\tvar divide = 0;\n\t\t\t\tnewlen = 0;\n\n\t\t\t\tfor (var i = 0; i < length; i++)\n\t\t\t\t{\n\t\t\t\t\tdivide = divide * @from + number[i];\n\n\t\t\t\t\tif (divide >= to)\n\t\t\t\t\t{\n\t\t\t\t\t\tnumber[newlen++] = divide / to;\n\t\t\t\t\t\tdivide = divide % to;\n\t\t\t\t\t}\n\t\t\t\t\telse if (newlen > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tnumber[newlen++] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlength = newlen;\n\t\t\t\tresult = chars[divide] + result;\n\t\t\t}\n\t\t\twhile (newlen != 0);\n\n\t\t\treturn result;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Encodes the XML.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string EncodeXml(this string value)\n\t\t{\n\t\t\treturn value.Replace(\"<\", \"&lt;\").Replace(\">\", \"&gt;\").Replace(\"&\", \"&amp;\");\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Encodes the json.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string EncodeJson(this string value)\n\t\t{\n\t\t\treturn String.Concat\n\t\t\t(\"\\\"\",\n\t\t\t\tvalue.Replace(\"\\\\\", \"\\\\\\\\\").Replace(\"\\\"\", \"\\\\\\\"\").Replace(\"\\r\", \"\").Replace(\"\\n\", \"\\\\n\"),\n\t\t\t\t\"\\\"\"\n\t\t\t);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Encodes the JSV.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string EncodeJsv(this string value)\n\t\t{\n\t\t\tif (JsState.QueryStringMode)\n\t\t\t{\n\t\t\t\treturn UrlEncode(value);\n\t\t\t}\n\t\t\treturn String.IsNullOrEmpty(value) || !JsWriter.HasAnyEscapeChars(value)\n\t\t\t\t? value\n\t\t\t\t: String.Concat\n\t\t\t\t\t(\n\t\t\t\t\t\tJsWriter.QuoteString,\n\t\t\t\t\t\tvalue.Replace(JsWriter.QuoteString, TypeSerializer.DoubleQuoteString),\n\t\t\t\t\t\tJsWriter.QuoteString\n\t\t\t\t\t);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Decodes the JSV.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string DecodeJsv(this string value)\n\t\t{\n\t\t\tconst int startingQuotePos = 1;\n\t\t\tconst int endingQuotePos = 2;\n\t\t\treturn String.IsNullOrEmpty(value) || value[0] != JsWriter.QuoteChar\n\t\t\t\t\t? value\n\t\t\t\t\t: value.Substring(startingQuotePos, value.Length - endingQuotePos)\n\t\t\t\t\t\t.Replace(TypeSerializer.DoubleQuoteString, JsWriter.QuoteString);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// URLs the encode.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string UrlEncode(this string text)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(text)) return text;\n\n\t\t\tvar sb = new StringBuilder();\n\n\t\t\tforeach (var charCode in Encoding.UTF8.GetBytes(text))\n\t\t\t{\n\n\t\t\t\tif (\n\t\t\t\t\tcharCode >= 65 && charCode <= 90        // A-Z\n\t\t\t\t\t|| charCode >= 97 && charCode <= 122    // a-z\n\t\t\t\t\t|| charCode >= 48 && charCode <= 57     // 0-9\n\t\t\t\t\t|| charCode >= 44 && charCode <= 46     // ,-.\n\t\t\t\t\t)\n\t\t\t\t{\n\t\t\t\t\tsb.Append((char)charCode);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.Append('%' + charCode.ToString(\"x2\"));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// URLs the decode.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string UrlDecode(this string text)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(text)) return null;\n\n\t\t\tvar bytes = new List<byte>();\n\n\t\t\tvar textLength = text.Length;\n\t\t\tfor (var i = 0; i < textLength; i++)\n\t\t\t{\n\t\t\t\tvar c = text[i];\n\t\t\t\tif (c == '+')\n\t\t\t\t{\n\t\t\t\t\tbytes.Add(32);\n\t\t\t\t}\n\t\t\t\telse if (c == '%')\n\t\t\t\t{\n\t\t\t\t\tvar hexNo = Convert.ToByte(text.Substring(i + 1, 2), 16);\n\t\t\t\t\tbytes.Add(hexNo);\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbytes.Add((byte)c);\n\t\t\t\t}\n\t\t\t}\n#if SILVERLIGHT\n\t\t\tbyte[] byteArray = bytes.ToArray();\n\t\t\treturn Encoding.UTF8.GetString(byteArray, 0, byteArray.Length);\n#else\n\t\t\treturn Encoding.UTF8.GetString(bytes.ToArray());\n#endif\n\t\t}\n\n#if !XBOX\n\t\t/// <summary>\n\t\t/// Hexadecimals the escape.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"anyCharOf\">Any character of.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string HexEscape(this string text, params char[] anyCharOf)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(text)) return text;\n\t\t\tif (anyCharOf == null || anyCharOf.Length == 0) return text;\n\n\t\t\tvar encodeCharMap = new HashSet<char>(anyCharOf);\n\n\t\t\tvar sb = new StringBuilder();\n\t\t\tvar textLength = text.Length;\n\n\t\t\tforeach (var c in text)\n\t\t\t{\n\t\t\t\t//sb.Append(encodeCharMap.Contains(c) ? '%' + ((int)c).ToString(\"x\") : c);\n\t\t\t\tif (encodeCharMap.Contains(c))\n\t\t\t\t{\n\t\t\t\t\tsb.Append('%' + ((int)c).ToString(\"x\"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.Append(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sb.ToString();\n\t\t}\n#endif\n\t\t/// <summary>\n\t\t/// Hexadecimals the unescape.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"anyCharOf\">Any character of.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string HexUnescape(this string text, params char[] anyCharOf)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(text)) return null;\n\t\t\tif (anyCharOf == null || anyCharOf.Length == 0) return text;\n\n\t\t\tvar sb = new StringBuilder();\n\n\t\t\tvar textLength = text.Length;\n\t\t\tfor (var i = 0; i < textLength; i++)\n\t\t\t{\n\t\t\t\tvar c = text.Substring(i, 1);\n\t\t\t\tif (c == \"%\")\n\t\t\t\t{\n\t\t\t\t\tvar hexNo = Convert.ToInt32(text.Substring(i + 1, 2), 16);\n\t\t\t\t\tsb.Append((char)hexNo);\n\t\t\t\t\ti += 2;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.Append(c);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// URLs the format.\n\t\t/// </summary>\n\t\t/// <param name=\"url\">The URL.</param>\n\t\t/// <param name=\"urlComponents\">The URL components.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string UrlFormat(this string url, params string[] urlComponents)\n\t\t{\n\t\t\tvar encodedUrlComponents = new string[urlComponents.Length];\n\t\t\tfor (var i = 0; i < urlComponents.Length; i++)\n\t\t\t{\n\t\t\t\tvar x = urlComponents[i];\n\t\t\t\tencodedUrlComponents[i] = x.UrlEncode();\n\t\t\t}\n\n\t\t\treturn String.Format(url, encodedUrlComponents);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the rot13.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ToRot13(this string value)\n\t\t{\n\t\t\tvar array = value.ToCharArray();\n\t\t\tfor (var i = 0; i < array.Length; i++)\n\t\t\t{\n\t\t\t\tvar number = (int)array[i];\n\n\t\t\t\tif (number >= 'a' && number <= 'z')\n\t\t\t\t\tnumber += (number > 'm') ? -13 : 13;\n\n\t\t\t\telse if (number >= 'A' && number <= 'Z')\n\t\t\t\t\tnumber += (number > 'M') ? -13 : 13;\n\n\t\t\t\tarray[i] = (char)number;\n\t\t\t}\n\t\t\treturn new string(array);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Withes the trailing slash.\n\t\t/// </summary>\n\t\t/// <param name=\"path\">The path.</param>\n\t\t/// <returns>System.String.</returns>\n\t\t/// <exception cref=\"System.ArgumentNullException\">path</exception>\n\t\tpublic static string WithTrailingSlash(this string path)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(path))\n\t\t\t\tthrow new ArgumentNullException(\"path\");\n\n\t\t\tif (path[path.Length - 1] != '/')\n\t\t\t{\n\t\t\t\treturn path + \"/\";\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Appends the path.\n\t\t/// </summary>\n\t\t/// <param name=\"uri\">The URI.</param>\n\t\t/// <param name=\"uriComponents\">The URI components.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string AppendPath(this string uri, params string[] uriComponents)\n\t\t{\n\t\t\treturn AppendUrlPaths(uri, uriComponents);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Appends the URL paths.\n\t\t/// </summary>\n\t\t/// <param name=\"uri\">The URI.</param>\n\t\t/// <param name=\"uriComponents\">The URI components.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string AppendUrlPaths(this string uri, params string[] uriComponents)\n\t\t{\n\t\t\tvar sb = new StringBuilder(uri.WithTrailingSlash());\n\t\t\tvar i = 0;\n\t\t\tforeach (var uriComponent in uriComponents)\n\t\t\t{\n\t\t\t\tif (i++ > 0) sb.Append('/');\n\t\t\t\tsb.Append(uriComponent.UrlEncode());\n\t\t\t}\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Appends the URL paths raw.\n\t\t/// </summary>\n\t\t/// <param name=\"uri\">The URI.</param>\n\t\t/// <param name=\"uriComponents\">The URI components.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string AppendUrlPathsRaw(this string uri, params string[] uriComponents)\n\t\t{\n\t\t\tvar sb = new StringBuilder(uri.WithTrailingSlash());\n\t\t\tvar i = 0;\n\t\t\tforeach (var uriComponent in uriComponents)\n\t\t\t{\n\t\t\t\tif (i++ > 0) sb.Append('/');\n\t\t\t\tsb.Append(uriComponent);\n\t\t\t}\n\t\t\treturn sb.ToString();\n\t\t}\n\n#if !SILVERLIGHT\n\t\t/// <summary>\n\t\t/// Froms the ASCII bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"bytes\">The bytes.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string FromAsciiBytes(this byte[] bytes)\n\t\t{\n\t\t\treturn bytes == null ? null\n\t\t\t\t: Encoding.ASCII.GetString(bytes, 0, bytes.Length);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the ASCII bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.Byte[].</returns>\n\t\tpublic static byte[] ToAsciiBytes(this string value)\n\t\t{\n\t\t\treturn Encoding.ASCII.GetBytes(value);\n\t\t}\n#endif\n\t\t/// <summary>\n\t\t/// Froms the UTF8 bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"bytes\">The bytes.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string FromUtf8Bytes(this byte[] bytes)\n\t\t{\n\t\t\treturn bytes == null ? null\n\t\t\t\t: Encoding.UTF8.GetString(bytes, 0, bytes.Length);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the UTF8 bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.Byte[].</returns>\n\t\tpublic static byte[] ToUtf8Bytes(this string value)\n\t\t{\n\t\t\treturn Encoding.UTF8.GetBytes(value);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the UTF8 bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"intVal\">The int value.</param>\n\t\t/// <returns>System.Byte[].</returns>\n\t\tpublic static byte[] ToUtf8Bytes(this int intVal)\n\t\t{\n\t\t\treturn FastToUtf8Bytes(intVal.ToString());\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the UTF8 bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"longVal\">The long value.</param>\n\t\t/// <returns>System.Byte[].</returns>\n\t\tpublic static byte[] ToUtf8Bytes(this long longVal)\n\t\t{\n\t\t\treturn FastToUtf8Bytes(longVal.ToString());\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the UTF8 bytes.\n\t\t/// </summary>\n\t\t/// <param name=\"doubleVal\">The double value.</param>\n\t\t/// <returns>System.Byte[].</returns>\n\t\tpublic static byte[] ToUtf8Bytes(this double doubleVal)\n\t\t{\n\t\t\tvar doubleStr = doubleVal.ToString(CultureInfo.InvariantCulture.NumberFormat);\n\n\t\t\tif (doubleStr.IndexOf('E') != -1 || doubleStr.IndexOf('e') != -1)\n\t\t\t\tdoubleStr = DoubleConverter.ToExactString(doubleVal);\n\n\t\t\treturn FastToUtf8Bytes(doubleStr);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Skip the encoding process for 'safe strings'\n\t\t/// </summary>\n\t\t/// <param name=\"strVal\">The string value.</param>\n\t\t/// <returns>System.Byte[].</returns>\n\t\tprivate static byte[] FastToUtf8Bytes(string strVal)\n\t\t{\n\t\t\tvar bytes = new byte[strVal.Length];\n\t\t\tfor (var i = 0; i < strVal.Length; i++)\n\t\t\t\tbytes[i] = (byte)strVal[i];\n\n\t\t\treturn bytes;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Splits the on first.\n\t\t/// </summary>\n\t\t/// <param name=\"strVal\">The string value.</param>\n\t\t/// <param name=\"needle\">The needle.</param>\n\t\t/// <returns>System.String[].</returns>\n\t\tpublic static string[] SplitOnFirst(this string strVal, char needle)\n\t\t{\n\t\t\tif (strVal == null) return new string[0];\n\t\t\tvar pos = strVal.IndexOf(needle);\n\t\t\treturn pos == -1\n\t\t\t\t? new[] { strVal }\n\t\t\t\t: new[] { strVal.Substring(0, pos), strVal.Substring(pos + 1) };\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Splits the on first.\n\t\t/// </summary>\n\t\t/// <param name=\"strVal\">The string value.</param>\n\t\t/// <param name=\"needle\">The needle.</param>\n\t\t/// <returns>System.String[].</returns>\n\t\tpublic static string[] SplitOnFirst(this string strVal, string needle)\n\t\t{\n\t\t\tif (strVal == null) return new string[0];\n\t\t\tvar pos = strVal.IndexOf(needle);\n\t\t\treturn pos == -1\n\t\t\t\t? new[] { strVal }\n\t\t\t\t: new[] { strVal.Substring(0, pos), strVal.Substring(pos + 1) };\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Splits the on last.\n\t\t/// </summary>\n\t\t/// <param name=\"strVal\">The string value.</param>\n\t\t/// <param name=\"needle\">The needle.</param>\n\t\t/// <returns>System.String[].</returns>\n\t\tpublic static string[] SplitOnLast(this string strVal, char needle)\n\t\t{\n\t\t\tif (strVal == null) return new string[0];\n\t\t\tvar pos = strVal.LastIndexOf(needle);\n\t\t\treturn pos == -1\n\t\t\t\t? new[] { strVal }\n\t\t\t\t: new[] { strVal.Substring(0, pos), strVal.Substring(pos + 1) };\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Splits the on last.\n\t\t/// </summary>\n\t\t/// <param name=\"strVal\">The string value.</param>\n\t\t/// <param name=\"needle\">The needle.</param>\n\t\t/// <returns>System.String[].</returns>\n\t\tpublic static string[] SplitOnLast(this string strVal, string needle)\n\t\t{\n\t\t\tif (strVal == null) return new string[0];\n\t\t\tvar pos = strVal.LastIndexOf(needle);\n\t\t\treturn pos == -1\n\t\t\t\t? new[] { strVal }\n\t\t\t\t: new[] { strVal.Substring(0, pos), strVal.Substring(pos + 1) };\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Withouts the extension.\n\t\t/// </summary>\n\t\t/// <param name=\"filePath\">The file path.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string WithoutExtension(this string filePath)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(filePath)) return null;\n\n\t\t\tvar extPos = filePath.LastIndexOf('.');\n\t\t\tif (extPos == -1) return filePath;\n\n\t\t\tvar dirPos = filePath.LastIndexOfAny(DirSeps);\n\t\t\treturn extPos > dirPos ? filePath.Substring(0, extPos) : filePath;\n\t\t}\n\n#if NETFX_CORE\n\t\tprivate static readonly char DirSep = '\\\\';//Path.DirectorySeparatorChar;\n\t\tprivate static readonly char AltDirSep = '/';//Path.DirectorySeparatorChar == '/' ? '\\\\' : '/';\n#else\n\t\t/// <summary>\n\t\t/// The dir sep\n\t\t/// </summary>\n\t\tprivate static readonly char DirSep = Path.DirectorySeparatorChar;\n\t\t/// <summary>\n\t\t/// The alt dir sep\n\t\t/// </summary>\n\t\tprivate static readonly char AltDirSep = Path.DirectorySeparatorChar == '/' ? '\\\\' : '/';\n#endif\n\t\t/// <summary>\n\t\t/// The dir seps\n\t\t/// </summary>\n\t\tstatic readonly char[] DirSeps = new[] { '\\\\', '/' };\n\n\t\t/// <summary>\n\t\t/// Parents the directory.\n\t\t/// </summary>\n\t\t/// <param name=\"filePath\">The file path.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ParentDirectory(this string filePath)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(filePath)) return null;\n\n\t\t\tvar dirSep = filePath.IndexOf(DirSep) != -1\n\t\t\t\t\t\t ? DirSep\n\t\t\t\t\t\t : filePath.IndexOf(AltDirSep) != -1 ? AltDirSep : (char)0;\n\n\t\t\treturn dirSep == 0 ? null : filePath.TrimEnd(dirSep).SplitOnLast(dirSep)[0];\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the JSV.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\t/// <param name=\"obj\">The object.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ToJsv<T>(this T obj)\n\t\t{\n\t\t\treturn TypeSerializer.SerializeToString(obj);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Froms the JSV.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\t/// <param name=\"jsv\">The JSV.</param>\n\t\t/// <returns>T.</returns>\n\t\tpublic static T FromJsv<T>(this string jsv)\n\t\t{\n\t\t\treturn TypeSerializer.DeserializeFromString<T>(jsv);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the json.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\t/// <param name=\"obj\">The object.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ToJson<T>(this T obj) {\n\t\t\treturn JsConfig.PreferInterfaces\n\t\t\t\t? JsonSerializer.SerializeToString(obj, AssemblyUtils.MainInterface<T>())\n\t\t\t\t: JsonSerializer.SerializeToString(obj);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Froms the json.\n\t\t/// </summary>\n\t\t/// <typeparam name=\"T\"></typeparam>\n\t\t/// <param name=\"json\">The json.</param>\n\t\t/// <returns>T.</returns>\n\t\tpublic static T FromJson<T>(this string json)\n\t\t{\n\t\t\treturn JsonSerializer.DeserializeFromString<T>(json);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Formats the with.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"args\">The arguments.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string FormatWith(this string text, params object[] args)\n\t\t{\n\t\t\treturn String.Format(text, args);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// FMTs the specified arguments.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"args\">The arguments.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string Fmt(this string text, params object[] args)\n\t\t{\n\t\t\treturn String.Format(text, args);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Startses the with ignore case.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"startsWith\">The starts with.</param>\n\t\t/// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>\n\t\tpublic static bool StartsWithIgnoreCase(this string text, string startsWith)\n\t\t{\n#if NETFX_CORE\n\t\t\treturn text != null\n\t\t\t\t&& text.StartsWith(startsWith, StringComparison.CurrentCultureIgnoreCase);\n#else\n\t\t\treturn text != null\n\t\t\t\t&& text.StartsWith(startsWith, StringComparison.InvariantCultureIgnoreCase);\n#endif\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Endses the with ignore case.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"endsWith\">The ends with.</param>\n\t\t/// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>\n\t\tpublic static bool EndsWithIgnoreCase(this string text, string endsWith)\n\t\t{\n#if NETFX_CORE\n\t\t\treturn text != null\n\t\t\t\t&& text.EndsWith(endsWith, StringComparison.CurrentCultureIgnoreCase);\n#else\n\t\t\treturn text != null\n\t\t\t\t&& text.EndsWith(endsWith, StringComparison.InvariantCultureIgnoreCase);\n#endif\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Reads all text.\n\t\t/// </summary>\n\t\t/// <param name=\"filePath\">The file path.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ReadAllText(this string filePath)\n\t\t{\n#if XBOX && !SILVERLIGHT\n\t\t\tusing( var fileStream = new FileStream( filePath, FileMode.Open, FileAccess.Read ) )\n\t\t\t{\n\t\t\t\treturn new StreamReader( fileStream ).ReadToEnd( ) ;\n\t\t\t}\n#elif NETFX_CORE\n\t\t\tvar task = Windows.Storage.StorageFile.GetFileFromPathAsync(filePath);\n\t\t\ttask.AsTask().Wait();\n\n\t\t\tvar file = task.GetResults();\n\t\t\t\n\t\t\tvar streamTask = file.OpenStreamForReadAsync();\n\t\t\tstreamTask.Wait();\n\n\t\t\tvar fileStream = streamTask.Result;\n\n\t\t\treturn new StreamReader( fileStream ).ReadToEnd( ) ;\n#elif WINDOWS_PHONE\n\t\t\tusing (var isoStore = IsolatedStorageFile.GetUserStoreForApplication())\n\t\t\t{\n\t\t\t\tusing (var fileStream = isoStore.OpenFile(filePath, FileMode.Open))\n\t\t\t\t{\n\t\t\t\t\treturn new StreamReader(fileStream).ReadToEnd();\n\t\t\t\t}\n\t\t\t}\n#else\n\t\t\treturn File.ReadAllText(filePath);\n#endif\n\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Indexes the of any.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"needles\">The needles.</param>\n\t\t/// <returns>System.Int32.</returns>\n\t\tpublic static int IndexOfAny(this string text, params string[] needles)\n\t\t{\n\t\t\treturn IndexOfAny(text, 0, needles);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Indexes the of any.\n\t\t/// </summary>\n\t\t/// <param name=\"text\">The text.</param>\n\t\t/// <param name=\"startIndex\">The start index.</param>\n\t\t/// <param name=\"needles\">The needles.</param>\n\t\t/// <returns>System.Int32.</returns>\n\t\tpublic static int IndexOfAny(this string text, int startIndex, params string[] needles)\n\t\t{\n\t\t\tif (text == null) return -1;\n\n\t\t\tvar firstPos = -1;\n\t\t\tforeach (var needle in needles)\n\t\t\t{\n\t\t\t\tvar pos = text.IndexOf(needle);\n\t\t\t\tif (firstPos == -1 || pos < firstPos) firstPos = pos;\n\t\t\t}\n\t\t\treturn firstPos;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Extracts the contents.\n\t\t/// </summary>\n\t\t/// <param name=\"fromText\">From text.</param>\n\t\t/// <param name=\"startAfter\">The start after.</param>\n\t\t/// <param name=\"endAt\">The end at.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ExtractContents(this string fromText, string startAfter, string endAt)\n\t\t{\n\t\t\treturn ExtractContents(fromText, startAfter, startAfter, endAt);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Extracts the contents.\n\t\t/// </summary>\n\t\t/// <param name=\"fromText\">From text.</param>\n\t\t/// <param name=\"uniqueMarker\">The unique marker.</param>\n\t\t/// <param name=\"startAfter\">The start after.</param>\n\t\t/// <param name=\"endAt\">The end at.</param>\n\t\t/// <returns>System.String.</returns>\n\t\t/// <exception cref=\"System.ArgumentNullException\">uniqueMarker\n\t\t/// or\n\t\t/// startAfter\n\t\t/// or\n\t\t/// endAt</exception>\n\t\tpublic static string ExtractContents(this string fromText, string uniqueMarker, string startAfter, string endAt)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(uniqueMarker))\n\t\t\t\tthrow new ArgumentNullException(\"uniqueMarker\");\n\t\t\tif (String.IsNullOrEmpty(startAfter))\n\t\t\t\tthrow new ArgumentNullException(\"startAfter\");\n\t\t\tif (String.IsNullOrEmpty(endAt))\n\t\t\t\tthrow new ArgumentNullException(\"endAt\");\n\n\t\t\tif (String.IsNullOrEmpty(fromText)) return null;\n\n\t\t\tvar markerPos = fromText.IndexOf(uniqueMarker);\n\t\t\tif (markerPos == -1) return null;\n\n\t\t\tvar startPos = fromText.IndexOf(startAfter, markerPos);\n\t\t\tif (startPos == -1) return null;\n\t\t\tstartPos += startAfter.Length;\n\n\t\t\tvar endPos = fromText.IndexOf(endAt, startPos);\n\t\t\tif (endPos == -1) endPos = fromText.Length;\n\n\t\t\treturn fromText.Substring(startPos, endPos - startPos);\n\t\t}\n\n#if XBOX && !SILVERLIGHT\n\t\tstatic readonly Regex StripHtmlRegEx = new Regex(@\"<(.|\\n)*?>\", RegexOptions.Compiled);\n#else\n\t\t/// <summary>\n\t\t/// The strip HTML reg ex\n\t\t/// </summary>\n\t\tstatic readonly Regex StripHtmlRegEx = new Regex(@\"<(.|\\n)*?>\");\n#endif\n\t\t/// <summary>\n\t\t/// Strips the HTML.\n\t\t/// </summary>\n\t\t/// <param name=\"html\">The HTML.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string StripHtml(this string html)\n\t\t{\n\t\t\treturn String.IsNullOrEmpty(html) ? null : StripHtmlRegEx.Replace(html, \"\");\n\t\t}\n\n#if XBOX && !SILVERLIGHT\n\t\tstatic readonly Regex StripBracketsRegEx = new Regex(@\"\\[(.|\\n)*?\\]\", RegexOptions.Compiled);\n\t\tstatic readonly Regex StripBracesRegEx = new Regex(@\"\\((.|\\n)*?\\)\", RegexOptions.Compiled);\n#else\n\t\t/// <summary>\n\t\t/// The strip brackets reg ex\n\t\t/// </summary>\n\t\tstatic readonly Regex StripBracketsRegEx = new Regex(@\"\\[(.|\\n)*?\\]\");\n\t\t/// <summary>\n\t\t/// The strip braces reg ex\n\t\t/// </summary>\n\t\tstatic readonly Regex StripBracesRegEx = new Regex(@\"\\((.|\\n)*?\\)\");\n#endif\n\t\t/// <summary>\n\t\t/// Strips the markdown markup.\n\t\t/// </summary>\n\t\t/// <param name=\"markdown\">The markdown.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string StripMarkdownMarkup(this string markdown)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(markdown)) return null;\n\t\t\tmarkdown = StripBracketsRegEx.Replace(markdown, \"\");\n\t\t\tmarkdown = StripBracesRegEx.Replace(markdown, \"\");\n\t\t\tmarkdown = markdown\n\t\t\t\t.Replace(\"*\", \"\")\n\t\t\t\t.Replace(\"!\", \"\")\n\t\t\t\t.Replace(\"\\r\", \"\")\n\t\t\t\t.Replace(\"\\n\", \"\")\n\t\t\t\t.Replace(\"#\", \"\");\n\n\t\t\treturn markdown;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// The lower case offset\n\t\t/// </summary>\n\t\tprivate const int LowerCaseOffset = 'a' - 'A';\n\t\t/// <summary>\n\t\t/// To the camel case.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ToCamelCase(this string value)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(value)) return value;\n\n\t\t\tvar len = value.Length;\n\t\t\tvar newValue = new char[len];\n\t\t\tvar firstPart = true;\n\n\t\t\tfor (var i = 0; i < len; ++i) {\n\t\t\t\tvar c0 = value[i];\n\t\t\t\tvar c1 = i < len - 1 ? value[i + 1] : 'A';\n\t\t\t\tvar c0isUpper = c0 >= 'A' && c0 <= 'Z';\n\t\t\t\tvar c1isUpper = c1 >= 'A' && c1 <= 'Z';\n\n\t\t\t\tif (firstPart && c0isUpper && (c1isUpper || i == 0))\n\t\t\t\t\tc0 = (char)(c0 + LowerCaseOffset);\n\t\t\t\telse\n\t\t\t\t\tfirstPart = false;\n\n\t\t\t\tnewValue[i] = c0;\n\t\t\t}\n\n\t\t\treturn new string(newValue);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// The text information\n\t\t/// </summary>\n\t\tprivate static readonly TextInfo TextInfo = CultureInfo.InvariantCulture.TextInfo;\n\t\t/// <summary>\n\t\t/// To the title case.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ToTitleCase(this string value)\n\t\t{\n#if SILVERLIGHT || __MonoCS__\n\t\t\tstring[] words = value.Split('_');\n\n\t\t\tfor (int i = 0; i <= words.Length - 1; i++)\n\t\t\t{\n\t\t\t\tif ((!object.ReferenceEquals(words[i], string.Empty)))\n\t\t\t\t{\n\t\t\t\t\tstring firstLetter = words[i].Substring(0, 1);\n\t\t\t\t\tstring rest = words[i].Substring(1);\n\t\t\t\t\tstring result = firstLetter.ToUpper() + rest.ToLower();\n\t\t\t\t\twords[i] = result;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn String.Join(\"\", words);\n#else\n\t\t\treturn TextInfo.ToTitleCase(value).Replace(\"_\", String.Empty);\n#endif\n\t\t}\n\n\t\t/// <summary>\n\t\t/// To the lowercase underscore.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string ToLowercaseUnderscore(this string value)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(value)) return value;\n\t\t\tvalue = value.ToCamelCase();\n\t\t\t\n\t\t\tvar sb = new StringBuilder(value.Length);\n\t\t\tforeach (var t in value)\n\t\t\t{\n\t\t\t\tif (Char.IsDigit(t) || (Char.IsLetter(t) && Char.IsLower(t)) || t == '_')\n\t\t\t\t{\n\t\t\t\t\tsb.Append(t);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsb.Append(\"_\");\n\t\t\t\t\tsb.Append(Char.ToLowerInvariant(t));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Safes the substring.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"length\">The length.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string SafeSubstring(this string value, int length)\n\t\t{\n\t\t\treturn String.IsNullOrEmpty(value)\n\t\t\t\t? String.Empty\n\t\t\t\t: value.Substring(Math.Min(length, value.Length));\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Safes the substring.\n\t\t/// </summary>\n\t\t/// <param name=\"value\">The value.</param>\n\t\t/// <param name=\"startIndex\">The start index.</param>\n\t\t/// <param name=\"length\">The length.</param>\n\t\t/// <returns>System.String.</returns>\n\t\tpublic static string SafeSubstring(this string value, int startIndex, int length)\n\t\t{\n\t\t\tif (String.IsNullOrEmpty(value)) return String.Empty;\n\t\t\tif (value.Length >= (startIndex + length))\n\t\t\t\treturn value.Substring(startIndex, length);\n\n\t\t\treturn value.Length > startIndex ? value.Substring(startIndex) : String.Empty;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Determines whether [is anonymous type] [the specified type].\n\t\t/// </summary>\n\t\t/// <param name=\"type\">The type.</param>\n\t\t/// <returns><c>true</c> if [is anonymous type] [the specified type]; otherwise, <c>false</c>.</returns>\n\t\t/// <exception cref=\"System.ArgumentNullException\">type</exception>\n\t\tpublic static bool IsAnonymousType(this Type type)\n\t\t{\n\t\t\tif (type == null)\n\t\t\t\tthrow new ArgumentNullException(\"type\");\n\n\t\t\t// HACK: The only way to detect anonymous types right now.\n#if NETFX_CORE\n\t\t\treturn type.IsGeneric() && type.Name.Contains(\"AnonymousType\")\n\t\t\t\t&& (type.Name.StartsWith(\"<>\", StringComparison.Ordinal) || type.Name.StartsWith(\"VB$\", StringComparison.Ordinal));\n#else\n\t\t\treturn Attribute.IsDefined(type, typeof(CompilerGeneratedAttribute), false)\n\t\t\t\t&& type.IsGeneric() && type.Name.Contains(\"AnonymousType\")\n\t\t\t\t&& (type.Name.StartsWith(\"<>\", StringComparison.Ordinal) || type.Name.StartsWith(\"VB$\", StringComparison.Ordinal))\n\t\t\t\t&& (type.Attributes & TypeAttributes.NotPublic) == TypeAttributes.NotPublic;\n#endif\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Compares the ignore case.\n\t\t/// </summary>\n\t\t/// <param name=\"strA\">The string a.</param>\n\t\t/// <param name=\"strB\">The string b.</param>\n\t\t/// <returns>System.Int32.</returns>\n\t\tpublic static int CompareIgnoreCase(this string strA, string strB)\n\t\t{\n\t\t\treturn String.Compare(strA, strB, InvariantComparisonIgnoreCase());\n\t\t}\n\n\t\t/// <summary>\n\t\t/// Endses the with invariant.\n\t\t/// </summary>\n\t\t/// <param name=\"str\">The string.</param>\n\t\t/// <param name=\"endsWith\">The ends with.</param>\n\t\t/// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>\n\t\tpublic static bool EndsWithInvariant(this string str, string endsWith)\n\t\t{\n\t\t\treturn str.EndsWith(endsWith, InvariantComparison());\n\t\t}\n\n#if NETFX_CORE\n\t\tpublic static char DirSeparatorChar = '\\\\';\n\t\tpublic static StringComparison InvariantComparison()\n\t\t{\n\t\t\treturn StringComparison.CurrentCulture;\n\t\t}\n\t\tpublic static StringComparison InvariantComparisonIgnoreCase()\n\t\t{\n\t\t\treturn StringComparison.CurrentCultureIgnoreCase;\n\t\t}\n\t\tpublic static StringComparer InvariantComparer()\n\t\t{\n\t\t\treturn StringComparer.CurrentCulture;\n\t\t}\n\t\tpublic static StringComparer InvariantComparerIgnoreCase()\n\t\t{\n\t\t\treturn StringComparer.CurrentCultureIgnoreCase;\n\t\t}\n#else\n\t\t/// <summary>\n\t\t/// The dir separator character\n\t\t/// </summary>\n\t\tpublic static char DirSeparatorChar = Path.DirectorySeparatorChar;\n\t\t/// <summary>\n\t\t/// Invariants the comparison.\n\t\t/// </summary>\n\t\t/// <returns>StringComparison.</returns>\n\t\tpublic static StringComparison InvariantComparison()\n\t\t{\n\t\t\treturn StringComparison.InvariantCulture;\n\t\t}\n\t\t/// <summary>\n\t\t/// Invariants the comparison ignore case.\n\t\t/// </summary>\n\t\t/// <returns>StringComparison.</returns>\n\t\tpublic static StringComparison InvariantComparisonIgnoreCase()\n\t\t{\n\t\t\treturn StringComparison.InvariantCultureIgnoreCase;\n\t\t}\n\t\t/// <summary>\n\t\t/// Invariants the comparer.\n\t\t/// </summary>\n\t\t/// <returns>StringComparer.</returns>\n\t\tpublic static StringComparer InvariantComparer()\n\t\t{\n\t\t\treturn StringComparer.InvariantCulture;\n\t\t}\n\t\t/// <summary>\n\t\t/// Invariants the comparer ignore case.\n\t\t/// </summary>\n\t\t/// <returns>StringComparer.</returns>\n\t\tpublic static StringComparer InvariantComparerIgnoreCase()\n\t\t{\n\t\t\treturn StringComparer.InvariantCultureIgnoreCase;\n\t\t}\n#endif\n\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "\n    public class MvcForumMembershipProvider : MembershipProvider\n    {\n        // MSDN how to implement a custom provider: http://msdn.microsoft.com/en-us/library/6tc47t75.aspx\n\n        // ALL THE METHODS MUST BE USED WITHIN A UNIT OF WORK IN THE CONTROLLERS\n\n        // TODO - Need to implement this properly\n\n        private string _applicationName;\n        private bool _enablePasswordReset;\n        private int _maxInvalidPasswordAttempts;\n        private int _minRequiredNonAlphanumericCharacters;\n        private int _minRequiredPasswordLength;\n        private int _passwordAttemptWindow;\n        private bool _requiresQuestionAndAnswer;\n        private bool _requiresUniqueEmail;\n\n        // Use Dependency Resolver\n        //public IUnitOfWorkManager UnitOfWorkManager\n        //{\n        //    get { return UnityHelper.Container.Resolve<IUnitOfWorkManager>(); }\n        //}\n        public IMembershipService MembershipService => UnityHelper.Container.Resolve<IMembershipService>();\n\n        public override int MinRequiredPasswordLength => _minRequiredPasswordLength;\n\n        public override int MaxInvalidPasswordAttempts => _maxInvalidPasswordAttempts;\n\n\n        public override string ApplicationName\n        {\n            get { return _applicationName; }\n            set { _applicationName = value; }\n        }\n\n        public override bool EnablePasswordReset => _enablePasswordReset;\n\n        public override bool EnablePasswordRetrieval { get; } = false;\n\n        public override int MinRequiredNonAlphanumericCharacters => _minRequiredNonAlphanumericCharacters;\n\n        public override int PasswordAttemptWindow => _passwordAttemptWindow;\n\n        public override MembershipPasswordFormat PasswordFormat\n        {\n            get { throw new NotImplementedException(); }\n        }\n\n        public override string PasswordStrengthRegularExpression\n        {\n            get { throw new NotImplementedException(); }\n        }\n\n        public override bool RequiresQuestionAndAnswer\n        {\n            get { throw new NotImplementedException(); }\n        }\n\n        public override bool RequiresUniqueEmail\n        {\n            get { throw new NotImplementedException(); }\n        }\n\n        /// <summary>\n        ///     Read a config file value\n        /// </summary>\n        /// <param name=\"configValue\"></param>\n        /// <param name=\"defaultValue\"></param>\n        /// <returns></returns>\n        private static string GetConfigValue(string configValue, string defaultValue)\n        {\n            return string.IsNullOrWhiteSpace(configValue) ? defaultValue : configValue;\n        }\n\n        /// <summary>\n        ///     Initialise membership properties from config file\n        /// </summary>\n        /// <param name=\"name\"></param>\n        /// <param name=\"config\"></param>\n        public override void Initialize(string name, NameValueCollection config)\n        {\n            if (config == null)\n            {\n                throw new ArgumentNullException(\"config\");\n            }\n\n            if (string.IsNullOrWhiteSpace(name))\n            {\n                name = \"n3oSqlMembershipProvider\";\n            }\n\n            if (string.IsNullOrWhiteSpace(config[\"description\"]))\n            {\n                config.Remove(\"description\");\n                config.Add(\"description\", \"MvcForum Standard Membership Provider\");\n            }\n\n            // Initialize the abstract base class.\n            base.Initialize(name, config);\n\n            _applicationName = GetConfigValue(config[\"applicationName\"], HostingEnvironment.ApplicationVirtualPath);\n            _maxInvalidPasswordAttempts = Convert.ToInt32(GetConfigValue(config[\"maxInvalidPasswordAttempts\"], \"5\"));\n            _passwordAttemptWindow = Convert.ToInt32(GetConfigValue(config[\"passwordAttemptWindow\"], \"10\"));\n            _minRequiredNonAlphanumericCharacters =\n                Convert.ToInt32(GetConfigValue(config[\"minRequiredNonAlphanumericCharacters\"], \"1\"));\n            _minRequiredPasswordLength = Convert.ToInt32(GetConfigValue(config[\"minRequiredPasswordLength\"], \"7\"));\n            _requiresQuestionAndAnswer =\n                Convert.ToBoolean(GetConfigValue(config[\"requiresQuestionAndAnswer\"], \"false\"));\n            _requiresUniqueEmail = Convert.ToBoolean(GetConfigValue(config[\"requiresUniqueEmail\"], \"true\"));\n            _enablePasswordReset = Convert.ToBoolean(GetConfigValue(config[\"enablePasswordReset\"], \"true\"));\n        }\n\n        //var user = MembershipService.GetUser(username);\n        //if (user != null)\n        //{\n        //    return \n        //}\n        //return false;\n\n        /// <summary>\n        ///     Validate the user (required for membership in MVC)\n        /// </summary>\n        /// <param name=\"username\"></param>\n        /// <param name=\"password\"></param>\n        /// <returns></returns>\n        public override bool ValidateUser(string username, string password)\n        {\n            // use the data in the graph object to authorise the user\n            return MembershipService.ValidateUser(username, password, MaxInvalidPasswordAttempts);\n        }\n\n        public override bool ChangePassword(string username, string oldPassword, string newPassword)\n        {\n            var user = MembershipService.GetUser(username);\n            if (user != null)\n            {\n                return MembershipService.ChangePassword(user, oldPassword, newPassword);\n            }\n            return false;\n        }\n\n        public override bool ChangePasswordQuestionAndAnswer(string username, string password,\n            string newPasswordQuestion, string newPasswordAnswer)\n        {\n            if (ValidateUser(username, password))\n            {\n                var user = MembershipService.GetUser(username);\n                user.PasswordQuestion = newPasswordQuestion;\n                user.PasswordAnswer = newPasswordAnswer;\n                return true;\n            }\n            return false;\n        }\n\n        public override bool DeleteUser(string username, bool deleteAllRelatedData)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override MembershipUserCollection FindUsersByEmail(string emailToMatch, int pageIndex, int pageSize,\n            out int totalRecords)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override MembershipUserCollection FindUsersByName(string usernameToMatch, int pageIndex, int pageSize,\n            out int totalRecords)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override MembershipUserCollection GetAllUsers(int pageIndex, int pageSize, out int totalRecords)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override int GetNumberOfUsersOnline()\n        {\n            throw new NotImplementedException();\n        }\n\n        public override string GetPassword(string username, string answer)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override MembershipUser GetUser(string username, bool userIsOnline)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override MembershipUser GetUser(object providerUserKey, bool userIsOnline)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override string GetUserNameByEmail(string email)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override string ResetPassword(string username, string answer)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override bool UnlockUser(string userName)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override MembershipUser CreateUser(string username, string password, string email,\n            string passwordQuestion, string passwordAnswer, bool isApproved, object providerUserKey,\n            out MembershipCreateStatus status)\n        {\n            throw new NotImplementedException();\n        }\n\n        public override void UpdateUser(MembershipUser user)\n        {\n            throw new NotImplementedException();\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>\n    /// This is an Element that contains\n    /// some meta information about the document.\n    /// </summary>\n    /// <remarks>\n    /// An object of type Meta can not be constructed by the user.\n    /// Userdefined meta information should be placed in a Header-object.\n    /// Meta is reserved for: Subject, Keywords, Author, Title, Producer\n    /// and Creationdate information.\n    /// </remarks>\n    /// <seealso cref=\"T:iTextSharp.text.Element\"/>\n    /// <seealso cref=\"T:iTextSharp.text.Header\"/>\n    public class Meta : IElement {\n    \n        // membervariables\n    \n        ///<summary> This is the type of Meta-information this object contains. </summary>\n        private int type;\n    \n        ///<summary> This is the content of the Meta-information. </summary>\n        private StringBuilder content;\n\n        /**\n         * The possible value of an alignment attribute.\n         * @since 5.0.6 (moved from ElementTags)\n         */\n        public const String UNKNOWN = \"unknown\";\n\n        /**\n         * The possible value of an alignment attribute.\n         * @since 5.0.6 (moved from ElementTags)\n         */\n        public const String PRODUCER = \"producer\";\n\n        /**\n         * The possible value of an alignment attribute.\n         * @since 5.0.6 (moved from ElementTags)\n         */\n        public const String CREATIONDATE = \"creationdate\";\n\n        /**\n         * The possible value of an alignment attribute.\n         * @since 5.0.6 (moved from ElementTags)\n         */\n        public const String AUTHOR = \"author\";\n\n        /**\n         * The possible value of an alignment attribute.\n         * @since 5.0.6 (moved from ElementTags)\n         */\n        public const String KEYWORDS = \"keywords\";\n\n        /**\n         * The possible value of an alignment attribute.\n         * @since 5.0.6 (moved from ElementTags)\n         */\n        public const String SUBJECT = \"subject\";\n\n        /**\n         * The possible value of an alignment attribute.\n         * @since 5.0.6 (moved from ElementTags)\n         */\n        public const String TITLE = \"title\";\n\n        // constructors\n    \n        /// <summary>\n        /// Constructs a Meta.\n        /// </summary>\n        /// <param name=\"type\">the type of meta-information</param>\n        /// <param name=\"content\">the content</param>\n        public Meta(int type, string content) {\n            this.type = type;\n            this.content = new StringBuilder(content);\n        }\n    \n        /// <summary>\n        /// Constructs a Meta.\n        /// </summary>\n        /// <param name=\"tag\">the tagname of the meta-information</param>\n        /// <param name=\"content\">the content</param>\n        public Meta(string tag, string content) {\n            this.type = Meta.GetType(tag);\n            this.content = new StringBuilder(content);\n        }\n    \n        // implementation of the Element-methods\n    \n        /// <summary>\n        /// Processes the element by adding it (or the different parts) to a\n        /// IElementListener.\n        /// </summary>\n        /// <param name=\"listener\">the IElementListener</param>\n        /// <returns>true if the element was processed successfully</returns>\n        virtual public bool Process(IElementListener listener) {\n            try {\n                return listener.Add(this);\n            }\n            catch (DocumentException) {\n                return false;\n            }\n        }\n    \n        /// <summary>\n        /// Gets the type of the text element.\n        /// </summary>\n        /// <value>a type</value>\n        virtual public int Type {\n            get {\n                return type;\n            }\n        }\n    \n        /// <summary>\n        /// Gets all the chunks in this element.\n        /// </summary>\n        /// <value>an ArrayList</value>\n        virtual public IList<Chunk> Chunks {\n            get {\n                return new List<Chunk>();\n            }\n        }\n    \n        /**\n        * @see com.lowagie.text.Element#isContent()\n        * @since   iText 2.0.8\n        */\n        virtual public bool IsContent() {\n            return false;\n        }\n\n        /**\n        * @see com.lowagie.text.Element#isNestable()\n        * @since   iText 2.0.8\n        */\n        virtual public bool IsNestable() {\n            return false;\n        }\n\n        // methods\n    \n        /// <summary>\n        /// appends some text to this Meta.\n        /// </summary>\n        /// <param name=\"str\">a string</param>\n        /// <returns>a StringBuilder</returns>\n        virtual public StringBuilder Append(string str) {\n            return content.Append(str);\n        }\n    \n        // methods to retrieve information\n    \n        /// <summary>\n        /// Returns the content of the meta information.\n        /// </summary>\n        /// <value>a string</value>\n        virtual public string Content {\n            get {\n                return content.ToString();\n            }\n        }\n    \n        /// <summary>\n        /// Returns the name of the meta information.\n        /// </summary>\n        /// <value>a string</value>\n        public virtual string Name {\n            get {\n                switch (type) {\n                    case Element.SUBJECT:\n                        return Meta.SUBJECT;\n                    case Element.KEYWORDS:\n                        return Meta.KEYWORDS;\n                    case Element.AUTHOR:\n                        return Meta.AUTHOR;\n                    case Element.TITLE:\n                        return Meta.TITLE;\n                    case Element.PRODUCER:\n                        return Meta.PRODUCER;\n                    case Element.CREATIONDATE:\n                        return Meta.CREATIONDATE;\n                    default:\n                        return Meta.UNKNOWN;\n                }\n            }\n        }\n    \n        /// <summary>\n        /// Returns the name of the meta information.\n        /// </summary>\n        /// <param name=\"tag\">name to match</param>\n        /// <returns>a string</returns>\n        public static int GetType(string tag) {\n            if (Meta.SUBJECT.Equals(tag)) {\n                return Element.SUBJECT;\n            }\n            if (Meta.KEYWORDS.Equals(tag)) {\n                return Element.KEYWORDS;\n            }\n            if (Meta.AUTHOR.Equals(tag)) {\n                return Element.AUTHOR;\n            }\n            if (Meta.TITLE.Equals(tag)) {\n                return Element.TITLE;\n            }\n            if (Meta.PRODUCER.Equals(tag)) {\n                return Element.PRODUCER;\n            }\n            if (Meta.CREATIONDATE.Equals(tag)) {\n                return Element.CREATIONDATE;\n            }\n            return Element.HEADER;\n        }\n    \n    \n        public override string ToString() {\n            return base.ToString();\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    /// <summary>\n    /// A full custom implementation of IBindingListView\n    /// </summary>\n    /// <typeparam name=\"T\">The underlying object type</typeparam>\n    [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1039:ListsAreStronglyTyped\"), System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Naming\", \"CA1710:IdentifiersShouldHaveCorrectSuffix\"), System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1035:ICollectionImplementationsHaveStronglyTypedMembers\"), System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1010:CollectionsShouldImplementGenericInterface\")]\n    public class EntityView<T> :\n        IBindingList,\n        IBindingListView,\n        IEntityView,\n        IEntityView<T>,\n        IList,\n        IRaiseItemChangedEvents,\n        ICancelAddNew,\n        ITypedList,\n        IComponent,\n        IDisposable,\n        IServiceProvider //,\n    //INotifyCollectionChanged\n    //where T : class\n    {\n        private Indexer<T> _indexer;\n\n        /// <summary>\n        /// Gets the indexer.\n        /// </summary>\n        /// <value>The indexer.</value>\n        protected Indexer<T> Indexer\n        {\n            get\n            {\n                if (_indexer == null)\n                {\n                    _indexer = new Indexer<T>(this);\n                }\n\n                return this._indexer;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether this instance is detached.\n        /// </summary>\n        /// <value>\n        ///     <c>true</c> if this instance is detached; otherwise, <c>false</c>.\n        /// </value>\n        public bool IsDetached\n        {\n            get;\n            private set;\n        }\n\n        /// <summary>\n        /// Returns a item indicationg this instance has an array\n        /// as underlying data storage or not\n        /// </summary>\n        /// <item>\n        ///     <collection>true</collection> if this instance is array based; otherwise, <collection>false</collection>.\n        /// </item>\n        public bool IsArrayBased\n        {\n            get;\n            private set;\n        }\n\n        /// <summary>\n        /// Gets the underlying DataSource as IList\n        /// </summary>\n        /// <item>The DataSource</item>\n        public IList DataSource\n        {\n            get;\n            private set;\n        }\n\n        EventHandler onEntityItemViewEditBegunHandler = null;\n        EventHandler onEntityItemViewEditCanceledHandler = null;\n        EventHandler onEntityItemViewEditEndedHandler = null;\n        PropertyChangedEventHandler onEntityItemViewPropertyChangedHandler = null;\n\n        #region .ctor\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"EntityView&lt;T&gt;\"/> class.\n        /// </summary>\n        public EntityView()\n            : this((IList)new EntityCollection<T>())\n        {\n            this.IsDetached = true;\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"EntityView&lt;T&gt;\"/> class.\n        /// </summary>\n        /// <param name=\"list\">The list.</param>\n        public EntityView(IEntityCollection<T> list)\n            : this((IList)list)\n        {\n\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"EntityView&lt;T&gt;\"/> \n        /// class using the supplied array of <typeparamref name=\"T\"/> as the\n        /// underlying list of elements\n        /// </summary>\n        /// <param name=\"list\">The list contining the data to build this view on</param>\n        public EntityView(T[] list)\n            : this((IList)list)\n        {\n\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"EntityView&lt;T&gt;\"/>\n        /// class using the supplied IList&lt;<typeparamref name=\"T\"/>&gt; as the\n        /// underlying list of elements\n        /// </summary>\n        /// <param name=\"list\">The list contining the data to build this view on</param>\n        public EntityView(IList<T> list)\n            : this((IList)list)\n        {\n\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"EntityView&lt;T&gt;\"/> class.\n        /// </summary>\n        /// <param name=\"list\">The list.</param>\n        protected EntityView(IList list)\n        {\n            this.DataSource = list;\n            this.IsArrayBased = this.DataSource.GetType().IsArray;\n\n            this.onEntityItemViewEditBegunHandler = new EventHandler(OnEntityItemViewEditBegun);\n            this.onEntityItemViewEditCanceledHandler = new EventHandler(OnEntityItemViewEditCanceled);\n            this.onEntityItemViewEditEndedHandler = new EventHandler(OnEntityItemViewEditEnded);\n            this.onEntityItemViewPropertyChangedHandler = new PropertyChangedEventHandler(OnEntityItemViewPropertyChanged);\n\n            this.OnInit();\n            this.Indexer.Rebuild();\n            this.OnLoad();\n        }\n\n        #endregion\n\n        protected internal virtual IEntityItemView<T> CreateEntityItemView(T sourceItem)\n        {\n            return new EntityItemView<T>(this, sourceItem);\n        }\n\n        /// <summary>\n        /// Called just before the first full indexing\n        /// </summary>\n        protected virtual void OnInit()\n        {\n            IEntityCollection<T> dataSource = this.DataSource as IEntityCollection<T>;\n            if (dataSource != null)\n            {\n                dataSource.CollectionChanged += OnDataSourceCollectionChanged;\n            }\n        }\n\n        #region DataSource Collection EventHandlers\n\n        /*\n         * Gestisce l'evento che viene scatenato \n         * quando la collection sottostante notifica\n         * che ci sono modifiche al suo interno.\n         */\n        void OnDataSourceCollectionChanged(object sender, CollectionChangedEventArgs<T> e)\n        {\n            int oldIndex;\n            int newIndex;\n            RebuildIndexesEventArgs args = new RebuildIndexesEventArgs(e.Index);\n\n            switch (e.ChangeType)\n            {\n                case CollectionChangeType.ItemAdded:\n                    this.OnCollectionChanged(args, e.ChangeType);\n                    if (!args.Cancel)\n                    {\n                        this.Indexer.Rebuild();\n                        newIndex = this.Indexer.FindEntityItemViewIndexInView(e.Index);\n                    }\n                    else\n                    {\n                        newIndex = e.Index;\n                    }\n\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, newIndex));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Add, this.Indexer[ newIndex ], newIndex ) );\n                    break;\n\n                //case CollectionChangeType.ItemSaved:\n                case CollectionChangeType.ItemChanged:\n                    oldIndex = this.Indexer.FindEntityItemViewIndexInView(e.Index);\n                    newIndex = oldIndex;\n\n                    this.OnCollectionChanged(args, e.ChangeType);\n                    if (!args.Cancel)\n                    {\n                        this.Indexer.Rebuild();\n                        newIndex = this.Indexer.FindEntityItemViewIndexInView(e.Index);\n                    }\n\n                    if (newIndex > -1)\n                    {\n                        if (newIndex != oldIndex)\n                        {\n                            /*\n                             * Se i due indici, prima e dopo il Rebuild sono diversi\n                             * significa che la posizione dell'elemento \u00e8 cambiata a seguito\n                             * della modifica che ha subito, molto presumibilmente questo \u00e8\n                             * dovuto al fatto che la View \u00e8 sortata quindi informiamo dello\n                             * spostamento\n                             */\n                            this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemMoved, newIndex, oldIndex));\n                            //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Move ) );\n                        }\n                        else\n                        {\n                            this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, newIndex));\n                            //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                        }\n                    }\n                    else\n                    {\n                        /*\n                         * L'introduzione di ItemDeleted non dovrebbe pi\u00f9 portare qui...\n                         */\n                        Debug.Fail(\"...CollectionChangeType.ItemChanged and newIndex = -1...\");\n                        this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, oldIndex));\n                        //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Remove, null, oldIndex ) );\n                    }\n                    break;\n\n                //case CollectionChangeType.ItemDeleted:\n                case CollectionChangeType.ItemRemoved:\n\n                    /*\n                     * Qui abbiamo una discreta magagna:\n                     * \n                     * quando un elemento viene rimosso dalla DataSource la griglia\n                     * collegata a questa IBindingList ha bisogno di sapere l'indice\n                     * (nella View) dell'elemento rimosso per farlo sparire anche a\n                     * video.\n                     * \n                     * Questa informazione non c'\u00e8... perch\u00e8 a questo punto l'elemento\n                     * \u00e8 gi\u00e0 stato rimosso e l'Indexer non \u00e8 in grado di dirci dove stava.\n                     * \n                     * L'unica soluzione che mi viene in mente \u00e8 che l'Indexer abbia un indice\n                     * che tiene traccia degli indici: Dictionary<int, int> con \n                     * SourceIndex --> ViewIndex\n                     * \n                     * Un'altra possibile soluzione \u00e8 che tra gli arguments ci sia anche un riferimento\n                     * all'elemento rimosso, in questo modo lo potremmo cercare nella View, perderemmo in\n                     * performance ma sarebbe pi\u00f9 semplice\n                     */\n                    oldIndex = this.Indexer.IndexOf((T)e.Item);\n                    this.ClearCustomValuesFor(e.Item);\n\n                    this.OnCollectionChanged(args, e.ChangeType);\n                    if (!args.Cancel)\n                    {\n                        this.Indexer.Rebuild();\n                    }\n\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, oldIndex));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Remove, null, oldIndex ) );\n                    break;\n\n                case CollectionChangeType.ItemReplaced:\n                case CollectionChangeType.ItemMoved:\n                case CollectionChangeType.SortChanged:\n                case CollectionChangeType.Reset:\n                    //case CollectionChangeType.ChangesRejected:\n\n                    if (e.ChangeType == CollectionChangeType.ItemReplaced)\n                    {\n                        this.ClearCustomValuesFor(e.Item);\n                    }\n                    else if (e.ChangeType == CollectionChangeType.Reset && this.DataSource.Count == 0)\n                    {\n                        //Supponiamo che possa esserci stata una clear...\n                        this.customPropertyValues.Clear();\n                    }\n\n                    this.OnCollectionChanged(args, e.ChangeType);\n                    if (!args.Cancel)\n                    {\n                        this.Indexer.Rebuild();\n                    }\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                    break;\n\n                    //case CollectionChangeType.ChangesAccepted:\n                    //    /*\n                    //     * In questo caso visivamente non cambia nulla\n                    //     * quindi non ribaltiamo niente all'esterno\n                    //     */\n                    //    break;\n            }\n        }\n\n        #endregion\n\n        /// <summary>\n        /// This method is called whenever the underlying DataSource fires the CollectionChanged event,\n        /// here inheritors have the opportunity to prevent this instance to rebuild indexes after the\n        /// changes, the default behavior is to rebuild indexes on every change.\n        /// </summary>\n        /// <param name=\"e\">The <see cref=\"Radical.Model.RebuildIndexesEventArgs\"/> instance containing the event data.</param>\n        /// <param name=\"changeType\">Type of the change.</param>\n        protected virtual void OnCollectionChanged(RebuildIndexesEventArgs e, CollectionChangeType changeType)\n        {\n\n        }\n\n        /// <summary>\n        /// Called when the View is initialized and fully indexed.\n        /// </summary>\n        protected virtual void OnLoad()\n        {\n\n        }\n\n        #region IEntityItemView EventHandlers\n\n        /// <summary>\n        /// This method is called whenever a new IEntityItemView is built in order\n        /// to allow the View to add event handlers to the new element\n        /// </summary>\n        /// <param name=\"item\">The IEntityItemView to wire.</param>\n        protected virtual internal void OnWireEntityItemView(IEntityItemView<T> item)\n        {\n            item.EditBegun += this.onEntityItemViewEditBegunHandler;\n            item.EditCanceled += this.onEntityItemViewEditCanceledHandler;\n            item.EditEnded += this.onEntityItemViewEditEndedHandler;\n            item.PropertyChanged += this.onEntityItemViewPropertyChangedHandler;\n\n            //if( this.tIsINotifySaved )\n            //{\n            //    ( ( INotifySaved )item.EntityItem ).Saved += this.onEntityItemViewSaved;\n            //}\n\n            //if( this.tIsINotifyDeleted )\n            //{\n            //    ( ( INotifyDeleted )item.EntityItem ).Deleted += this.onEntityItemViewDeleted;\n            //}\n        }\n\n        /// <summary>\n        /// This method is called alaways before destroyng an EntityItemView\n        /// in order to allow the View to detach event handlers from the element\n        /// </summary>\n        /// <param name=\"item\">The EntityItemView to unwire.</param>\n        protected virtual internal void OnUnwireEntityItemView(IEntityItemView<T> item)\n        {\n            item.EditBegun -= this.onEntityItemViewEditBegunHandler;\n            item.EditCanceled -= this.onEntityItemViewEditCanceledHandler;\n            item.EditEnded -= this.onEntityItemViewEditEndedHandler;\n            item.PropertyChanged -= this.onEntityItemViewPropertyChangedHandler;\n\n            //if( this.tIsINotifySaved )\n            //{\n            //    ( ( INotifySaved )item.EntityItem ).Saved -= this.onEntityItemViewSaved;\n            //}\n\n            //if( this.tIsINotifyDeleted )\n            //{\n            //    ( ( INotifyDeleted )item.EntityItem ).Deleted -= this.onEntityItemViewDeleted;\n            //}\n        }\n\n        //void OnEntityItemViewDeleted( object sender, DeletedEventArgs e )\n        //{\n        //    /*\n        //     * Questo \u00e8 l'elemento che \u00e8 stato cancellato\n        //     */\n        //    T item = ( T )sender;\n\n        //    /*\n        //     * Ci assicuriamo che il contesto sia quello giusto,\n        //     * non vedo perch\u00e8 non dovrebbe ma un controllo in pi\u00f9\n        //     * non fa male... :-)\n        //     */\n        //    if( this.IsInAddingNewQueue( item ) )\n        //    {\n        //        int viewIndex = this.Indexer.IndexOf( item );\n        //        this.CancelNew( viewIndex );\n        //    }\n        //}\n\n        //void OnEntityItemViewSaved( object sender, SavedEventArgs e )\n        //{\n        //    /*\n        //     * Questo \u00e8 l'elemento che \u00e8 stato salvato\n        //     */\n        //    T item = ( T )sender;\n\n        //    /*\n        //     * Ci assicuriamo che il contesto sia quello giusto,\n        //     * non vedo perch\u00e8 non dovrebbe ma un controllo in pi\u00f9\n        //     * non fa male... :-)\n        //     */\n        //    if( this.IsInAddingNewQueue( item ) )\n        //    {\n        //        int viewIndex = this.Indexer.IndexOf( item );\n        //        this.EndNew( viewIndex );\n        //    }\n        //}\n\n        void OnEntityItemViewPropertyChanged(object sender, PropertyChangedEventArgs e)\n        {\n            IEntityItemView<T> obj = (IEntityItemView<T>)sender;\n\n            int index = this.Indexer.IndexOf(obj);\n            if (index > -1)\n            {\n                /*\n                 * Scateniamo l'evento solo nel caso in cui l'item che sta comunicando una\n                 * modifica sia presente nella View, potrebbe non esserci perch\u00e8 in quel \n                 * momento la View \u00e8 filtrata. In realt\u00e0 non \u00e8 vero perch\u00e8 se \u00e8 filtrata non\n                 * dovrebbe esistere neanche l'EntityItemView\n                 */\n                this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, index));\n                //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n            }\n        }\n\n        /// <summary>\n        /// Called when EntityItemView edit begins\n        /// </summary>\n        /// <param name=\"item\">The item. entered in edit mode</param>\n        protected virtual void OnEntityItemViewEditBegun(IEntityItemView<T> item)\n        {\n\n        }\n\n        void OnEntityItemViewEditBegun(object sender, EventArgs e)\n        {\n            IEntityItemView<T> item = (IEntityItemView<T>)sender;\n            this.OnEntityItemViewEditBegun(item);\n        }\n\n        /// <summary>\n        /// Called when IEntityItemView edit is ended. This method can be overriden in order to decide\n        /// if after an Edit operation the Index has to be rebuilt or not. One reason not to rebuild the\n        /// Indexes after an edit operation is that the position, or the visibility, of the edited element\n        /// could change due to the applied changes.\n        /// </summary>\n        /// <param name=\"e\">A RebuildIndexesEventArgs wich allow derived classes to change the rebuild indexes behavior</param>\n        protected virtual void OnEntityItemViewEditEnded(RebuildIndexesEventArgs e)\n        {\n\n        }\n\n        void OnEntityItemViewEditEnded(object sender, EventArgs e)\n        {\n            /*\n             * Al termine dell'edit di un elemento abbiamo un problema che \n             * non siamo in grado di risolvere in autonomia:\n             * \n             * Se la View \u00e8 filtrata o sortata in qualche modo collection'\u00e8 la possibilit\u00e0 che\n             * l'elemento di cui abbiamo appena finito l'editing si sposti dalla sua \n             * posizione, a causa del sort, o addirittura scompaia a causa del filtro:\n             * un esempio classico \u00e8 la classica Person con una propriet\u00e0 Name, se la View\n             * \u00e8 sortata e cambio il Name la posizione dell'istanza all'interno della view\n             * potrebbe dover essere cambiata, stessa cosa per il filtro se sto visualizzando\n             * le sole Person il cui nome inizia per \"M*\" cmabiando il nome di una person\n             * non \u00e8 detto che questa debba restare tra quelle visibili.\n             * \n             * Anche se tutto ci\u00f2 concettualmente \u00e8 giusto resta il problema che la variazione \n             * di visibilit\u00e0 o posizione potrebbe essere \"mal digerita\" dall'utente diamo quindi\n             * la possibilit\u00e0 alla classe derivata di decidere se riapplicare filtro e sort a seguito\n             * di una modifica ad un elemento.\n             * \n             * Il comportamento \u00e8: riapplicare sempre.\n             */\n            IEntityItemView<T> item = (IEntityItemView<T>)sender;\n\n            /*\n             * Dobbiamo sapere se l'elemento \u00e8 visibile \n             * o meno a seconda del filtro corrente, recuperiamo\n             * quindi l'indice dell'elemento prima di applicare\n             * il filtro\n             */\n            int preFilterIndex = this.Indexer.IndexOf(item);\n\n            /*\n             * Costruiamo un bel RebuildIndexesEventArgs e lo passiamo \n             * all'eventuale classe derivata che avr\u00e0 la possibilit\u00e0 di\n             * bloccare il Rebuild\n             */\n            RebuildIndexesEventArgs args = new RebuildIndexesEventArgs(preFilterIndex);\n            this.OnEntityItemViewEditEnded(args);\n\n            if (!args.Cancel)\n            {\n                /*\n                 * Se nessuno blocca riapplichiamo il filtro\n                 */\n                this.Indexer.Rebuild();\n            }\n\n            /*\n             * Recuperiamo l'indice dopo aver applicato il filtro\n             * se il valore \u00e8 -1 significa che \u00e8 stato escluso dal \n             * filtro corrente, adesso siamo obbligati ad usare EntityItem\n             * perch\u00e8 se gli Indici sono stati ricreati l'istanza (sender)\n             * che abbiamo di IEntityItemView non esister\u00e0 di certo pi\u00f9\n             */\n            int postFilterIndex = this.Indexer.IndexOf(item.EntityItem);\n\n            if (postFilterIndex > -1)\n            {\n                if (preFilterIndex == postFilterIndex)\n                {\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemChanged, postFilterIndex));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                }\n                else\n                {\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemMoved, postFilterIndex, preFilterIndex));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Move, item, postFilterIndex, preFilterIndex ) );\n                }\n            }\n            else\n            {\n                this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, preFilterIndex));\n                //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Remove, item, preFilterIndex ) );\n            }\n\n\n        }\n\n        /// <summary>\n        /// Called when IEntityItemView edit is canceled by the user\n        /// </summary>\n        /// <param name=\"item\">The item which editing has been cancelled</param>\n        protected virtual void OnEntityItemViewEditCanceled(IEntityItemView<T> item)\n        {\n\n        }\n\n        void OnEntityItemViewEditCanceled(object sender, EventArgs e)\n        {\n            IEntityItemView<T> item = (IEntityItemView<T>)sender;\n            this.OnEntityItemViewEditCanceled(item);\n        }\n\n        #endregion\n\n        /// <summary>\n        /// Refreshes this instance, rebuilding internal indexes\n        /// </summary>\n        public virtual void Refresh()\n        {\n            this.Indexer.Rebuild();\n            this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n            //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n        }\n\n        /// <summary>\n        /// Gets a value indicating whether moving elements is allowed in this view.\n        /// </summary>\n        /// <value><c>true</c> if move is allowed; otherwise, <c>false</c>.</value>\n        public bool AllowMove\n        {\n            get { return !this.IsSorted; }\n        }\n\n        /// <summary>\n        /// Moves the element at the specified source index to the specified new index.\n        /// </summary>\n        /// <param name=\"sourceIndex\">Index of the source element to move.</param>\n        /// <param name=\"newIndex\">The destination index.</param>\n        public void Move(int sourceIndex, int newIndex)\n        {\n            /*\n             * Non ha nessun senso \"spostare\" elementi su un qualcosa \n             * che \u00e8 sortato perch\u00e8 dato che dopo la Move gli indici \n             * vengono ricostruiti gli elementi restano, per l'utente,\n             * nella stessa identica posizione....\n             */\n            //TODO: migliorare l'eccezione\n            Ensure.That(this)\n                .If(view => view.IsSorted || view.IsArrayBased)\n                .Then((val) => { throw new NotSupportedException(); });\n\n            //TODO: migliorare l'eccezione\n            Ensure.That(sourceIndex)\n                .If((val) => val < 0 || val > this.Count - 1)\n                .Then((val) => { throw new ArgumentOutOfRangeException(); });\n\n            Ensure.That(newIndex)\n                .If((val) => val < 0 || val > this.Count - 1)\n                .Then((val) => { throw new ArgumentOutOfRangeException(); });\n\n            /*\n             * Se la view non \u00e8 sorted/filterd gli indici coincidono\n             * con quelli della data source altrimenti no, quindi in\n             * tutti i casi la prima operazione \u00e8 quella di recuperare\n             * gli indici dei rispettivi item nella data source e poi\n             * delegare a lei.\n             */\n            int sourceIndexInDataSource = this.Indexer.FindObjectIndexInDataSource(sourceIndex);\n            int destinationIndexInDataSource = this.Indexer.FindObjectIndexInDataSource(newIndex);\n\n            IEntityCollection<T> entityCollection = this.DataSource as IEntityCollection<T>;\n            if (entityCollection != null)\n            {\n                /*\n                 * Se \u00e8 una IEntityCollection<T> usiamo Move cos\u00ec l'eventuale\n                 * motore di tracking traccia una singola operazione atomica\n                 */\n                entityCollection.Move(sourceIndexInDataSource, destinationIndexInDataSource);\n            }\n            else\n            {\n                /*\n                 * Altrimenti rimuoviamo e reinseriamo\n                 * e alla fine indicizziamo\n                 */\n                T entityItem = this[sourceIndex].EntityItem;\n\n                this.DataSource.RemoveAt(sourceIndexInDataSource);\n                this.DataSource.Insert(destinationIndexInDataSource, entityItem);\n\n                this.Indexer.Rebuild();\n                this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n            }\n        }\n\n        /// <summary>\n        /// Moves the specified item to the specified new index.\n        /// </summary>\n        /// <param name=\"item\">The item to move.</param>\n        /// <param name=\"newIndex\">The destination index.</param>\n        public void Move(IEntityItemView<T> item, int newIndex)\n        {\n            int sourceIndex = this.IndexOf(item);\n            this.Move(sourceIndex, newIndex);\n        }\n\n        #region Filtering\n\n        /// <summary>\n        /// Gets a item indicating whether this instance is currently filtered.\n        /// </summary>\n        /// <item>\n        ///     <collection>true</collection> if this instance is filtered; otherwise, <collection>false</collection>.\n        /// </item>\n        public bool IsFiltered\n        {\n            get { return this.Filter != ViewAllEntityItemViewFilter<T>.Instance; }\n        }\n\n        /// <summary>\n        /// Gets a item indicating whether the data source supports filtering.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if the data source supports filtering; otherwise, false. </returns>\n        bool IBindingListView.SupportsFiltering\n        {\n            get { return true; }\n        }\n\n        /// <summary>\n        /// Gets or sets the filter to be used to exclude items from the collection of items returned by the data source\n        /// </summary>\n        /// <item></item>\n        /// <returns>The string used to filter items out in the item collection returned by the data source. </returns>\n        string IBindingListView.Filter\n        {\n            get { return this.Filter.ToString(); }\n            set\n            {\n                var msg = string.Format(\"Setting '{0}' directly as Filter is not supported.\", value ?? \"<null>\");\n                throw new NotSupportedException(msg);\n                //TODO: IBindingListView.Instance\n                /* Bisogna capire se siamo in grado data \n                 * una stringa di convertirla in un filtro \n                 * valido...\n                 */\n            }\n        }\n\n        IEntityItemViewFilter IEntityView.Filter\n        {\n            get { return this.Filter; }\n            set\n            {\n                if (value == null)\n                {\n                    this.Filter = null;\n                }\n                else\n                {\n                    IEntityItemViewFilter<T> filter = value as IEntityItemViewFilter<T>;\n                    if (filter == null)\n                    {\n                        //TODO: impostare il messaggio dell'eccezione\n                        throw new ArgumentException();\n                    }\n\n                    this.Filter = filter;\n                }\n            }\n        }\n\n        public void ApplyFilter(Predicate<T> predicate)\n        {\n            if (predicate == null)\n            {\n                this.Filter = null;\n            }\n            else\n            {\n                this.Filter = new PredicateEntityItemViewFilter<T>(predicate);\n            }\n        }\n\n        /*\n         * Il filtro correntemente impostato\n         */\n        private IEntityItemViewFilter<T> _filter;\n\n        /// <summary>\n        /// Gets or sets the filter to be used to exclude items from the collection of items returned by the data source\n        /// </summary>\n        /// <value></value>\n        /// <returns>\n        /// The string used to filter items out in the item collection returned by the data source.\n        /// </returns>\n        public IEntityItemViewFilter<T> Filter\n        {\n            get\n            {\n                if (this._filter == null)\n                {\n                    /*\n                     * Se il filtro \u00e8 null impostiamo un bel \"ViewAll\"\n                     */\n                    this._filter = (IEntityItemViewFilter<T>)ViewAllEntityItemViewFilter<T>.Instance;\n                }\n\n                return this._filter;\n            }\n            set\n            {\n                if (value == null)\n                {\n                    /*\n                     * Se il filtro \u00e8 null impostiamo un bel \"ViewAll\"\n                     */\n                    value = (IEntityItemViewFilter<T>)ViewAllEntityItemViewFilter<T>.Instance;\n                }\n\n                if (this._filter != value)\n                {\n                    /*\n                     * Se il filtro sta per cambiare:\n                     *    - impostiamo la nuova istanza\n                     *    - ricostruiamo gli indici in modo\n                     *      da applicare le modifiche\n                     *    - comunichiamo al mondo sia il reset della lista\n                     *      che un evento custom che informa che il filtro\n                     *      \u00e8 cambiato\n                     */\n                    this._filter = value;\n\n                    this.Indexer.Rebuild();\n\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                    this.OnFilterChanged();\n                    this.OnPropertyChanged(\"IsFiltered\");\n                }\n            }\n        }\n\n        ///// <summary>\n        ///// Reapply the given filter to the underlying data\n        ///// </summary>\n        ///// <param name=\"filter\">The filter to (re)apply</param>\n        //void IEntityView.ReapplyFilter( IEntityItemViewFilter filter )\n        //{\n        //    IEntityItemViewFilter<T> value = filter as IEntityItemViewFilter<T>;\n        //    if( value == null )\n        //    {\n        //        //TODO: impostare il messaggio dell'eccezione\n        //        throw new ArgumentException();\n        //    }\n\n        //    this.ReapplyFilter( value );\n        //}\n\n\n        ///// <summary>\n        ///// Reapply the given filter to the underlying data\n        ///// </summary>\n        ///// <param name=\"filter\">The filter to (re)apply</param>\n        //public void ReapplyFilter( IEntityItemViewFilter<T> filter )\n        //{\n        //    if( filter == null )\n        //    {\n        //        filter = ( IEntityItemViewFilter<T> )ViewAllEntityItemViewFilter<T>.Instance;\n        //    }\n\n        //    bool filterIsChanged = false;\n        //    if( this.Filter != filter )\n        //    {\n        //        this._filter = filter;\n        //        filterIsChanged = true;\n        //    }\n\n        //    this.Indexer.Rebuild();\n\n        //    this.OnListChanged( new ListChangedEventArgs( ListChangedType.Reset, -1 ) );\n        //    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n\n        //    if( filterIsChanged )\n        //    {\n        //        this.OnFilterChanged();\n        //    }\n        //}\n\n        /// <summary>\n        /// Removes the current filter applied to the data source.\n        /// </summary>\n        public void RemoveFilter()\n        {\n            this.Filter = null;\n        }\n\n        private static readonly object filterChangedEventKey = new object();\n\n        /// <summary>\n        /// Occurs when filter changes.\n        /// </summary>\n        public event EventHandler FilterChanged\n        {\n            add { this.Events.AddHandler(filterChangedEventKey, value); }\n            remove { this.Events.RemoveHandler(filterChangedEventKey, value); }\n        }\n\n        /// <summary>\n        /// Fires the FilterChanged event.\n        /// </summary>\n        protected virtual void OnFilterChanged()\n        {\n            EventHandler h = this.Events[filterChangedEventKey] as EventHandler;\n            if (h != null)\n            {\n                h(this, EventArgs.Empty);\n            }\n        }\n\n        #endregion\n\n        #region Sorting\n\n        /// <summary>\n        /// Called when this list needs to create the sort comparer used for data sorting.\n        /// </summary>\n        /// <returns>An implementation of the IComparer&lt;IEntityItemView&lt;T&gt;&gt; used to compare items.</returns>\n        protected virtual IComparer<IEntityItemView<T>> OnCreateSortComparer()\n        {\n            return new EntityItemViewSortComparer<T>(this.SortDescriptions);\n        }\n\n        bool IsCustomComparer = false;\n\n        private IComparer<IEntityItemView<T>> _sortComparer;\n        internal IComparer<IEntityItemView<T>> SortComparer\n        {\n            get\n            {\n                if (this._sortComparer == null)\n                {\n                    this._sortComparer = this.OnCreateSortComparer();\n                    this.IsCustomComparer = false;\n                }\n\n                return this._sortComparer;\n            }\n        }\n\n        /// <summary>\n        /// Gets whether the list supports sorting.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if the list supports sorting; otherwise, false.</returns>\n        bool IBindingList.SupportsSorting\n        {\n            get { return this.AllowSort; }\n        }\n\n        /// <summary>\n        /// Gets a item indicating whether the data source supports advanced sorting.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if the data source supports advanced sorting; otherwise, false. </returns>\n        bool IBindingListView.SupportsAdvancedSorting\n        {\n            get { return this.AllowSort; }\n        }\n\n        /// <summary>\n        /// Sorts the list based on a <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> and a <see cref=\"T:System.ComponentModel.ListSortDirection\"/>.\n        /// </summary>\n        /// <param name=\"property\">The <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> to sort by.</param>\n        /// <param name=\"direction\">One of the <see cref=\"T:System.ComponentModel.ListSortDirection\"/> values.</param>\n        /// <exception cref=\"T:System.NotSupportedException\">\n        ///     <see cref=\"P:System.ComponentModel.IBindingList.SupportsSorting\"/> is false. </exception>\n        public void ApplySort(PropertyDescriptor property, ListSortDirection direction)\n        {\n            ListSortDescription[] sorts = new ListSortDescription[] { new ListSortDescription(property, direction) };\n            this.ApplySort(new ListSortDescriptionCollection(sorts));\n        }\n\n        /// <summary>\n        /// Sorts the data source based on the given <see cref=\"T:System.ComponentModel.ListSortDescriptionCollection\"/>.\n        /// </summary>\n        /// <param name=\"sorts\">The <see cref=\"T:System.ComponentModel.ListSortDescriptionCollection\"/> containing the sorts to apply to the data source.</param>\n        public void ApplySort(ListSortDescriptionCollection sorts)\n        {\n            //this.SortDescriptions = sorts;\n\n            bool wasSorted = this.IsSorted;\n\n            this._sortDescriptions = sorts;\n\n            //TODO: dovremmo verificare se le SortDescriptions sono effettivamente cambiate.\n\n            /*\n             * Le SortDescriptions sono cambiate quindi l'eventuale SortComparer attuale\n             * non va pi\u00f9 bene, lo impostiamo a null in questo modo quando l'Indexer \n             * riapplica il sort e chiede alla View il SortComparer ne viene creato uno nuovo\n             */\n            this._sortComparer = null;\n            this.IsCustomComparer = false;\n\n            if (wasSorted && !this.IsSorted)\n            {\n                this.Indexer.RemoveSort();\n            }\n            else\n            {\n                this.Indexer.ApplySort();\n            }\n\n            this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n            //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n            this.OnSortChanged();\n            this.OnPropertyChanged(\"IsSorted\");\n        }\n\n        /// <summary>\n        /// Sorts the data source based on the given sort string.\n        /// </summary>\n        /// <param name=\"sort\">The sort string in T-Sql format</param>\n        public void ApplySort(string sort)\n        {\n            if (string.IsNullOrEmpty(sort))\n            {\n                this.RemoveSort();\n            }\n            else\n            {\n                //Cerca gli elementi secondo cui sortare\n                var sorts = sort.Split(',');\n\n                var col = new ListSortDescription[sorts.Length];\n                for (var i = 0; i < sorts.Length; i++)\n                {\n                    /*\n                     * Estrae la propriet\u00e0 per cui sortare, \n                     * eventualmente seguita dalla direzione\n                     * */\n                    sort = sorts[i].Trim();\n\n                    //L'eventuale spazio che separa la \"SortDirection\"\n                    var pos = sort.IndexOf(' ');\n\n                    string name;\n                    var direction = ListSortDirection.Ascending;\n\n                    if (pos == -1)\n                    {\n                        name = sort;\n                    }\n                    else\n                    {\n                        /*\n                         * Il nome \u00e8 tutto ci\u00f2 che c'\u00e8 \n                         * prima dello spazio\n                         */\n                        name = sort.Substring(0, pos);\n\n                        /*\n                         * La direzione tutto quello che viene dopo\n                         */\n                        var dir = sort.Substring(pos + 1).Trim();\n                        if (string.Equals(dir, \"desc\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            direction = ListSortDirection.Descending;\n                        }\n                    }\n\n                    /*\n                     * Cerchiamo di ricavre la propriet\u00e0 che \n                     * rappresentata dal nome passato\n                     */\n                    var property = new EntityItemViewPropertyDescriptor<T>(typeof(T).GetProperty(name));\n\n                    /*\n                     * Tutto ok, aggiungiamo al ns elenco\n                     */\n                    col[i] = new ListSortDescription(property, direction);\n                }\n\n                this.ApplySort(new ListSortDescriptionCollection(col));\n            }\n        }\n\n        public void ApplySort(IComparer<IEntityItemView<T>> comparer)\n        {\n            //this.SortDescriptions = null;\n            if (this.IsSorted)\n            {\n                this.RemoveSort();\n            }\n\n            this._sortComparer = comparer;\n            if (comparer == null)\n            {\n                this.Indexer.RemoveSort();\n            }\n            else\n            {\n                this.IsCustomComparer = true;\n                this.Indexer.ApplySort();\n            }\n        }\n\n        /// <summary>\n        /// Removes any sort applied using <see cref=\"M:System.ComponentModel.IBindingList.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)\"/>.\n        /// </summary>\n        /// <exception cref=\"T:System.NotSupportedException\">\n        ///     <see cref=\"P:System.ComponentModel.IBindingList.SupportsSorting\"/> is false. </exception>\n        public void RemoveSort()\n        {\n            this.ApplySort(new ListSortDescriptionCollection());\n        }\n\n        /// <summary>\n        /// Gets whether the items in the list are sorted.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if <see cref=\"M:System.ComponentModel.IBindingList.ApplySort(System.ComponentModel.PropertyDescriptor,System.ComponentModel.ListSortDirection)\"/> has been called and <see cref=\"M:System.ComponentModel.IBindingList.RemoveSort\"/> has not been called; otherwise, false.</returns>\n        /// <exception cref=\"T:System.NotSupportedException\">\n        ///     <see cref=\"P:System.ComponentModel.IBindingList.SupportsSorting\"/> is false. </exception>\n        public bool IsSorted\n        {\n            get { return (this.SortDescriptions.Count > 0 || this.IsCustomComparer); }\n        }\n\n        /// <summary>\n        /// Gets the direction of the sort.\n        /// </summary>\n        /// <item></item>\n        /// <returns>One of the <see cref=\"T:System.ComponentModel.ListSortDirection\"/> values.</returns>\n        /// <exception cref=\"T:System.NotSupportedException\">\n        ///     <see cref=\"P:System.ComponentModel.IBindingList.SupportsSorting\"/> is false. </exception>\n        public ListSortDirection SortDirection\n        {\n            get\n            {\n                if (this.IsSorted)\n                {\n                    return this.SortDescriptions[0].SortDirection;\n                }\n                else\n                {\n                    return ListSortDirection.Ascending;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets the <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> that is being used for sorting.\n        /// </summary>\n        /// <item></item>\n        /// <returns>The <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> that is being used for sorting.</returns>\n        /// <exception cref=\"T:System.NotSupportedException\">\n        ///     <see cref=\"P:System.ComponentModel.IBindingList.SupportsSorting\"/> is false. </exception>\n        public PropertyDescriptor SortProperty\n        {\n            get\n            {\n                if (this.IsSorted)\n                {\n                    return this.SortDescriptions[0].PropertyDescriptor;\n                }\n                else\n                {\n                    return null;\n                }\n            }\n        }\n\n        private ListSortDescriptionCollection _sortDescriptions;\n        /// <summary>\n        /// Gets the collection of sort descriptions currently applied to the data source.\n        /// </summary>\n        /// <item></item>\n        /// <returns>The <see cref=\"T:System.ComponentModel.ListSortDescriptionCollection\"/> currently applied to the data source.</returns>\n        public ListSortDescriptionCollection SortDescriptions\n        {\n            get\n            {\n                if (this._sortDescriptions == null)\n                {\n                    this._sortDescriptions = new ListSortDescriptionCollection();\n                }\n\n                return this._sortDescriptions;\n            }\n            //private set\n            //{\n            //    bool wasSorted = this.IsSorted;\n\n            //    this._sortDescriptions = value;\n\n            //    //TODO: dovremmo verificare se le SortDescriptions sono effettivamente cambiate.\n\n            //    /*\n            //     * Le SortDescriptions sono cambiate quindi l'eventuale SortComparer attuale\n            //     * non va pi\u00f9 bene, lo impostiamo a null in questo modo quando l'Indexer \n            //     * riapplica il sort e chiede alla View il SortComparer ne viene creato uno nuovo\n            //     */\n            //    this._sortComparer = null;\n            //    this.IsCustomComparer = false;\n\n            //    if( wasSorted && !this.IsSorted )\n            //    {\n            //        this.Indexer.RemoveSort();\n            //    }\n            //    else\n            //    {\n            //        this.Indexer.ApplySort();\n            //    }\n\n            //    this.OnListChanged( new ListChangedEventArgs( ListChangedType.Reset, -1 ) );\n            //    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n            //    this.OnSortChanged();\n            //    this.OnPropertyChanged( \"IsSorted\" );\n            //}\n        }\n\n        private static readonly object sortChangedEventKey = new object();\n\n        /// <summary>\n        /// Occurs when sort changes.\n        /// </summary>\n        public event EventHandler SortChanged\n        {\n            add { this.Events.AddHandler(sortChangedEventKey, value); }\n            remove { this.Events.RemoveHandler(sortChangedEventKey, value); }\n        }\n\n        /// <summary>\n        /// Fires the SortChanged event.\n        /// </summary>\n        protected virtual void OnSortChanged()\n        {\n            EventHandler h = this.Events[sortChangedEventKey] as EventHandler;\n            if (h != null)\n            {\n                h(this, EventArgs.Empty);\n            }\n        }\n\n        #endregion\n\n        #region IRaiseItemChangedEvents Members\n\n        /// <summary>\n        /// Gets a item indicating whether the <see cref=\"T:System.ComponentModel.IRaiseItemChangedEvents\"/> object raises <see cref=\"E:System.ComponentModel.IBindingList.ListChanged\"/> events.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if the <see cref=\"T:System.ComponentModel.IRaiseItemChangedEvents\"/> object raises <see cref=\"E:System.ComponentModel.IBindingList.ListChanged\"/> events when one of its property values changes; otherwise, false.</returns>\n        public bool RaisesItemChangedEvents\n        {\n            get { return true; }\n        }\n\n        #endregion\n\n        #region IEnumerable Members\n\n        /// <summary>\n        /// Returns an enumerator that iterates through a collection.\n        /// </summary>\n        /// <returns>\n        /// An <see cref=\"T:System.Collections.IEnumerator\"/> object that can be used to iterate through the collection.\n        /// </returns>\n        IEnumerator IEnumerable.GetEnumerator()\n        {\n            return ((IEnumerable)this.Indexer).GetEnumerator();\n        }\n\n        #endregion\n\n        #region ICollection Members\n\n        /// <summary>\n        /// Copies the elements of the <see cref=\"T:System.Collections.ICollection\"/> to an <see cref=\"T:System.Array\"/>, starting at a particular <see cref=\"T:System.Array\"/> index.\n        /// </summary>\n        /// <param name=\"array\">The one-dimensional <see cref=\"T:System.Array\"/> that is the destination of the elements copied from <see cref=\"T:System.Collections.ICollection\"/>. The <see cref=\"T:System.Array\"/> must have zero-based indexing.</param>\n        /// <param name=\"index\">The zero-based index in <paramref name=\"array\"/> at which copying begins.</param>\n        /// <exception cref=\"T:System.ArgumentNullException\">\n        ///     <paramref name=\"array\"/> is null. </exception>\n        /// <exception cref=\"T:System.ArgumentOutOfRangeException\">\n        ///     <paramref name=\"index\"/> is less than zero. </exception>\n        /// <exception cref=\"T:System.ArgumentException\">\n        ///     <paramref name=\"array\"/> is multidimensional.-or- <paramref name=\"index\"/> is equal to or greater than the length of <paramref name=\"array\"/>.-or- The number of elements in the source <see cref=\"T:System.Collections.ICollection\"/> is greater than the available space from <paramref name=\"index\"/> to the end of the destination <paramref name=\"array\"/>. </exception>\n        /// <exception cref=\"T:System.ArgumentException\">The type of the source <see cref=\"T:System.Collections.ICollection\"/> cannot be cast automatically to the type of the destination <paramref name=\"array\"/>. </exception>\n        void ICollection.CopyTo(Array array, int index)\n        {\n            IEntityItemView<T>[] data = new IEntityItemView<T>[this.Indexer.Count];\n            this.Indexer.CopyTo(data, index);\n            data.CopyTo(array, index);\n        }\n\n        /// <summary>\n        /// Gets a item indicating whether access to the <see cref=\"T:System.Collections.ICollection\"/> is synchronized (thread safe).\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if access to the <see cref=\"T:System.Collections.ICollection\"/> is synchronized (thread safe); otherwise, false.</returns>\n        bool ICollection.IsSynchronized\n        {\n            get { return ((ICollection)this.DataSource).IsSynchronized; }\n        }\n\n        /// <summary>\n        /// Gets an object that can be used to synchronize access to the <see cref=\"T:System.Collections.ICollection\"/>.\n        /// </summary>\n        /// <item></item>\n        /// <returns>An object that can be used to synchronize access to the <see cref=\"T:System.Collections.ICollection\"/>.</returns>\n        object ICollection.SyncRoot\n        {\n            get { return ((ICollection)this.DataSource).SyncRoot; }\n        }\n\n        /// <summary>\n        /// Gets the number of elements contained in the <see cref=\"T:System.Collections.ICollection\"/>.\n        /// </summary>\n        /// <item></item>\n        /// <returns>The number of elements contained in the <see cref=\"T:System.Collections.ICollection\"/>.</returns>\n        public int Count\n        {\n            get { return this.Indexer.Count; }\n        }\n\n        #endregion\n\n        #region IList Members\n\n        /// <summary>\n        /// Adds an item to the <see cref=\"T:System.Collections.IList\"/>.\n        /// </summary>\n        /// <param name=\"value\">The <see cref=\"T:System.Object\"/> to add to the <see cref=\"T:System.Collections.IList\"/>.</param>\n        /// <returns>\n        /// The position into which the new element was inserted.\n        /// </returns>\n        /// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.IList\"/> is read-only.-or- The <see cref=\"T:System.Collections.IList\"/> has a fixed size. </exception>\n        int IList.Add(object value)\n        {\n            throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exceptions.CannotAccessEntityViewException, \"Add\"));\n        }\n\n        /// <summary>\n        /// Removes all items from the <see cref=\"T:System.Collections.IList\"/>.\n        /// </summary>\n        /// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.IList\"/> is read-only. </exception>\n        void IList.Clear()\n        {\n            throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exceptions.CannotAccessEntityViewException, \"Clear\"));\n        }\n\n        /// <summary>\n        /// Determines whether the <see cref=\"T:System.Collections.IList\"/> contains a specific item.\n        /// </summary>\n        /// <param name=\"value\">The <see cref=\"T:System.Object\"/> to locate in the <see cref=\"T:System.Collections.IList\"/>.</param>\n        /// <returns>\n        /// true if the <see cref=\"T:System.Object\"/> is found in the <see cref=\"T:System.Collections.IList\"/>; otherwise, false.\n        /// </returns>\n        bool IList.Contains(object value)\n        {\n            //return ( -1 != this.IndexOf( value as IEntityItemView<T> ) );\n\n            //WARN: implementazione di IndexOf e Contains probabilmente errata;\n            /*\n             * Dobbiamo prima capire come funziona la DataView e scrivere poi dei test\n             * L'inghippo \u00e8 questo, da verificare se con la DataView non si verifica.\n             * Utilizzando il sistema per sincronizzare gli elementi selected di una\n             * listview wpf con una collection nel ViewModel succede che la sincronia\n             * funziona solo dalla listview verso il vm e non viceversa, la cosa \u00e8 evidente\n             * perch\u00e8 non potendo aggiungere alla view degli elementi selezionati\n             * direttamente un EntityItemView l'unica cosa che possiamo fare \u00e8 agire\n             * sulla datasource ma questo comporta che i 2 entityitemview che wrappano\n             * la datasource siano diversi, quando aggiungiamo l'elemento alla lista dei selected\n             * da codice e sincronizziamocon la listview la listview viene qui e con in\n             * mano un'istanza dell'entityitemview ci chiede se lo conteniamo, \u00e8 evidente\n             * che la risposta \u00e8 no perch\u00e8 quell'elemento sta nella lista dei selezionati\n             * e non nella lista degli itemsSource della lista, quello che invece \u00e8 shared\n             * \u00e8 la data source. In effetti, se spulciamo con reflector, sembra che la dataView\n             * faccia sempre il controllo sull'entity warppata e non sull'itemview...\n             */\n            var contains = false;\n\n            IEntityItemView<T> v1 = value as IEntityItemView<T>;\n            if (v1 != null)\n            {\n                contains = this.Indexer.Contains(v1);\n            }\n\n            //T v2 = value as T;\n            //if( v2 != null )\n            //{\n            //    contains = this.Indexer.Contains( v2 );\n            //}\n\n            if (value is T)\n            {\n                contains = this.Indexer.Contains((T)value);\n            }\n\n            return contains;\n        }\n\n        /// <summary>\n        /// Determines the index of a specific item in the <see cref=\"T:System.Collections.IList\"/>.\n        /// </summary>\n        /// <param name=\"value\">The <see cref=\"T:System.Object\"/> to locate in the <see cref=\"T:System.Collections.IList\"/>.</param>\n        /// <returns>\n        /// The index of <paramref name=\"value\"/> if found in the list; otherwise, -1.\n        /// </returns>\n        int IList.IndexOf(object value)\n        {\n            //return this.IndexOf( value as IEntityItemView<T> );\n\n            var idx = -1;\n\n            //T v1 = value as T;\n            //if( v1 != null )\n            //{\n            //    idx = this.IndexOf( v1 );\n            //}\n\n            if (value is T)\n            {\n                idx = this.IndexOf((T)value);\n            }\n\n            IEntityItemView<T> v2 = value as IEntityItemView<T>;\n            if (v2 != null)\n            {\n                idx = this.IndexOf(v2);\n            }\n\n            return idx;\n        }\n\n        /// <summary>\n        /// Determines the index of a specific item in the <see cref=\"T:System.Collections.IList\"/>.\n        /// </summary>\n        /// <param name=\"item\">The <see cref=\"T:System.Object\"/> to locate in the <see cref=\"T:System.Collections.IList\"/>.</param>\n        /// <returns>\n        /// The index of <paramref name=\"item\"/> if found in the list; otherwise, -1.\n        /// </returns>\n        public int IndexOf(IEntityItemView<T> item)\n        {\n            if (item != null)\n            {\n                if (this.IsAddingNew && Object.ReferenceEquals(this.PendingNewItem.EntityItem, item.EntityItem))\n                {\n                    return this.Count - 1;\n                }\n\n                var idx = this.Indexer.IndexOf(item);\n                return idx;\n            }\n\n            return -1;\n        }\n\n        /// <summary>\n        /// Determines the index of a specific item in the <see cref=\"T:System.Collections.IList\"/>.\n        /// </summary>\n        /// <param name=\"item\">The <see cref=\"T:System.Object\"/> to locate in the <see cref=\"T:System.Collections.IList\"/>.</param>\n        /// <returns>\n        /// The index of <paramref name=\"item\"/> if found in the list; otherwise, -1.\n        /// </returns>\n        public int IndexOf(T item)\n        {\n            return this.Indexer.IndexOf(item);\n        }\n\n        /// <summary>\n        /// Inserts an item to the <see cref=\"T:System.Collections.IList\"/> at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The zero-based index at which <paramref name=\"item\"/> should be inserted.</param>\n        /// <param name=\"item\">The <see cref=\"T:System.Object\"/> to insert into the <see cref=\"T:System.Collections.IList\"/>.</param>\n        /// <exception cref=\"T:System.ArgumentOutOfRangeException\">\n        ///     <paramref name=\"index\"/> is not a valid index in the <see cref=\"T:System.Collections.IList\"/>. </exception>\n        /// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.IList\"/> is read-only.-or- The <see cref=\"T:System.Collections.IList\"/> has a fixed size. </exception>\n        /// <exception cref=\"T:System.NullReferenceException\">\n        ///     <paramref name=\"item\"/> is null reference in the <see cref=\"T:System.Collections.IList\"/>.</exception>\n        void IList.Insert(int index, object item)\n        {\n            throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exceptions.CannotAccessEntityViewException, \"Insert\"));\n        }\n\n        /// <summary>\n        /// Gets a item indicating whether the <see cref=\"T:System.Collections.IList\"/> is read-only.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if the <see cref=\"T:System.Collections.IList\"/> is read-only; otherwise, false.</returns>\n        bool IList.IsReadOnly\n        {\n            get\n            {\n                if (this.IsArrayBased)\n                {\n                    return true;\n                }\n                else\n                {\n                    return this.DataSource.IsReadOnly;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets a item indicating whether the <see cref=\"T:System.Collections.IList\"/> has a fixed size.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if the <see cref=\"T:System.Collections.IList\"/> has a fixed size; otherwise, false.</returns>\n        bool IList.IsFixedSize\n        {\n            get { return this.DataSource.IsFixedSize; }\n        }\n\n        /// <summary>\n        /// Removes the first occurrence of a specific object from the <see cref=\"T:System.Collections.IList\"/>.\n        /// </summary>\n        /// <param name=\"item\">The <see cref=\"T:System.Object\"/> to remove from the <see cref=\"T:System.Collections.IList\"/>.</param>\n        /// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.IList\"/> is read-only.-or- The <see cref=\"T:System.Collections.IList\"/> has a fixed size. </exception>\n        void IList.Remove(object item)\n        {\n            IEntityItemView<T> eiv = item as IEntityItemView<T>;\n            if (eiv != null)\n            {\n                int eivIndex = this.IndexOf(eiv);\n                if (eivIndex != -1)\n                {\n                    ((IList)this).RemoveAt(eivIndex);\n                }\n                else\n                {\n                    //TODO: migliorare l'eccezione\n                    throw new ArgumentOutOfRangeException();\n                }\n            }\n            else\n            {\n                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exceptions.CannotAccessEntityViewException, \"Remove\"));\n            }\n        }\n\n        /// <summary>\n        /// Override this method in order to prevent this instance to rebuild indexes after \n        /// a remove operation\n        /// </summary>\n        /// <param name=\"e\">The <see cref=\"Radical.Model.RebuildIndexesEventArgs\"/> instance containing the event data.</param>\n        protected virtual void OnRemovedAt(RebuildIndexesEventArgs e)\n        {\n            /*\n             * E' stato rimosso un elemento di default la EntityView\n             * (Data) farebbe il rebuild degli indici ma \n             * siccome in questo caso la DataSource supporta le notifiche \n             * il rebuild viene gi\u00e0 fatto a seguito degli eventi scatenati\n             * dalla DataSource, chiediamo quindi alla EntityView di non\n             * fare il rebuild\n             */\n            e.Cancel = this.DataSource is IEntityCollection<T>;\n        }\n\n        /// <summary>\n        /// Removes the <see cref=\"T:System.Collections.IList\"/> item at the specified index.\n        /// </summary>\n        /// <param name=\"index\">The zero-based index of the item to remove.</param>\n        /// <exception cref=\"T:System.ArgumentOutOfRangeException\">\n        ///     <paramref name=\"index\"/> is not a valid index in the <see cref=\"T:System.Collections.IList\"/>. </exception>\n        /// <exception cref=\"T:System.NotSupportedException\">The <see cref=\"T:System.Collections.IList\"/> is read-only.-or- The <see cref=\"T:System.Collections.IList\"/> has a fixed size. </exception>\n        void IList.RemoveAt(int index)\n        {\n            /*\n             * L'indice (index) che arriva \u00e8 l'indice\n             * dell'elemento nella Vista\n             * Recuperiamo dall'Indexer l'indice\n             * dell'elemento originale\n             */\n            int sourceIndex = this.Indexer.FindObjectIndexInDataSource(index);\n            if (sourceIndex > -1)\n            {\n                /*\n                 * Chiediamo alla lista su cui siamo\n                 * montati di rimuovere l'elemento \n                 */\n                this.DataSource.RemoveAt(sourceIndex);\n\n                /*\n                 * Anche qui abbiamo un problema, se la lista supporta\n                 * le notifiche noi non dobbiamo ricostruire gli indici\n                 * perch\u00e8 il meccanismo \u00e8 implicito, in caso contrario\n                 * dobbiamo pensarci noi alla ricostruzione dell'indice\n                 * l'unica possibilit\u00e0 che abbiamo \u00e8 quella di chiedere\n                 */\n                RebuildIndexesEventArgs args = new RebuildIndexesEventArgs(index);\n                this.OnRemovedAt(args);\n\n                if (!args.Cancel)\n                {\n                    this.Indexer.Rebuild();\n\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, index));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Remove, null, index ) );\n                }\n            }\n            else\n            {\n                /*\n                 * Se il sourceIndex \u00e8 -1 significa\n                 * che l'elemento \u00e8 nuovo... quindi ci\n                 * limitaimo a cancellare l'aggiunta del\n                 * nuovo elemento\n                 */\n                this.CancelNew(index);\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the <see cref=\"IEntityItemView&lt;T&gt;\"/> at the specified index.\n        /// </summary>\n        /// <item></item>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Usage\", \"CA1801:ReviewUnusedParameters\", MessageId = \"value\")]\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Usage\", \"CA1801:ReviewUnusedParameters\", MessageId = \"index\")]\n        public IEntityItemView<T> this[int index]\n        {\n            get { return this.Indexer[index]; }\n            set { throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exceptions.CannotAccessEntityViewException, \"Set Accessor\"), \"index\"); }\n        }\n\n        /// <summary>\n        /// Gets or sets the <see cref=\"System.Object\"/> at the specified index.\n        /// </summary>\n        /// <item></item>\n        object IList.this[int index]\n        {\n            get { return this[index]; }\n            set { this[index] = (IEntityItemView<T>)value; }\n        }\n\n        #endregion\n\n        #region IBindingList Members\n\n        static readonly object listChangedEventKey = new object();\n\n        /// <summary>\n        /// Occurs when the list changes or an item in the list changes.\n        /// </summary>\n        public event ListChangedEventHandler ListChanged\n        {\n            add { this.Events.AddHandler(listChangedEventKey, value); }\n            remove { this.Events.RemoveHandler(listChangedEventKey, value); }\n        }\n\n        /// <summary>\n        /// Raises the <see cref=\"E:ListChanged\"/> event.\n        /// </summary>\n        /// <param name=\"e\">The <see cref=\"System.ComponentModel.ListChangedEventArgs\"/> instance containing the event data.</param>\n        protected virtual void OnListChanged(ListChangedEventArgs e)\n        {\n            if (!this.IsInitializing)\n            {\n                ListChangedEventHandler h = this.Events[listChangedEventKey] as ListChangedEventHandler;\n                if (h != null)\n                {\n                    h(this, e);\n                }\n\n                if (e.ListChangedType == ListChangedType.ItemAdded || e.ListChangedType == ListChangedType.ItemDeleted || e.ListChangedType == ListChangedType.Reset)\n                {\n                    this.OnPropertyChanged(\"Count\");\n                }\n            }\n        }\n\n        /// <summary>\n        /// Gets whether a <see cref=\"E:System.ComponentModel.IBindingList.ListChanged\"/> event is raised when the list changes or an item in the list changes.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if a <see cref=\"E:System.ComponentModel.IBindingList.ListChanged\"/> event is raised when the list changes or when an item changes; otherwise, false.</returns>\n        bool IBindingList.SupportsChangeNotification\n        {\n            get { return true; }\n        }\n\n        /// <summary>\n        /// Gets whether the list supports searching using the <see cref=\"M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)\"/> method.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if the list supports searching using the <see cref=\"M:System.ComponentModel.IBindingList.Find(System.ComponentModel.PropertyDescriptor,System.Object)\"/> method; otherwise, false.</returns>\n        bool IBindingList.SupportsSearching\n        {\n            get { return true; }\n        }\n\n        /// <summary>\n        /// Adds a new item to the list.\n        /// </summary>\n        /// <returns>The item added to the list.</returns>\n        /// <exception cref=\"T:System.NotSupportedException\">\n        ///     <see cref=\"P:System.ComponentModel.IBindingList.AllowNew\"/> is false. </exception>\n        object IBindingList.AddNew()\n        {\n            return this.AddNew();\n        }\n\n        private bool _allowEdit = true;\n        /// <summary>\n        /// Gets whether you can update items in the list.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if you can update the items in the list; otherwise, false.</returns>\n        public virtual bool AllowEdit\n        {\n            get { return this._allowEdit; }\n            set\n            {\n                if (this._allowEdit != value)\n                {\n                    this._allowEdit = value;\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n                    this.OnPropertyChanged(\"AllowEdit\");\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                }\n            }\n        }\n\n        private bool _allowNew = true;\n        /// <summary>\n        /// Gets whether you can add items to the list using <see cref=\"M:System.ComponentModel.IBindingList.AddNew\"/>.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if you can add items to the list using <see cref=\"M:System.ComponentModel.IBindingList.AddNew\"/>; otherwise, false.</returns>\n        public virtual bool AllowNew\n        {\n            get\n            {\n                if (this.IsArrayBased)\n                {\n                    return false;\n                }\n                else\n                {\n                    return this._allowNew;\n                }\n            }\n            set\n            {\n                if (this.IsArrayBased)\n                {\n                    throw new InvalidOperationException(\"Cannot change AllowNew item on a ArrayBased EntityView.\");\n                }\n                else if (this._allowNew != value)\n                {\n                    this._allowNew = value;\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n                    this.OnPropertyChanged(\"AllowNew\");\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                }\n            }\n        }\n\n        private bool _allowRemove = true;\n        /// <summary>\n        /// Gets whether you can remove items from the list, using <see cref=\"M:System.Collections.IList.Remove(System.Object)\"/> or <see cref=\"M:System.Collections.IList.RemoveAt(System.int)\"/>.\n        /// </summary>\n        /// <item></item>\n        /// <returns>true if you can remove items from the list; otherwise, false.</returns>\n        public virtual bool AllowRemove\n        {\n            get\n            {\n                if (this.IsArrayBased)\n                {\n                    return false;\n                }\n                else\n                {\n                    return this._allowRemove;\n                }\n            }\n            set\n            {\n                if (this.IsArrayBased)\n                {\n                    throw new InvalidOperationException(\"Cannot change AllowRemove item on a ArrayBased EntityView\");\n                }\n\n                if (this._allowRemove != value)\n                {\n                    this._allowRemove = value;\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n                    this.OnPropertyChanged(\"AllowRemove\");\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                }\n            }\n        }\n\n        private bool _allowSort = true;\n        /// <summary>\n        /// Gets or sets a value indicating whether this list allow sort.\n        /// </summary>\n        /// <value><c>true</c> if [allow sort]; otherwise, <c>false</c>.</value>\n        public virtual bool AllowSort\n        {\n            get { return this._allowSort; }\n            set\n            {\n                if (this.AllowSort != value)\n                {\n                    this._allowSort = value;\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n                    this.OnPropertyChanged(\"AllowSort\");\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n                }\n            }\n        }\n\n        /// <summary>\n        /// Adds the <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> to the indexes used for searching.\n        /// </summary>\n        /// <param name=\"property\">The <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> to add to the indexes used for searching.</param>\n        public void AddIndex(PropertyDescriptor property)\n        {\n            this.Indexer.AddIndex(property);\n        }\n\n        /// <summary>\n        /// Adds the property with the given name to the indexes used for searching.\n        /// </summary>\n        /// <param name=\"propertyName\">The name of the property to add to the indexes used for searching.</param>\n        public void AddIndex(string propertyName)\n        {\n            PropertyDescriptor property = TypeDescriptor.GetProperties(typeof(T)).Find(propertyName, false);\n            this.Indexer.AddIndex(property);\n        }\n\n        /// <summary>\n        /// Removes the <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> from the indexes used for searching.\n        /// </summary>\n        /// <param name=\"property\">The <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> to remove from the indexes used for searching.</param>\n        public void RemoveIndex(PropertyDescriptor property)\n        {\n            this.Indexer.RemoveIndex(property);\n        }\n\n        /// <summary>\n        /// removes the property with the given name from the indexes used for searching.\n        /// </summary>\n        /// <param name=\"propertyName\">The name of the property to remove from the indexes used for searching.</param>\n        public void RemoveIndex(string propertyName)\n        {\n            PropertyDescriptor property = TypeDescriptor.GetProperties(typeof(T)).Find(propertyName, false);\n            this.Indexer.RemoveIndex(property);\n        }\n\n        #endregion\n\n        public PropertyDescriptor GetProperty(string name)\n        {\n            var all = ((ITypedList)this).GetItemProperties(null);\n            foreach (PropertyDescriptor property in all)\n            {\n                if (property.Name == name)\n                {\n                    return property;\n                }\n            }\n\n            return null;\n        }\n\n        #region Custom Property Mappings\n\n        private bool _autoGenerateProperties = true;\n\n        /// <summary>\n        /// Gets or sets a item indicating whether this instance must auto generate properties.\n        /// The default item is <collection>true</collection>\n        /// </summary>\n        /// <item>\n        ///     <collection>true</collection> if this instance must auto generate properties; otherwise, <collection>false</collection>.\n        /// </item>\n        public bool AutoGenerateProperties\n        {\n            get { return this._autoGenerateProperties; }\n            set\n            {\n                if (value != this.AutoGenerateProperties)\n                {\n                    this._autoGenerateProperties = value;\n                }\n            }\n        }\n\n        IDictionary<string, EntityItemViewPropertyDescriptor<T>> _customProperties = null;\n\n        /// <summary>\n        /// Gets the custom properties.\n        /// </summary>\n        /// <value>The custom properties.</value>\n        [System.Diagnostics.CodeAnalysis.SuppressMessage(\"Microsoft.Design\", \"CA1006:DoNotNestGenericTypesInMemberSignatures\")]\n        protected IDictionary<string, EntityItemViewPropertyDescriptor<T>> CustomProperties\n        {\n            get\n            {\n                if (this._customProperties == null)\n                {\n                    this._customProperties = new Dictionary<string, EntityItemViewPropertyDescriptor<T>>();\n                }\n\n                return this._customProperties;\n            }\n        }\n\n        /// <summary>\n        /// Gets the all the dinamically added custom property mappings.\n        /// </summary>\n        /// <returns>\n        /// A read-only list af du\u00ecinamically added property mappings.\n        /// </returns>\n        public IEnumerable<EntityItemViewPropertyDescriptor<T>> GetCustomProperties()\n        {\n            return this.CustomProperties.Values.ToArray<EntityItemViewPropertyDescriptor<T>>();\n        }\n\n        public bool IsPropertyMappingDefined(string propertyName)\n        {\n            return this.CustomProperties.ContainsKey(propertyName);\n        }\n\n        public EntityItemViewPropertyDescriptor<T> GetCustomProperty(string name)\n        {\n            return this.CustomProperties[name];\n        }\n\n        readonly IDictionary<T, IDictionary<string, PropertyValue>> customPropertyValues = new Dictionary<T, IDictionary<string, PropertyValue>>();\n\n        public TValue GetCustomPropertyValue<TValue>(string customPropertyName, IEntityItemView<T> owner)\n        {\n            Ensure.That(customPropertyName)\n                .Named(() => customPropertyName)\n                .IsNotNullNorEmpty()\n                .IsTrue(c => this.CustomProperties.ContainsKey(c));\n\n            Ensure.That(owner).Named(\"owner\").IsNotNull();\n\n            return this.GetCustomPropertyValueCore<TValue>(customPropertyName, owner);\n        }\n\n        protected virtual TValue GetCustomPropertyValueCore<TValue>(string customPropertyName, IEntityItemView<T> owner)\n        {\n            var item = owner.EntityItem;\n            if (this.customPropertyValues.ContainsKey(item))\n            {\n                var values = this.customPropertyValues[item];\n                if (values.ContainsKey(customPropertyName))\n                {\n                    return ((PropertyValue<TValue>)values[customPropertyName]).Value;\n                }\n            }\n            else\n            {\n                var pd = this.CustomProperties[customPropertyName]\n                    as EntityItemViewCustomPropertyDescriptor<T, TValue>;\n\n                if (pd != null)\n                {\n                    var value = pd.GetDefaultValue();\n                    this.SetCustomPropertyValue(customPropertyName, owner, value);\n\n                    return value;\n                }\n            }\n\n            return default(TValue);\n        }\n\n        public void SetCustomPropertyValue<TValue>(string customPropertyName, IEntityItemView<T> owner, TValue value)\n        {\n            Ensure.That(customPropertyName)\n                .Named(\"customPropertyName\")\n                .IsNotNullNorEmpty()\n                .IsTrue(c => this.CustomProperties.ContainsKey(c));\n\n            Ensure.That(owner).Named(\"owner\").IsNotNull();\n\n            var item = owner.EntityItem;\n            if (!this.customPropertyValues.ContainsKey(item))\n            {\n                this.customPropertyValues.Add(item, new Dictionary<string, PropertyValue>());\n            }\n\n            var values = this.customPropertyValues[item];\n            if (!values.ContainsKey(customPropertyName))\n            {\n                values.Add(customPropertyName, null);\n            }\n\n            values[customPropertyName] = new PropertyValue<TValue>(value);\n        }\n\n        private void ClearCustomValuesFor(T item)\n        {\n            if (this.customPropertyValues.ContainsKey(item))\n            {\n                this.customPropertyValues.Remove(item);\n            }\n        }\n\n        /// <summary>\n        /// Adds a the given property to the property mappings of this instance.\n        /// </summary>\n        /// <param name=\"customProperty\">The custom property to add.</param>\n        public virtual EntityItemViewPropertyDescriptor<T> AddPropertyMapping(EntityItemViewPropertyDescriptor<T> customProperty)\n        {\n            this.CustomProperties.Add(customProperty.Name, customProperty);\n            this.OnListChanged(new ListChangedEventArgs(ListChangedType.PropertyDescriptorAdded, customProperty));\n\n            return customProperty;\n        }\n\n        /// <summary>\n        /// Adds a property mapping that maps the supplied property.\n        /// </summary>\n        /// <param name=\"propertyName\">Name of the property to map to.</param>\n        /// <returns>\n        /// A reference to the dinamically generated property.\n        /// </returns>\n        public EntityItemViewPropertyDescriptor<T> AddPropertyMapping(string propertyName)\n        {\n            var pd = new EntityItemViewPropertyDescriptor<T>(propertyName);\n            return this.AddPropertyMapping(pd);\n        }\n\n        /// <summary>\n        /// Adds a property mapping that maps a property using the supplied display name.\n        /// </summary>\n        /// <param name=\"propertyName\">Name of the property to map to.</param>\n        /// <param name=\"displayName\">The display name.</param>\n        /// <returns>\n        /// A reference to the dinamically generated property.\n        /// </returns>\n        public EntityItemViewPropertyDescriptor<T> AddPropertyMapping(string propertyName, string displayName)\n        {\n            var pd = new EntityItemViewPropertyDescriptor<T>(propertyName, displayName);\n            return this.AddPropertyMapping(pd);\n        }\n\n        /// <summary>\n        /// Adds a property mapping using the specified display name, the supplied property type and the supplied getter.\n        /// </summary>\n        /// <typeparam name=\"TProperty\">The type of the property.</typeparam>\n        /// <param name=\"customPropertyName\">Custom property name, must be unique among entity properties.</param>\n        /// <param name=\"getter\">A delegate to call in order to get the value of the dinamically generated property.</param>\n        /// <returns>\n        /// A reference to the dinamically generated property.\n        /// </returns>\n        /// <remarks>\n        /// Using this overload implicitly creates a read-only property because no setter has been supplied.\n        /// </remarks>\n        public EntityItemViewPropertyDescriptor<T> AddPropertyMapping<TProperty>(\n            string customPropertyName,\n            EntityItemViewValueGetter<T, TProperty> getter)\n        {\n            return this.AddPropertyMapping(customPropertyName, getter, null, null);\n        }\n\n        public EntityItemViewPropertyDescriptor<T> AddPropertyMapping<TProperty>(\n            string customPropertyName,\n            EntityItemViewValueGetter<T, TProperty> getter,\n            Func<TProperty> defaultValueInterceptor)\n        {\n            return this.AddPropertyMapping(customPropertyName, getter, null, defaultValueInterceptor);\n        }\n\n        /// <summary>\n        /// Adds a property mapping using the specified display name, the supplied property type and the supplied getter and setter.\n        /// </summary>\n        /// <typeparam name=\"TProperty\">The type of the property.</typeparam>\n        /// <param name=\"customPropertyName\">Custom property name, must be unique among entity properties.</param>\n        /// <param name=\"getter\">A delegate to call in order to get the value of the dinamically generated property.</param>\n        /// <param name=\"setter\">A delegate to call in order to set the value of the dinamically generated property.</param>\n        /// <returns>\n        /// A reference to the dinamically generated property.\n        /// </returns>\n        public EntityItemViewPropertyDescriptor<T> AddPropertyMapping<TProperty>(\n            string customPropertyName,\n            EntityItemViewValueGetter<T, TProperty> getter,\n            EntityItemViewValueSetter<T, TProperty> setter)\n        {\n            return this.AddPropertyMapping(customPropertyName, getter, setter, null);\n        }\n\n        public EntityItemViewPropertyDescriptor<T> AddPropertyMapping<TProperty>(\n            string customPropertyName,\n            EntityItemViewValueGetter<T, TProperty> getter,\n            EntityItemViewValueSetter<T, TProperty> setter,\n            Func<TProperty> defaultValueInterceptor)\n        {\n            var pd = new EntityItemViewCustomPropertyDescriptor<T, TProperty>(\n                customPropertyName,\n                getter,\n                setter);\n\n            pd.DafaultValueInterceptor = defaultValueInterceptor;\n\n            return this.AddPropertyMapping(pd);\n        }\n\n        /// <summary>\n        /// Removes the property mapping.\n        /// </summary>\n        /// <param name=\"customProperty\">The custom property.</param>\n        /// <returns><c>True</c> if the operation was successful, otherwise <c>false</c>.</returns>\n        public virtual bool RemovePropertyMapping(EntityItemViewPropertyDescriptor<T> customProperty)\n        {\n            return this.RemovePropertyMapping(customProperty.Name);\n        }\n\n        /// <summary>\n        /// Removes the property mapping.\n        /// </summary>\n        /// <param name=\"propertyName\">Name of the property.</param>\n        /// <returns><c>True</c> if the operation was successful, otherwise <c>false</c>.</returns>\n        public bool RemovePropertyMapping(string propertyName)\n        {\n            EntityItemViewPropertyDescriptor<T> customProperty;\n            if (this.CustomProperties.TryGetValue(propertyName, out customProperty))\n            {\n                foreach (var kvp in this.customPropertyValues)\n                {\n                    if (kvp.Value.ContainsKey(propertyName))\n                    {\n                        kvp.Value.Remove(propertyName);\n                    }\n                }\n\n                this.CustomProperties.Remove(propertyName);\n\n                this.OnListChanged(new ListChangedEventArgs(ListChangedType.PropertyDescriptorDeleted, customProperty));\n                //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Reset ) );\n\n                return true;\n            }\n\n            return false;\n        }\n\n        #endregion\n\n        #region ITypedList Members\n\n        /// <summary>\n        /// Returns the <see cref=\"T:System.ComponentModel.PropertyDescriptorCollection\"/> that represents the properties on each item used to bind data.\n        /// </summary>\n        /// <param name=\"listAccessors\">An array of <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> objects to find in the collection as bindable. This can be null.</param>\n        /// <returns>\n        /// The <see cref=\"T:System.ComponentModel.PropertyDescriptorCollection\"/> that represents the properties on each item used to bind data.\n        /// </returns>\n        PropertyDescriptorCollection ITypedList.GetItemProperties(PropertyDescriptor[] listAccessors)\n        {\n            return this.OnGetItemProperties(listAccessors);\n        }\n\n        /// <summary>\n        /// Returns the <see cref=\"T:System.ComponentModel.PropertyDescriptorCollection\"/> that represents the properties on each item used to bind data.\n        /// </summary>\n        /// <param name=\"listAccessors\">An array of <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> objects to find in the collection as bindable. This can be null.</param>\n        /// <returns>\n        /// The <see cref=\"T:System.ComponentModel.PropertyDescriptorCollection\"/> that represents the properties on each item used to bind data.\n        /// </returns>\n        protected virtual PropertyDescriptorCollection OnGetItemProperties(PropertyDescriptor[] listAccessors)\n        {\n            if (listAccessors == null || listAccessors.Length == 0)\n            {\n                List<EntityItemViewPropertyDescriptor<T>> properties = new List<EntityItemViewPropertyDescriptor<T>>();\n\n                if (this.AutoGenerateProperties)\n                {\n                    /*\n                     * Dobbiamo generare automaticamente le colonne, procediamo \n                     * nel pi\u00f9 tradizionale dei metodi analizzando via reflection\n                     * il tipo T e recuperando tutte le propriet\u00e0 che non hanno un\n                     * attributo \"Bindable\" impostato a false.\n                     * Per ogni PropertyDescriptor trovato generiamo un nuovo\n                     * EntityItemViewPropertyDescriptor<T> passandogli un riferimento\n                     * alla property (PropertyInfo) su cui mapparsi \n                     */\n                    IEnumerable<EntityItemViewPropertyDescriptor<T>> bindableProperties = null;\n\n                    if (typeof(T).IsInterface)\n                    {\n                        bindableProperties = this.FlattenInterfaces()\n                            .Aggregate(new List<EntityItemViewPropertyDescriptor<T>>(), (a, t) =>\n                           {\n                               var all = this.GetBindablePropertiesForType(t);\n\n                               a.AddRange(all);\n\n                               return a;\n                           });\n                    }\n                    else\n                    {\n                        bindableProperties = this.GetBindablePropertiesForType(typeof(T));\n                    }\n\n                    /*\n                     * aggiungiamo i descriptor cos\u00ec trovati alla lista di quelli che\n                     * dovranno essere ritornati al chiamante\n                     */\n                    properties.AddRange(bindableProperties);\n                }\n\n                if (this.CustomProperties.Count > 0)\n                {\n                    /*\n                     * Se ci sono delle propriet\u00e0 custom le aggiungiamo\n                     * alla lista delle propriet\u00e0 da ritornare, in questo\n                     * modo se AutoGenerateProperties \u00e8 true le propriet\u00e0\n                     * custom verranno correttamente aggiunte in coda\n                     */\n                    properties.AddRange(this.GetCustomProperties());\n                }\n\n                return new PropertyDescriptorCollection(properties.ToArray());\n            }\n\n            return new PropertyDescriptorCollection(null);\n        }\n\n        IEnumerable<EntityItemViewPropertyDescriptor<T>> GetBindablePropertiesForType(Type t)\n        {\n            var all = TypeDescriptor.GetProperties(t)\n                        .OfType<PropertyDescriptor>()\n                        .Where(pd => !pd.Attributes.Matches(BindableAttribute.No))\n                        .Select(pd => this.OnCreateDescriptor(pd.ComponentType.GetProperty(pd.Name)));\n\n            return all;\n        }\n\n        IEnumerable<Type> FlattenInterfaces()\n        {\n            Ensure.That(typeof(T)).IsTrue(t => t.IsInterface);\n\n            yield return typeof(T);\n\n            foreach (var i in typeof(T).GetInterfaces())\n            {\n                yield return i;\n            }\n        }\n\n        /// <summary>\n        /// Called when by this instance in each time this list needs to create a new \n        /// item property descriptor, inheritors can override this method in order to \n        /// provide their own descriptor implementation.\n        /// </summary>\n        /// <param name=\"property\">The property to build the descriptor for.</param>\n        /// <returns>The built descriptor.</returns>\n        protected virtual EntityItemViewPropertyDescriptor<T> OnCreateDescriptor(PropertyInfo property)\n        {\n            return new EntityItemViewPropertyDescriptor<T>(property);\n        }\n\n        /// <summary>\n        /// Returns the name of the list.\n        /// </summary>\n        /// <param name=\"listAccessors\">An array of <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> objects, for which the list name is returned. This can be null.</param>\n        /// <returns>The name of the list.</returns>\n        string ITypedList.GetListName(PropertyDescriptor[] listAccessors)\n        {\n            return this.OnGetListName(listAccessors);\n        }\n\n        /// <summary>\n        /// Returns the name of the list.\n        /// </summary>\n        /// <param name=\"listAccessors\">An array of <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> objects, for which the list name is returned. This can be null.</param>\n        /// <returns>The name of the list.</returns>\n        protected virtual string OnGetListName(PropertyDescriptor[] listAccessors)\n        {\n            if (listAccessors == null || listAccessors.Length == 0)\n            {\n                return this.GetType().Name;\n            }\n\n            return string.Empty;\n        }\n\n        #endregion\n\n        #region Searching\n\n        /// <summary>\n        /// Returns the index of the row that has the given <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/>.\n        /// </summary>\n        /// <param name=\"property\">The <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/> to search on.</param>\n        /// <param name=\"key\">The item of the <paramref name=\"property\"/> parameter to search for.</param>\n        /// <returns>\n        /// The index of the row that has the given <see cref=\"T:System.ComponentModel.PropertyDescriptor\"/>.\n        /// </returns>\n        /// <exception cref=\"T:System.NotSupportedException\">\n        ///     <see cref=\"P:System.ComponentModel.IBindingList.SupportsSearching\"/> is false. </exception>\n        public int Find(PropertyDescriptor property, object key)\n        {\n            return this.Indexer.Find(property, key);\n        }\n\n        /// <summary>\n        /// Returns the index of the row that has the given property name set to the given key item.\n        /// </summary>\n        /// <param name=\"propertyName\">The property name to search on.</param>\n        /// <param name=\"key\">The item of the <paramref name=\"propertyName\"/> parameter to search for.</param>\n        /// <returns>\n        /// The index of the row that has the given property name set to the given key item.\n        /// </returns>\n        public int Find(string propertyName, object key)\n        {\n            PropertyDescriptor pd = TypeDescriptor.GetProperties(typeof(T)).Find(propertyName, false);\n            if (pd != null)\n            {\n                return this.Find(pd, key);\n            }\n            else\n            {\n                throw new ArgumentException(string.Format(CultureInfo.CurrentCulture, Resources.Exceptions.PropertyNotFoundException, propertyName), \"propertyName\");\n            }\n        }\n\n        #endregion\n\n        /// <summary>\n        /// Gets a item indicating whether this instance is adding new.\n        /// The case is when AddNew as been called but nor CancelNew nor EndNew\n        /// has already been called.\n        /// </summary>\n        /// <item>\n        ///     <collection>true</collection> if this instance is adding new; otherwise, <collection>false</collection>.\n        /// </item>\n        public bool IsAddingNew\n        {\n            get { return this.PendingNewItem != null; }\n        }\n\n        /// <summary>\n        /// Determines whether the specified item is a pending item.\n        /// </summary>\n        /// <param name=\"item\">The item.</param>\n        /// <returns>\n        ///     <c>true</c> if the specified item is a pending new item; otherwise, <c>false</c>.\n        /// </returns>\n        protected bool IsInAddingNewQueue(T item)\n        {\n            return this.IsAddingNew && this.PendingNewItem.EntityItem.Equals(item);\n        }\n\n        private static readonly object addingNewEventKey = new object();\n\n        /// <summary>\n        /// Occurs when AddingNew is invoked or the list needs to add a new item.\n        /// </summary>\n        public event EventHandler<AddingNewEventArgs<T>> AddingNew\n        {\n            add { this.Events.AddHandler(addingNewEventKey, value); }\n            remove { this.Events.RemoveHandler(addingNewEventKey, value); }\n        }\n\n        /// <summary>\n        /// Raises the <see cref=\"E:AddingNew\"/> event.\n        /// </summary>\n        /// <param name=\"e\">The <see cref=\"Radical.Model.AddingNewEventArgs&lt;T&gt;\"/> instance containing the event data.</param>\n        protected virtual void OnAddingNew(AddingNewEventArgs<T> e)\n        {\n            EventHandler<AddingNewEventArgs<T>> h = this.Events[addingNewEventKey] as EventHandler<AddingNewEventArgs<T>>;\n            if (h != null)\n            {\n                h(this, e);\n            }\n\n            if (!e.Cancel)\n            {\n                IEntityCollection<T> dataSource = this.DataSource as IEntityCollection<T>;\n                if (e.NewItem == null && dataSource != null && dataSource.AllowNew)\n                {\n                    /*\n                     * il comportamento di default \u00e8 che se NewItem \u00e8 null\n                     * e abbiamo in mano IEntityCollection<T> usiamo l'implementazione\n                     * di default di CreateNew su IEntityCollection<T>\n                     * Se invece ci viene fornito un elemento prendiamo quello e\n                     * scavalchiamo IEntityCollection<T>\n                     */\n                    e.NewItem = dataSource.CreateNew();\n                }\n            }\n        }\n\n        private IEntityItemView<T> _pendingNewItem;\n\n        /// <summary>\n        /// Gets the pending new item.\n        /// </summary>\n        /// <value>The pending new item.</value>\n        protected IEntityItemView<T> PendingNewItem\n        {\n            get { return this._pendingNewItem; }\n            private set\n            {\n                if (value != this._pendingNewItem)\n                {\n                    this._pendingNewItem = value;\n                    this.OnPropertyChanged(\"IsAddingNew\");\n                }\n            }\n        }\n\n        public IEntityItemView<T> AddNew(Action<AddingNewEventArgs<T>> addNewInterceptor)\n        {\n            Ensure.That(addNewInterceptor).Named(\"addNewInterceptor\").IsNotNull();\n\n            if (!this.AllowNew)\n            {\n                throw new InvalidOperationException(Resources.Exceptions.AllowNewException);\n            }\n\n            var args = new AddingNewEventArgs<T>();\n            addNewInterceptor(args);\n            return this.OnAddNewCompleted(args);\n        }\n\n        /// <summary>\n        /// Adds, if supported, a new Item to this list.\n        /// </summary>\n        /// <returns>The newly added item.</returns>\n        public IEntityItemView<T> AddNew()\n        {\n            if (!this.AllowNew)\n            {\n                throw new InvalidOperationException(Resources.Exceptions.AllowNewException);\n            }\n\n            //Informiamo il mondo che stiamo per aggiungere\n            var args = new AddingNewEventArgs<T>();\n            this.OnAddingNew(args);\n\n            return this.OnAddNewCompleted(args);\n        }\n\n        IEntityItemView<T> OnAddNewCompleted(AddingNewEventArgs<T> args)\n        {\n            if (!args.Cancel)\n            {\n                T item = args.NewItem;\n\n                /*\n                 * qui dovremmo avere in mano per forza un item\n                 * perch\u00e8 o \u00e8 stato creato nel gestore dell'evento\n                 * o ci \u00e8 stato dato da EntityCollection<T> quindi se\n                 * non c'\u00e8 l'exception \u00e8 sacrosanta!\n                 */\n                if (item == null)\n                {\n                    throw new InvalidOperationException(\"New Item cannot be null.\");\n                }\n\n                if (this.IsAddingNew)\n                {\n                    /*\n                     * C'\u00e8 un elemento in attesa\n                     * di essere 'committed', quindi\n                     * prima di aggiungerne uno nuovo\n                     * eseguiamo il 'commit'\n                     */\n                    this.EndNew(this.Indexer.Count - 1);\n                }\n\n                IEntityItemView<T> obj = this.CreateEntityItemView(item);\n\n                this.OnWireEntityItemView(obj);\n                this.PendingNewItem = obj;\n                this.Indexer.Add(obj);\n\n                if (args.AutoCommit)\n                {\n                    this.EndNew();\n                }\n                else\n                {\n                    int index = this.Indexer.Count - 1;\n                    this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemAdded, index));\n                    //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Add, obj, index ) );\n                }\n\n                return obj;\n            }\n            else\n            {\n                //Cancel\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Ends a pending AddNew operation.\n        /// </summary>\n        public void EndNew()\n        {\n            if (this.IsAddingNew)\n            {\n                this.EndNew(this.IndexOf(this.PendingNewItem));\n            }\n        }\n\n        /// <summary>\n        /// Called when EndNew].\n        /// </summary>\n        /// <param name=\"index\">The index.</param>\n        protected virtual void OnEndNew(int index)\n        {\n\n        }\n\n        /// <summary>\n        /// Override this method in order to prevent this instance to rebuild indexes after \n        /// an EndNew operation\n        /// </summary>\n        /// <param name=\"e\">The <see cref=\"RebuildIndexesEventArgs\"/> instance containing the event data.</param>\n        protected virtual void OnEndNewCompleted(RebuildIndexesEventArgs e)\n        {\n            /*\n             * E' stato completato l'editing di un elemento\n             * di default la EntityView (Radical.Model) farebbe\n             * il rebuild degli indici ma siccome in questo caso\n             * la DataSource supporta le notifiche il rebuild viene\n             * gi\u00e0 fatto a seguito degli eventi scatenati dalla\n             * DataSource, chiediamo quindi alla IEntityView di non\n             * fare il rebuild se la DataSource \u00e8 di tipo IEntityCollection\n             */\n            e.Cancel = this.DataSource is IEntityCollection<T>;\n        }\n\n        /// <summary>\n        /// Ends a pending AddNew operation.\n        /// </summary>\n        /// <param name=\"itemIndex\">Index of the item.</param>\n        public void EndNew(int itemIndex)\n        {\n            if (this.AllowNew && itemIndex > -1 && itemIndex < this.Indexer.Count &&\n                this.PendingNewItem != null && this.Indexer[itemIndex] == this.PendingNewItem)\n            {\n                this.OnEndNew(itemIndex);\n\n                /*\n                 * Siamo in fase di commit, come da MSDN ci assicuriamo di avere\n                 * degli elementi pending (pu\u00f2 succedere che questo metodo venga \n                 * richiamato pi\u00f9 volte).\n                 * \n                 * Sganciamo il gestore degli eventi per l'oggetto pending\n                 * \n                 * E' importante notare che nelle implementazioni attuali\n                 * della DataGrid e del DataGridView itemIndex corrisponder\u00e0\n                 * _sempre_ all'indice dell'ultimo elemento semplicemente perch\u00e8\n                 * i 2 controlli non consentono di avere pi\u00f9 elementi \n                 * contemporaneamente in Edit e quindi alla stessa stregua in\n                 * PendingAddNew \n                 */\n                this.OnUnwireEntityItemView(PendingNewItem);\n\n                /*\n                 * Lo rimuoviamo dall'Indice\n                 */\n                this.Indexer.RemoveAt(itemIndex);\n\n                try\n                {\n                    /*\n                     * Lo aggiungiamo alla Collection sottostante \n                     * e aspettiamo la notifica \n                     * \n                     * sta minchia!!! perch\u00e8 qui non avviene proprio un bel nulla...\n                     * la collection sottostante non ci notifica proprio un cazzo...\n                     * \n                     * Il problema \u00e8 che la DataSource qui non sappiamo cosa sia\n                     * quindi non possiamo affidarci al suo motore di notifica\n                     * per sapere che un nuovo elemento \u00e8 stato aggiunto e quindi\n                     * ricostruire gli indici\n                     */\n                    this.DataSource.Add(this.PendingNewItem.EntityItem);\n\n                    RebuildIndexesEventArgs args = new RebuildIndexesEventArgs(itemIndex);\n                    this.OnEndNewCompleted(args);\n\n                    if (!args.Cancel)\n                    {\n                        this.OnWireEntityItemView(this.PendingNewItem);\n                        this.Indexer.Add(this.PendingNewItem);\n                    }\n                }\n                finally\n                {\n                    //TODO: Exception --> Roolback\n                    /*\n                     * Probabilmente in caso di Exception sarebbe pi\u00f9 sensato\n                     * eseguire un \"Rollback\" per non perdere il riferimento\n                     * al \"PendingNewItem\"\n                     * \n                     * Rimuoviamo il riferimento all'elemento \n                     * pending\n                     */\n                    this.PendingNewItem = null;\n                }\n            }\n        }\n\n        /// <summary>\n        /// Cancels a pending AddNew operation.\n        /// </summary>\n        public void CancelNew()\n        {\n            if (this.IsAddingNew)\n            {\n                this.CancelNew(this.IndexOf(this.PendingNewItem));\n            }\n        }\n\n        /// <summary>\n        /// Called when on CancelNew].\n        /// </summary>\n        /// <param name=\"itemIndex\">Index of the item.</param>\n        protected virtual void OnCancelNew(int itemIndex)\n        {\n\n        }\n\n        /// <summary>\n        /// Cancels a pending AddNew operation that is occurring\n        /// at the specified index.\n        /// </summary>\n        /// <param name=\"itemIndex\">Index of the item.</param>\n        public void CancelNew(int itemIndex)\n        {\n            if (this.AllowNew && itemIndex > -1 && itemIndex < this.Indexer.Count &&\n                this.PendingNewItem != null && this.Indexer[itemIndex] == this.PendingNewItem)\n            {\n                this.OnCancelNew(itemIndex);\n\n                /*\n                 * Per l'itemIndex valgono le stesse considerazione\n                 * fatte per il metodo EndNew\n                 */\n                this.OnUnwireEntityItemView(this.PendingNewItem);\n\n                this.Indexer.RemoveAt(itemIndex);\n\n                this.OnListChanged(new ListChangedEventArgs(ListChangedType.ItemDeleted, itemIndex));\n                //this.OnCollectionChanged( new NotifyCollectionChangedEventArgs( NotifyCollectionChangedAction.Remove, this.pendingNewItem, itemIndex ) );\n\n                this.PendingNewItem = null;\n            }\n        }\n\n        #region IDisposable Members\n\n        /// <summary>\n        /// Releases unmanaged resources and performs other cleanup operations before the\n        /// <see cref=\"EntityView&lt;T&gt;\"/> is reclaimed by garbage collection.\n        /// </summary>\n        ~EntityView()\n        {\n            this.Dispose(false);\n        }\n\n        private bool isDisposed;\n\n        /// <summary>\n        /// Releases unmanaged and - optionally - managed resources\n        /// </summary>\n        /// <param name=\"disposing\"><collection>true</collection> to release both managed and unmanaged resources; <collection>false</collection> to release only unmanaged resources.</param>\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!this.isDisposed)\n            {\n                if (disposing)\n                {\n                    /*\n                     * Se disposing \u00e8 'true' significa che dispose\n                     * \u00e8 stato invocato direttamentente dall'utente\n                     * \u00e8 quindi lecito accedere ai 'field' e ad \n                     * eventuali reference perch\u00e8 sicuramente Finalize\n                     * non \u00e8 ancora stato chiamato su questi oggetti\n                     */\n                    lock (this)\n                    {\n                        if (this.site != null && this.site.Container != null)\n                        {\n                            this.site.Container.Remove(this);\n                        }\n\n                        if (this._events != null)\n                        {\n                            EventHandler h = this.Events[disposedEventKey] as EventHandler;\n                            if (h != null)\n                            {\n                                h(this, EventArgs.Empty);\n                            }\n                        }\n                    }\n                }\n\n                if (this._events != null)\n                {\n                    this.Events.Dispose();\n                    this._events = null;\n                }\n\n                //Set isDisposed flag\n                this.isDisposed = true;\n            }\n        }\n\n        /// <summary>\n        /// Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\n        /// </summary>\n        public void Dispose()\n        {\n            this.Dispose(true);\n            GC.SuppressFinalize(this);\n        }\n\n        #endregion\n\n        #region IComponent, IServiceProvider\n\n        private static readonly object disposedEventKey = new object();\n\n        /// <summary>\n        /// Represents the method that handles the <see cref=\"E:System.ComponentModel.IComponent.Disposed\"/> event of a component.\n        /// </summary>\n        public event EventHandler Disposed\n        {\n            add { this.Events.AddHandler(disposedEventKey, value); }\n            remove { this.Events.RemoveHandler(disposedEventKey, value); }\n        }\n\n        private ISite site;\n\n        /// <summary>\n        /// Gets or sets the <see cref=\"T:System.ComponentModel.ISite\"/> associated with the <see cref=\"T:System.ComponentModel.IComponent\"/>.\n        /// </summary>\n        /// <returns>The <see cref=\"T:System.ComponentModel.ISite\"/> object associated with the component; or null, if the component does not have a site.</returns>\n        [Browsable(false)]\n        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]\n        public virtual ISite Site\n        {\n            get { return this.site; }\n            set { this.site = value; }\n        }\n\n        [NonSerialized]\n        private EventHandlerList _events;\n\n        /// <summary>\n        /// Gets the events.\n        /// </summary>\n        /// <value>The events.</value>\n        protected EventHandlerList Events\n        {\n            get\n            {\n                if (this._events == null)\n                {\n                    this._events = new EventHandlerList();\n                }\n\n                return this._events;\n            }\n        }\n\n        /// <summary>\n        /// Gets a value indicating whether [design mode].\n        /// </summary>\n        /// <value><c>true</c> if [design mode]; otherwise, <c>false</c>.</value>\n        [Browsable(false)]\n        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]\n        public virtual bool DesignMode\n        {\n            get\n            {\n                if (this.site != null)\n                {\n                    return this.site.DesignMode;\n                }\n\n                return false;\n            }\n        }\n\n        /// <summary>\n        /// Gets the container.\n        /// </summary>\n        /// <value>The container.</value>\n        [Browsable(false)]\n        [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]\n        public virtual IContainer Container\n        {\n            get\n            {\n                if (this.site != null)\n                {\n                    return this.site.Container;\n                }\n                return null;\n            }\n        }\n\n        /// <summary>\n        /// Gets the service object of the specified type.\n        /// </summary>\n        /// <param name=\"serviceType\">An object that specifies the type of service object to get.</param>\n        /// <returns>\n        /// A service object of type <paramref name=\"serviceType\"/>.\n        /// -or-\n        /// null if there is no service object of type <paramref name=\"serviceType\"/>.\n        /// </returns>\n        public virtual object GetService(Type serviceType)\n        {\n            if (this.site != null)\n            {\n                return this.site.GetService(serviceType);\n            }\n\n            return null;\n        }\n\n        #endregion\n\n        #region INotifyPropertyChanged Members\n\n        static readonly object propertyChangedEventKey = new object();\n\n        /// <summary>\n        /// Occurs when a property value changes.\n        /// </summary>\n        public event PropertyChangedEventHandler PropertyChanged\n        {\n            add { this.Events.AddHandler(propertyChangedEventKey, value); }\n            remove { this.Events.RemoveHandler(propertyChangedEventKey, value); }\n        }\n\n        /// <summary>\n        /// Raises the PropertyChanged event.\n        /// </summary>\n        /// <param name=\"property\">The name of the property.</param>\n        protected void OnPropertyChanged<T>(Expression<Func<T>> property)\n        {\n            var h = this.Events[propertyChangedEventKey] as PropertyChangedEventHandler;\n            if (h != null)\n            {\n                this.OnPropertyChanged(property.GetMemberName());\n            }\n        }\n\n        /// <summary>\n        /// Raises the PropertyChanged event.\n        /// </summary>\n        /// <param name=\"propertyName\">The name of the property.</param>\n        protected virtual void OnPropertyChanged(string propertyName)\n        {\n            Ensure.That(propertyName)\n                .IsNotNull()\n                .IsNotEmpty();\n\n            var h = this.Events[propertyChangedEventKey] as PropertyChangedEventHandler;\n            if (h != null)\n            {\n                h(this, new PropertyChangedEventArgs(propertyName));\n            }\n        }\n\n        #endregion\n\n        #region IEnumerable<IEntityItemView<T>> Members\n\n        /// <summary>\n        /// Returns an enumerator that iterates through the collection.\n        /// </summary>\n        /// <returns>\n        /// A <see cref=\"T:System.Collections.Generic.IEnumerator`1\"/> that can be used to iterate through the collection.\n        /// </returns>\n        IEnumerator<IEntityItemView<T>> IEnumerable<IEntityItemView<T>>.GetEnumerator()\n        {\n            return ((IEnumerable<IEntityItemView<T>>)this.Indexer).GetEnumerator();\n        }\n\n        #endregion\n\n        void ISupportInitialize.BeginInit()\n        {\n            this.IsInitializing = true;\n        }\n\n        protected bool IsInitializing { get; private set; }\n\n        void ISupportInitialize.EndInit()\n        {\n            this.IsInitializing = false;\n            this.OnListChanged(new ListChangedEventArgs(ListChangedType.Reset, -1));\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    internal static class Utils\n    {\n        #region Authentication URLs\n        internal const string ACCESS_TOKEN_URL =\n            \"https://www.linkedin.com/uas/oauth2/accessToken?grant_type=authorization_code&code=\";\n        internal const string AUTHORIZATION_URL =\n            \"https://www.linkedin.com/uas/oauth2/authorization?response_type=code&client_id=\";\n        #endregion\n\n        #region Updates URLs\n        internal const string UPDATE_STATUS_URL = \"https://api.linkedin.com/v1/people/~/shares?\";\n        internal const string GET_UPDATES_URL = \"https://api.linkedin.com/v1/people/~/network/updates?\";\n        internal const string GET_UPDATES_BY_ID_URL = \"https://api.linkedin.com/v1/people/id=$USER_ID$/network/updates?\";\n        internal const string GET_UPDATES_BY_URL_URL =\n            \"https://api.linkedin.com/v1/people/url=$USER_URL$/network/updates?\";\n        internal const string UPDATE_LIKES_URL =\n            \"https://api.linkedin.com/v1/people/~/network/updates/key={NETWORK UPDATE KEY}/likes\";\n        internal const string UPDATE_IS_LIKED_URL =\n            \"https://api.linkedin.com/v1/people/~/network/updates/key={NETWORK UPDATE KEY}/is-liked\";\n        internal const string UPDATE_COMMENTS_URL =\n            \"https://api.linkedin.com/v1/people/~/network/updates/key={NETWORK UPDATE KEY}/update-comments\";\n        #endregion\n\n        #region Profile URLs\n        internal const string PROFILE_URL = \"https://api.linkedin.com/v1/people/\";\n        internal const string PROFILE_SELF_URL = \"https://api.linkedin.com/v1/people/~\";\n        internal const string PROFILE_BY_ID_URL = \"https://api.linkedin.com/v1/people/id=\";\n        internal const string PROFILE_BY_URL_URL = \"https://api.linkedin.com/v1/people/url=\";\n        internal const string PROFILE_MULTIPLE_URL = \"https://api.linkedin.com/v1/people::\";\n        #endregion\n\n        #region Groups URLs\n        internal const string GROUPS_SUGGESTIONS_URL = \"https://api.linkedin.com/v1/people/~/suggestions/groups\";\n        internal const string GROUPS_MEMBERSHIP_URL = \"https://api.linkedin.com/v1/people/~/group-memberships:(group\";\n        internal const string GROUP_POSTS_URL = \"https://api.linkedin.com/v1/groups/{GROUP_ID}/posts\";\n        internal const string GROUP_MEMBER_POSTS_URL =\n            \"https://api.linkedin.com/v1/people/~/group-memberships/{GROUP_ID}/posts\";\n        internal const string POSTS_COMMENTS_URL = \"https://api.linkedin.com/v1/posts/{POST_ID}/comments\";\n        internal const string GROUP_JOIN_URL = \"https://api.linkedin.com/v1/people/~/group-memberships/{GROUP_ID}\";\n        internal const string POSTS_URL = \"https://api.linkedin.com/v1/posts/{POST_ID}\";\n        internal const string POSTS_LIKE_URL = \"https://api.linkedin.com/v1/posts/{POST_ID}/relation-to-viewer/is-liked\";\n        internal const string POSTS_FOLLOW_URL =\n            \"https://api.linkedin.com/v1/posts/{POST_ID}/relation-to-viewer/is-following\";\n        internal const string POSTS_FLAG_URL = \"https://api.linkedin.com/v1/posts/{POST_ID}/category/code\";\n        internal const string COMMENTS_URL = \"https://api.linkedin.com/v1/comments/{COMMENT_ID}\";\n        #endregion\n\n        #region Messages URLs\n        internal const string SEND_MESSAGE_URL = \"https://api.linkedin.com/v1/people/~/mailbox\";\n        #endregion\n\n        #region Search URLs\n        internal const string PEOPLE_SEARCH_URL = \"https://api.linkedin.com/v1/people-search\";\n        #endregion\n\n        internal const string CALLBACK = \"https://linkin/done\";\n\n        private enum CompanyUpdateType\n        {\n            Invalid,\n            Profile,\n            Status, Job,\n            Person\n        }\n\n        internal static readonly Dictionary<LinkedInCountries, string> CountryCodes = new Dictionary<LinkedInCountries, string>\n        {\n            {LinkedInCountries.Andorra, \"ad\"},\n            {LinkedInCountries.UnitedArabEmirates, \"ae\"},\n            {LinkedInCountries.Afghanistan, \"af\"},\n            {LinkedInCountries.AntiguaAndBarbuda, \"ag\"},\n            {LinkedInCountries.Anguilla, \"ai\"},\n            {LinkedInCountries.Albania, \"al\"},\n            {LinkedInCountries.Armenia, \"am\"},\n            {LinkedInCountries.Angola, \"ao\"},\n            {LinkedInCountries.Antarctica, \"aq\"},\n            {LinkedInCountries.Argentina, \"ar\"},\n            {LinkedInCountries.AmericanSamoa, \"as\"},\n            {LinkedInCountries.Austria, \"at\"},\n            {LinkedInCountries.Australia, \"au\"},\n            {LinkedInCountries.Aruba, \"aw\"},\n            {LinkedInCountries.AlandIslands, \"ax\"},\n            {LinkedInCountries.Azerbaijan, \"az\"},\n            {LinkedInCountries.BosniaAndHerzegovina, \"ba\"},\n            {LinkedInCountries.Barbados, \"bb\"},\n            {LinkedInCountries.Bangladesh, \"bd\"},\n            {LinkedInCountries.Belgium, \"be\"},\n            {LinkedInCountries.BurkinaFaso, \"bf\"},\n            {LinkedInCountries.Bulgaria, \"bg\"},\n            {LinkedInCountries.Bahrain, \"bh\"},\n            {LinkedInCountries.Burundi, \"bi\"},\n            {LinkedInCountries.Benin, \"bj\"},\n            {LinkedInCountries.SaintBarthelemy, \"bl\"},\n            {LinkedInCountries.Bermuda, \"bm\"},\n            {LinkedInCountries.BruneiDarussalam, \"bn\"},\n            {LinkedInCountries.BoliviaPlurinationalStateOf, \"bo\"},\n            {LinkedInCountries.BonaireSintEustatiusAndSaba, \"bq\"},\n            {LinkedInCountries.Brazil, \"br\"},\n            {LinkedInCountries.Bahamas, \"bs\"},\n            {LinkedInCountries.Bhutan, \"bt\"},\n            {LinkedInCountries.BouvetIsland, \"bv\"},\n            {LinkedInCountries.Botswana, \"bw\"},\n            {LinkedInCountries.Belarus, \"by\"},\n            {LinkedInCountries.Belize, \"bz\"},\n            {LinkedInCountries.Canada, \"ca\"},\n            {LinkedInCountries.CocosIslands, \"cc\"},\n            {LinkedInCountries.CongoTheDemocraticRepublic, \"cd\"},\n            {LinkedInCountries.CentralAfricanRepublic, \"cf\"},\n            {LinkedInCountries.Congo, \"cg\"},\n            {LinkedInCountries.Switzerland, \"ch\"},\n            {LinkedInCountries.CoteDivoire, \"ci\"},\n            {LinkedInCountries.CookIslands, \"ck\"},\n            {LinkedInCountries.Chile, \"cl\"},\n            {LinkedInCountries.Cameroon, \"cm\"},\n            {LinkedInCountries.China, \"cn\"},\n            {LinkedInCountries.Colombia, \"co\"},\n            {LinkedInCountries.CostaRica, \"cr\"},\n            {LinkedInCountries.Cuba, \"cu\"},\n            {LinkedInCountries.CapeVerde, \"cv\"},\n            {LinkedInCountries.Curacao, \"cw\"},\n            {LinkedInCountries.ChristmasIsland, \"cx\"},\n            {LinkedInCountries.Cyprus, \"cy\"},\n            {LinkedInCountries.CzechRepublic, \"cz\"},\n            {LinkedInCountries.Germany, \"de\"},\n            {LinkedInCountries.Djibouti, \"dj\"},\n            {LinkedInCountries.Denmark, \"dk\"},\n            {LinkedInCountries.Dominica, \"dm\"},\n            {LinkedInCountries.DominicanRepublic, \"do\"},\n            {LinkedInCountries.Algeria, \"dz\"},\n            {LinkedInCountries.Ecuador, \"ec\"},\n            {LinkedInCountries.Estonia, \"ee\"},\n            {LinkedInCountries.Egypt, \"eg\"},\n            {LinkedInCountries.WesternSahara, \"eh\"},\n            {LinkedInCountries.Eritrea, \"er\"},\n            {LinkedInCountries.Spain, \"es\"},\n            {LinkedInCountries.Ethiopia, \"et\"},\n            {LinkedInCountries.Finland, \"fi\"},\n            {LinkedInCountries.Fiji, \"fj\"},\n            {LinkedInCountries.FalklandIslands, \"fk\"},\n            {LinkedInCountries.MicronesiaFederatedStatesOf, \"fm\"},\n            {LinkedInCountries.FaroeIslands, \"fo\"},\n            {LinkedInCountries.France, \"fr\"},\n            {LinkedInCountries.Gabon, \"ga\"},\n            {LinkedInCountries.UnitedKingdom, \"gb\"},\n            {LinkedInCountries.Grenada, \"gd\"},\n            {LinkedInCountries.Georgia, \"ge\"},\n            {LinkedInCountries.FrenchGuiana, \"gf\"},\n            {LinkedInCountries.Guernsey, \"gg\"},\n            {LinkedInCountries.Ghana, \"gh\"},\n            {LinkedInCountries.Gibraltar, \"gi\"},\n            {LinkedInCountries.Greenland, \"gl\"},\n            {LinkedInCountries.Gambia, \"gm\"},\n            {LinkedInCountries.Guinea, \"gn\"},\n            {LinkedInCountries.Guadeloupe, \"gp\"},\n            {LinkedInCountries.EquatorialGuinea, \"gq\"},\n            {LinkedInCountries.Greece, \"gr\"},\n            {LinkedInCountries.SouthGeorgiaAndTheSouthSandwichIslands, \"gs\"},\n            {LinkedInCountries.Guatemala, \"gt\"},\n            {LinkedInCountries.Guam, \"gu\"},\n            {LinkedInCountries.GuineaBissau, \"gw\"},\n            {LinkedInCountries.Guyana, \"gy\"},\n            {LinkedInCountries.HongKong, \"hk\"},\n            {LinkedInCountries.HeardIslandAndMcDonaldIslands, \"hm\"},\n            {LinkedInCountries.Honduras, \"hn\"},\n            {LinkedInCountries.Croatia, \"hr\"},\n            {LinkedInCountries.Haiti, \"ht\"},\n            {LinkedInCountries.Hungary, \"hu\"},\n            {LinkedInCountries.Indonesia, \"id\"},\n            {LinkedInCountries.Ireland, \"ie\"},\n            {LinkedInCountries.Israel, \"il\"},\n            {LinkedInCountries.IsleOfMan, \"im\"},\n            {LinkedInCountries.India, \"in\"},\n            {LinkedInCountries.BritishIndianOceanTerritory, \"io\"},\n            {LinkedInCountries.Iraq, \"iq\"},\n            {LinkedInCountries.IranIslamicRepublicOf, \"ir\"},\n            {LinkedInCountries.Iceland, \"is\"},\n            {LinkedInCountries.Italy, \"it\"},\n            {LinkedInCountries.Jersey, \"je\"},\n            {LinkedInCountries.Jamaica, \"jm\"},\n            {LinkedInCountries.Jordan, \"jo\"},\n            {LinkedInCountries.Japan, \"jp\"},\n            {LinkedInCountries.Kenya, \"ke\"},\n            {LinkedInCountries.Kyrgyzstan, \"kg\"},\n            {LinkedInCountries.Cambodia, \"kh\"},\n            {LinkedInCountries.Kiribati, \"ki\"},\n            {LinkedInCountries.Comoros, \"km\"},\n            {LinkedInCountries.SaintKittsAndNevis, \"kn\"},\n            {LinkedInCountries.KoreaDemocraticPeopleRepublicOf, \"kp\"},\n            {LinkedInCountries.KoreaRepublicOf, \"kr\"},\n            {LinkedInCountries.Kuwait, \"kw\"},\n            {LinkedInCountries.CaymanIslands, \"ky\"},\n            {LinkedInCountries.Kazakhstan, \"kz\"},\n            {LinkedInCountries.LaoPeopleDemocraticRepublic, \"la\"},\n            {LinkedInCountries.Lebanon, \"lb\"},\n            {LinkedInCountries.SaintLucia, \"lc\"},\n            {LinkedInCountries.Liechtenstein, \"li\"},\n            {LinkedInCountries.SriLanka, \"lk\"},\n            {LinkedInCountries.Liberia, \"lr\"},\n            {LinkedInCountries.Lesotho, \"ls\"},\n            {LinkedInCountries.Lithuania, \"lt\"},\n            {LinkedInCountries.Luxembourg, \"lu\"},\n            {LinkedInCountries.Latvia, \"lv\"},\n            {LinkedInCountries.Libya, \"ly\"},\n            {LinkedInCountries.Morocco, \"ma\"},\n            {LinkedInCountries.Monaco, \"mc\"},\n            {LinkedInCountries.MoldovaRepublicOf, \"md\"},\n            {LinkedInCountries.Montenegro, \"me\"},\n            {LinkedInCountries.SaintMartinFrenchPart, \"mf\"},\n            {LinkedInCountries.Madagascar, \"mg\"},\n            {LinkedInCountries.MarshallIslands, \"mh\"},\n            {LinkedInCountries.MacedoniaTheFormerYugoslavRepublicOf, \"mk\"},\n            {LinkedInCountries.Mali, \"ml\"},\n            {LinkedInCountries.Myanmar, \"mm\"},\n            {LinkedInCountries.Mongolia, \"mn\"},\n            {LinkedInCountries.Macao, \"mo\"},\n            {LinkedInCountries.NorthernMarianaIslands, \"mp\"},\n            {LinkedInCountries.Martinique, \"mq\"},\n            {LinkedInCountries.Mauritania, \"mr\"},\n            {LinkedInCountries.Montserrat, \"ms\"},\n            {LinkedInCountries.Malta, \"mt\"},\n            {LinkedInCountries.Mauritius, \"mu\"},\n            {LinkedInCountries.Maldives, \"mv\"},\n            {LinkedInCountries.Malawi, \"mw\"},\n            {LinkedInCountries.Mexico, \"mx\"},\n            {LinkedInCountries.Malaysia, \"my\"},\n            {LinkedInCountries.Mozambique, \"mz\"},\n            {LinkedInCountries.Namibia, \"na\"},\n            {LinkedInCountries.NewCaledonia, \"nc\"},\n            {LinkedInCountries.Niger, \"ne\"},\n            {LinkedInCountries.NorfolkIsland, \"nf\"},\n            {LinkedInCountries.Nigeria, \"ng\"},\n            {LinkedInCountries.Nicaragua, \"ni\"},\n            {LinkedInCountries.Netherlands, \"nl\"},\n            {LinkedInCountries.Norway, \"no\"},\n            {LinkedInCountries.Nepal, \"np\"},\n            {LinkedInCountries.Nauru, \"nr\"},\n            {LinkedInCountries.Niue, \"nu\"},\n            {LinkedInCountries.NewZealand, \"nz\"},\n            {LinkedInCountries.Oman, \"om\"},\n            {LinkedInCountries.Panama, \"pa\"},\n            {LinkedInCountries.Peru, \"pe\"},\n            {LinkedInCountries.FrenchPolynesia, \"pf\"},\n            {LinkedInCountries.PapuaNewGuinea, \"pg\"},\n            {LinkedInCountries.Philippines, \"ph\"},\n            {LinkedInCountries.Pakistan, \"pk\"},\n            {LinkedInCountries.Poland, \"pl\"},\n            {LinkedInCountries.SaintPierreAndMiquelon, \"pm\"},\n            {LinkedInCountries.Pitcairn, \"pn\"},\n            {LinkedInCountries.PuertoRico, \"pr\"},\n            {LinkedInCountries.PalestineStateOf, \"ps\"},\n            {LinkedInCountries.Portugal, \"pt\"},\n            {LinkedInCountries.Palau, \"pw\"},\n            {LinkedInCountries.Paraguay, \"py\"},\n            {LinkedInCountries.Qatar, \"qa\"},\n            {LinkedInCountries.Reunion, \"re\"},\n            {LinkedInCountries.Romania, \"ro\"},\n            {LinkedInCountries.Serbia, \"rs\"},\n            {LinkedInCountries.RussianFederation, \"ru\"},\n            {LinkedInCountries.Rwanda, \"rw\"},\n            {LinkedInCountries.SaudiArabia, \"sa\"},\n            {LinkedInCountries.SolomonIslands, \"request\"},\n            {LinkedInCountries.Seychelles, \"sc\"},\n            {LinkedInCountries.Sudan, \"sd\"},\n            {LinkedInCountries.Sweden, \"se\"},\n            {LinkedInCountries.Singapore, \"sg\"},\n            {LinkedInCountries.SaintHelenaAscensionAndTristanDaCunha, \"sh\"},\n            {LinkedInCountries.Slovenia, \"si\"},\n            {LinkedInCountries.SvalbardAndJanMayen, \"sj\"},\n            {LinkedInCountries.Slovakia, \"sk\"},\n            {LinkedInCountries.SierraLeone, \"sl\"},\n            {LinkedInCountries.SanMarino, \"sm\"},\n            {LinkedInCountries.Senegal, \"sn\"},\n            {LinkedInCountries.Somalia, \"so\"},\n            {LinkedInCountries.Suriname, \"sr\"},\n            {LinkedInCountries.SouthSudan, \"ss\"},\n            {LinkedInCountries.SaoTomeAndPrincipe, \"st\"},\n            {LinkedInCountries.ElSalvador, \"sv\"},\n            {LinkedInCountries.SintMaartenDutchPart, \"sx\"},\n            {LinkedInCountries.SyrianArabRepublic, \"sy\"},\n            {LinkedInCountries.Swaziland, \"sz\"},\n            {LinkedInCountries.TurksAndCaicosIslands, \"tc\"},\n            {LinkedInCountries.Chad, \"td\"},\n            {LinkedInCountries.FrenchSouthernTerritories, \"tf\"},\n            {LinkedInCountries.Togo, \"tg\"},\n            {LinkedInCountries.Thailand, \"th\"},\n            {LinkedInCountries.Tajikistan, \"tj\"},\n            {LinkedInCountries.Tokelau, \"tk\"},\n            {LinkedInCountries.TimorLeste, \"tl\"},\n            {LinkedInCountries.Turkmenistan, \"tm\"},\n            {LinkedInCountries.Tunisia, \"tn\"},\n            {LinkedInCountries.Tonga, \"to\"},\n            {LinkedInCountries.Turkey, \"tr\"},\n            {LinkedInCountries.TrinidadAndTobago, \"tt\"},\n            {LinkedInCountries.Tuvalu, \"tv\"},\n            {LinkedInCountries.TaiwanProvinceOfChina, \"tw\"},\n            {LinkedInCountries.TanzaniaUnitedRepublicOf, \"tz\"},\n            {LinkedInCountries.Ukraine, \"ua\"},\n            {LinkedInCountries.Uganda, \"ug\"},\n            {LinkedInCountries.UnitedStatesMinorOutlyingIslands, \"um\"},\n            {LinkedInCountries.UnitedStates, \"us\"},\n            {LinkedInCountries.Uruguay, \"uy\"},\n            {LinkedInCountries.Uzbekistan, \"uz\"},\n            {LinkedInCountries.VaticanCityState, \"va\"},\n            {LinkedInCountries.SaintVincentAndTheGrenadines, \"vc\"},\n            {LinkedInCountries.VenezuelaBolivarianRepublicOf, \"ve\"},\n            {LinkedInCountries.VirginIslandsBritish, \"vg\"},\n            {LinkedInCountries.VirginIslandsUS, \"vi\"},\n            {LinkedInCountries.VietNam, \"vn\"},\n            {LinkedInCountries.Vanuatu, \"vu\"},\n            {LinkedInCountries.WallisAndFutuna, \"wf\"},\n            {LinkedInCountries.Samoa, \"ws\"},\n            {LinkedInCountries.Yemen, \"ye\"},\n            {LinkedInCountries.Mayotte, \"yt\"},\n            {LinkedInCountries.SouthAfrica, \"za\"},\n            {LinkedInCountries.Zambia, \"zm\"},\n            {LinkedInCountries.Zimbabwe, \"zw\"}\n        };\n\n        internal static readonly Dictionary<string, string> IndustryCodes = new Dictionary<string, string>\n            {\n                {\"47\", \"corp fin|Accounting\"},\n                {\"94\", \"man tech tran|Airlines/Aviation\"},\n                {\"120\", \"leg org|Alternative Dispute Resolution\"},\n                {\"125\", \"hlth|Alternative Medicine\"},\n                {\"127\", \"art med|Animation\"},\n                {\"19\", \"good|Apparel & Fashion\"},\n                {\"50\", \"cons|Architecture & Planning\"},\n                {\"111\", \"art med rec|Arts and Crafts\"},\n                {\"53\", \"man|Automotive\"},\n                {\"52\", \"gov man|Aviation & Aerospace\"},\n                {\"41\", \"fin|Banking\"},\n                {\"12\", \"gov hlth tech|Biotechnology\"},\n                {\"36\", \"med rec|Broadcast Media\"},\n                {\"49\", \"cons|Building Materials\"},\n                {\"138\", \"corp man|Business Supplies and Equipment\"},\n                {\"129\", \"fin|Capital Markets\"},\n                {\"54\", \"man|Chemicals\"},\n                {\"90\", \"org serv|Civic & Social Organization\"},\n                {\"51\", \"cons gov|Civil Engineering\"},\n                {\"128\", \"cons corp fin|Commercial Real Estate\"},\n                {\"118\", \"tech|Computer & Network Security\"},\n                {\"109\", \"med rec|Computer Games\"},\n                {\"3\", \"tech|Computer Hardware\"},\n                {\"5\", \"tech|Computer Networking\"},\n                {\"4\", \"tech|Computer Software\"},\n                {\"48\", \"cons|Construction\"},\n                {\"24\", \"good man|Consumer Electronics\"},\n                {\"25\", \"good man|Consumer Goods\"},\n                {\"91\", \"org serv|Consumer Services\"},\n                {\"18\", \"good|Cosmetics\"},\n                {\"65\", \"agr|Dairy\"},\n                {\"1\", \"gov tech|Defense & Space\"},\n                {\"99\", \"art med|Design\"},\n                {\"69\", \"edu|Education Management\"},\n                {\"132\", \"edu org|E-Learning\"},\n                {\"112\", \"good man|Electrical/Electronic Manufacturing\"},\n                {\"28\", \"med rec|Entertainment\"},\n                {\"86\", \"org serv|Environmental Services\"},\n                {\"110\", \"corp rec serv|Events Services\"},\n                {\"76\", \"gov|Executive Office\"},\n                {\"122\", \"corp serv|Facilities Services\"},\n                {\"63\", \"agr|Farming\"},\n                {\"43\", \"fin|Financial Services\"},\n                {\"38\", \"art med rec|Fine Art\"},\n                {\"66\", \"agr|Fishery\"},\n                {\"34\", \"rec serv|Food & Beverages\"},\n                {\"23\", \"good man serv|Food Production\"},\n                {\"101\", \"org|Fund-Raising\"},\n                {\"26\", \"good man|Furniture\"},\n                {\"29\", \"rec|Gambling & Casinos\"},\n                {\"145\", \"cons man|Glass, Ceramics & Concrete\"},\n                {\"75\", \"gov|Government Administration\"},\n                {\"148\", \"gov|Government Relations\"},\n                {\"140\", \"art med|Graphic Design\"},\n                {\"124\", \"hlth rec|Health, Wellness and Fitness\"},\n                {\"68\", \"edu|Higher Education\"},\n                {\"14\", \"hlth|Hospital & Health Care\"},\n                {\"31\", \"rec serv tran|Hospitality\"},\n                {\"137\", \"corp|Human Resources\"},\n                {\"134\", \"corp good tran|Import and Export\"},\n                {\"88\", \"org serv|Individual & Family Services\"},\n                {\"147\", \"cons man|Industrial Automation\"},\n                {\"84\", \"med serv|Information Services\"},\n                {\"96\", \"tech|Information Technology and Services\"},\n                {\"42\", \"fin|Insurance\"},\n                {\"74\", \"gov|International Affairs\"},\n                {\"141\", \"gov org tran|International Trade and Development\"},\n                {\"6\", \"tech|Internet\"},\n                {\"45\", \"fin|Investment Banking\"},\n                {\"46\", \"fin|Investment Management\"},\n                {\"73\", \"gov leg|Judiciary\"},\n                {\"77\", \"gov leg|Law Enforcement\"},\n                {\"9\", \"leg|Law Practice\"},\n                {\"10\", \"leg|Legal Services\"},\n                {\"72\", \"gov leg|Legislative Office\"},\n                {\"30\", \"rec serv tran|Leisure, Travel & Tourism\"},\n                {\"85\", \"med rec serv|Libraries\"},\n                {\"116\", \"corp tran|Logistics and Supply Chain\"},\n                {\"143\", \"good|Luxury Goods & Jewelry\"},\n                {\"55\", \"man|Machinery\"},\n                {\"11\", \"corp|Management Consulting\"},\n                {\"95\", \"tran|Maritime\"},\n                {\"97\", \"corp|Market Research\"},\n                {\"80\", \"corp med|Marketing and Advertising\"},\n                {\"135\", \"cons gov man|Mechanical or Industrial Engineering\"},\n                {\"126\", \"med rec|Media Production\"},\n                {\"17\", \"hlth|Medical Devices\"},\n                {\"13\", \"hlth|Medical Practice\"},\n                {\"139\", \"hlth|Mental Health Care\"},\n                {\"71\", \"gov|Military\"},\n                {\"56\", \"man|Mining & Metals\"},\n                {\"35\", \"art med rec|Motion Pictures and Film\"},\n                {\"37\", \"art med rec|Museums and Institutions\"},\n                {\"115\", \"art rec|Music\"},\n                {\"114\", \"gov man tech|Nanotechnology\"},\n                {\"81\", \"med rec|Newspapers\"},\n                {\"100\", \"org|Non-Profit Organization Management\"},\n                {\"57\", \"man|Oil & Energy\"},\n                {\"113\", \"med|Online Media\"},\n                {\"123\", \"corp|Outsourcing/Offshoring\"},\n                {\"87\", \"serv tran|Package/Freight Delivery\"},\n                {\"146\", \"good man|Packaging and Containers\"},\n                {\"61\", \"man|Paper & Forest Products\"},\n                {\"39\", \"art med rec|Performing Arts\"},\n                {\"15\", \"hlth tech|Pharmaceuticals\"},\n                {\"131\", \"org|Philanthropy\"},\n                {\"136\", \"art med rec|Photography\"},\n                {\"117\", \"man|Plastics\"},\n                {\"107\", \"gov org|Political Organization\"},\n                {\"67\", \"edu|Primary/Secondary Education\"},\n                {\"83\", \"med rec|Printing\"},\n                {\"105\", \"corp|Professional Training & Coaching\"},\n                {\"102\", \"corp org|Program Development\"},\n                {\"79\", \"gov|Public Policy\"},\n                {\"98\", \"corp|Public Relations and Communications\"},\n                {\"78\", \"gov|Public Safety\"},\n                {\"82\", \"med rec|Publishing\"},\n                {\"62\", \"man|Railroad Manufacture\"},\n                {\"64\", \"agr|Ranching\"},\n                {\"44\", \"cons fin good|Real Estate\"},\n                {\"40\", \"rec serv|Recreational Facilities and Services\"},\n                {\"89\", \"org serv|Religious Institutions\"},\n                {\"144\", \"gov man org|Renewables & Environment\"},\n                {\"70\", \"edu gov|Research\"},\n                {\"32\", \"rec serv|Restaurants\"},\n                {\"27\", \"good man|Retail\"},\n                {\"121\", \"corp org serv|Security and Investigations\"},\n                {\"7\", \"tech|Semiconductors\"},\n                {\"58\", \"man|Shipbuilding\"},\n                {\"20\", \"good rec|Sporting Goods\"},\n                {\"33\", \"rec|Sports\"},\n                {\"104\", \"corp|Staffing and Recruiting\"},\n                {\"22\", \"good|Supermarkets\"},\n                {\"8\", \"gov tech|Telecommunications\"},\n                {\"60\", \"man|Textiles\"},\n                {\"130\", \"gov org|Think Tanks\"},\n                {\"21\", \"good|Tobacco\"},\n                {\"108\", \"corp gov serv|Translation and Localization\"},\n                {\"92\", \"tran|Transportation/Trucking/Railroad\"},\n                {\"59\", \"man|Utilities\"},\n                {\"106\", \"fin tech|Venture Capital & Private Equity\"},\n                {\"16\", \"hlth|Veterinary\"},\n                {\"93\", \"tran|Warehousing\"},\n                {\"133\", \"good|Wholesale\"},\n                {\"142\", \"good man rec|Wine and Spirits\"},\n                {\"119\", \"tech|Wireless\"},\n                {\"103\", \"art med rec|Writing and Editing\"}\n            };\n\n        private static DateTime _unixStartDate = new DateTime(1970, 1, 1);\n\n        internal static LinkedInPerson GetCurrentUser()\n        {\n            var sb = new StringBuilder(PROFILE_SELF_URL);\n            sb.Append(\":(id,first-name,last-name,headline)\");\n            sb.Append(\"?oauth2_access_token=\");\n            sb.Append(Singleton.Instance.AccessToken);\n            var requestString = MakeRequest(sb.ToString(), \"GET\");\n            var xdoc = XDocument.Parse(requestString);\n            return xdoc.Root != null ? BuildPerson(new LinkedInPerson(), xdoc.Root) : null;\n        }\n\n        /// <summary>\n        /// Builds and process web request\n        /// </summary>\n        /// <param name=\"url\">Request url</param>\n        /// <param name=\"method\">Request method</param>\n        /// <param name=\"postData\">Post data for POST/PUT request - optional</param>\n        /// <returns>The response data</returns>\n        internal static string MakeRequest(string url, string method, string postData = null)\n        {\n            var statusCode = HttpStatusCode.OK;\n            return MakeRequest(url, method, ref statusCode, postData);\n        }\n\n        /// <summary>\n        /// Builds and process web request\n        /// </summary>\n        /// <param name=\"url\">Request url</param>\n        /// <param name=\"method\">Request method</param>\n        /// <param name=\"statusCode\">On return, represents response status code</param>\n        /// <param name=\"postData\">Post data for POST/PUT request - optional</param>\n        /// <returns>The response data</returns>\n        internal static string MakeRequest(string url, string method, ref HttpStatusCode statusCode, string postData = null)\n        {\n            var o = new object();\n            lock (o)\n            {\n                Singleton.Instance.LastRequest = url;\n                var webRequest = WebRequest.Create(new Uri(url)) as HttpWebRequest;\n                if (webRequest == null) return \"\";\n                webRequest.Method = method;\n                webRequest.Credentials = CredentialCache.DefaultCredentials;\n                webRequest.AllowWriteStreamBuffering = true;\n                webRequest.PreAuthenticate = true;\n                webRequest.ServicePoint.Expect100Continue = false;\n                ServicePointManager.SecurityProtocol = Singleton.Instance.SecurityProtocol;\n                if (postData == null) return webResponseGet(webRequest, ref statusCode);\n                var fileToSend = Encoding.UTF8.GetBytes(postData);\n                webRequest.ContentLength = fileToSend.Length;\n\n                using (var reqStream = webRequest.GetRequestStream())\n                {\n                    reqStream.Write(fileToSend, 0, fileToSend.Length);\n                }\n                return webResponseGet(webRequest, ref statusCode);\n            }\n        }\n\n        /// <summary>\n        /// Processes the web response.\n        /// </summary>\n        /// <param name=\"webRequest\">The request object.</param>\n        /// <param name=\"statusCode\">On return, represents response status code</param>\n        /// <returns>The response data.</returns>\n        private static string webResponseGet(HttpWebRequest webRequest, ref HttpStatusCode statusCode)\n        {\n            var responseData = \"\";\n            var response = (HttpWebResponse)webRequest.GetResponse();\n            statusCode = response.StatusCode;\n            using (var stream = response.GetResponseStream())\n            {\n                if (stream == null) return responseData;\n                using (var responseReader = new StreamReader(stream))\n                {\n                    responseData = responseReader.ReadToEnd();\n                }\n            }\n            return responseData;\n        }\n\n        internal static NameValueCollection ParseResponse(string response)\n        {\n            var nvc = new NameValueCollection();\n            if (response.StartsWith(\"?\")) response = response.Substring(1);\n            var arr1 = response.Split('&');\n            foreach (var arr2 in arr1.Select(s => s.Split('=')).Where(arr2 => arr2.Length == 2))\n            {\n                nvc.Add(arr2[0].Trim(), arr2[1].Trim());\n            }\n            return nvc;\n        }\n\n        internal static string NormalizeUrl(string url)\n        {\n            return url.Replace(\":\", \"%3A\").Replace(\"/\", \"%2F\");\n        }\n\n        internal static string EscapeXml(string source)\n        {\n            string target = source;\n            target = target.Replace(\"&\", \"&amp;\");\n            target = target.Replace(\"\\\"\", \"&quot;\");\n            target = target.Replace(\"<\", \"&lt;\");\n            target = target.Replace(\">\", \"&gt;\");\n            return target;\n        }\n\n        internal static DateTime GetRealDateTime(double milliseconds)\n        {\n            return _unixStartDate.AddMilliseconds(milliseconds).ToLocalTime();\n        }\n\n        internal static LinkedInFacet BuildFacet(XElement xp)\n        {\n            var liFacet = new LinkedInFacet();\n\n            //code\n            var xe = xp.Element(\"code\");\n            if (xe != null)\n                liFacet.Code = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liFacet.Name = xe.Value.Trim();\n            //buckets\n            xe = xp.Element(\"buckets\");\n            if (xe != null)\n                liFacet.AddBuckets(xe.Elements(\"bucket\").Select(buildBucket));\n\n            return liFacet;\n        }\n\n        internal static LinkedInCompanyBase BuildCompanyBase(XElement xp)\n        {\n            var liCompanyBase = new LinkedInCompanyBase();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liCompanyBase.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liCompanyBase.Name = xe.Value.Trim();\n\n            return liCompanyBase;\n        }\n\n        internal static LinkedInDate BuildDate(XElement xe)\n        {\n            var liDate = new LinkedInDate();\n\n            var xn = xe.Element(\"year\");\n            if (xn != null)\n                liDate.Year = Convert.ToInt32(xn.Value.Trim());\n            xn = xe.Element(\"month\");\n            if (xn != null)\n                liDate.Month = Convert.ToInt32(xn.Value.Trim());\n            xn = xe.Element(\"day\");\n            if (xn != null)\n                liDate.Day = Convert.ToInt32(xn.Value.Trim());\n\n            return liDate;\n        }\n\n        internal static LinkedInPerson BuildPerson(LinkedInPerson liPerson, XElement xp)\n        {\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liPerson.Id = xe.Value.Trim();\n            //first-name\n            xe = xp.Element(\"first-name\");\n            if (xe != null)\n                liPerson.FirstName = xe.Value.Trim();\n            //last-name\n            xe = xp.Element(\"last-name\");\n            if (xe != null)\n                liPerson.LastName = xe.Value.Trim();\n            //headline\n            xe = xp.Element(\"headline\");\n            if (xe != null)\n                liPerson.Headline = xe.Value.Trim();\n            //picture-url\n            xe = xp.Element(\"picture-url\");\n            if (xe != null)\n                liPerson.PictureUrl = xe.Value.Trim();\n            //api-standard-profile-request\n            xe = xp.Element(\"api-standard-profile-request\");\n            if (xe != null)\n                liPerson.ApiStandardProfileRquest = buildApiStandardProfileRequest(xe);\n            //site-standard-profile-request\n            xe = xp.Element(\"site-standard-profile-request\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"url\");\n                if (xn != null)\n                    liPerson.SiteStandardProfileRequest = xn.Value.Trim();\n            }\n            return liPerson;\n        }\n\n        internal static LinkedInLike BuildLike(XElement xp)\n        {\n            var liLike = new LinkedInLike();\n\n            var xe = xp.Element(\"person\");\n            if (xe != null)\n            {\n                liLike.Person = BuildPerson(new LinkedInPerson(), xe);\n            }\n\n            return liLike;\n        }\n\n        internal static LinkedInComment BuildComment(XElement xp)\n        {\n            var liComment = new LinkedInComment();\n\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n            {\n                liComment.Id = xe.Value.Trim();\n            }\n            xe = xp.Element(\"sequence-number\");\n            if (xe != null)\n            {\n                liComment.SequenceNumber = Convert.ToInt32(xe.Value.Trim());\n            }\n            xe = xp.Element(\"comment\");\n            if (xe != null)\n            {\n                liComment.Comment = xe.Value.Trim();\n            }\n            xe = xp.Element(\"timestamp\");\n            if (xe != null)\n            {\n                liComment.CommentDate = GetRealDateTime(Convert.ToDouble(xe.Value.Trim()));\n            }\n            xe = xp.Element(\"person\");\n            if (xe != null)\n            {\n                liComment.Person = BuildPerson(new LinkedInPerson(), xe);\n            }\n\n            return liComment;\n        }\n\n        internal static LinkedInShare BuildShare(XElement xe)\n        {\n            var liShare = new LinkedInShare();\n\n            var xn = xe.Element(\"id\");\n            if (xn != null)\n            {\n                liShare.Id = xn.Value.Trim();\n            }\n            xn = xe.Element(\"timestamp\");\n            if (xn != null)\n            {\n                liShare.ShareDate = GetRealDateTime(Convert.ToDouble(xn.Value.Trim()));\n            }\n            xn = xe.Element(\"visibility\");\n            if (xn != null)\n            {\n                xn = xn.Element(\"code\");\n                if (xn != null)\n                {\n                    liShare.VisibilityCode = xn.Value.Trim() == \"anyone\"\n                                                               ? LinkedInShareVisibilityCode.Anyone\n                                                               : LinkedInShareVisibilityCode.ConnectionsOnly;\n                }\n            }\n            xn = xe.Element(\"comment\");\n            if (xn != null)\n            {\n                liShare.Comment = xn.Value.Trim();\n            }\n            xn = xe.Element(\"source\");\n            if (xn != null)\n            {\n                var xs = xn.Element(\"service-provider\");\n                if (xs != null)\n                {\n                    xs = xs.Element(\"name\");\n                    if (xs != null)\n                    {\n                        liShare.SourceServiceProvider = xs.Value.Trim();\n                    }\n                }\n                xs = xn.Element(\"application\");\n                if (xs != null)\n                {\n                    xs = xs.Element(\"name\");\n                    if (xs != null)\n                    {\n                        liShare.SourceApplication = xs.Value.Trim();\n                    }\n                }\n            }\n            xn = xe.Element(\"author\");\n            if (xn != null)\n            {\n                liShare.Author = BuildPerson(new LinkedInPerson(), xn);\n            }\n            xn = xe.Element(\"content\");\n            if (xn != null)\n            {\n                liShare.Content = new LinkedInShareContent();\n                var xc = xn.Element(\"submitted-url\");\n                if (xc != null)\n                    liShare.Content.SubmittedUrl = xc.Value.Trim();\n                xc = xn.Element(\"resolved-url\");\n                if (xc != null)\n                    liShare.Content.ResolvedUrl = xc.Value.Trim();\n                xc = xn.Element(\"shortened-url\");\n                if (xc != null)\n                    liShare.Content.ShorteneddUrl = xc.Value.Trim();\n                xc = xn.Element(\"title\");\n                if (xc != null)\n                    liShare.Content.Title = xc.Value.Trim();\n                xc = xn.Element(\"description\");\n                if (xc != null)\n                    liShare.Content.Description = xc.Value.Trim();\n                xc = xn.Element(\"submitted-image-url\");\n                if (xc != null)\n                    liShare.Content.SubmittedImageUrl = xc.Value.Trim();\n                xc = xn.Element(\"thumbnail-url\");\n                if (xc != null)\n                    liShare.Content.ThumbnailUrl = xc.Value.Trim();\n                xc = xn.Element(\"eyebrow-url\");\n                if (xc != null)\n                    liShare.Content.EyebrowUrl = xc.Value.Trim();\n            }\n            return liShare;\n        }\n\n        internal static LinkedInActionUpdate BuildUpdateAction(XElement xa)\n        {\n            var liUpdateAction = new LinkedInActionUpdate();\n\n            //action code\n            var xe = xa.Element(\"action\");\n            if (xe != null)\n            {\n                xe = xe.Element(\"code\");\n                if (xe != null)\n                {\n                    liUpdateAction.ActionCode = xe.Value.Trim();\n                }\n            }\n\n            return liUpdateAction;\n        }\n\n        internal static LinkedInMemberGroup BuildMemberGroup(XElement xp)\n        {\n            var liGroup = new LinkedInMemberGroup();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liGroup.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liGroup.Name = xe.Value.Trim();\n            //site-group-request\n            xe = xp.Element(\"site-group-request\");\n            if (xe != null)\n            {\n                xe = xe.Element(\"url\");\n                if (xe != null)\n                    liGroup.SiteGroupRequestUrl = xe.Value.Trim();\n            }\n\n            return liGroup;\n        }\n\n        internal static LinkedInActivity BuildActivity(XElement xp)\n        {\n            var liActivity = new LinkedInActivity();\n\n            //body\n            var xe = xp.Element(\"body\");\n            if (xe != null)\n                liActivity.Body = xe.Value.Trim();\n            //app-id\n            xe = xp.Element(\"app-id\");\n            if (xe != null)\n                liActivity.AppId = xe.Value.Trim();\n\n            return liActivity;\n        }\n\n        internal static LinkedInPositionBase BuildPositionBase(XElement xp)\n        {\n            var liPos = new LinkedInPositionBase();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liPos.Id = xe.Value.Trim();\n            //title\n            xe = xp.Element(\"title\");\n            if (xe != null)\n                liPos.Title = xe.Value.Trim();\n            //company\n            xe = xp.Element(\"company\");\n            if (xe != null)\n                liPos.Company = buildCompany(xe);\n\n            return liPos;\n        }\n\n        internal static LinkedInGroupSettings BuildGroupSettings(XElement xp)\n        {\n            var liSettings = new LinkedInGroupSettings();\n\n            //show-group-logo-in-profile\n            var xe = xp.Element(\"show-group-logo-in-profile\");\n            if (xe != null)\n                liSettings.ShowGroupLogoInProfile = Convert.ToBoolean(xe.Value.Trim());\n            //allow-messages-from-members\n            xe = xp.Element(\"allow-messages-from-members\");\n            if (xe != null)\n                liSettings.AllowMessagesFromMembers = Convert.ToBoolean(xe.Value.Trim());\n            //email-announcements-from-managers\n            xe = xp.Element(\"email-announcements-from-managers\");\n            if (xe != null)\n                liSettings.EmailAnnouncementsFromManagers = Convert.ToBoolean(xe.Value.Trim());\n            //email-for-every-new-post\n            xe = xp.Element(\"email-for-every-new-post\");\n            if (xe != null)\n                liSettings.EmailForEveryNewPost = Convert.ToBoolean(xe.Value.Trim());\n            //email-digest-frequency\n            xe = xp.Element(\"email-digest-frequency\");\n            if (xe != null)\n            {\n                var xc = xe.Element(\"code\");\n                if (xc != null)\n                {\n                    switch (xc.Value.Trim())\n                    {\n                        case \"none\":\n                            liSettings.EmailDigestFrequency = LinkedInEmailDigestFrequency.None;\n                            break;\n                        case \"daily\":\n                            liSettings.EmailDigestFrequency = LinkedInEmailDigestFrequency.Daily;\n                            break;\n                        case \"weekly\":\n                            liSettings.EmailDigestFrequency = LinkedInEmailDigestFrequency.Weekly;\n                            break;\n                    }\n                }\n            }\n\n            return liSettings;\n        }\n\n        internal static LinkedInGroup BuildGroup(XElement xp)\n        {\n            var liGroup = new LinkedInGroup();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liGroup.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liGroup.Name = xe.Value.Trim();\n            //short-description\n            xe = xp.Element(\"short-description\");\n            if (xe != null)\n                liGroup.ShortDescription = xe.Value.Trim();\n            //description\n            xe = xp.Element(\"description\");\n            if (xe != null)\n                liGroup.Description = xe.Value.Trim();\n            //relation-to-viewer\n            xe = xp.Element(\"relation-to-viewer\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"membership-state\");\n                if (xn != null)\n                {\n                    var xc = xn.Element(\"code\");\n                    if (xc != null)\n                    {\n                        switch (xc.Value.Trim())\n                        {\n                            case \"blocked\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.Blocked;\n                                break;\n                            case \"non-member\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.NonMember;\n                                break;\n                            case \"awaiting-confirmation\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.AwaitingConfirmation;\n                                break;\n                            case \"awaiting-parent-group-confirmation\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.AwaitingParentGroupConfirmation;\n                                break;\n                            case \"member\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.Member;\n                                break;\n                            case \"moderator\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.Moderator;\n                                break;\n                            case \"manager\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.Manager;\n                                break;\n                            case \"owner\":\n                                liGroup.MembershipState = LinkedInGroupRelationship.Owner;\n                                break;\n                        }\n                    }\n                }\n                var xactions = xe.Element(\"available-actions\");\n                if (xactions != null)\n                {\n                    foreach (\n                        var xc in xactions.Elements(\"action\").Select(xa => xa.Element(\"code\")).Where(xc => xc != null))\n                    {\n                        switch (xc.Value.Trim())\n                        {\n                            case \"add-post\":\n                                liGroup.AvailableAction[LinkedInGroupAction.AddPost] = true;\n                                break;\n                            case \"leave\":\n                                liGroup.AvailableAction[LinkedInGroupAction.Leave] = true;\n                                break;\n                            case \"view-posts\":\n                                liGroup.AvailableAction[LinkedInGroupAction.ViewPosts] = true;\n                                break;\n                        }\n                    }\n                }\n            }\n            //counts-by-category\n            xe = xp.Element(\"counts-by-category\");\n            if (xe != null)\n                liGroup.AddCountsByCategory(xe.Elements(\"count-for-category\").Select(buildGroupCategoryCount));\n            //is-open-to-non-members\n            xe = xp.Element(\"is-open-to-non-members\");\n            if (xe != null)\n                liGroup.IsOpenToNonMembers = Convert.ToBoolean(xe.Value.Trim());\n            //category\n            xe = xp.Element(\"category\");\n            if (xe != null)\n            {\n                var xc = xe.Element(\"code\");\n                if (xc != null)\n                {\n                    switch (xc.Value.Trim())\n                    {\n                        case \"alumni\":\n                            liGroup.Category = LinkedInGroupCategory.Alumni;\n                            break;\n                        case \"corporate\":\n                            liGroup.Category = LinkedInGroupCategory.Corporate;\n                            break;\n                        case \"conference\":\n                            liGroup.Category = LinkedInGroupCategory.Conference;\n                            break;\n                        case \"network\":\n                            liGroup.Category = LinkedInGroupCategory.Network;\n                            break;\n                        case \"philanthropic\":\n                            liGroup.Category = LinkedInGroupCategory.Philantropic;\n                            break;\n                        case \"professional\":\n                            liGroup.Category = LinkedInGroupCategory.Professional;\n                            break;\n                        case \"other\":\n                            liGroup.Category = LinkedInGroupCategory.Other;\n                            break;\n                    }\n                }\n            }\n            //website-url\n            xe = xp.Element(\"website-url\");\n            if (xe != null)\n                liGroup.WebSiteUrl = xe.Value.Trim();\n            //site-group-url\n            xe = xp.Element(\"site-group-url\");\n            if (xe != null)\n                liGroup.SiteGroupUrl = xe.Value.Trim();\n            //locale\n            xe = xp.Element(\"locale\");\n            if (xe != null)\n                liGroup.Locale = xe.Value.Trim();\n            //allow-member-invites\n            xe = xp.Element(\"allow-member-invites\");\n            if (xe != null)\n                liGroup.AllowMembersInvite = Convert.ToBoolean(xe.Value.Trim());\n            //small-logo-url\n            xe = xp.Element(\"small-logo-url\");\n            if (xe != null)\n                liGroup.SmallLogoUrl = xe.Value.Trim();\n            //large-logo-url\n            xe = xp.Element(\"large-logo-url\");\n            if (xe != null)\n                liGroup.LargeLogoUrl = xe.Value.Trim();\n            //num-members\n            xe = xp.Element(\"num-members\");\n            if (xe != null)\n                liGroup.NumberOfMembers = Convert.ToInt32(xe.Value.Trim());\n            //location\n            xe = xp.Element(\"location\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"country\");\n                if (xn != null)\n                {\n                    xn = xn.Element(\"code\");\n                    if (xn != null)\n                        liGroup.LocationCountry = xn.Value.Trim();\n                }\n                xn = xe.Element(\"postal-code\");\n                if (xn != null)\n                    liGroup.LocationPostalCode = xn.Value.Trim();\n            }\n\n            return liGroup;\n        }\n\n        internal static LinkedInGroupPost BuildGroupPost(XElement xp)\n        {\n            var liPost = new LinkedInGroupPost();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liPost.Id = xe.Value.Trim();\n            //type\n            xe = xp.Element(\"type\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"code\");\n                if (xn != null)\n                {\n                    switch (xn.Value.Trim())\n                    {\n                        case \"standard\":\n                            liPost.PostType = LinkedInGroupPostType.Standard;\n                            break;\n                        case \"news\":\n                            liPost.PostType = LinkedInGroupPostType.News;\n                            break;\n                    }\n                }\n            }\n            //category\n            xe = xp.Element(\"category\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"code\");\n                if (xn != null)\n                {\n                    switch (xn.Value.Trim())\n                    {\n                        case \"discussion\":\n                            liPost.Category = LinkedInGroupPostCategory.Discussion;\n                            break;\n                    }\n                }\n            }\n            //creator\n            xe = xp.Element(\"creator\");\n            if (xe != null)\n                liPost.Creator = BuildPerson(new LinkedInPerson(), xe);\n            //creation-timestamp\n            xe = xp.Element(\"creation-timestamp\");\n            if (xe != null)\n                liPost.CreationTime = GetRealDateTime(Convert.ToDouble(xe.Value.Trim()));\n            //title\n            xe = xp.Element(\"title\");\n            if (xe != null)\n                liPost.Title = xe.Value.Trim();\n            //summary\n            xe = xp.Element(\"summary\");\n            if (xe != null)\n                liPost.Summary = xe.Value.Trim();\n            //relation-to-viewer\n            xe = xp.Element(\"relation-to-viewer\");\n            if (xe != null)\n            {\n                //is-following\n                var xn = xe.Element(\"is-following\");\n                if (xn != null)\n                    liPost.IsFollowingByUser = Convert.ToBoolean(xn.Value.Trim());\n                //is-liked\n                xn = xe.Element(\"is-liked\");\n                if (xn != null)\n                    liPost.IsLikedByUser = Convert.ToBoolean(xn.Value.Trim());\n                var xactions = xe.Element(\"available-actions\");\n                if (xactions != null)\n                {\n                    foreach (var xc in xactions.Elements(\"action\").Select(xa => xa.Element(\"code\")).Where(xc => xc != null))\n                    {\n                        switch (xc.Value.Trim())\n                        {\n                            case \"add-comment\":\n                                liPost.AvailableAction[LinkedInGroupPostAction.AddComment] = true;\n                                break;\n                            case \"flag-as-inappropriate\":\n                            case \"delete\":\n                                liPost.AvailableAction[LinkedInGroupPostAction.FlagAsInappropriate] = true;\n                                break;\n                            case \"categorize-as-job\":\n                                liPost.AvailableAction[LinkedInGroupPostAction.CategorizeAsJob] = true;\n                                break;\n                            case \"categorize-as-promotion\":\n                                liPost.AvailableAction[LinkedInGroupPostAction.CategorizeAsPromotion] = true;\n                                break;\n                            case \"follow\":\n                            case \"unfollow\":\n                                liPost.AvailableAction[LinkedInGroupPostAction.Follow] = true;\n                                break;\n                            case \"like\":\n                            case \"unlike\":\n                                liPost.AvailableAction[LinkedInGroupPostAction.Like] = true;\n                                break;\n                            case \"reply-privately\":\n                                liPost.AvailableAction[LinkedInGroupPostAction.ReplyPrivately] = true;\n                                break;\n                        }\n                    }\n                }\n            }\n            //likes\n            xe = xp.Element(\"likes\");\n            if (xe != null)\n                liPost.AddLikes(xe.Elements(\"like\").Select(BuildLike));\n            //attachment\n            xe = xp.Element(\"attachment\");\n            if (xe != null)\n                liPost.Attachment = buildPostAttachment(xe);\n            //site-group-post-url\n            xe = xp.Element(\"site-group-post-url\");\n            if (xe != null)\n                liPost.SiteGroupPostUrl = xe.Value.Trim();\n\n            return liPost;\n        }\n\n        internal static LinkedInGroupComment BuildGroupComment(XElement xp)\n        {\n            var liComment = new LinkedInGroupComment();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liComment.Id = xe.Value.Trim();\n            //text\n            xe = xp.Element(\"text\");\n            if (xe != null)\n                liComment.Text = xe.Value.Trim();\n            //creator\n            xe = xp.Element(\"creator\");\n            if (xe != null)\n                liComment.Creator = BuildPerson(new LinkedInPerson(), xe);\n            //creation-timestamp\n            xe = xp.Element(\"creation-timestamp\");\n            if (xe != null)\n                liComment.CreationTime = GetRealDateTime(Convert.ToDouble(xe.Value.Trim()));\n            //relation-to-viewer\n            xe = xp.Element(\"relation-to-viewer\");\n            if (xe == null) return liComment;\n            var xactions = xe.Element(\"available-actions\");\n            if (xactions == null) return liComment;\n            foreach (var xc in xactions.Elements(\"action\").Select(xa => xa.Element(\"code\")).Where(xc => xc != null))\n            {\n                switch (xc.Value.Trim())\n                {\n                    case \"flag-as-inappropriate\":\n                        liComment.AvailableAction[LinkedInGroupCommentAction.FlagAsInappropriate] = true;\n                        break;\n                    case \"delete\":\n                        liComment.AvailableAction[LinkedInGroupCommentAction.Delete] = true;\n                        break;\n                }\n            }\n\n            return liComment;\n        }\n\n        internal static LinkedInRecommendation BuildRecommendationReceived(XElement xp)\n        {\n            var liRecommendation = new LinkedInRecommendation();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liRecommendation.Id = xe.Value.Trim();\n            //recommendation-type\n            xe = xp.Element(\"recommendation-type\");\n            if (xe != null)\n            {\n                xe = xe.Element(\"code\");\n                if (xe != null)\n                    liRecommendation.TypeCode = xe.Value.Trim();\n            }\n            //recommendation-text\n            xe = xp.Element(\"recommendation-text\");\n            if (xe != null)\n                liRecommendation.Text = xe.Value.Trim();\n            //recommender\n            xe = xp.Element(\"recommender\");\n            if (xe != null)\n                liRecommendation.RecommendationPerson = BuildPerson(new LinkedInPerson(), xe);\n            //web-url\n            xe = xp.Element(\"web-url\");\n            if (xe != null)\n                liRecommendation.WebUrl = xe.Value.Trim();\n\n            liRecommendation.RecommendationType = LinkedInRecommendationType.Received;\n\n            return liRecommendation;\n        }\n\n        internal static LinkedInRecommendation BuildRecommendationGiven(XElement xp)\n        {\n            var liRecommendation = new LinkedInRecommendation();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liRecommendation.Id = xe.Value.Trim();\n            //recommendation-type\n            xe = xp.Element(\"recommendation-type\");\n            if (xe != null)\n            {\n                xe = xe.Element(\"code\");\n                if (xe != null)\n                    liRecommendation.TypeCode = xe.Value.Trim();\n            }\n            //recommendation-snippet\n            xe = xp.Element(\"recommendation-snippet\");\n            if (xe != null)\n                liRecommendation.Text = xe.Value.Trim();\n            //recommendee\n            xe = xp.Element(\"recommendee\");\n            if (xe != null)\n                liRecommendation.RecommendationPerson = BuildPerson(new LinkedInPerson(), xe);\n            //web-url\n            xe = xp.Element(\"web-url\");\n            if (xe != null)\n                liRecommendation.WebUrl = xe.Value.Trim();\n\n            liRecommendation.RecommendationType = LinkedInRecommendationType.Given;\n\n            return liRecommendation;\n        }\n\n        internal static LinkedInJob BuildJob(XElement xp)\n        {\n            var liJob = new LinkedInJob();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liJob.Id = xe.Value.Trim();\n            //active\n            xe = xp.Element(\"active\");\n            if (xe != null)\n                liJob.Active = Convert.ToBoolean(xe.Value.Trim());\n            //company\n            xe = xp.Element(\"company\");\n            if (xe != null)\n                liJob.Company = BuildCompanyBase(xe);\n            //position\n            xe = xp.Element(\"position\");\n            if (xe != null)\n            {\n                xe = xe.Element(\"title\");\n                if (xe != null)\n                    liJob.PositionTitle = xe.Value.Trim();\n            }\n            //description-snippet\n            xe = xp.Element(\"description-snippet\");\n            if (xe != null)\n                liJob.DescriptionSnippet = xe.Value.Trim();\n            //description\n            xe = xp.Element(\"description\");\n            if (xe != null)\n                liJob.Description = xe.Value.Trim();\n            //posting-timestamp\n            xe = xp.Element(\"posting-timestamp\");\n            if (xe != null)\n                liJob.PostingTimestamp = GetRealDateTime(Convert.ToDouble(xe.Value.Trim()));\n            //site-job-request\n            xe = xp.Element(\"site-job-request\");\n            if (xe != null)\n            {\n                xe = xe.Element(\"url\");\n                if (xe != null)\n                    liJob.JobSiteRequestUrl = xe.Value.Trim();\n            }\n            //location-description\n            xe = xp.Element(\"location-description\");\n            if (xe != null)\n                liJob.LocationDescription = xe.Value.Trim();\n\n            return liJob;\n        }\n\n        internal static LinkedInUpdate BuildUpdate(XElement xu)\n        {\n            var updType = \"\";\n            var xe = xu.Element(\"update-type\");\n            if (xe != null)\n                updType = xe.Value.Trim();\n            LinkedInUpdate update = null;\n            switch (updType)\n            {\n                case \"CONN\":\n                    update = new LinkedInConnectionMemberUpdate();\n                    break;\n                case \"NCON\":\n                case \"CCEM\":\n                    update = new LinkedInConnectionUpdate();\n                    break;\n                case \"SHAR\":\n                    update = new LinkedInShareUpdate();\n                    break;\n                case \"STAT\":\n                    update = new LinkedInStatusUpdate();\n                    break;\n                case \"VIRL\":\n                    update = new LinkedInViralUpdate();\n                    break;\n                case \"JGRP\":\n                    update = new LinkedInGroupUpdate();\n                    break;\n                case \"APPS\":\n                case \"APPM\":\n                    update = new LinkedInApplicationUpdate();\n                    break;\n                case \"PICU\":\n                    update = new LinkedInPictureUpdate();\n                    break;\n                case \"PROF\":\n                    update = new LinkedInPositionUpdate();\n                    break;\n                case \"PRFX\":\n                    update = new LinkedInExtendedProfileUpdate();\n                    break;\n                case \"PREC\":\n                case \"SVPR\":\n                    update = new LinkedInRecommendationUpdate();\n                    break;\n                case \"JOBP\":\n                    update = new LinkedInJobPostingUpdate();\n                    break;\n                case \"CMPY\":\n                    switch (getCompanyUpdateType(xu))\n                    {\n                        case CompanyUpdateType.Profile:\n                            update = new LinkedInCompanyProfileUpdate();\n                            break;\n                        case CompanyUpdateType.Status:\n                            update = new LinkedInCompanyStatusUpdate();\n                            break;\n                        case CompanyUpdateType.Job:\n                            update = new LinkedInCompanyJobUpdate();\n                            break;\n                        case CompanyUpdateType.Person:\n                            update = new LinkedInCompanyPersonUpdate();\n                            break;\n                    }\n                    break;\n                case \"MSFC\":\n                    update = new LinkedInStartFollowCompanyUpdate();\n                    break;\n            }\n            if (update != null)\n                update.BuildUpdate(xu);\n            return update;\n        }\n\n        internal static LinkedInMember BuildMember(XElement xp)\n        {\n            return new LinkedInMember\n            {\n                BasicProfile = buildBasicProfile(xp),\n                EmailProfile = buildEmailProfile(xp),\n                FullProfile = buildFullProfile(xp)\n            };\n        }\n\n        private static LinkedInFullProfile buildFullProfile(XElement xp)\n        {\n            var liFull = new LinkedInFullProfile();\n\n            //last-modified-timestamp\n            var xe = xp.Element(\"last-modified-timestamp\");\n            if (xe != null)\n                liFull.LastModifiedTimestamp = GetRealDateTime(Convert.ToDouble(xe.Value.Trim()));\n            //proposal-comments\n            xe = xp.Element(\"proposal-comments\");\n            if (xe != null)\n                liFull.ProposalComments = xe.Value.Trim();\n            //interests\n            xe = xp.Element(\"interests\");\n            if (xe != null)\n                liFull.Interests = xe.Value.Trim();\n            //associations\n            xe = xp.Element(\"associations\");\n            if (xe != null)\n                liFull.Associations = xe.Value.Trim();\n            //publications\n            xe = xp.Element(\"publications\");\n            if (xe != null)\n                liFull.AddPublications(xe.Elements(\"publication\").Select(buildPublication));\n            //patents\n            xe = xp.Element(\"patents\");\n            if (xe != null)\n                liFull.AddPatents(xe.Elements(\"patent\").Select(buildPatent));\n            //languages\n            xe = xp.Element(\"languages\");\n            if (xe != null)\n                liFull.AddLanguages(xe.Elements(\"language\").Select(buildLanguage));\n            //skills\n            xe = xp.Element(\"skills\");\n            if (xe != null)\n                liFull.AddSkills(xe.Elements(\"skill\").Select(buildSkill));\n            //educations\n            xe = xp.Element(\"educations\");\n            if (xe != null)\n                liFull.AddEducations(xe.Elements(\"education\").Select(buildEducation));\n            //certifications\n            xe = xp.Element(\"certifications\");\n            if (xe != null)\n                liFull.AddCertifications(xe.Elements(\"certification\").Select(buildCertification));\n            //courses\n            xe = xp.Element(\"courses\");\n            if (xe != null)\n                liFull.AddCourses(xe.Elements(\"course\").Select(buildCourse));\n            //volunteer\n            xe = xp.Element(\"volunteer\");\n            if (xe != null)\n            {\n                xe = xe.Element(\"volunteer-experiences\");\n                if (xe != null)\n                    liFull.AddVolunteer(xe.Elements(\"volunteer-experience\").Select(buildVoluteerExpirience));\n            }\n            //three-current-positions\n            xe = xp.Element(\"three-current-positions\");\n            if (xe != null)\n                liFull.AddPositions(xe.Elements(\"position\").Select(buildPosition), true);\n            //three-past-positions\n            xe = xp.Element(\"three-past-positions\");\n            if (xe != null)\n                liFull.AddPositions(xe.Elements(\"position\").Select(buildPosition), false);\n            //related-profile-views\n            xe = xp.Element(\"related-profile-views\");\n            if (xe != null)\n                liFull.AddRelatedProfileViews(\n                    xe.Elements(\"person\").Select(p => BuildPerson(new LinkedInPerson(), p)));\n            //member-url-resources\n            xe = xp.Element(\"member-url-resources\");\n            if (xe != null)\n                liFull.AddMemberUrls(xe.Elements(\"member-url\").Select(buildMemberUrls));\n            //date-of-birth\n            xe = xp.Element(\"date-of-birth\");\n            if (xe != null)\n                liFull.DateOfBirth = BuildDate(xe);\n            //num-recommenders\n            xe = xp.Element(\"num-recommenders\");\n            if (xe != null)\n                liFull.NumRecommenders = Convert.ToInt32(xe.Value.Trim());\n            //recommendations-received\n            xe = xp.Element(\"recommendations-received\");\n            if (xe != null)\n                liFull.AddRecommendations(xe.Elements(\"recommendation\").Select(BuildRecommendationReceived));\n            //mfeed-rss-url\n            xe = xp.Element(\"mfeed-rss-url\");\n            if (xe != null)\n                liFull.MfeedRssUrl = xe.Value.Trim();\n            //job-bookmarks\n            xe = xp.Element(\"job-bookmarks\");\n            if (xe != null)\n                liFull.AddJobBookmarks(xe.Elements(\"job-bookmark\").Select(buildJobBookmark));\n            //following\n            xe = xp.Element(\"following\");\n            if (xe != null)\n                liFull.Following = buildFollowing(xe);\n            //suggestions\n            xe = xp.Element(\"suggestions\");\n            if (xe != null)\n                liFull.Suggestions = buildSuggestions(xe);\n            //connections\n            xe = xp.Element(\"connections\");\n            if (xe != null)\n                liFull.AddConnections(\n                    xe.Elements(\"person\").Select(p => BuildPerson(new LinkedInPerson(), p)));\n\n            return liFull;\n        }\n\n        private static LinkedInHttpHeader buildHeader(XElement xp)\n        {\n            var liHeader = new LinkedInHttpHeader();\n\n            //name\n            var xe = xp.Element(\"name\");\n            if (xe != null)\n                liHeader.Name = xe.Value.Trim();\n            //value\n            xe = xp.Element(\"value\");\n            if (xe != null)\n                liHeader.Value = xe.Value.Trim();\n\n            return liHeader;\n        }\n\n        private static LinkedInApiStandardProfileRequest buildApiStandardProfileRequest(XElement xp)\n        {\n            var liRequest = new LinkedInApiStandardProfileRequest();\n\n            //url\n            var xn = xp.Element(\"url\");\n            if (xn != null)\n                liRequest.Url = xn.Value.Trim();\n            //headers\n            xn = xp.Element(\"headers\");\n            if (xn != null)\n            {\n                liRequest.AddHeaders(xn.Elements(\"http-header\").Select(buildHeader));\n            }\n\n            return liRequest;\n        }\n\n        private static LinkedInCompany buildCompany(XElement xp)\n        {\n            var liCompany = new LinkedInCompany();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liCompany.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liCompany.Name = xe.Value.Trim();\n            //size\n            xe = xp.Element(\"size\");\n            if (xe != null)\n                liCompany.Size = xe.Value.Trim();\n            //type\n            xe = xp.Element(\"type\");\n            if (xe != null)\n                liCompany.Type = xe.Value.Trim();\n            //industry\n            xe = xp.Element(\"industry\");\n            if (xe != null)\n                liCompany.Industry = xe.Value.Trim();\n            //ticker\n            xe = xp.Element(\"ticker\");\n            if (xe != null)\n                liCompany.Ticker = xe.Value.Trim();\n\n            return liCompany;\n        }\n\n        private static LinkedInSuggestions buildSuggestions(XElement xp)\n        {\n            var liSuggestion = new LinkedInSuggestions();\n\n            var xe = xp.Element(\"to-follow\");\n            if (xe != null)\n                liSuggestion.ToFollow = buildToFollow(xe);\n            return liSuggestion;\n        }\n\n        private static LinkedInToFollow buildToFollow(XElement xp)\n        {\n            var liToFollow = new LinkedInToFollow();\n\n            //people\n            var xe = xp.Element(\"people\");\n            if (xe != null)\n                liToFollow.AddPeople(\n                    xe.Elements(\"person\").Select(p => BuildPerson(new LinkedInPerson(), p)));\n            //companies\n            xe = xp.Element(\"companies\");\n            if (xe != null)\n                liToFollow.AddCompanies(xe.Elements(\"company\").Select(buildCompany));\n            //industries\n            xe = xp.Element(\"industries\");\n            if (xe != null)\n                liToFollow.AddIndustries(xe.Elements(\"industry\").Select(buildIndustry));\n            //news-sources\n            xe = xp.Element(\"news-sources\");\n            if (xe != null)\n                liToFollow.AddNewsSources(xe.Elements(\"news-source\").Select(buildNewsSource));\n\n            return liToFollow;\n        }\n\n        private static LinkedInNewsSource buildNewsSource(XElement xp)\n        {\n            var liNewsSource = new LinkedInNewsSource();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liNewsSource.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liNewsSource.Name = xe.Value.Trim();\n\n            return liNewsSource;\n        }\n\n        private static LinkedInJobBookmark buildJobBookmark(XElement xp)\n        {\n            var liJbookmark = new LinkedInJobBookmark();\n\n            //is-applied\n            var xe = xp.Element(\"is-applied\");\n            if (xe != null)\n                liJbookmark.IsApplied = Convert.ToBoolean(xe.Value.Trim());\n            //is-saved\n            xe = xp.Element(\"is-saved\");\n            if (xe != null)\n                liJbookmark.IsSaved = Convert.ToBoolean(xe.Value.Trim());\n            //saved-timestamp\n            xe = xp.Element(\"saved-timestamp\");\n            if (xe != null)\n                liJbookmark.SavedTimestamp = GetRealDateTime(Convert.ToDouble(xe.Value.Trim()));\n            //job\n            xe = xp.Element(\"job\");\n            if (xe != null)\n                liJbookmark.Job = BuildJob(xe);\n\n            return liJbookmark;\n        }\n\n        private static LinkedInFollowing buildFollowing(XElement xp)\n        {\n            var liFoll = new LinkedInFollowing();\n\n            //people\n            var xe = xp.Element(\"people\");\n            if (xe != null)\n                liFoll.AddPeople(xe.Elements(\"person\").Select(p => BuildPerson(new LinkedInPerson(), p)));\n            //companies\n            xe = xp.Element(\"companies\");\n            if (xe != null)\n                liFoll.AddCompanies(xe.Elements(\"company\").Select(buildCompany));\n            //industries\n            xe = xp.Element(\"industries\");\n            if (xe != null)\n                liFoll.AddIndustries(xe.Elements(\"industry\").Select(buildIndustry));\n            //special-editions\n            xe = xp.Element(\"special-editions\");\n            if (xe != null)\n                liFoll.AddSpecialEditions(xe.Elements(\"special-edition\").Select(buildSpecialEdition));\n\n            return liFoll;\n        }\n\n        private static LinkedInSpecialEdition buildSpecialEdition(XElement xp)\n        {\n            var liSpecialEd = new LinkedInSpecialEdition();\n\n            return liSpecialEd;\n        }\n\n        private static LinkedInIndustry buildIndustry(XElement xp)\n        {\n            var liIndustry = new LinkedInIndustry();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liIndustry.Id = xe.Value.Trim();\n            if (IndustryCodes.ContainsKey(liIndustry.Id))\n            {\n                var temp = IndustryCodes[liIndustry.Id];\n                var arr = temp.Split('|');\n                liIndustry.Group = arr[0];\n                liIndustry.Description = arr[1];\n            }\n            return liIndustry;\n        }\n\n        private static LinkedInMemberUrl buildMemberUrls(XElement xp)\n        {\n            var liUrl = new LinkedInMemberUrl();\n\n            //url\n            var xe = xp.Element(\"url\");\n            if (xe != null)\n                liUrl.Url = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liUrl.Name = xe.Value.Trim();\n\n            return liUrl;\n        }\n\n        private static LinkedInPublication buildPublication(XElement xp)\n        {\n            var liPub = new LinkedInPublication();\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liPub.Id = xe.Value.Trim();\n            //title\n            xe = xp.Element(\"title\");\n            if (xe != null)\n                liPub.Title = xe.Value.Trim();\n            //summary\n            xe = xp.Element(\"summary\");\n            if (xe != null)\n                liPub.Summary = xe.Value.Trim();\n            //url\n            xe = xp.Element(\"url\");\n            if (xe != null)\n                liPub.Url = xe.Value.Trim();\n            //publisher\n            xe = xp.Element(\"publisher\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"name\");\n                if (xn != null)\n                    liPub.Publisher = xn.Value.Trim();\n            }\n            //date\n            xe = xp.Element(\"date\");\n            if (xe != null)\n            {\n                liPub.Date = BuildDate(xe);\n            }\n            //authors\n            xe = xp.Element(\"authors\");\n            if (xe != null)\n            {\n                liPub.AddAuthors(xe.Elements(\"author\").Select(buildAuthor));\n            }\n\n            return liPub;\n        }\n\n        private static LinkedInVolunteerExperience buildVoluteerExpirience(XElement xp)\n        {\n            var liExp = new LinkedInVolunteerExperience();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liExp.Id = xe.Value.Trim();\n            //role\n            xe = xp.Element(\"role\");\n            if (xe != null)\n                liExp.Role = xe.Value.Trim();\n            //organization\n            xe = xp.Element(\"organization\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"id\");\n                if (xn != null)\n                    liExp.Organization.Id = xn.Value.Trim();\n                xn = xe.Element(\"name\");\n                if (xn != null)\n                    liExp.Organization.Name = xn.Value.Trim();\n            }\n            //cause\n            xe = xp.Element(\"cause\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"name\");\n                if (xn != null)\n                    liExp.Cause = xn.Value.Trim();\n            }\n\n            return liExp;\n        }\n\n        private static LinkedInCourse buildCourse(XElement xp)\n        {\n            var liCourse = new LinkedInCourse();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liCourse.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liCourse.Name = xe.Value.Trim();\n            //number\n            xe = xp.Element(\"number\");\n            if (xe != null)\n                liCourse.Number = xe.Value.Trim();\n\n            return liCourse;\n        }\n\n        private static LinkedInEducation buildEducation(XElement xp)\n        {\n            var liEducation = new LinkedInEducation();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liEducation.Id = xe.Value.Trim();\n            //school-name\n            xe = xp.Element(\"school-name\");\n            if (xe != null)\n                liEducation.SchoolName = xe.Value.Trim();\n            //field-of-study\n            xe = xp.Element(\"field-of-study\");\n            if (xe != null)\n                liEducation.FieldOfStudy = xe.Value.Trim();\n            //start-date\n            xe = xp.Element(\"start-date\");\n            if (xe != null)\n                liEducation.StartDate = BuildDate(xe);\n            //end-date\n            xe = xp.Element(\"end-date\");\n            if (xe != null)\n                liEducation.EndDate = BuildDate(xe);\n            //degree\n            xe = xp.Element(\"degree\");\n            if (xe != null)\n                liEducation.Degree = xe.Value.Trim();\n            //activities\n            xe = xp.Element(\"activities\");\n            if (xe != null)\n                liEducation.Activities = xe.Value.Trim();\n            //notes\n            xe = xp.Element(\"notes\");\n            if (xe != null)\n                liEducation.Notes = xe.Value.Trim();\n\n            return liEducation;\n        }\n\n        private static LinkedInPatent buildPatent(XElement xp)\n        {\n            var liPatent = new LinkedInPatent();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liPatent.Id = xe.Value.Trim();\n            //title\n            xe = xp.Element(\"title\");\n            if (xe != null)\n                liPatent.Title = xe.Value.Trim();\n            //summary\n            xe = xp.Element(\"summary\");\n            if (xe != null)\n                liPatent.Summary = xe.Value.Trim();\n            //number\n            xe = xp.Element(\"number\");\n            if (xe != null)\n                liPatent.Number = xe.Value.Trim();\n            //status\n            xe = xp.Element(\"status\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"id\");\n                if (xn != null)\n                    liPatent.Status.Type = (LinkedInPatentStatusType)Convert.ToInt32(xn.Value.Trim());\n                xn = xe.Element(\"name\");\n                if (xn != null)\n                    liPatent.Status.Name = xn.Value.Trim();\n            }\n            //office\n            xe = xp.Element(\"office\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"name\");\n                if (xn != null)\n                    liPatent.Office.Name = xn.Value.Trim();\n            }\n            //inventors\n            xe = xp.Element(\"inventors\");\n            if (xe != null)\n                liPatent.AddInventors(xe.Elements(\"inventor\").Select(buildInventor));\n            //date\n            xe = xp.Element(\"date\");\n            if (xe != null)\n                liPatent.Date = BuildDate(xe);\n\n            return liPatent;\n        }\n\n        private static LinkedInInventor buildInventor(XElement xp)\n        {\n            var liInventor = new LinkedInInventor();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liInventor.Id = xe.Value.Trim();\n            //person\n            xe = xp.Element(\"person\");\n            if (xe != null)\n                liInventor.Person = BuildPerson(new LinkedInPerson(), xe);\n\n            return liInventor;\n        }\n\n        private static LinkedInAuthor buildAuthor(XElement xp)\n        {\n            var liAuthor = new LinkedInAuthor();\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liAuthor.Id = xe.Value.Trim();\n            //person\n            xe = xp.Element(\"person\");\n            if (xe != null)\n                liAuthor.Person = BuildPerson(new LinkedInPerson(), xe);\n\n            return liAuthor;\n        }\n\n        private static LinkedInSkill buildSkill(XElement xp)\n        {\n            var liSkill = new LinkedInSkill();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liSkill.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"skill\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"name\");\n                if (xn != null)\n                    liSkill.Name = xn.Value.Trim();\n            }\n\n            return liSkill;\n        }\n\n        private static LinkedInLanguage buildLanguage(XElement xp)\n        {\n            var liLang = new LinkedInLanguage();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liLang.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"language\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"name\");\n                if (xn != null)\n                    liLang.Name = xn.Value.Trim();\n            }\n            //proficiency\n            xe = xp.Element(\"proficiency\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"level\");\n                if (xn != null)\n                    liLang.Proficiency.Level = xn.Value.Trim();\n                xn = xe.Element(\"name\");\n                if (xn != null)\n                    liLang.Proficiency.Name = xn.Value.Trim();\n            }\n\n            return liLang;\n        }\n\n        private static LinkedInEmailProfile buildEmailProfile(XElement xp)\n        {\n            var liEmail = new LinkedInEmailProfile();\n\n            //email-address\n            var xe = xp.Element(\"email-address\");\n            if (xe != null)\n                liEmail.EmailAddress = xe.Value.Trim();\n\n            return liEmail;\n        }\n\n        private static LinkedInBasicProfile buildBasicProfile(XElement xp)\n        {\n            var liBasic = new LinkedInBasicProfile();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liBasic.Id = xe.Value.Trim();\n            //first-name\n            xe = xp.Element(\"first-name\");\n            if (xe != null)\n                liBasic.FirstName = xe.Value.Trim();\n            //last-name\n            xe = xp.Element(\"last-name\");\n            if (xe != null)\n                liBasic.LastName = xe.Value.Trim();\n            //maiden-name\n            xe = xp.Element(\"maiden-name\");\n            if (xe != null)\n                liBasic.MaidenName = xe.Value.Trim();\n            //formatted-name\n            xe = xp.Element(\"formatted-name\");\n            if (xe != null)\n                liBasic.FormattedName = xe.Value.Trim();\n            //phonetic-first-name\n            xe = xp.Element(\"phonetic-first-name\");\n            if (xe != null)\n                liBasic.PhoneticFirstName = xe.Value.Trim();\n            //phonetic-last-name\n            xe = xp.Element(\"phonetic-last-name\");\n            if (xe != null)\n                liBasic.PhoneticLastName = xe.Value.Trim();\n            //formatted-phonetic-name\n            xe = xp.Element(\"formatted-phonetic-name\");\n            if (xe != null)\n                liBasic.FormattedPhoneticName = xe.Value.Trim();\n            //headline\n            xe = xp.Element(\"headline\");\n            if (xe != null)\n                liBasic.Headline = xe.Value.Trim();\n            //location\n            xe = xp.Element(\"location\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"name\");\n                if (xn != null)\n                    liBasic.Location.Name = xn.Value.Trim();\n                xn = xe.Element(\"country\");\n                if (xn != null)\n                {\n                    xn = xn.Element(\"code\");\n                    if (xn != null)\n                        liBasic.Location.CountryCode = xn.Value.Trim();\n                }\n            }\n            //industry\n            xe = xp.Element(\"industry\");\n            if (xe != null)\n                liBasic.Industry = xe.Value.Trim();\n            //distance\n            xe = xp.Element(\"distance\");\n            if (xe != null)\n                liBasic.Distance = Convert.ToInt32(xe.Value.Trim());\n            //relation-to-viewer\n            xe = xp.Element(\"relation-to-viewer\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"relation-to-viewer\");\n                if (xn != null)\n                {\n                    xn = xn.Element(\"distance\");\n                    if (xn != null)\n                        liBasic.RelationToViewer.Distance = Convert.ToInt32(xn.Value.Trim());\n                }\n            }\n            //current-share\n            xe = xp.Element(\"current-share\");\n            if (xe != null)\n            {\n                liBasic.CurrentShare = BuildShare(xe);\n            }\n            //num-connections\n            xe = xp.Element(\"num-connections\");\n            if (xe != null)\n                liBasic.NumConnections = Convert.ToInt32(xe.Value.Trim());\n            //num-connections-capped\n            xe = xp.Element(\"num-connections-capped\");\n            if (xe != null)\n                liBasic.NumConnectionsCapped = Convert.ToBoolean(xe.Value.Trim());\n            //summary\n            xe = xp.Element(\"summary\");\n            if (xe != null)\n                liBasic.Summary = xe.Value.Trim();\n            //specialties\n            xe = xp.Element(\"specialties\");\n            if (xe != null)\n                liBasic.Specialities = xe.Value.Trim();\n            //positions\n            xe = xp.Element(\"positions\");\n            if (xe != null)\n            {\n                liBasic.AddPositions(xe.Elements(\"position\").Select(buildPosition));\n            }\n            //picture-url\n            xe = xp.Element(\"picture-url\");\n            if (xe != null)\n                liBasic.PictureUrl = xe.Value.Trim();\n            //site-standard-profile-request\n            xe = xp.Element(\"site-standard-profile-request\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"url\");\n                if (xn != null)\n                    liBasic.SiteStandardProfileRequest = xn.Value.Trim();\n            }\n            //api-standard-profile-request\n            xe = xp.Element(\"api-standard-profile-request\");\n            if (xe != null)\n            {\n                liBasic.ApiStandardProfileRquest = buildApiStandardProfileRequest(xe);\n            }\n            //public-profile-url\n            xe = xp.Element(\"public-profile-url\");\n            if (xe != null)\n                liBasic.PublicProfileUrl = xe.Value.Trim();\n\n            return liBasic;\n        }\n\n        private static LinkedInPosition buildPosition(XElement xp)\n        {\n            var liPosition = new LinkedInPosition();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liPosition.Id = xe.Value.Trim();\n            //title\n            xe = xp.Element(\"title\");\n            if (xe != null)\n                liPosition.Title = xe.Value.Trim();\n            //summary\n            xe = xp.Element(\"summary\");\n            if (xe != null)\n                liPosition.Summary = xe.Value.Trim();\n            //start-date\n            xe = xp.Element(\"start-date\");\n            if (xe != null)\n                liPosition.StartDate = BuildDate(xe);\n            //end-date\n            xe = xp.Element(\"end-date\");\n            if (xe != null)\n                liPosition.EndDate = BuildDate(xe);\n            //company\n            xe = xp.Element(\"company\");\n            if (xe != null)\n                liPosition.Company = buildCompany(xe);\n            //is-current\n            xe = xp.Element(\"is-current\");\n            if (xe != null)\n                liPosition.IsCurrent = Convert.ToBoolean(xe.Value.Trim());\n\n            return liPosition;\n        }\n\n        private static LinkedInCertification buildCertification(XElement xp)\n        {\n            var liCert = new LinkedInCertification();\n\n            //id\n            var xe = xp.Element(\"id\");\n            if (xe != null)\n                liCert.Id = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liCert.Name = xe.Value.Trim();\n            //authority\n            xe = xp.Element(\"authority\");\n            if (xe != null)\n            {\n                var xn = xe.Element(\"name\");\n                if (xn != null)\n                    liCert.AuthorityName = xn.Value.Trim();\n            }\n            //number\n            xe = xp.Element(\"number\");\n            if (xe != null)\n                liCert.Number = xe.Value.Trim();\n            //start-date\n            xe = xp.Element(\"start-date\");\n            if (xe != null)\n                liCert.StartDate = BuildDate(xe);\n\n            return liCert;\n        }\n\n        private static LinkedInBucket buildBucket(XElement xp)\n        {\n            var liBucket = new LinkedInBucket();\n\n            //code\n            var xe = xp.Element(\"code\");\n            if (xe != null)\n                liBucket.Code = xe.Value.Trim();\n            //name\n            xe = xp.Element(\"name\");\n            if (xe != null)\n                liBucket.Name = xe.Value.Trim();\n            //count\n            xe = xp.Element(\"count\");\n            if (xe != null)\n                liBucket.Count = Convert.ToInt32(xe.Value.Trim());\n            //selected\n            xe = xp.Element(\"selected\");\n            if (xe != null)\n                liBucket.Selected = Convert.ToBoolean(xe.Value.Trim());\n\n            return liBucket;\n        }\n\n        private static LinkedInGroupCategoryCount buildGroupCategoryCount(XElement xp)\n        {\n            var liCount = new LinkedInGroupCategoryCount();\n\n            //category\n            var xe = xp.Element(\"category\");\n            if (xe != null)\n            {\n                var xc = xe.Element(\"code\");\n                if (xc != null)\n                    liCount.Category = xc.Value.Trim();\n            }\n            xe = xp.Element(\"count\");\n            if (xe != null)\n                liCount.Count = Convert.ToInt32(xe.Value.Trim());\n\n            return liCount;\n        }\n\n        private static LinkedInGroupPostAttachment buildPostAttachment(XElement xp)\n        {\n            var liAttach = new LinkedInGroupPostAttachment();\n\n            //content-url\n            var xe = xp.Element(\"content-url\");\n            if (xe != null)\n                liAttach.ContentUrl = xe.Value.Trim();\n            //title\n            xe = xp.Element(\"title\");\n            if (xe != null)\n                liAttach.Title = xe.Value.Trim();\n            //summary\n            xe = xp.Element(\"summary\");\n            if (xe != null)\n                liAttach.Summary = xe.Value.Trim();\n            //image-url\n            xe = xp.Element(\"image-url\");\n            if (xe != null)\n                liAttach.ImageUrl = xe.Value.Trim();\n            //content-domain\n            xe = xp.Element(\"content-domain\");\n            if (xe != null)\n                liAttach.ContentDomain = xe.Value.Trim();\n\n            return liAttach;\n        }\n\n        private static CompanyUpdateType getCompanyUpdateType(XElement xp)\n        {\n            //update-content\n            var xc = xp.Element(\"update-content\");\n            if (xc != null)\n            {\n                if (xc.Elements().Any(xe => xe.Name.ToString() == \"company-profile-update\"))\n                    return CompanyUpdateType.Profile;\n                if (xc.Elements().Any(xe => xe.Name.ToString() == \"company-status-update\"))\n                    return CompanyUpdateType.Status;\n                if (xc.Elements().Any(xe => xe.Name.ToString() == \"company-job-update\"))\n                    return CompanyUpdateType.Job;\n                if (xc.Elements().Any(xe => xe.Name.ToString() == \"company-person-update\"))\n                    return CompanyUpdateType.Person;\n            }\n            return CompanyUpdateType.Invalid;\n        }\n\n        internal static Tuple<LinkedInResponseStatus, string> GetResponseError(WebException wex)\n        {\n            var result = new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.UnparsedWebException, wex.Message);\n            if (wex.Response == null) return result;\n            var stream = wex.Response.GetResponseStream();\n            if (stream == null) return result;\n            using (var reader = new StreamReader(stream))\n            {\n                try\n                {\n                    var xdoc = XDocument.Parse(reader.ReadToEnd());\n                    var xroot = xdoc.Root;\n                    if (xroot == null) return result;\n                    var xStatus = xroot.Element(\"status\");\n                    var xMessage = xroot.Element(\"message\");\n                    if (xStatus == null || xMessage == null) return result;\n                    switch (Convert.ToInt32(xStatus.Value))\n                    {\n                        case 400:\n                            return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.BadRequest,\n                                xMessage.Value);\n                        case 401:\n                            if (xMessage.Value.ToLower().Contains(\"expired\"))\n                                return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.ExpiredToken,\n                                xMessage.Value);\n                            if (xMessage.Value.ToLower().Contains(\"invalid access token\") || xMessage.Value.ToLower().Contains(\"unable to verify access token\"))\n                                return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.InvalidAccessToken,\n                                xMessage.Value);\n                            if (xMessage.Value.ToLower().Contains(\"ssl required\"))\n                                return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.SslRequired,\n                                xMessage.Value);\n                            break;\n                        case 403:\n                            if (xMessage.Value.ToLower().Contains(\"throttle limit for calls to this resource\"))\n                                return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.TrottleLimitReached,\n                                xMessage.Value);\n                            if (xMessage.Value.ToLower().Contains(\"unauthorized change of forum type\") || xMessage.Value.ToLower().Contains(\"anetauthexception: applicationrequired\"))\n                                return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.UnauthorizedAction,\n                                    xMessage.Value);\n                            return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.UnparsedWebException,\n                                xMessage.Value);\n                        case 404:\n                            return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.PageNotFound,\n                                xMessage.Value);\n                        case 500:\n                            return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.InternalServerError,\n                                xMessage.Value);\n                    }\n                    return result;\n                }\n                catch (Exception)\n                {\n                    return new Tuple<LinkedInResponseStatus, string>(LinkedInResponseStatus.UnparsedWebException, reader.ReadToEnd());\n                }\n            }\n        }\n\n        internal static LinkedInResponse<T> GetResponse<T>(T type, WebException wex, object userState)\n        {\n            var err = GetResponseError(wex);\n            return new LinkedInResponse<T>(type, err.Item1, userState, err.Item2);\n        }\n\n        internal static bool IsAnyString(params string[] strings)\n        {\n            return strings.Any(s => !string.IsNullOrEmpty(s));\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    [Export(typeof(TeamspeakViewModel))]\n    public class TeamspeakViewModel : BindableBase\n    {\n        private string messageText;\n        private string serverName;\n        private string serverAddress;\n        private string clientChannelName;\n        private string clientChannelDescription;\n\n        /// <summary>\n        /// List of 'orphan' channels - channels that have been added but who's parent has not been added 'yet'\n        /// </summary>\n        private List<ChannelViewModel> orphanChannels = new List<ChannelViewModel>();\n\n        /// <summary>\n        /// Default logger\n        /// </summary>\n        private static Logger logger = LogManager.GetCurrentClassLogger();\n\n        /// <summary>\n        /// True if the viewmodel is shutting down the connection, else false\n        /// </summary>\n        private bool isShuttingDown;\n\n        /// <summary>\n        /// The teamspeak service\n        /// </summary>\n        public ITeamspeakService TeamspeakService { get; private set; }\n\n        /// <summary>\n        /// The text to send in a message\n        /// </summary>\n        public string MessageText\n        {\n            get { return this.messageText; }\n            set { this.SetProperty(ref this.messageText, value); }\n        }\n\n        /// <summary>\n        /// The currently connected server's name\n        /// </summary>\n        public string ServerName\n        {\n            get { return this.serverName; }\n            set { this.SetProperty(ref this.serverName, value); }\n        }\n\n        /// <summary>\n        /// The address of the currently connected server\n        /// </summary>\n        public string ServerAddress\n        {\n            get { return this.serverAddress; }\n            set { this.SetProperty(ref this.serverAddress, value); }\n        }\n\n        /// <summary>\n        /// The currently connected channel's name\n        /// </summary>\n        public string ClientChannelName\n        {\n            get { return this.clientChannelName; }\n            set { this.SetProperty(ref this.clientChannelName, value); }\n        }\n\n        /// <summary>\n        /// The description of the currently connected channel\n        /// </summary>\n        public string ClientChannelDescription\n        {\n            get { return this.clientChannelDescription; }\n            set { this.SetProperty(ref this.clientChannelDescription, value); }\n        }\n\n        /// <summary>\n        /// User data for the Teamspeak Overlay\n        /// </summary>\n        public TeamspeakUserData UserData { get; private set; }\n\n        /// <summary>\n        /// True if channels have been loaded, else false\n        /// </summary>\n        public bool AreChannelsLoaded\n        {\n            get { return this.Channels.Count > 0; }\n        }\n\n        /// <summary>\n        /// Observable collection of sent/received chat messages\n        /// </summary>\n        public ObservableCollection<ChatMsgViewModel> ChatMessages { get; private set; }\n\n        /// <summary>\n        /// Collection of client notifications (speaking users, messages, users entering, etc)\n        /// </summary>\n        public ObservableCollection<TSNotificationViewModel> Notifications { get; private set; }\n\n        /// <summary>\n        /// Collection of sub channels for this channel\n        /// </summary>\n        public ObservableCollection<ChannelViewModel> Channels { get; private set; }\n\n        /// <summary>\n        /// Collection view of channels\n        /// </summary>\n        public AutoRefreshCollectionViewSource ChannelsSource { get; private set; }\n\n        /// <summary>\n        /// Collection clients in the current channel\n        /// </summary>\n        public ObservableCollection<ClientViewModel> CurrentChannelClients { get; private set; }\n\n        /// <summary>\n        /// Command to reset all hidden objectives\n        /// </summary>\n        public DelegateCommand SendMessageCommand { get { return new DelegateCommand(this.SendMessage); } }\n\n        /// <summary>\n        /// Default constructor\n        /// </summary>\n        [ImportingConstructor]\n        public TeamspeakViewModel(ITeamspeakService teamspeakService, TeamspeakUserData userData)\n        {\n            this.isShuttingDown = false;\n            this.UserData = userData;\n            this.ChatMessages = new ObservableCollection<ChatMsgViewModel>();\n            this.Notifications = new ObservableCollection<TSNotificationViewModel>();\n            this.Channels = new ObservableCollection<ChannelViewModel>();\n            this.CurrentChannelClients = new ObservableCollection<ClientViewModel>();\n\n            var channelsSource = new AutoRefreshCollectionViewSource();\n            channelsSource.Source = this.Channels;\n            this.ChannelsSource = channelsSource;\n            this.ChannelsSource.SortDescriptions.Add(new SortDescription(\"OrderIndex\", ListSortDirection.Ascending));\n\n            this.TeamspeakService = teamspeakService;\n            this.TeamspeakService.NewServerInfo += TeamspeakService_NewServerInfo;\n            this.TeamspeakService.ClientChannelChanged += TeamspeakService_ClientChannelChanged;\n            this.TeamspeakService.ConnectionRefused += TeamspeakService_ConnectionRefused;\n            this.TeamspeakService.TalkStatusChanged += TeamspeakService_TalkStatusChanged;\n            this.TeamspeakService.TextMessageReceived += TeamspeakService_TextMessageReceived;\n            this.TeamspeakService.ClientEnteredChannel += TeamspeakService_ClientEnteredChannel;\n            this.TeamspeakService.ClientExitedChannel += TeamspeakService_ClientExitedChannel;\n            this.TeamspeakService.ChannelAdded += TeamspeakService_ChannelAdded;\n            this.TeamspeakService.ChannelRemoved += TeamspeakService_ChannelRemoved;\n            this.TeamspeakService.ChannelUpdated += TeamspeakService_ChannelUpdated;\n\n            Task.Factory.StartNew((state) =>\n                {\n                    // Start this on another thread so that we don't hold up anything creating us\n                    this.TeamspeakService.Connect();\n                }, null, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.FromCurrentSynchronizationContext() );\n        }\n\n        /// <summary>\n        /// Shutsdown the teamspeak view model, including connection to the Teamspeak Application\n        /// </summary>\n        public void Shutdown()\n        {\n            this.isShuttingDown = true;\n            this.TeamspeakService.Disconnect();\n        }\n\n        /// <summary>\n        /// Sends a message to the teamspeak channel's chat\n        /// Uses the value of the MessageText property\n        /// </summary>\n        private void SendMessage()\n        {\n            logger.Info(\"Attempting to send message: {0}\", MessageText);\n            if (!string.IsNullOrWhiteSpace(MessageText))\n            {\n                this.TeamspeakService.SendChannelMessage(this.MessageText);\n                this.MessageText = string.Empty;\n            }\n        }\n\n        /// <summary>\n        /// Handles the New Server Info event of the Teamspeak Service\n        /// </summary>\n        private void TeamspeakService_NewServerInfo(object sender, TS3.Data.NewServerInfoEventArgs e)\n        {\n            Threading.InvokeOnUI(() =>\n                {\n                    this.ServerName = e.ServerName;\n                    this.ServerAddress = e.ServerAddress;\n                    this.ChatMessages.Clear();\n                    this.Notifications.Clear();\n                });\n        }\n\n        /// <summary>\n        /// Handles the New Channel Info event of the Teamspeak Service\n        /// </summary>\n        private void TeamspeakService_ClientChannelChanged(object sender, TS3.Data.ChannelEventArgs e)\n        {\n            Threading.InvokeOnUI(() =>\n                {\n                    this.ClientChannelName = e.Channel.Name;\n                    this.ClientChannelDescription = e.Channel.Description;\n                });\n        }\n\n        /// <summary>\n        /// Connection was refused, meaning teamspeak is not running\n        /// </summary>\n        private void TeamspeakService_ConnectionRefused(object sender, EventArgs e)\n        {\n            this.TeamspeakService.ConnectionRefused -= TeamspeakService_ConnectionRefused;\n\n            Task.Factory.StartNew(() =>\n                {\n                    var cannotConnectNotification = new TSNotificationViewModel(0, Properties.Resources.StartTeamspeak, TSNotificationType.CannotConnect);\n                    Threading.InvokeOnUI(() => this.Notifications.Add(cannotConnectNotification));\n\n                    // Start a loop attempting to connect once every 5 seconds\n                    int sleepTime = 250; // ms\n                    int retryInterval = 5000 / sleepTime;\n                    int i = 0;\n                    while (!this.isShuttingDown && this.TeamspeakService.ConnectionState != TS3.Data.Enums.ConnectionState.Connected)\n                    {\n                        Thread.Sleep(250);\n                        i++;\n                        if (i > retryInterval)\n                        {\n                            Threading.InvokeOnUI(() => this.TeamspeakService.Connect());\n                            i = 0;\n                        }\n                    }\n\n                    if (!this.isShuttingDown)\n                    {\n                        this.TeamspeakService.ConnectionRefused += TeamspeakService_ConnectionRefused;\n                        Threading.InvokeOnUI(() => this.Notifications.Remove(cannotConnectNotification));\n                    }\n                }, TaskCreationOptions.LongRunning);\n        }\n\n        /// <summary>\n        /// Handles the talk status changed event\n        /// </summary>\n        private void TeamspeakService_TalkStatusChanged(object sender, TS3.Data.TalkStatusEventArgs e)\n        {\n            var speechNotification = new TSNotificationViewModel(e.ClientID, e.ClientName, TSNotificationType.Speech);\n            var existingNotification = this.Notifications.FirstOrDefault(notification => notification.Equals(speechNotification));\n            switch (e.Status)\n            {\n                case TS3.Data.Enums.TalkStatus.TalkStarted:\n                    // Add to our collection of speaking users if it's not already there                  \n                    if (existingNotification == null)\n                        Threading.BeginInvokeOnUI(() => this.Notifications.Add(speechNotification));\n                    break;\n                case TS3.Data.Enums.TalkStatus.TalkStopped:\n                    // Remove from our collection of speaking users\n                    if (existingNotification != null)\n                        Threading.BeginInvokeOnUI(() => this.Notifications.Remove(existingNotification));\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        /// <summary>\n        /// Handles the text message received event\n        /// </summary>\n        private void TeamspeakService_TextMessageReceived(object sender, TS3.Data.TextMessageEventArgs e)\n        {\n            Threading.BeginInvokeOnUI(() =>\n                {\n                    this.ChatMessages.Insert(0, new ChatMsgViewModel(DateTime.Now, e.ClientName, e.Message));\n                });\n        }\n\n        /// <summary>\n        /// Handler for the Client Entered Channel event\n        /// </summary>\n        private void TeamspeakService_ClientEnteredChannel(object sender, TS3.Data.ClientEventArgs e)\n        {\n            if (this.UserData.ShowEnterExitChannelNotifications)\n            {\n                Task.Factory.StartNew(() =>\n                {\n                    var notification = new TSNotificationViewModel(e.ClientID, e.ClientName, TSNotificationType.UserEntered);\n                    Threading.InvokeOnUI(() => this.Notifications.Add(notification));\n                    Thread.Sleep(5000); // Let channel notifications stay for 5 seconds\n                    Threading.InvokeOnUI(() => this.Notifications.Remove(notification));\n                });\n                Threading.InvokeOnUI(() =>\n                    {\n                        this.CurrentChannelClients.Add(new ClientViewModel(e.ClientID, e.ClientName));\n                    });\n            }\n        }\n\n        /// <summary>\n        /// Handler for the Client Exited Channel event\n        /// </summary>\n        private void TeamspeakService_ClientExitedChannel(object sender, TS3.Data.ClientEventArgs e)\n        {\n            if (this.UserData.ShowEnterExitChannelNotifications)\n            {\n                Task.Factory.StartNew(() =>\n                {\n                    var notification = new TSNotificationViewModel(e.ClientID, e.ClientName, TSNotificationType.UserExited);\n                    Threading.InvokeOnUI(() => this.Notifications.Add(notification));\n                    Thread.Sleep(5000); // Let channel notifications stay for 5 seconds\n                    Threading.InvokeOnUI(() => this.Notifications.Remove(notification));\n                });\n                Threading.InvokeOnUI(() =>\n                {\n                    var client = this.CurrentChannelClients.FirstOrDefault(c => c.ID == e.ClientID);\n                    if (client != null)\n                        this.CurrentChannelClients.Remove(client);\n                });\n            }\n        }\n\n        /// <summary>\n        /// Handler for the Channel Added event\n        /// </summary>\n        private void TeamspeakService_ChannelAdded(object sender, TS3.Data.ChannelEventArgs e)\n        {\n            Threading.BeginInvokeOnUI(() =>\n                {\n                    if (e.Channel.IsSpacer)\n                        return; // Totally ignore spacers\n\n                    var newChannel = new ChannelViewModel(e.Channel, this.TeamspeakService);\n\n                    // Check if we have any orphans that are a subchannel of this new channel\n                    var matchingOrphans = this.orphanChannels.Where(c => c.ParentID == newChannel.ID);\n                    foreach (var orphan in matchingOrphans)\n                    {\n                        newChannel.Subchannels.Add(orphan);\n                    }\n                    this.orphanChannels.RemoveAll(c => c.ParentID == newChannel.ID);\n\n                    if (newChannel.ParentID != 0)\n                    {\n                        // This has a parent channel - find it\n                        var parentChannel = this.FindParentChannel(this.Channels, newChannel);\n\n                        if (parentChannel != null)\n                        {\n                            parentChannel.Subchannels.Add(newChannel);\n                        }\n                        else\n                        {\n                            // This is an orphan channel... add it to our orphan list for now\n                            this.orphanChannels.Add(newChannel);\n                        }\n                    }\n                    else\n                    {\n                        // No parent\n                        this.Channels.Insert(0, newChannel);\n                    }\n\n                    this.OnPropertyChanged(() => this.AreChannelsLoaded);\n                });\n        }\n\n        /// <summary>\n        /// Handler for the Channel Removed event\n        /// </summary>\n        private void TeamspeakService_ChannelRemoved(object sender, TS3.Data.ChannelEventArgs e)\n        {\n            Threading.BeginInvokeOnUI(() =>\n                {\n                    var removedChannel = new ChannelViewModel(e.Channel, this.TeamspeakService);\n\n                    if (removedChannel.ParentID != 0)\n                    {\n                        // This has a parent channel - find it\n                        var parentChannel = this.FindParentChannel(this.Channels, removedChannel);\n\n                        if (parentChannel != null)\n                        {\n                            var toRemove = parentChannel.Subchannels.FirstOrDefault(channel => channel.ID == removedChannel.ID);\n                            parentChannel.Subchannels.Remove(toRemove);\n                        }\n                    }\n                    else\n                    {\n                        // No parent\n                        var toRemove = this.Channels.FirstOrDefault(channel => channel.ID == removedChannel.ID);\n                        this.Channels.Remove(toRemove);\n                    }\n\n                    this.OnPropertyChanged(() => this.AreChannelsLoaded);\n                });\n        }\n\n        /// <summary>\n        /// Handler for the Channel Updated event\n        /// </summary>\n        private void TeamspeakService_ChannelUpdated(object sender, TS3.Data.ChannelEventArgs e)\n        {\n            Threading.BeginInvokeOnUI(() =>\n                {\n                    // Find the matching existing channel\n                    ChannelViewModel existingChannel = this.FindChannel(this.Channels, e.Channel.ID);\n\n                    if (existingChannel == null)\n                    {\n                        // This shouldn't happen, but if it does, don't crash, just treat it as a \"channel added\"\n                        this.TeamspeakService_ChannelAdded(sender, e);\n                        return;\n                    }\n\n                    existingChannel.Name = e.Channel.Name;\n                    existingChannel.OrderIndex = e.Channel.Order;\n                    existingChannel.ClientsCount = e.Channel.ClientsCount;\n\n                    // Check to see if the parent ID has changed. If so, update it and move the channel\n                    if (existingChannel.ParentID != e.Channel.ParentID)\n                    {\n                        // Find the existing parent\n                        ChannelViewModel existingParent = this.FindParentChannel(this.Channels, existingChannel);\n\n                        if (existingParent != null)\n                        {\n                            // Remove it from the parent\n                            existingParent.Subchannels.Remove(existingChannel);\n                        }\n\n                        // Update the parent ID\n                        existingChannel.ParentID = e.Channel.ParentID;\n\n                        // Find the new parent\n                        ChannelViewModel newParent = this.FindParentChannel(this.Channels, existingChannel);\n\n                        if (newParent != null)\n                        {\n                            // Add it to the parent\n                            newParent.Subchannels.Add(existingChannel);\n                        }\n                        else\n                        {\n                            // Orphan...\n                            this.orphanChannels.Add(existingChannel);\n                        }\n                    }\n\n                    this.OnPropertyChanged(() => this.AreChannelsLoaded);\n                });\n        }\n\n        /// <summary>\n        /// Recursively searches through a collection of channels to find a subChannel's parent ChannelViewModel object\n        /// </summary>\n        /// <param name=\"channelCollection\">The collection to search</param>\n        /// <param name=\"subChannel\">The subChannel of which to the find the parent of</param>\n        /// <returns>The parent of the subchannel, or null if not found</returns>\n        private ChannelViewModel FindParentChannel(ICollection<ChannelViewModel> channelCollection, ChannelViewModel subChannel)\n        {\n            foreach (var channel in channelCollection)\n            {\n                if (channel.ID == subChannel.ParentID)\n                {\n                    return channel;\n                }\n                else\n                {\n                    // Recurse within the subchannels of this channel\n                    var parent = this.FindParentChannel(channel.Subchannels, subChannel);\n                    if (parent != null)\n                    {\n                        return parent;\n                    }\n                }\n            }\n\n            // Didn't find parent\n            return null;\n        }\n\n        /// <summary>\n        /// Recursively searches through a collection of channels to find a specific ChannelViewModel object\n        /// </summary>\n        /// <param name=\"channelCollection\">The collection to search</param>\n        /// <param name=\"subChannel\">The subChannel of which to the find the parent of</param>\n        /// <returns>The parent of the subchannel, or null if not found</returns>\n        private ChannelViewModel FindChannel(ICollection<ChannelViewModel> channelCollection, uint channelId)\n        {\n            foreach (var channel in channelCollection)\n            {\n                if (channel.ID == channelId)\n                {\n                    return channel;\n                }\n                else\n                {\n                    // Recurse within the subchannels of this channel\n                    var foundChannel = this.FindChannel(channel.Subchannels, channelId);\n                    if (foundChannel != null)\n                    {\n                        return foundChannel;\n                    }\n                }\n            }\n\n            // Didn't find channel\n            return null;\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n    /// <summary>\n    /// Contract details for a <see cref=\"Type\"/> used by the <see cref=\"JsonSerializer\"/>.\n    /// </summary>\n    public abstract class JsonContract\n    {\n        internal bool IsNullable;\n        internal bool IsConvertable;\n        internal bool IsEnum;\n        internal Type NonNullableUnderlyingType;\n        internal ReadType InternalReadType;\n        internal JsonContractType ContractType;\n        internal bool IsReadOnlyOrFixedSize;\n        internal bool IsSealed;\n        internal bool IsInstantiable;\n\n        private List<SerializationCallback> _onDeserializedCallbacks;\n        private IList<SerializationCallback> _onDeserializingCallbacks;\n        private IList<SerializationCallback> _onSerializedCallbacks;\n        private IList<SerializationCallback> _onSerializingCallbacks;\n        private IList<SerializationErrorCallback> _onErrorCallbacks;\n        private Type _createdType;\n\n        /// <summary>\n        /// Gets the underlying type for the contract.\n        /// </summary>\n        /// <value>The underlying type for the contract.</value>\n        public Type UnderlyingType { get; private set; }\n\n        /// <summary>\n        /// Gets or sets the type created during deserialization.\n        /// </summary>\n        /// <value>The type created during deserialization.</value>\n        public Type CreatedType\n        {\n            get { return _createdType; }\n            set\n            {\n                _createdType = value;\n\n                IsSealed = _createdType.IsSealed();\n                IsInstantiable = !(_createdType.IsInterface() || _createdType.IsAbstract());\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets whether this type contract is serialized as a reference.\n        /// </summary>\n        /// <value>Whether this type contract is serialized as a reference.</value>\n        public bool? IsReference { get; set; }\n\n        /// <summary>\n        /// Gets or sets the default <see cref=\"JsonConverter\" /> for this contract.\n        /// </summary>\n        /// <value>The converter.</value>\n        public JsonConverter Converter { get; set; }\n\n        // internally specified JsonConverter's to override default behavour\n        // checked for after passed in converters and attribute specified converters\n        internal JsonConverter InternalConverter { get; set; }\n\n        /// <summary>\n        /// Gets or sets all methods called immediately after deserialization of the object.\n        /// </summary>\n        /// <value>The methods called immediately after deserialization of the object.</value>\n        public IList<SerializationCallback> OnDeserializedCallbacks\n        {\n            get\n            {\n                if (_onDeserializedCallbacks == null)\n                    _onDeserializedCallbacks = new List<SerializationCallback>();\n\n                return _onDeserializedCallbacks;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets all methods called during deserialization of the object.\n        /// </summary>\n        /// <value>The methods called during deserialization of the object.</value>\n        public IList<SerializationCallback> OnDeserializingCallbacks\n        {\n            get\n            {\n                if (_onDeserializingCallbacks == null)\n                    _onDeserializingCallbacks = new List<SerializationCallback>();\n\n                return _onDeserializingCallbacks;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets all methods called after serialization of the object graph.\n        /// </summary>\n        /// <value>The methods called after serialization of the object graph.</value>\n        public IList<SerializationCallback> OnSerializedCallbacks\n        {\n            get\n            {\n                if (_onSerializedCallbacks == null)\n                    _onSerializedCallbacks = new List<SerializationCallback>();\n\n                return _onSerializedCallbacks;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets all methods called before serialization of the object.\n        /// </summary>\n        /// <value>The methods called before serialization of the object.</value>\n        public IList<SerializationCallback> OnSerializingCallbacks\n        {\n            get\n            {\n                if (_onSerializingCallbacks == null)\n                    _onSerializingCallbacks = new List<SerializationCallback>();\n\n                return _onSerializingCallbacks;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets all method called when an error is thrown during the serialization of the object.\n        /// </summary>\n        /// <value>The methods called when an error is thrown during the serialization of the object.</value>\n        public IList<SerializationErrorCallback> OnErrorCallbacks\n        {\n            get\n            {\n                if (_onErrorCallbacks == null)\n                    _onErrorCallbacks = new List<SerializationErrorCallback>();\n\n                return _onErrorCallbacks;\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the method called immediately after deserialization of the object.\n        /// </summary>\n        /// <value>The method called immediately after deserialization of the object.</value>\n        [Obsolete(\"This property is obsolete and has been replaced by the OnDeserializedCallbacks collection.\")]\n        public MethodInfo OnDeserialized\n        {\n            get { return (OnDeserializedCallbacks.Count > 0) ? OnDeserializedCallbacks[0].Method() : null; }\n            set\n            {\n                OnDeserializedCallbacks.Clear();\n                OnDeserializedCallbacks.Add(CreateSerializationCallback(value));\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the method called during deserialization of the object.\n        /// </summary>\n        /// <value>The method called during deserialization of the object.</value>\n        [Obsolete(\"This property is obsolete and has been replaced by the OnDeserializingCallbacks collection.\")]\n        public MethodInfo OnDeserializing\n        {\n            get { return (OnDeserializingCallbacks.Count > 0) ? OnDeserializingCallbacks[0].Method() : null; }\n            set\n            {\n                OnDeserializingCallbacks.Clear();\n                OnDeserializingCallbacks.Add(CreateSerializationCallback(value));\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the method called after serialization of the object graph.\n        /// </summary>\n        /// <value>The method called after serialization of the object graph.</value>\n        [Obsolete(\"This property is obsolete and has been replaced by the OnSerializedCallbacks collection.\")]\n        public MethodInfo OnSerialized\n        {\n            get { return (OnSerializedCallbacks.Count > 0) ? OnSerializedCallbacks[0].Method() : null; }\n            set\n            {\n                OnSerializedCallbacks.Clear();\n                OnSerializedCallbacks.Add(CreateSerializationCallback(value));\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the method called before serialization of the object.\n        /// </summary>\n        /// <value>The method called before serialization of the object.</value>\n        [Obsolete(\"This property is obsolete and has been replaced by the OnSerializingCallbacks collection.\")]\n        public MethodInfo OnSerializing\n        {\n            get { return (OnSerializingCallbacks.Count > 0) ? OnSerializingCallbacks[0].Method() : null; }\n            set\n            {\n                OnSerializingCallbacks.Clear();\n                OnSerializingCallbacks.Add(CreateSerializationCallback(value));\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the method called when an error is thrown during the serialization of the object.\n        /// </summary>\n        /// <value>The method called when an error is thrown during the serialization of the object.</value>\n        [Obsolete(\"This property is obsolete and has been replaced by the OnErrorCallbacks collection.\")]\n        public MethodInfo OnError\n        {\n            get { return (OnErrorCallbacks.Count > 0) ? OnErrorCallbacks[0].Method() : null; }\n            set\n            {\n                OnErrorCallbacks.Clear();\n                OnErrorCallbacks.Add(CreateSerializationErrorCallback(value));\n            }\n        }\n\n        /// <summary>\n        /// Gets or sets the default creator method used to create the object.\n        /// </summary>\n        /// <value>The default creator method used to create the object.</value>\n        public Func<object> DefaultCreator { get; set; }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether the default creator is non public.\n        /// </summary>\n        /// <value><c>true</c> if the default object creator is non-public; otherwise, <c>false</c>.</value>\n        public bool DefaultCreatorNonPublic { get; set; }\n\n        internal JsonContract(Type underlyingType)\n        {\n            ValidationUtils.ArgumentNotNull(underlyingType, \"underlyingType\");\n\n            UnderlyingType = underlyingType;\n\n            IsNullable = ReflectionUtils.IsNullable(underlyingType);\n            NonNullableUnderlyingType = (IsNullable && ReflectionUtils.IsNullableType(underlyingType)) ? Nullable.GetUnderlyingType(underlyingType) : underlyingType;\n\n            CreatedType = NonNullableUnderlyingType;\n\n            IsConvertable = ConvertUtils.IsConvertible(NonNullableUnderlyingType);\n            IsEnum = NonNullableUnderlyingType.IsEnum();\n\n            if (NonNullableUnderlyingType == typeof(byte[]))\n            {\n                InternalReadType = ReadType.ReadAsBytes;\n            }\n            else if (NonNullableUnderlyingType == typeof(int))\n            {\n                InternalReadType = ReadType.ReadAsInt32;\n            }\n            else if (NonNullableUnderlyingType == typeof(decimal))\n            {\n                InternalReadType = ReadType.ReadAsDecimal;\n            }\n            else if (NonNullableUnderlyingType == typeof(string))\n            {\n                InternalReadType = ReadType.ReadAsString;\n            }\n            else if (NonNullableUnderlyingType == typeof(DateTime))\n            {\n                InternalReadType = ReadType.ReadAsDateTime;\n            }\n#if !NET20\n            else if (NonNullableUnderlyingType == typeof(DateTimeOffset))\n            {\n                InternalReadType = ReadType.ReadAsDateTimeOffset;\n            }\n#endif\n            else\n            {\n                InternalReadType = ReadType.Read;\n            }\n        }\n\n        internal void InvokeOnSerializing(object o, StreamingContext context)\n        {\n            if (_onSerializingCallbacks != null)\n            {\n                foreach (SerializationCallback callback in _onSerializingCallbacks)\n                {\n                    callback(o, context);\n                }\n            }\n        }\n\n        internal void InvokeOnSerialized(object o, StreamingContext context)\n        {\n            if (_onSerializedCallbacks != null)\n            {\n                foreach (SerializationCallback callback in _onSerializedCallbacks)\n                {\n                    callback(o, context);\n                }\n            }\n        }\n\n        internal void InvokeOnDeserializing(object o, StreamingContext context)\n        {\n            if (_onDeserializingCallbacks != null)\n            {\n                foreach (SerializationCallback callback in _onDeserializingCallbacks)\n                {\n                    callback(o, context);\n                }\n            }\n        }\n\n        internal void InvokeOnDeserialized(object o, StreamingContext context)\n        {\n            if (_onDeserializedCallbacks != null)\n            {\n                foreach (SerializationCallback callback in _onDeserializedCallbacks)\n                {\n                    callback(o, context);\n                }\n            }\n        }\n\n        internal void InvokeOnError(object o, StreamingContext context, ErrorContext errorContext)\n        {\n            if (_onErrorCallbacks != null)\n            {\n                foreach (SerializationErrorCallback callback in _onErrorCallbacks)\n                {\n                    callback(o, context, errorContext);\n                }\n            }\n        }\n\n        internal static SerializationCallback CreateSerializationCallback(MethodInfo callbackMethodInfo)\n        {\n            return (o, context) => callbackMethodInfo.Invoke(o, new object[] { context });\n        }\n\n        internal static SerializationErrorCallback CreateSerializationErrorCallback(MethodInfo callbackMethodInfo)\n        {\n            return (o, context, econtext) => callbackMethodInfo.Invoke(o, new object[] { context, econtext });\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\t/// <summary>Class which represents the entity 'PurchaseOrderHeader', mapped on table 'AdventureWorks.Purchasing.PurchaseOrderHeader'.</summary>\n\t[Table(Name=\"[Purchasing].[PurchaseOrderHeader]\")]\n\tpublic partial class PurchaseOrderHeader : INotifyPropertyChanging, INotifyPropertyChanged\n\t{\n\t\t#region Events\n\t\t/// <summary>Event which is raised when a property value is changing.</summary>\n\t\tpublic event PropertyChangingEventHandler PropertyChanging;\n\t\t/// <summary>Event which is raised when a property value changes.</summary>\n\t\tpublic event PropertyChangedEventHandler PropertyChanged;\n\t\t#endregion\n\t\t\n\t\t#region Class Member Declarations\n\t\tprivate System.Int32\t_employeeId;\n\t\tprivate System.Decimal\t_freight;\n\t\tprivate System.DateTime\t_modifiedDate;\n\t\tprivate System.DateTime\t_orderDate;\n\t\tprivate System.Int32\t_purchaseOrderId;\n\t\tprivate System.Byte\t_revisionNumber;\n\t\tprivate Nullable<System.DateTime>\t_shipDate;\n\t\tprivate System.Int32\t_shipMethodId;\n\t\tprivate System.Byte\t_status;\n\t\tprivate System.Decimal\t_subTotal;\n\t\tprivate System.Decimal\t_taxAmt;\n\t\tprivate System.Decimal\t_totalDue;\n\t\tprivate System.Int32\t_vendorId;\n\t\tprivate EntityRef <Employee> _employee;\n\t\tprivate EntitySet <PurchaseOrderDetail> _purchaseOrderDetails;\n\t\tprivate EntityRef <ShipMethod> _shipMethod;\n\t\tprivate EntityRef <Vendor> _vendor;\n\t\t#endregion\n\t\t\n\t\t#region Extensibility Method Definitions\n\t\tpartial void OnLoaded();\n\t\tpartial void OnValidate(System.Data.Linq.ChangeAction action);\n\t\tpartial void OnCreated();\n\t\tpartial void OnEmployeeIdChanging(System.Int32 value);\n\t\tpartial void OnEmployeeIdChanged();\n\t\tpartial void OnFreightChanging(System.Decimal value);\n\t\tpartial void OnFreightChanged();\n\t\tpartial void OnModifiedDateChanging(System.DateTime value);\n\t\tpartial void OnModifiedDateChanged();\n\t\tpartial void OnOrderDateChanging(System.DateTime value);\n\t\tpartial void OnOrderDateChanged();\n\t\tpartial void OnPurchaseOrderIdChanging(System.Int32 value);\n\t\tpartial void OnPurchaseOrderIdChanged();\n\t\tpartial void OnRevisionNumberChanging(System.Byte value);\n\t\tpartial void OnRevisionNumberChanged();\n\t\tpartial void OnShipDateChanging(Nullable<System.DateTime> value);\n\t\tpartial void OnShipDateChanged();\n\t\tpartial void OnShipMethodIdChanging(System.Int32 value);\n\t\tpartial void OnShipMethodIdChanged();\n\t\tpartial void OnStatusChanging(System.Byte value);\n\t\tpartial void OnStatusChanged();\n\t\tpartial void OnSubTotalChanging(System.Decimal value);\n\t\tpartial void OnSubTotalChanged();\n\t\tpartial void OnTaxAmtChanging(System.Decimal value);\n\t\tpartial void OnTaxAmtChanged();\n\t\tpartial void OnTotalDueChanging(System.Decimal value);\n\t\tpartial void OnTotalDueChanged();\n\t\tpartial void OnVendorIdChanging(System.Int32 value);\n\t\tpartial void OnVendorIdChanged();\n\t\t#endregion\n\t\t\n\t\t/// <summary>Initializes a new instance of the <see cref=\"PurchaseOrderHeader\"/> class.</summary>\n\t\tpublic PurchaseOrderHeader()\n\t\t{\n\t\t\t_employee = default(EntityRef<Employee>);\n\t\t\t_purchaseOrderDetails = new EntitySet<PurchaseOrderDetail>(new Action<PurchaseOrderDetail>(this.Attach_PurchaseOrderDetails), new Action<PurchaseOrderDetail>(this.Detach_PurchaseOrderDetails) );\n\t\t\t_shipMethod = default(EntityRef<ShipMethod>);\n\t\t\t_vendor = default(EntityRef<Vendor>);\n\t\t\tOnCreated();\n\t\t}\n\n\t\t/// <summary>Raises the PropertyChanging event</summary>\n\t\t/// <param name=\"propertyName\">name of the property which is changing</param>\n\t\tprotected virtual void SendPropertyChanging(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanging != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanging(this, new PropertyChangingEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Raises the PropertyChanged event for the property specified</summary>\n\t\t/// <param name=\"propertyName\">name of the property which was changed</param>\n\t\tprotected virtual void SendPropertyChanged(string propertyName)\n\t\t{\n\t\t\tif((this.PropertyChanged != null))\n\t\t\t{\n\t\t\t\tthis.PropertyChanged(this, new PropertyChangedEventArgs(propertyName));\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Attaches this instance to the entity specified as an associated entity</summary>\n\t\t/// <param name=\"entity\">The related entity to attach to</param>\n\t\tprivate void Attach_PurchaseOrderDetails(PurchaseOrderDetail entity)\n\t\t{\n\t\t\tthis.SendPropertyChanging(\"PurchaseOrderDetails\");\n\t\t\tentity.PurchaseOrderHeader = this;\n\t\t}\n\t\t\n\t\t/// <summary>Detaches this instance from the entity specified so it's no longer an associated entity</summary>\n\t\t/// <param name=\"entity\">The related entity to detach from</param>\n\t\tprivate void Detach_PurchaseOrderDetails(PurchaseOrderDetail entity)\n\t\t{\n\t\t\tthis.SendPropertyChanging(\"PurchaseOrderDetails\");\n\t\t\tentity.PurchaseOrderHeader = null;\n\t\t}\n\n\n\t\t#region Class Property Declarations\n\t\t/// <summary>Gets or sets the EmployeeId field. Mapped on target field 'EmployeeID'. </summary>\n\t\t[Column(Name=\"EmployeeID\", Storage=\"_employeeId\", CanBeNull=false, DbType=\"int NOT NULL\")]\n\t\tpublic System.Int32 EmployeeId\n\t\t{\n\t\t\tget\t{ return _employeeId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_employeeId != value))\n\t\t\t\t{\n\t\t\t\t\tif(_employee.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnEmployeeIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"EmployeeId\");\n\t\t\t\t\t_employeeId = value;\n\t\t\t\t\tSendPropertyChanged(\"EmployeeId\");\n\t\t\t\t\tOnEmployeeIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Freight field. Mapped on target field 'Freight'. </summary>\n\t\t[Column(Name=\"Freight\", Storage=\"_freight\", CanBeNull=false, DbType=\"money NOT NULL\")]\n\t\tpublic System.Decimal Freight\n\t\t{\n\t\t\tget\t{ return _freight; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_freight != value))\n\t\t\t\t{\n\t\t\t\t\tOnFreightChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Freight\");\n\t\t\t\t\t_freight = value;\n\t\t\t\t\tSendPropertyChanged(\"Freight\");\n\t\t\t\t\tOnFreightChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the ModifiedDate field. Mapped on target field 'ModifiedDate'. </summary>\n\t\t[Column(Name=\"ModifiedDate\", Storage=\"_modifiedDate\", CanBeNull=false, DbType=\"datetime NOT NULL\")]\n\t\tpublic System.DateTime ModifiedDate\n\t\t{\n\t\t\tget\t{ return _modifiedDate; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_modifiedDate != value))\n\t\t\t\t{\n\t\t\t\t\tOnModifiedDateChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ModifiedDate\");\n\t\t\t\t\t_modifiedDate = value;\n\t\t\t\t\tSendPropertyChanged(\"ModifiedDate\");\n\t\t\t\t\tOnModifiedDateChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the OrderDate field. Mapped on target field 'OrderDate'. </summary>\n\t\t[Column(Name=\"OrderDate\", Storage=\"_orderDate\", CanBeNull=false, DbType=\"datetime NOT NULL\")]\n\t\tpublic System.DateTime OrderDate\n\t\t{\n\t\t\tget\t{ return _orderDate; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_orderDate != value))\n\t\t\t\t{\n\t\t\t\t\tOnOrderDateChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"OrderDate\");\n\t\t\t\t\t_orderDate = value;\n\t\t\t\t\tSendPropertyChanged(\"OrderDate\");\n\t\t\t\t\tOnOrderDateChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the PurchaseOrderId field. Mapped on target field 'PurchaseOrderID'. </summary>\n\t\t[Column(Name=\"PurchaseOrderID\", Storage=\"_purchaseOrderId\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"int NOT NULL IDENTITY\", IsPrimaryKey=true, IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.Int32 PurchaseOrderId\n\t\t{\n\t\t\tget\t{ return _purchaseOrderId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_purchaseOrderId != value))\n\t\t\t\t{\n\t\t\t\t\tOnPurchaseOrderIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"PurchaseOrderId\");\n\t\t\t\t\t_purchaseOrderId = value;\n\t\t\t\t\tSendPropertyChanged(\"PurchaseOrderId\");\n\t\t\t\t\tOnPurchaseOrderIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the RevisionNumber field. Mapped on target field 'RevisionNumber'. </summary>\n\t\t[Column(Name=\"RevisionNumber\", Storage=\"_revisionNumber\", CanBeNull=false, DbType=\"tinyint NOT NULL\")]\n\t\tpublic System.Byte RevisionNumber\n\t\t{\n\t\t\tget\t{ return _revisionNumber; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_revisionNumber != value))\n\t\t\t\t{\n\t\t\t\t\tOnRevisionNumberChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"RevisionNumber\");\n\t\t\t\t\t_revisionNumber = value;\n\t\t\t\t\tSendPropertyChanged(\"RevisionNumber\");\n\t\t\t\t\tOnRevisionNumberChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the ShipDate field. Mapped on target field 'ShipDate'. </summary>\n\t\t[Column(Name=\"ShipDate\", Storage=\"_shipDate\", DbType=\"datetime NULL\")]\n\t\tpublic Nullable<System.DateTime> ShipDate\n\t\t{\n\t\t\tget\t{ return _shipDate; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_shipDate != value))\n\t\t\t\t{\n\t\t\t\t\tOnShipDateChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ShipDate\");\n\t\t\t\t\t_shipDate = value;\n\t\t\t\t\tSendPropertyChanged(\"ShipDate\");\n\t\t\t\t\tOnShipDateChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the ShipMethodId field. Mapped on target field 'ShipMethodID'. </summary>\n\t\t[Column(Name=\"ShipMethodID\", Storage=\"_shipMethodId\", CanBeNull=false, DbType=\"int NOT NULL\")]\n\t\tpublic System.Int32 ShipMethodId\n\t\t{\n\t\t\tget\t{ return _shipMethodId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_shipMethodId != value))\n\t\t\t\t{\n\t\t\t\t\tif(_shipMethod.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnShipMethodIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"ShipMethodId\");\n\t\t\t\t\t_shipMethodId = value;\n\t\t\t\t\tSendPropertyChanged(\"ShipMethodId\");\n\t\t\t\t\tOnShipMethodIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the Status field. Mapped on target field 'Status'. </summary>\n\t\t[Column(Name=\"Status\", Storage=\"_status\", CanBeNull=false, DbType=\"tinyint NOT NULL\")]\n\t\tpublic System.Byte Status\n\t\t{\n\t\t\tget\t{ return _status; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_status != value))\n\t\t\t\t{\n\t\t\t\t\tOnStatusChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"Status\");\n\t\t\t\t\t_status = value;\n\t\t\t\t\tSendPropertyChanged(\"Status\");\n\t\t\t\t\tOnStatusChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the SubTotal field. Mapped on target field 'SubTotal'. </summary>\n\t\t[Column(Name=\"SubTotal\", Storage=\"_subTotal\", CanBeNull=false, DbType=\"money NOT NULL\")]\n\t\tpublic System.Decimal SubTotal\n\t\t{\n\t\t\tget\t{ return _subTotal; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_subTotal != value))\n\t\t\t\t{\n\t\t\t\t\tOnSubTotalChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"SubTotal\");\n\t\t\t\t\t_subTotal = value;\n\t\t\t\t\tSendPropertyChanged(\"SubTotal\");\n\t\t\t\t\tOnSubTotalChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the TaxAmt field. Mapped on target field 'TaxAmt'. </summary>\n\t\t[Column(Name=\"TaxAmt\", Storage=\"_taxAmt\", CanBeNull=false, DbType=\"money NOT NULL\")]\n\t\tpublic System.Decimal TaxAmt\n\t\t{\n\t\t\tget\t{ return _taxAmt; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_taxAmt != value))\n\t\t\t\t{\n\t\t\t\t\tOnTaxAmtChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"TaxAmt\");\n\t\t\t\t\t_taxAmt = value;\n\t\t\t\t\tSendPropertyChanged(\"TaxAmt\");\n\t\t\t\t\tOnTaxAmtChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Gets or sets the TotalDue field. Mapped on target field 'TotalDue'. </summary>\n\t\t[Column(Name=\"TotalDue\", Storage=\"_totalDue\", AutoSync=AutoSync.OnInsert, CanBeNull=false, DbType=\"money NOT NULL\", IsDbGenerated=true, UpdateCheck=UpdateCheck.Never)]\n\t\tpublic System.Decimal TotalDue\n\t\t{\n\t\t\tget\t{ return _totalDue; }\n\t\t}\n\n\t\t/// <summary>Gets or sets the VendorId field. Mapped on target field 'VendorID'. </summary>\n\t\t[Column(Name=\"VendorID\", Storage=\"_vendorId\", CanBeNull=false, DbType=\"int NOT NULL\")]\n\t\tpublic System.Int32 VendorId\n\t\t{\n\t\t\tget\t{ return _vendorId; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tif((_vendorId != value))\n\t\t\t\t{\n\t\t\t\t\tif(_vendor.HasLoadedOrAssignedValue)\n\t\t\t\t\t{\n\t\t\t\t\t\tthrow new System.Data.Linq.ForeignKeyReferenceAlreadyHasValueException();\n\t\t\t\t\t}\n\t\t\t\t\tOnVendorIdChanging(value);\n\t\t\t\t\tSendPropertyChanging(\"VendorId\");\n\t\t\t\t\t_vendorId = value;\n\t\t\t\t\tSendPropertyChanged(\"VendorId\");\n\t\t\t\t\tOnVendorIdChanged();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'PurchaseOrderHeader.Employee - Employee.PurchaseOrderHeaders (m:1)'</summary>\n\t\t[Association(Name=\"PurchaseOrderHeader_Employeec4979523b2b34bb4a3c1e0c347d9b665\", Storage=\"_employee\", ThisKey=\"EmployeeId\", IsForeignKey=true)] \n\t\tpublic Employee Employee\n\t\t{\n\t\t\tget { return _employee.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tEmployee previousValue = _employee.Entity;\n\t\t\t\tif((previousValue != value) || (_employee.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"Employee\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_employee.Entity = null;\n\t\t\t\t\t\tpreviousValue.PurchaseOrderHeaders.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_employee.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_employeeId = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.PurchaseOrderHeaders.Add(this);\n\t\t\t\t\t\t_employeeId = value.BusinessEntityId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"Employee\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'PurchaseOrderDetail.PurchaseOrderHeader - PurchaseOrderHeader.PurchaseOrderDetails (m:1)'</summary>\n\t\t[Association(Name=\"PurchaseOrderDetail_PurchaseOrderHeader16afa68c7f36487c81bf5a4e7de500df\", Storage=\"_purchaseOrderDetails\", OtherKey=\"PurchaseOrderId\")]\n\t\tpublic EntitySet<PurchaseOrderDetail> PurchaseOrderDetails\n\t\t{\n\t\t\tget { return this._purchaseOrderDetails; }\n\t\t\tset { this._purchaseOrderDetails.Assign(value); }\n\t\t}\n\t\t\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'PurchaseOrderHeader.ShipMethod - ShipMethod.PurchaseOrderHeaders (m:1)'</summary>\n\t\t[Association(Name=\"PurchaseOrderHeader_ShipMethodb9e0447b9efd4e07b6e8902dabe7ca65\", Storage=\"_shipMethod\", ThisKey=\"ShipMethodId\", IsForeignKey=true)] \n\t\tpublic ShipMethod ShipMethod\n\t\t{\n\t\t\tget { return _shipMethod.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tShipMethod previousValue = _shipMethod.Entity;\n\t\t\t\tif((previousValue != value) || (_shipMethod.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"ShipMethod\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_shipMethod.Entity = null;\n\t\t\t\t\t\tpreviousValue.PurchaseOrderHeaders.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_shipMethod.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_shipMethodId = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.PurchaseOrderHeaders.Add(this);\n\t\t\t\t\t\t_shipMethodId = value.ShipMethodId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"ShipMethod\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/// <summary>Represents the navigator which is mapped onto the association 'PurchaseOrderHeader.Vendor - Vendor.PurchaseOrderHeaders (m:1)'</summary>\n\t\t[Association(Name=\"PurchaseOrderHeader_Vendor0c14df47893649fa9f436089a770b879\", Storage=\"_vendor\", ThisKey=\"VendorId\", IsForeignKey=true)] \n\t\tpublic Vendor Vendor\n\t\t{\n\t\t\tget { return _vendor.Entity; }\n\t\t\tset\n\t\t\t{\n\t\t\t\tVendor previousValue = _vendor.Entity;\n\t\t\t\tif((previousValue != value) || (_vendor.HasLoadedOrAssignedValue == false))\n\t\t\t\t{\n\t\t\t\t\tthis.SendPropertyChanging(\"Vendor\");\n\t\t\t\t\tif(previousValue != null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_vendor.Entity = null;\n\t\t\t\t\t\tpreviousValue.PurchaseOrderHeaders.Remove(this);\n\t\t\t\t\t}\n\t\t\t\t\t_vendor.Entity = value;\n\t\t\t\t\tif(value == null)\n\t\t\t\t\t{\n\t\t\t\t\t\t_vendorId = default(System.Int32);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvalue.PurchaseOrderHeaders.Add(this);\n\t\t\t\t\t\t_vendorId = value.BusinessEntityId;\n\t\t\t\t\t}\n\t\t\t\t\tthis.SendPropertyChanged(\"Vendor\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t#endregion\n\t}\n", "label": "MultifacetedAbstraction"}
{"text": "        \n\n        /// <summary>\n        /// \n        /// </summary>\n        public abstract class MaterialVariable : ReferenceCountDisposeObject\n        {\n            public static readonly ConstantBufferDescription DefaultMeshConstantBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.ModelCB,\n                          PhongPBRMaterialStruct.SizeInBytes);\n\n            public static readonly ConstantBufferDescription DefaultPointLineConstantBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.PointLineModelCB,\n                            PointLineMaterialStruct.SizeInBytes);\n\n            public static readonly ConstantBufferDescription DefaultVolumeConstantBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.VolumeModelCB,\n                            VolumeParamsStruct.SizeInBytes);\n\n            public static readonly ConstantBufferDescription DefaultNonMaterialBufferDesc\n                = new ConstantBufferDescription(DefaultBufferNames.SimpleMeshCB,\n                    SimpleMeshStruct.SizeInBytes);\n\n            public event EventHandler UpdateNeeded;\n            /// <summary>\n            /// Gets or sets the identifier. Used for material sorting\n            /// </summary>\n            /// <value>\n            /// The identifier.\n            /// </value>\n            public ushort ID { set; get; } = 0;\n\n            protected IRenderTechnique Technique { get; }\n            protected IEffectsManager EffectsManager { get; }\n            protected bool NeedUpdate { private set; get; } = true;\n            /// <summary>\n            /// Gets the material cb.\n            /// </summary>\n            /// <value>\n            /// The material cb.\n            /// </value>\n            protected ConstantBufferComponent MaterialCB { get; }\n            /// <summary>\n            /// Gets the non material cb. Used for non material related rendering such as Shadow map\n            /// </summary>\n            /// <value>\n            /// The non material cb.\n            /// </value>\n            protected ConstantBufferComponent NonMaterialCB { get; }\n            private readonly object updateLock = new object();\n            private readonly MaterialCore material;\n            /// <summary>\n            /// Initializes a new instance of the <see cref=\"MaterialVariable\"/> class.\n            /// </summary>\n            /// <param name=\"manager\">The manager.</param>\n            /// <param name=\"technique\">The technique.</param>\n            /// <param name=\"meshMaterialConstantBufferDesc\">The Constant Buffer description</param>\n            /// <param name=\"materialCore\"></param>\n            public MaterialVariable(IEffectsManager manager, IRenderTechnique technique, \n                ConstantBufferDescription meshMaterialConstantBufferDesc, \n                MaterialCore materialCore)\n            {\n                Technique = technique;\n                EffectsManager = manager;\n                if(materialCore != null)\n                {\n                    material = materialCore;\n                    material.PropertyChanged += MaterialCore_PropertyChanged;\n                }\n                MaterialCB = new ConstantBufferComponent(meshMaterialConstantBufferDesc);\n                NonMaterialCB = new ConstantBufferComponent(DefaultNonMaterialBufferDesc);\n            }\n\n            internal void Initialize()\n            {\n                MaterialCB.Attach(Technique);\n                NonMaterialCB.Attach(Technique);\n                OnInitialPropertyBindings();\n                foreach(var v in propertyBindings.Values)\n                {\n                    v.Invoke();\n                }\n            }\n\n            protected virtual void OnInitialPropertyBindings() { }\n            /// <summary>\n            /// Binds the material textures, samplers, etc,.\n            /// </summary>\n            /// <param name=\"context\"></param>\n            /// <param name=\"deviceContext\">The device context.</param>\n            /// <param name=\"shaderPass\">The shader pass.</param>\n            /// <returns></returns>\n            public abstract bool BindMaterialResources(RenderContext context, DeviceContextProxy deviceContext, ShaderPass shaderPass);\n\n            protected virtual void UpdateInternalVariables(DeviceContextProxy deviceContext) { }\n\n            /// <summary>\n            /// Gets the pass.\n            /// </summary>\n            /// <param name=\"renderType\">Type of the render.</param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetPass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the shadow pass.\n            /// </summary>\n            /// <param name=\"renderType\"></param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetShadowPass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the wireframe pass.\n            /// </summary>\n            /// <param name=\"renderType\"></param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetWireframePass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the depth pass.\n            /// </summary>\n            /// <param name=\"renderType\">Type of the render.</param>\n            /// <param name=\"context\">The context.</param>\n            /// <returns></returns>\n            public abstract ShaderPass GetDepthPass(RenderType renderType, RenderContext context);\n            /// <summary>\n            /// Gets the name of the pass by.\n            /// </summary>\n            /// <param name=\"name\">The name.</param>\n            /// <returns></returns>\n            public ShaderPass GetPassByName(string name)\n            {\n                return Technique[name];\n            }\n\n            /// <summary>\n            /// Updates the material structure. And upload data to constant buffer\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"context\">The context.</param>\n            /// <param name=\"model\">The model.</param>\n            /// <param name=\"structSize\"></param>\n            public bool UpdateMaterialStruct<T>(DeviceContextProxy context, ref T model, int structSize) where T : struct\n            {\n                if (NeedUpdate)\n                {\n                    lock (updateLock)\n                    {\n                        if (NeedUpdate)\n                        {\n                            UpdateInternalVariables(context);\n                            NeedUpdate = false;\n                        }\n                    }\n                }\n                return MaterialCB.Upload(context, ref model, structSize);\n            }\n            /// <summary>\n            /// Updates the non material structure.\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"context\">The context.</param>\n            /// <param name=\"model\">The model.</param>\n            /// <param name=\"structSize\">Size of the structure.</param>\n            /// <returns></returns>\n            public bool UpdateNonMaterialStruct<T>(DeviceContextProxy context, ref T model, int structSize) where T : struct\n            {\n                return NonMaterialCB.Upload(context, ref model, structSize);\n            }\n            /// <summary>\n            /// Draws the specified device context.\n            /// </summary>\n            /// <param name=\"deviceContext\">The device context.</param>\n            /// <param name=\"bufferModel\">Geometry buffer model.</param>\n            /// <param name=\"instanceCount\">The instance count.</param>\n            public abstract void Draw(DeviceContextProxy deviceContext, IAttachableBufferModel bufferModel, int instanceCount);\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            protected void InvalidateRenderer()\n            {\n                Technique?.EffectsManager?.RaiseInvalidateRender();\n            }\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            protected void NotifyUpdateNeeded()\n            {\n                NeedUpdate = true;\n                UpdateNeeded?.Invoke(this, EventArgs.Empty);\n                InvalidateRenderer();\n            }\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public static void DrawIndexed(DeviceContextProxy context, int indexCount, int instanceCount)\n            {\n                if (instanceCount <= 0)\n                {\n                    context.DrawIndexed(indexCount, 0, 0);\n                }\n                else\n                {\n                    context.DrawIndexedInstanced(indexCount, instanceCount, 0, 0, 0);\n                }\n            }\n\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public static void DrawPoints(DeviceContextProxy context, int vertexCount, int instanceCount)\n            {\n                if (instanceCount <= 0)\n                {\n                    context.Draw(vertexCount, 0);\n                }\n                else\n                {\n                    context.DrawInstanced(vertexCount, instanceCount, 0, 0);\n                }\n            }\n            /// <summary>\n            /// Writes the value to internal buffer array\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"name\">The name.</param>\n            /// <param name=\"value\">The value.</param>\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public void WriteValue<T>(string name, ref T value) where T : struct\n            {\n                MaterialCB.WriteValueByName(name, value);\n            }\n            /// <summary>\n            /// Writes the value to internal buffer array\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"name\">The name.</param>\n            /// <param name=\"value\">The value.</param>\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public void WriteValue<T>(string name, T value) where T : struct\n            {\n                MaterialCB.WriteValueByName(name, value);\n            }\n            /// <summary>\n            /// Writes the value to internal buffer array with offset\n            /// </summary>\n            /// <typeparam name=\"T\"></typeparam>\n            /// <param name=\"value\">The value.</param>\n            /// <param name=\"offset\">The offset.</param>\n            [MethodImpl(MethodImplOptions.AggressiveInlining)]\n            public void WriteValue<T>(ref T value, int offset) where T : struct\n            {\n                MaterialCB.WriteValue(value, offset);\n            }\n\n            /// <summary>\n            /// \n            /// </summary>\n            /// <param name=\"disposeManagedResources\"></param>\n            protected override void OnDispose(bool disposeManagedResources)\n            {\n                if (disposeManagedResources)\n                {\n                    UpdateNeeded = null;\n                    if(material != null)\n                    {\n                        material.PropertyChanged -= MaterialCore_PropertyChanged;\n                    }\n                    MaterialCB.Detach();\n                    NonMaterialCB.Detach();\n                    propertyBindings.Clear();\n                }\n                base.OnDispose(disposeManagedResources);\n            }\n\n            #region Material Property Bindings\n            private readonly Dictionary<string, Action> propertyBindings = new Dictionary<string, Action>();\n\n            protected void AddPropertyBinding(string propertyName, Action action)\n            {\n                propertyBindings.Add(propertyName, action);\n            }\n\n            protected void TriggerPropertyAction(string propertyName)\n            {\n                if (propertyBindings.TryGetValue(propertyName, out Action act))\n                {\n                    act.Invoke();\n                }\n            }\n\n            private void MaterialCore_PropertyChanged(object sender, PropertyChangedEventArgs e)\n            {\n                TriggerPropertyAction(e.PropertyName);\n                InvalidateRenderer();\n            }\n            #endregion\n        }\n", "label": "MultifacetedAbstraction"}
{"text": "\n        private class BaseTextBox : TextBox\n        {\n            [DllImport(\"user32.dll\", CharSet = CharSet.Auto)]\n            private static extern IntPtr SendMessage(IntPtr hWnd, int msg, int wParam, string lParam);\n\n            private const int EM_SETCUEBANNER = 0x1501;\n            private const char EmptyChar = (char)0;\n            private const char VisualStylePasswordChar = '\\u25CF';\n            private const char NonVisualStylePasswordChar = '\\u002A';\n\n            private string hint = string.Empty;\n            public string Hint\n            {\n                get { return hint; }\n                set\n                {\n                    hint = value;\n                    SendMessage(Handle, EM_SETCUEBANNER, (int)IntPtr.Zero, Hint);\n                }\n            }\n\n            private char _passwordChar = EmptyChar;\n            public new char PasswordChar\n            {\n                get { return _passwordChar; }\n                set\n                {\n                    _passwordChar = value;\n                    SetBasePasswordChar();\n                }\n            }\n\n            public new void SelectAll()\n            {\n                BeginInvoke((MethodInvoker)delegate ()\n                {\n                    base.Focus();\n                    base.SelectAll();\n                });\n            }\n\n            public new void Focus()\n            {\n                BeginInvoke((MethodInvoker)delegate ()\n                {\n                    base.Focus();\n                });\n            }\n\n            private char _useSystemPasswordChar = EmptyChar;\n            public new bool UseSystemPasswordChar\n            {\n                get { return _useSystemPasswordChar != EmptyChar; }\n                set\n                {\n                    if (value)\n                    {\n                        _useSystemPasswordChar = Application.RenderWithVisualStyles ? VisualStylePasswordChar : NonVisualStylePasswordChar;\n                    }\n                    else\n                    {\n                        _useSystemPasswordChar = EmptyChar;\n                    }\n\n                    SetBasePasswordChar();\n                }\n            }\n\n            private void SetBasePasswordChar()\n            {\n                base.PasswordChar = UseSystemPasswordChar ? _useSystemPasswordChar : _passwordChar;\n            }\n\n            public BaseTextBox()\n            {\n                MaterialContextMenuStrip cms = new TextBoxContextMenuStrip();\n                cms.Opening += ContextMenuStripOnOpening;\n                cms.OnItemClickStart += ContextMenuStripOnItemClickStart;\n\n                ContextMenuStrip = cms;\n            }\n\n            private void ContextMenuStripOnItemClickStart(object sender, ToolStripItemClickedEventArgs toolStripItemClickedEventArgs)\n            {\n                switch (toolStripItemClickedEventArgs.ClickedItem.Text)\n                {\n                    case \"Undo\":\n                        Undo();\n                        break;\n                    case \"Cut\":\n                        Cut();\n                        break;\n                    case \"Copy\":\n                        Copy();\n                        break;\n                    case \"Paste\":\n                        Paste();\n                        break;\n                    case \"Delete\":\n                        SelectedText = string.Empty;\n                        break;\n                    case \"Select All\":\n                        SelectAll();\n                        break;\n                }\n            }\n\n            private void ContextMenuStripOnOpening(object sender, CancelEventArgs cancelEventArgs)\n            {\n                var strip = sender as TextBoxContextMenuStrip;\n                if (strip != null)\n                {\n                    strip.Undo.Enabled = CanUndo;\n                    strip.Cut.Enabled = !string.IsNullOrEmpty(SelectedText);\n                    strip.Copy.Enabled = !string.IsNullOrEmpty(SelectedText);\n                    strip.Paste.Enabled = Clipboard.ContainsText();\n                    strip.Delete.Enabled = !string.IsNullOrEmpty(SelectedText);\n                    strip.SelectAll.Enabled = !string.IsNullOrEmpty(Text);\n                }\n            }\n        }\n", "label": "MultifacetedAbstraction"}
{"text": "    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n    \n    \n    /// <summary>\n    /// The WindowsMvcElement Configuration Element.\n    /// </summary>\n    public partial class WindowsMvcElement : global::System.Configuration.ConfigurationElement\n    {\n        \n        #region IsReadOnly override\n        /// <summary>\n        /// Gets a value indicating whether the element is read-only.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        public override bool IsReadOnly()\n        {\n            return false;\n        }\n        #endregion\n        \n        #region Controllers Property\n        /// <summary>\n        /// The XML name of the <see cref=\"Controllers\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string ControllersPropertyName = \"controllers\";\n        \n        /// <summary>\n        /// Gets or sets the Controllers.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The Controllers.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.ControllerElementCollection Controllers\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.ControllerElementCollection)(base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.ControllersPropertyName] = value;\n            }\n        }\n        #endregion\n        \n        #region DefaultControllerFactory Property\n        /// <summary>\n        /// The XML name of the <see cref=\"DefaultControllerFactory\"/> property.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        internal const string DefaultControllerFactoryPropertyName = \"defaultControllerFactory\";\n        \n        /// <summary>\n        /// Gets or sets the DefaultControllerFactory.\n        /// </summary>\n        [global::System.CodeDom.Compiler.GeneratedCodeAttribute(\"ConfigurationSectionDesigner.CsdFileGenerator\", \"2.0.0.5\")]\n        [global::System.ComponentModel.DescriptionAttribute(\"The DefaultControllerFactory.\")]\n        [global::System.Configuration.ConfigurationPropertyAttribute(global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName, IsRequired=false, IsKey=false, IsDefaultCollection=false)]\n        public virtual global::EApp.Core.Configuration.SingleProviderElement DefaultControllerFactory\n        {\n            get\n            {\n                return ((global::EApp.Core.Configuration.SingleProviderElement)(base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName]));\n            }\n            set\n            {\n                base[global::EApp.Core.Configuration.WindowsMvcElement.DefaultControllerFactoryPropertyName] = value;\n            }\n        }\n        #endregion\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "    /// <summary>\n    /// Base class for top-level widgets.\n    /// </summary>\n    /// <remarks>\n    /// This class acts as a base for top level widget.\n    /// It handles scheduling layout, styling and rendering as well as\n    /// tracking the widget's <see cref=\"ClientSize\"/>.\n    /// </remarks>\n    public abstract class TopLevel : ContentControl,\n        IInputRoot,\n        ILayoutRoot,\n        IRenderRoot,\n        ICloseable,\n        IStyleRoot,\n        IWeakSubscriber<ResourcesChangedEventArgs>\n    {\n        /// <summary>\n        /// Defines the <see cref=\"ClientSize\"/> property.\n        /// </summary>\n        public static readonly DirectProperty<TopLevel, Size> ClientSizeProperty =\n            AvaloniaProperty.RegisterDirect<TopLevel, Size>(nameof(ClientSize), o => o.ClientSize);\n\n        /// <summary>\n        /// Defines the <see cref=\"IInputRoot.PointerOverElement\"/> property.\n        /// </summary>\n        public static readonly StyledProperty<IInputElement> PointerOverElementProperty =\n            AvaloniaProperty.Register<TopLevel, IInputElement>(nameof(IInputRoot.PointerOverElement));\n\n        private readonly IInputManager _inputManager;\n        private readonly IAccessKeyHandler _accessKeyHandler;\n        private readonly IKeyboardNavigationHandler _keyboardNavigationHandler;\n        private readonly IPlatformRenderInterface _renderInterface;\n        private Size _clientSize;\n        private ILayoutManager _layoutManager;\n\n        /// <summary>\n        /// Initializes static members of the <see cref=\"TopLevel\"/> class.\n        /// </summary>\n        static TopLevel()\n        {\n            AffectsMeasure<TopLevel>(ClientSizeProperty);\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"TopLevel\"/> class.\n        /// </summary>\n        /// <param name=\"impl\">The platform-specific window implementation.</param>\n        public TopLevel(ITopLevelImpl impl)\n            : this(impl, AvaloniaLocator.Current)\n        {\n        }\n\n        /// <summary>\n        /// Initializes a new instance of the <see cref=\"TopLevel\"/> class.\n        /// </summary>\n        /// <param name=\"impl\">The platform-specific window implementation.</param>\n        /// <param name=\"dependencyResolver\">\n        /// The dependency resolver to use. If null the default dependency resolver will be used.\n        /// </param>\n        public TopLevel(ITopLevelImpl impl, IAvaloniaDependencyResolver dependencyResolver)\n        {\n            if (impl == null)\n            {\n                throw new InvalidOperationException(\n                    \"Could not create window implementation: maybe no windowing subsystem was initialized?\");\n            }\n\n            PlatformImpl = impl;\n\n            dependencyResolver = dependencyResolver ?? AvaloniaLocator.Current;\n            var styler = TryGetService<IStyler>(dependencyResolver);\n\n            _accessKeyHandler = TryGetService<IAccessKeyHandler>(dependencyResolver);\n            _inputManager = TryGetService<IInputManager>(dependencyResolver);\n            _keyboardNavigationHandler = TryGetService<IKeyboardNavigationHandler>(dependencyResolver);\n            _renderInterface = TryGetService<IPlatformRenderInterface>(dependencyResolver);\n\n            Renderer = impl.CreateRenderer(this);\n\n            if (Renderer != null)\n            {\n                Renderer.SceneInvalidated += SceneInvalidated;\n            }\n\n            impl.SetInputRoot(this);\n\n            impl.Closed = HandleClosed;\n            impl.Input = HandleInput;\n            impl.Paint = HandlePaint;\n            impl.Resized = HandleResized;\n            impl.ScalingChanged = HandleScalingChanged;\n\n            _keyboardNavigationHandler?.SetOwner(this);\n            _accessKeyHandler?.SetOwner(this);\n            styler?.ApplyStyles(this);\n\n            ClientSize = impl.ClientSize;\n            \n            this.GetObservable(PointerOverElementProperty)\n                .Select(\n                    x => (x as InputElement)?.GetObservable(CursorProperty) ?? Observable.Empty<Cursor>())\n                .Switch().Subscribe(cursor => PlatformImpl?.SetCursor(cursor?.PlatformCursor));\n\n            if (((IStyleHost)this).StylingParent is IResourceProvider applicationResources)\n            {\n                WeakSubscriptionManager.Subscribe(\n                    applicationResources,\n                    nameof(IResourceProvider.ResourcesChanged),\n                    this);\n            }\n        }\n\n        /// <summary>\n        /// Fired when the window is opened.\n        /// </summary>\n        public event EventHandler Opened;\n\n        /// <summary>\n        /// Fired when the window is closed.\n        /// </summary>\n        public event EventHandler Closed;\n\n        /// <summary>\n        /// Gets or sets the client size of the window.\n        /// </summary>\n        public Size ClientSize\n        {\n            get { return _clientSize; }\n            protected set { SetAndRaise(ClientSizeProperty, ref _clientSize, value); }\n        }\n\n        public ILayoutManager LayoutManager\n        {\n            get\n            {\n                if (_layoutManager == null)\n                    _layoutManager = CreateLayoutManager();\n                return _layoutManager;\n            }\n        }\n\n        /// <summary>\n        /// Gets the platform-specific window implementation.\n        /// </summary>\n        [CanBeNull]\n        public ITopLevelImpl PlatformImpl { get; private set; }\n        \n        /// <summary>\n        /// Gets the renderer for the window.\n        /// </summary>\n        public IRenderer Renderer { get; private set; }\n\n        /// <summary>\n        /// Gets the access key handler for the window.\n        /// </summary>\n        IAccessKeyHandler IInputRoot.AccessKeyHandler => _accessKeyHandler;\n\n        /// <summary>\n        /// Gets or sets the keyboard navigation handler for the window.\n        /// </summary>\n        IKeyboardNavigationHandler IInputRoot.KeyboardNavigationHandler => _keyboardNavigationHandler;\n\n        /// <summary>\n        /// Gets or sets the input element that the pointer is currently over.\n        /// </summary>\n        IInputElement IInputRoot.PointerOverElement\n        {\n            get { return GetValue(PointerOverElementProperty); }\n            set { SetValue(PointerOverElementProperty, value); }\n        }\n\n        /// <inheritdoc/>\n        IMouseDevice IInputRoot.MouseDevice => PlatformImpl?.MouseDevice;\n\n        void IWeakSubscriber<ResourcesChangedEventArgs>.OnEvent(object sender, ResourcesChangedEventArgs e)\n        {\n            ((ILogical)this).NotifyResourcesChanged(e);\n        }\n\n        /// <summary>\n        /// Gets or sets a value indicating whether access keys are shown in the window.\n        /// </summary>\n        bool IInputRoot.ShowAccessKeys\n        {\n            get { return GetValue(AccessText.ShowAccessKeyProperty); }\n            set { SetValue(AccessText.ShowAccessKeyProperty, value); }\n        }\n\n        /// <inheritdoc/>\n        Size ILayoutRoot.MaxClientSize => Size.Infinity;\n\n        /// <inheritdoc/>\n        double ILayoutRoot.LayoutScaling => PlatformImpl?.Scaling ?? 1;\n\n        /// <inheritdoc/>\n        double IRenderRoot.RenderScaling => PlatformImpl?.Scaling ?? 1;\n\n        IStyleHost IStyleHost.StylingParent\n        {\n            get { return AvaloniaLocator.Current.GetService<IGlobalStyles>(); }\n        }\n\n        IRenderTarget IRenderRoot.CreateRenderTarget() => CreateRenderTarget();\n\n        /// <inheritdoc/>\n        protected virtual IRenderTarget CreateRenderTarget()\n        {\n            if(PlatformImpl == null)\n                throw new InvalidOperationException(\"Can't create render target, PlatformImpl is null (might be already disposed)\");\n            return _renderInterface.CreateRenderTarget(PlatformImpl.Surfaces);\n        }\n\n        /// <inheritdoc/>\n        void IRenderRoot.Invalidate(Rect rect)\n        {\n            PlatformImpl?.Invalidate(rect);\n        }\n        \n        /// <inheritdoc/>\n        Point IRenderRoot.PointToClient(PixelPoint p)\n        {\n            return PlatformImpl?.PointToClient(p) ?? default;\n        }\n\n        /// <inheritdoc/>\n        PixelPoint IRenderRoot.PointToScreen(Point p)\n        {\n            return PlatformImpl?.PointToScreen(p) ?? default;\n        }\n        \n        /// <summary>\n        /// Creates the layout manager for this <see cref=\"TopLevel\" />.\n        /// </summary>\n        protected virtual ILayoutManager CreateLayoutManager() => new LayoutManager();\n\n        /// <summary>\n        /// Handles a paint notification from <see cref=\"ITopLevelImpl.Resized\"/>.\n        /// </summary>\n        /// <param name=\"rect\">The dirty area.</param>\n        protected virtual void HandlePaint(Rect rect)\n        {\n            Renderer?.Paint(rect);\n        }\n\n        /// <summary>\n        /// Handles a closed notification from <see cref=\"ITopLevelImpl.Closed\"/>.\n        /// </summary>\n        protected virtual void HandleClosed()\n        {\n            (this as IInputRoot).MouseDevice?.TopLevelClosed(this);\n            PlatformImpl = null;\n            Closed?.Invoke(this, EventArgs.Empty);\n            Renderer?.Dispose();\n            Renderer = null;\n        }\n\n        /// <summary>\n        /// Handles a resize notification from <see cref=\"ITopLevelImpl.Resized\"/>.\n        /// </summary>\n        /// <param name=\"clientSize\">The new client size.</param>\n        protected virtual void HandleResized(Size clientSize)\n        {\n            ClientSize = clientSize;\n            Width = clientSize.Width;\n            Height = clientSize.Height;\n            LayoutManager.ExecuteLayoutPass();\n            Renderer?.Resized(clientSize);\n        }\n\n        /// <summary>\n        /// Handles a window scaling change notification from \n        /// <see cref=\"ITopLevelImpl.ScalingChanged\"/>.\n        /// </summary>\n        /// <param name=\"scaling\">The window scaling.</param>\n        protected virtual void HandleScalingChanged(double scaling)\n        {\n            foreach (ILayoutable control in this.GetSelfAndVisualDescendants())\n            {\n                control.InvalidateMeasure();\n            }\n        }\n\n        /// <inheritdoc/>\n        protected override void OnAttachedToVisualTree(VisualTreeAttachmentEventArgs e)\n        {\n            base.OnAttachedToVisualTree(e);\n\n            throw new InvalidOperationException(\n                $\"Control '{GetType().Name}' is a top level control and cannot be added as a child.\");\n        }\n\n        /// <summary>\n        /// Raises the <see cref=\"Opened\"/> event.\n        /// </summary>\n        /// <param name=\"e\">The event args.</param>\n        protected virtual void OnOpened(EventArgs e) => Opened?.Invoke(this, e);\n\n        /// <summary>\n        /// Tries to get a service from an <see cref=\"IAvaloniaDependencyResolver\"/>, logging a\n        /// warning if not found.\n        /// </summary>\n        /// <typeparam name=\"T\">The service type.</typeparam>\n        /// <param name=\"resolver\">The resolver.</param>\n        /// <returns>The service.</returns>\n        private T TryGetService<T>(IAvaloniaDependencyResolver resolver) where T : class\n        {\n            var result = resolver.GetService<T>();\n\n            if (result == null)\n            {\n                Logger.Warning(\n                    LogArea.Control,\n                    this,\n                    \"Could not create {Service} : maybe Application.RegisterServices() wasn't called?\",\n                    typeof(T));\n            }\n\n            return result;\n        }\n\n        /// <summary>\n        /// Handles input from <see cref=\"ITopLevelImpl.Input\"/>.\n        /// </summary>\n        /// <param name=\"e\">The event args.</param>\n        private void HandleInput(RawInputEventArgs e)\n        {\n            _inputManager.ProcessInput(e);\n        }\n\n        private void SceneInvalidated(object sender, SceneInvalidatedEventArgs e)\n        {\n            (this as IInputRoot).MouseDevice.SceneInvalidated(this, e.DirtyRect);\n        }\n    }\n", "label": "MultifacetedAbstraction"}
{"text": "\n  internal sealed partial class DefaultResizer : pb::IMessage<DefaultResizer> {\n    private static readonly pb::MessageParser<DefaultResizer> _parser = new pb::MessageParser<DefaultResizer>(() => new DefaultResizer());\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public static pb::MessageParser<DefaultResizer> Parser { get { return _parser; } }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public static pbr::MessageDescriptor Descriptor {\n      get { return global::Akka.Remote.Serialization.Proto.Msg.WireFormatsReflection.Descriptor.MessageTypes[10]; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    pbr::MessageDescriptor pb::IMessage.Descriptor {\n      get { return Descriptor; }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public DefaultResizer() {\n      OnConstruction();\n    }\n\n    partial void OnConstruction();\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public DefaultResizer(DefaultResizer other) : this() {\n      lowerBound_ = other.lowerBound_;\n      upperBound_ = other.upperBound_;\n      pressureThreshold_ = other.pressureThreshold_;\n      rampupRate_ = other.rampupRate_;\n      backoffThreshold_ = other.backoffThreshold_;\n      backoffRate_ = other.backoffRate_;\n      messagesPerResize_ = other.messagesPerResize_;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public DefaultResizer Clone() {\n      return new DefaultResizer(this);\n    }\n\n    /// <summary>Field number for the \"lowerBound\" field.</summary>\n    public const int LowerBoundFieldNumber = 1;\n    private uint lowerBound_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public uint LowerBound {\n      get { return lowerBound_; }\n      set {\n        lowerBound_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"upperBound\" field.</summary>\n    public const int UpperBoundFieldNumber = 2;\n    private uint upperBound_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public uint UpperBound {\n      get { return upperBound_; }\n      set {\n        upperBound_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"pressureThreshold\" field.</summary>\n    public const int PressureThresholdFieldNumber = 3;\n    private uint pressureThreshold_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public uint PressureThreshold {\n      get { return pressureThreshold_; }\n      set {\n        pressureThreshold_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"rampupRate\" field.</summary>\n    public const int RampupRateFieldNumber = 4;\n    private double rampupRate_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public double RampupRate {\n      get { return rampupRate_; }\n      set {\n        rampupRate_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"backoffThreshold\" field.</summary>\n    public const int BackoffThresholdFieldNumber = 5;\n    private double backoffThreshold_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public double BackoffThreshold {\n      get { return backoffThreshold_; }\n      set {\n        backoffThreshold_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"backoffRate\" field.</summary>\n    public const int BackoffRateFieldNumber = 6;\n    private double backoffRate_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public double BackoffRate {\n      get { return backoffRate_; }\n      set {\n        backoffRate_ = value;\n      }\n    }\n\n    /// <summary>Field number for the \"messagesPerResize\" field.</summary>\n    public const int MessagesPerResizeFieldNumber = 7;\n    private uint messagesPerResize_;\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public uint MessagesPerResize {\n      get { return messagesPerResize_; }\n      set {\n        messagesPerResize_ = value;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override bool Equals(object other) {\n      return Equals(other as DefaultResizer);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public bool Equals(DefaultResizer other) {\n      if (ReferenceEquals(other, null)) {\n        return false;\n      }\n      if (ReferenceEquals(other, this)) {\n        return true;\n      }\n      if (LowerBound != other.LowerBound) return false;\n      if (UpperBound != other.UpperBound) return false;\n      if (PressureThreshold != other.PressureThreshold) return false;\n      if (RampupRate != other.RampupRate) return false;\n      if (BackoffThreshold != other.BackoffThreshold) return false;\n      if (BackoffRate != other.BackoffRate) return false;\n      if (MessagesPerResize != other.MessagesPerResize) return false;\n      return true;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override int GetHashCode() {\n      int hash = 1;\n      if (LowerBound != 0) hash ^= LowerBound.GetHashCode();\n      if (UpperBound != 0) hash ^= UpperBound.GetHashCode();\n      if (PressureThreshold != 0) hash ^= PressureThreshold.GetHashCode();\n      if (RampupRate != 0D) hash ^= RampupRate.GetHashCode();\n      if (BackoffThreshold != 0D) hash ^= BackoffThreshold.GetHashCode();\n      if (BackoffRate != 0D) hash ^= BackoffRate.GetHashCode();\n      if (MessagesPerResize != 0) hash ^= MessagesPerResize.GetHashCode();\n      return hash;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public override string ToString() {\n      return pb::JsonFormatter.ToDiagnosticString(this);\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void WriteTo(pb::CodedOutputStream output) {\n      if (LowerBound != 0) {\n        output.WriteRawTag(8);\n        output.WriteUInt32(LowerBound);\n      }\n      if (UpperBound != 0) {\n        output.WriteRawTag(16);\n        output.WriteUInt32(UpperBound);\n      }\n      if (PressureThreshold != 0) {\n        output.WriteRawTag(24);\n        output.WriteUInt32(PressureThreshold);\n      }\n      if (RampupRate != 0D) {\n        output.WriteRawTag(33);\n        output.WriteDouble(RampupRate);\n      }\n      if (BackoffThreshold != 0D) {\n        output.WriteRawTag(41);\n        output.WriteDouble(BackoffThreshold);\n      }\n      if (BackoffRate != 0D) {\n        output.WriteRawTag(49);\n        output.WriteDouble(BackoffRate);\n      }\n      if (MessagesPerResize != 0) {\n        output.WriteRawTag(56);\n        output.WriteUInt32(MessagesPerResize);\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public int CalculateSize() {\n      int size = 0;\n      if (LowerBound != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(LowerBound);\n      }\n      if (UpperBound != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(UpperBound);\n      }\n      if (PressureThreshold != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PressureThreshold);\n      }\n      if (RampupRate != 0D) {\n        size += 1 + 8;\n      }\n      if (BackoffThreshold != 0D) {\n        size += 1 + 8;\n      }\n      if (BackoffRate != 0D) {\n        size += 1 + 8;\n      }\n      if (MessagesPerResize != 0) {\n        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MessagesPerResize);\n      }\n      return size;\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void MergeFrom(DefaultResizer other) {\n      if (other == null) {\n        return;\n      }\n      if (other.LowerBound != 0) {\n        LowerBound = other.LowerBound;\n      }\n      if (other.UpperBound != 0) {\n        UpperBound = other.UpperBound;\n      }\n      if (other.PressureThreshold != 0) {\n        PressureThreshold = other.PressureThreshold;\n      }\n      if (other.RampupRate != 0D) {\n        RampupRate = other.RampupRate;\n      }\n      if (other.BackoffThreshold != 0D) {\n        BackoffThreshold = other.BackoffThreshold;\n      }\n      if (other.BackoffRate != 0D) {\n        BackoffRate = other.BackoffRate;\n      }\n      if (other.MessagesPerResize != 0) {\n        MessagesPerResize = other.MessagesPerResize;\n      }\n    }\n\n    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]\n    public void MergeFrom(pb::CodedInputStream input) {\n      uint tag;\n      while ((tag = input.ReadTag()) != 0) {\n        switch(tag) {\n          default:\n            input.SkipLastField();\n            break;\n          case 8: {\n            LowerBound = input.ReadUInt32();\n            break;\n          }\n          case 16: {\n            UpperBound = input.ReadUInt32();\n            break;\n          }\n          case 24: {\n            PressureThreshold = input.ReadUInt32();\n            break;\n          }\n          case 33: {\n            RampupRate = input.ReadDouble();\n            break;\n          }\n          case 41: {\n            BackoffThreshold = input.ReadDouble();\n            break;\n          }\n          case 49: {\n            BackoffRate = input.ReadDouble();\n            break;\n          }\n          case 56: {\n            MessagesPerResize = input.ReadUInt32();\n            break;\n          }\n        }\n      }\n    }\n\n  }\n", "label": "MultifacetedAbstraction"}
